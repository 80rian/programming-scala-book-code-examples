<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book><title>Programming Scala</title><bookinfo><othercredit role="proofreader"><firstname>Sarah</firstname><surname>Schneider</surname></othercredit><othercredit role="interiordesigner"><firstname>David</firstname><surname>Futato</surname></othercredit><othercredit role="illustrator"><firstname>Robert</firstname><surname>Romano</surname></othercredit><!-- All rights reserved. --><publisher><publishername>O’Reilly Media, Inc.</publishername><address format="linespecific">
      <street>1005 Gravenstein Highway North</street>
      <city>Sebastopol</city>
      <state>CA</state>
      <postcode>95472</postcode>
    </address></publisher><legalnotice role="printlocation"><para>Printed in the United States of America.</para></legalnotice><legalnotice role="printer"><para>[M]</para></legalnotice><legalnotice role="use"><para>O’Reilly books may be purchased for educational, business, or sales
    promotional use. Online editions are also available for most titles
    (<ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>).
    For more information, contact our corporate/institutional sales
    department: 800-998-9938 or <email>corporate@oreilly.com</email>.</para></legalnotice><legalnotice role="trademarks"><para>O’Reilly and the O’Reilly logo are registered trademarks of O’Reilly
    Media, Inc. <citetitle>Programming Scala</citetitle>, the image of a
    Malayan tapir, and related trade dress are trademarks of O’Reilly Media,
    Inc.</para><para>Many of the designations used by manufacturers and sellers to
    distinguish their products are claimed as trademarks. Where those
    designations appear in this book, and O’Reilly Media, Inc. was aware of a
    trademark claim, the designations have been printed in caps or initial
    caps.</para></legalnotice><legalnotice role="damages"><para>While every precaution has been taken in the preparation of this
    book, the publisher and authors assume no responsibility for errors or
    omissions, or for damages resulting from the use of the information
    contained herein. This work has been released under the <ulink url="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons
    Attribution-Noncommercial license</ulink>.</para></legalnotice><isbn>9780596155957</isbn><edition>1</edition><author><firstname>Dean</firstname><surname>Wampler</surname><authorblurb><para><emphasis role="strong">Dean Wampler</emphasis> is a consultant,
      trainer, and mentor with Object Mentor, Inc. He specializes in Scala,
      Java, and Ruby, and works with clients on application design strategies
      that combine object-oriented programming, functional programming, and
      <phrase role="keep-together">aspect-</phrase><phrase role="keep-together">oriented</phrase> programming. He also consults on
      Agile methods, such as Lean and XP. Dean is a frequent speaker at
      industry and academic conferences on these topics. He has a Ph.D. in
      physics from the University of Washington.</para></authorblurb></author><author><firstname>Alex</firstname><surname>Payne</surname><authorblurb><para><emphasis role="strong">Alex Payne</emphasis> is Platform Lead at
      Twitter, Inc., where he develops services that enable programmers to
      build atop the popular social messaging service. Alex has previously
      built web applications for political campaigns, non-profits, and
      early-stage startups, and supported information security efforts for
      military and intelligence customers. In his free time, Alex studies,
      speaks, and writes about the history, present use, and evolution of
      programming languages, as well as minimalist art and design.</para></authorblurb></author><editor><firstname>Mike</firstname><surname>Loukides</surname></editor><copyright><year>2009</year><holder>Dean Wampler and Alex Payne</holder></copyright><editor role="production"><firstname>Sarah</firstname><surname>Schneider</surname></editor><othercredit role="indexer"><firstname>Ellen</firstname><surname>Troutman Zaig</surname></othercredit><othercredit role="coverdesigner"><firstname>Karen</firstname><surname>Montgomery</surname></othercredit><printhistory><formalpara><title>First Edition</title><para>September, 2009</para></formalpara></printhistory></bookinfo><dedication id="dedication"><title>Dedication</title><blockquote><attribution>Dean</attribution><para>To Dad and Mom, who always believed in me.</para><para>To Ann, who was always there for me.</para></blockquote><blockquote><attribution>Alex</attribution><para>To my mother, who gave me an appreciation for good writing and the
    accompanying intellectual tools with which to attempt to produce
    it.</para><para>To Kristen, for her unending patience, love, and kindness.</para></blockquote></dedication><preface id="foreword" role="foreword"><prefaceinfo><author><firstname>Jonas</firstname><surname>Bonér</surname><affiliation><jobtitle>Independent Consultant, Scalable Solutions AB</jobtitle></affiliation></author><date>August, 2009</date></prefaceinfo><title>Foreword</title><para>If there has been a common theme throughout my career as a programmer,
  it has been the quest for better abstractions and better tools to support
  the craft of writing software. Over the years, I have come to value one
  trait more than any other: composability. If one can write code with good
  composability, it usually means that other traits we software developers
  value—such as orthogonality, loose coupling, and high <phrase role="keep-together">cohesion—</phrase>are already present. It is all
  connected.</para><para>When I discovered Scala some years ago, the thing that made the
  biggest impression on me was its composability. Through some very elegant
  design choices and simple yet powerful abstractions that were taken from the
  object-oriented and functional <phrase role="keep-together">programming</phrase> worlds, Martin Odersky has managed
  to create a language with high <phrase role="keep-together">cohesion</phrase> and orthogonal, deep abstractions
  that invites composability in all dimensions of software design. Scala is
  truly a SCAlable LAnguage that scales with usage, from scripting all the way
  up to large-scale enterprise applications and middleware. Scala was born out
  of academia, but it has grown into a pragmatic and practical language that
  is very much ready for real-world production use.</para><para>What excites me most about this book is that it’s so practical. Dean
  and Alex have done a fantastic job, not only by explaining the language
  through interesting discussions and samples, but also by putting it in the
  context of the real world. Itʼs written for the programmer who wants to get
  things done. I had the pleasure of getting to know Dean some years ago when
  we were both part of the aspect-oriented programming community. Dean holds a
  rare mix of deep analytical academic thinking and a pragmatic,
  get-things-done kind of mentality. Alex, whom I’ve had the pleasure to meet
  once, is leading the API team at Twitter, Inc. Alex has played a leading
  role in moving Twitter’s code and infrastructure to Scala, making it one on
  the first companies to successfully deploy Scala in production.</para><?dbfo-need height=”2in”
?><para>You are about to learn how to write reusable components using mixin
  and function composition; how to write concurrent applications using Scala’s
  Actors; how to make effective use of Scala’s XML/XPath support; how to
  utilize Scalaʼs rich, flexible, and expressive syntax to build
  Domain-Specific Languages; how to effectively test your Scala code; how to
  use Scala with popular frameworks such as Spring, Hadoop, and Terracotta;
  and much, much more. Enjoy the ride. I sure did.</para></preface><preface id="Preface"><title>Preface</title><para><citetitle>Programming Scala</citetitle> introduces an exciting new
  language that offers all the benefits of a modern object model, functional
  programming, and an advanced type system. Packed with code examples, this
  comprehensive book teaches you how to be productive with Scala quickly, and
  explains what makes this language ideal for today’s scalable, distributed,
  component-based applications that support concurrency and distribution.
  You’ll also learn how Scala takes advantage of the advanced Java Virtual
  Machine as a platform for programming languages.</para><para>Learn more at <ulink url="http://programmingscala.com">http://programmingscala.com</ulink> or at
  the book’s <ulink url="http://oreilly.com/catalog/9780596155957/">catalog
  page</ulink>.</para><sect1><title>Welcome to Programming Scala</title><para>Programming languages become popular for many reasons. Sometimes,
    programmers on a given platform prefer a particular language, or one is
    institutionalized by a vendor. Most Mac OS programmers use Objective-C.
    Most Windows programmers use C++ and .NET languages. Most embedded-systems
    developers use C and C++.</para><para>Sometimes, popularity derived from technical merit gives way to
    fashion and fanaticism. C++, Java, and Ruby have been the objects of
    fanatical devotion among <phrase role="keep-together">programmers</phrase>.</para><para>Sometimes, a language becomes popular because it fits the needs of
    its era. Java was initially seen as a perfect fit for browser-based, rich
    client applications. Smalltalk <phrase role="keep-together">captured</phrase> the essence of object-oriented
    programming (OOP) as that model of programming entered the
    mainstream.</para><para>Today, concurrency, heterogeneity, always-on services, and
    ever-shrinking development schedules are driving interest in functional
    programming (FP). It appears that the dominance of object-oriented
    programming may be over. Mixing paradigms is becoming popular, even
    necessary.</para><para>We gravitated to Scala from other languages because Scala embodies
    many of the optimal qualities we want in a general-purpose programming
    language for the kinds of applications we build today: reliable,
    high-performance, highly concurrent Internet and enterprise
    applications.</para><para>Scala is a multi-paradigm language, supporting both object-oriented
    and functional programming approaches. Scala is scalable, suitable for
    everything from short scripts up to large-scale, component-based
    applications. Scala is sophisticated, incorporating state-of-the-art ideas
    from the halls of computer science departments worldwide. Yet Scala is
    practical. Its creator, Martin Odersky, participated in the development of
    Java for years and understands the needs of professional
    developers.</para><para>Both of us were seduced by Scala, by its concise, elegant, and
    expressive syntax and by the breadth of tools it put at our disposal. In
    this book, we strive to demonstrate why all these qualities make Scala a
    compelling and indispensable programming language.</para><para>If you are an experienced developer who wants a fast, thorough
    introduction to Scala, this book is for you. You may be evaluating Scala
    as a replacement for or complement to your current languages. Maybe you
    have already decided to use Scala, and you need to learn its features and
    how to use it well. Either way, we hope to illuminate this powerful
    language for you in an accessible way.</para><para>We assume that you are well versed in object-oriented programming,
    but we don’t assume that you have prior exposure to functional
    programming. We assume that you are experienced in one or more other
    programming languages. We draw parallels to features in Java, C#, Ruby,
    and other languages. If you know any of these languages, we’ll point out
    similar features in Scala, as well as many features that are new.</para><para>Whether you come from an object-oriented or functional programming
    background, you will see how Scala elegantly combines both paradigms,
    demonstrating their complementary nature. Based on many examples, you will
    understand how and when to apply OOP and FP techniques to many different
    design problems.</para><para>In the end, we hope that you too will be seduced by Scala. Even if
    Scala does not end up becoming your day-to-day language, we hope you will
    gain insights that you can apply regardless of which language you are
    using.</para></sect1><sect1 id="_conventions_used_in_this_book"><title>Conventions Used in This Book</title><para id="para_the_following_typographical_co">The following typographical
    conventions are used in this book:</para><variablelist id="para_book_conventions"><varlistentry id="varlistentry-italic"><term><emphasis>Italic</emphasis></term><listitem><para>Indicates new terms, URLs, email addresses, file names, and
          file extensions. Many italicized terms are defined in the <xref linkend="Glossary"/>.</para></listitem></varlistentry><varlistentry id="varlistentry-constant-width"><term><literal moreinfo="none">Constant width</literal></term><listitem><para>Used for program listings, as well as within paragraphs to
          refer to program elements such as variable or function names,
          databases, data types, environment variables, statements, and
          keywords.</para></listitem></varlistentry><varlistentry id="varlistentry-constant-width-bold"><term><userinput moreinfo="none">Constant width bold</userinput></term><listitem><para>Shows commands or other text that should be typed literally by
          the user.</para></listitem></varlistentry><varlistentry id="varlistentry-constant-width-italic"><term><replaceable>Constant width italic</replaceable></term><listitem><para>Shows text that should be replaced with user-supplied values
          or by values determined by context.</para></listitem></varlistentry></variablelist><tip id="para_tip_this_icon_signifies_a_tip"><para>This icon signifies a tip, suggestion, or general note.</para></tip><caution id="para_caution_this_icon_indicates_a"><para>This icon indicates a warning or caution.</para></caution></sect1><sect1 id="UsingCodeExamples"><title>Using Code Examples</title><para id="para_this_book_is_here_to_help_you_">This book is here to help
    you get your job done. In general, you may use the code in this book in
    your programs and documentation. You do not need to contact us for
    permission unless you’re reproducing a significant portion of the code.
    For example, writing a program that uses several chunks of code from this
    book does not require permission. Selling or distributing a CD-ROM of
    examples from O’Reilly books does require permission. Answering a question
    by citing this book and quoting example code does not require permission.
    Incorporating a significant amount of example code from this book into
    your product’s documentation does require permission.</para><para id="para_we_appreciate_but_do_not_requ">We appreciate, but do not
    require, attribution. An attribution usually includes the title, author,
    publisher, and ISBN. For example: “<emphasis>Programming Scala</emphasis>
    by Dean Wampler and Alex Payne. Copyright 2009 Dean Wampler and Alex
    Payne, 978-0-596-15595-7.”</para><para id="para_if_you_feel_your_use_of_code_e">If you feel your use of
    code examples falls outside fair use or the permission given above, feel
    free to contact us at <email>permissions@oreilly.com</email>.</para><sect2 id="GettingCodeExamples"><title>Getting the Code Examples</title><para id="para_you_can_download_the_code_exam">You can download the code
      examples from <ulink url="http://examples.oreilly.com/9780596155964/">http://examples.oreilly.com/9780596155964/</ulink>.
      Unzip the files to a convenient location. See the
      <filename moreinfo="none">README.txt</filename> file in the distribution for
      instructions on building and using the examples.</para><para id="para_file_name_conventions">Some of the example files can be
      run as scripts using the <literal moreinfo="none">scala</literal> command. Others must
      be compiled into class files. Some files contain deliberate errors and
      won’t compile. We have adopted a file naming convention to indicate each
      of these cases, although as you learn Scala it should become obvious
      from the contents of the files, in most cases:<indexterm significance="normal"><primary>code examples in this book</primary></indexterm><indexterm significance="normal"><primary>web page for this book</primary><secondary>code examples</secondary></indexterm></para><variablelist id="para_script_file_convention"><varlistentry id="varlistentry-script-scala"><term><filename moreinfo="none">*-script.scala</filename></term><listitem><para>Files that end in <filename moreinfo="none">-script.scala</filename> can be
            run on a command line using <literal moreinfo="none">scala</literal>, e.g.,
            <literal moreinfo="none">scala foo-script.scala</literal>. You can also start
            <literal moreinfo="none">scala</literal> in the interpreter mode (when you <phrase role="keep-together">don’t specify</phrase> a script file) and
            load any script file in the interpreter using the <literal moreinfo="none">:load
            file⁠name</literal> command.</para></listitem></varlistentry><varlistentry id="varlistentry-wont-compile-scala"><term><filename moreinfo="none">*-wont-compile.scala</filename></term><listitem><para>Files that end in <filename moreinfo="none">-wont-compile.scala</filename>
            contain deliberate errors that will cause them to fail to compile.
            We use this naming convention, along with one or more embedded
            comments about the errors, so it will be clear that they are
            invalid. Also, these files are skipped by the build process for
            the examples.</para></listitem></varlistentry><varlistentry id="varlistentry-sake-scala"><term><filename moreinfo="none">sake.scala</filename></term><listitem><para>Files named <filename moreinfo="none">sake.scala</filename> are used by our
            build tool, called <literal moreinfo="none">sake</literal>. The
            <filename moreinfo="none">README.txt</filename> file describes this tool.</para></listitem></varlistentry><varlistentry id="varlistentry-scala"><term><filename moreinfo="none">*.scala</filename></term><listitem><para>All other Scala files must be compiled using
            <literal moreinfo="none">scalac</literal>. In the distribution, they are used
            either by other compiled or script files, such as tests, not all
            of which are listed in this book.</para></listitem></varlistentry></variablelist></sect2></sect1><sect1><title>Safari® Books Online</title><note role="safarienabled"><para>Safari Books Online is an on-demand digital library that lets you
      easily search over 7,500 technology and creative reference books and
      videos to find the answers you need quickly.</para></note><para>With a subscription, you can read any page and watch any video from
    our library online. Read books on your cell phone and mobile devices.
    Access new titles before they are available for print, and get exclusive
    access to manuscripts in development and post feedback for the authors.
    Copy and paste code samples, organize your favorites, download chapters,
    bookmark key sections, create notes, print out pages, and benefit from
    tons of other time-saving features.</para><para>O’Reilly Media has uploaded this book to the Safari Books Online
    service. To have full digital access to this book and others on similar
    topics from O’Reilly and other publishers, sign up for free at <ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>.</para></sect1><sect1 id="_how_to_contact_us"><title>How to Contact Us</title><para id="para_please_address_comments_and_qu">Please address comments and
    questions concerning this book to the publisher:</para><simplelist type="vert"><member>O’Reilly Media, Inc.</member><member>1005 Gravenstein Highway North</member><member>Sebastopol, CA 95472</member><member>800-998-9938 (in the United States or Canada)<?dbfo-need height=”1in”
?></member><member>707-829-0515 (international or local)</member><member>707-829-0104 (fax)</member></simplelist><para id="para_we_have_a_web_page_for_this_bo">We have a web page for this
    book, where we list errata, examples, and any additional information. You
    can access this page at:<indexterm significance="normal"><primary>web page for this book</primary></indexterm></para><simplelist type="vert"><member><ulink url="http://oreilly.com/catalog/9780596155957/"/></member></simplelist><para id="para_to_comment_or_ask_technical_qu">To comment or ask technical
    questions about this book, send email to:</para><simplelist type="vert"><member><email>bookquestions@oreilly.com</email></member></simplelist><para id="para_for_more_information_about_our">For more information about
    our books, conferences, Resource Centers, and the <phrase role="keep-together">O’Reilly</phrase> Network, see our website at:</para><simplelist type="vert"><member><ulink url="http://oreilly.com"/></member></simplelist></sect1><sect1><title>Acknowledgments</title><para>As we developed this book, many people read early drafts and
    suggested numerous improvements to the text, for which we are eternally
    grateful. We are especially grateful to Steve Jensen, Ramnivas Laddad,
    Marcel Molina, Bill Venners, and Jonas Bonér for their extensive
    feedback.</para><para>Much of the feedback we received came through the Safari Rough Cuts
    releases and the online edition available at <ulink url="http://programmingscala.com">http://programmingscala.com</ulink>. We
    are grateful for the feedback provided by (in no particular order) Iulian
    Dragos, Nikolaj Lindberg, Matt Hellige, David Vydra, Ricky Clarkson, Alex
    Cruise, Josh Cronemeyer, Tyler Jennings, Alan Supynuk, Tony Hillerson,
    Roger Vaughn, Arbi Sookazian, Bruce Leidl, Daniel Sobral, Eder Andres
    Avila, Marek Kubica, Henrik Huttunen, Bhaskar Maddala, Ged Byrne, Derek
    Mahar, Geoffrey Wiseman, Peter Rawsthorne, Geoffrey Wiseman, Joe Bowbeer,
    Alexander Battisti, Rob Dickens, Tim MacEachern, Jason Harris, Steven
    Grady, Bob Follek, Ariel Ortiz, Parth Malwankar, Reid Hochstedler, Jason
    Zaugg, Jon Hanson, Mario Gleichmann, David Gates, Zef Hemel, Michael Yee,
    Marius Kreis, Martin Süsskraut, Javier Vegas, Tobias Hauth, Francesco
    Bochicchio, Stephen Duncan Jr., Patrik Dudits, Jan Niehusmann, Bill
    Burdick, David Holbrook, Shalom Deitch, Jesper Nordenberg, Esa Laine, Gleb
    Frank, Simon Andersson, Patrik Dudits, Chris Lewis, Julian Howarth, Dirk
    Kuzemczak, Henri Gerrits, John Heintz, Stuart Roebuck, and Jungho Kim.
    Many other readers for whom we only have usernames also provided feedback.
    We wish to thank Zack, JoshG, ewilligers, abcoates, brad, teto, pjcj,
    mkleint, dandoyon, Arek, rue, acangiano, vkelman, bryanl, Jeff, mbaxter,
    pjb3, kxen, hipertracker, ctran, Ram R., cody, Nolan, Joshua, Ajay, Joe,
    and anonymous contributors. We apologize if we have overlooked
    anyone!</para><para>Our editor, Mike Loukides, knows how to push and prod gentle. He’s
    been a great help throughout this crazy process. Many other people at
    O’Reilly were always there to answer our questions and help us move
    forward.</para><para>We thank Jonas Bonér for writing the <xref linkend="foreword" xrefstyle="select:nopage"/> for the book. Jonas is a longtime friend and
    collaborator from the aspect-oriented programming (AOP) community. For
    years, he has done pioneering work in the Java community. Now he is
    applying his energies to promoting Scala and growing that
    community.</para><para>Bill Venners graciously provided the quote on the back cover. The
    first published book on Scala, <citetitle>Programming in Scala</citetitle>
    (Artima), that he cowrote with Martin Odersky and Lex Spoon, is
    indispensable for the Scala developer. Bill has also created the wonderful
    ScalaTest library.</para><para>We have learned a lot from fellow developers around the world.
    Besides Jonas and Bill, Debasish Ghosh, James Iry, Daniel Spiewak, David
    Pollack, Paul Snively, Ola Bini, Daniel Sobral, Josh Suereth, Robey
    Pointer, Nathan Hamblen, Jorge Ortiz, and others have illuminated dark
    corners with their blog entries, forum discussions, and personal
    conversations.</para><para>Dean thanks his colleagues at Object Mentor and several developers
    at client sites for many stimulating discussions on languages, software
    design, and the pragmatic issues facing developers in industry. The
    members of the Chicago Area Scala Enthusiasts (CASE) group have also been
    a source of valuable feedback and inspiration.</para><para>Alex thanks his colleagues at Twitter for their encouragement and
    superb work in demonstrating Scala’s effectiveness as a language. He also
    thanks the Bay Area Scala Enthusiasts (BASE) for their motivation and
    <phrase role="keep-together">community</phrase>.</para><para>Most of all, we thank Martin Odersky and his team for creating
    Scala.</para></sect1></preface><chapter id="IntroducingScala"><title>Zero to Sixty: Introducing Scala</title><sect1 id="_why_scala"><title>Why Scala?</title><para id="para_why_scala1">Today’s enterprise and Internet applications
    must balance a number of concerns. They must be implemented quickly and
    reliably. New features must be added in short, incremental cycles. Beyond
    simply providing business logic, applications must support secure access,
    persistence of data, transactional behavior, and other advanced features.
    Applications must be highly available and scalable, requiring designs that
    support <phrase role="keep-together">concurrency</phrase> and
    distribution. Applications are networked and provide interfaces for both
    people and other applications to use.</para><para id="para_why_scala2">To meet these challenges, many developers are
    looking for new languages and tools. Venerable standbys like Java, C#, and
    C++ are no longer optimal for developing the next generation of
    applications.</para><sect2 id="_if_you_are_a_java_programmer_8230"><title>If You Are a Java Programmer…</title><para id="para_java_was_officially_introduced">Java was officially
      introduced by Sun Microsystems in May of 1995, at the advent of
      widespread interest in the Internet. Java was immediately hailed as an
      ideal language for writing browser-based applets, where a secure,
      portable, and developer-friendly application language was needed. The
      reigning language of the day, C++, was not suitable for this
      domain.<indexterm significance="normal"><primary>Java</primary></indexterm></para><para id="para_today_java_is_more_often_used">Today, Java is more often
      used for server-side applications. It is one of the most popular
      languages in use for the development of web and enterprise
      applications.</para><para id="para_however_java_was_a_child_of_i">However, Java was a child
      of its time. Now it shows its age. In 1995, Java provided a syntax
      similar enough to C++ to entice C++ developers, while avoiding many of
      that language’s deficiencies and “sharp edges.” Java adopted the most
      useful ideas for the development problems of its era, such as
      object-oriented programming (OOP), while discarding more troublesome
      techniques, such as manual memory management. These design choices
      struck an excellent balance that minimized complexity and maximized
      developer productivity, while trading-off performance compared to
      natively compiled code. While Java has evolved since its birth, many
      people believe it has grown too complex without adequately addressing
      some newer development challenges.</para><para id="para_developers_want_languages_that">Developers want languages
      that are more succinct and flexible to improve their productivity. This
      is one reason why so-called scripting languages like Ruby and Python
      have become more popular recently.<indexterm significance="normal"><primary>scripting languages, popularity of</primary></indexterm></para><para id="para_the_never_ending_need_to_scale">The never-ending need to
      scale is driving architectures toward pervasive concurrency. However,
      Java’s concurrency model, which is based on synchronized access to
      shared, mutable state, results in complex and error-prone
      programs.<indexterm significance="normal"><primary>concurrency</primary><secondary>Java and</secondary></indexterm></para><para id="para_while_the_java_language_is_sho">While the Java language
      is showing its age, the Java Virtual Machine (JVM) on which it runs
      continues to shine. The optimizations performed by today’s JVM are
      extraordinary, allowing byte code to outperform natively compiled code
      in many cases. Today, many developers believe that using the JVM with
      new languages is the path forward. Sun is embracing this trend by
      employing many of the lead developers of JRuby and Jython, which are JVM
      ports of Ruby and Python, respectively.<indexterm significance="normal"><primary>JVM (Java Virtual Machine)</primary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>JVM (Java Virtual Machine)</secondary></indexterm></para><para id="para_the_appeal_of_scala_for_the_ja">The appeal of Scala for
      the Java developer is that it gives you a newer, more modern language,
      while leveraging the JVM’s amazing performance and the wealth of Java
      libraries that have been developed for over a decade.</para></sect2><sect2 id="_if_you_are_a_ruby_python_etc_programmer_8230"><title>If You Are a Ruby, Python, etc. Programmer…</title><para id="para__dynamically_typed__languages_"><emphasis>Dynamically
      typed</emphasis> languages like Ruby, Python, Groovy, JavaScript, and
      Smalltalk <phrase role="keep-together">offer</phrase> very high
      productivity due to their flexibility, powerful metaprogramming, and
      <phrase role="keep-together">elegance</phrase>.<indexterm significance="normal"><primary>Ruby</primary><secondary>dynamic typing</secondary></indexterm><indexterm significance="normal"><primary>dynamically typed languages</primary></indexterm></para><sidebar><title>Statically Typed Versus Dynamically Typed Languages</title><para id="para_one_of_the_fundamental_languag">One of the fundamental
        language design choices is <emphasis>static versus dynamic</emphasis>
        typing.<indexterm significance="normal"><primary>data types</primary><secondary>static versus dynamic typing</secondary></indexterm><indexterm significance="normal"><primary>static typing</primary><secondary>versus dynamic typing</secondary></indexterm><indexterm significance="normal"><primary>dynamic typing</primary><secondary>versus static typing</secondary></indexterm></para><para id="para_the_word_typing_is_used_in">The word “typing” is used
        in many contexts in software. The following is a “plausible”
        definition that is useful for our purposes.<indexterm significance="normal"><primary>typing</primary></indexterm></para><blockquote><attribution>Benjamin C. Pierce, <citetitle>Types and Programming
          Languages</citetitle> (MIT Press, 2002)</attribution><para>A type system is a tractable syntactic method for preserving
          the absence of certain program behaviors by classifying phrases
          according to the kinds of values they compute.</para></blockquote><para id="para_note_the_emphasis_on_how_a_typ">Note the emphasis on
        how a type system allows reasoning about what a system
        <emphasis>excludes</emphasis> from happening. That’s generally easier
        than trying to determine the set of all allowed possibilities. A type
        system is used to catch various errors, like unsupported operations on
        particular data structures, attempting to combine data in an undefined
        way (e.g., trying to add an integer to a string), breaking
        abstractions, etc.<indexterm significance="normal"><primary>type system</primary></indexterm></para><para id="para_informally_in_static_typing_">Informally, in static
        typing, a <emphasis>variable</emphasis> is bound to a particular type
        for its lifetime. Its type can’t be changed and it can only reference
        type-compatible instances. That is, if a variable refers to a value of
        type <literal moreinfo="none">A</literal>, you can’t assign a value of a different
        type <literal moreinfo="none">B</literal> to it, unless <literal moreinfo="none">B</literal> is a
        subtype of <literal moreinfo="none">A</literal>, for some reasonable definition of
        “subtype.”<indexterm significance="normal"><primary>variables</primary><secondary sortas="static and dynamic typing">in static and
            dynamic typing</secondary></indexterm></para><para id="para_in_dynamic_typing_the_type_is">In dynamic typing, the
        type is bound to the <emphasis>value</emphasis>, not the
        <emphasis>variable</emphasis>. So, a variable might refer to a value
        of type <literal moreinfo="none">A</literal>, then be reassigned later to a value of
        an unrelated type <literal moreinfo="none">X</literal>.</para><para id="para_the_term__dynamically_typed__i">The term
        <emphasis>dynamically typed</emphasis> is used because the type of a
        <emphasis>variable</emphasis> is evaluated when it is used during
        runtime, while in a statically typed language the type is evaluated at
        parse time.</para><para id="para_this_may_seem_like_a_small_dis">This may seem like a
        small distinction, but it has a pervasive impact on the philosophy,
        design, and implementation of a language. We’ll explore some of these
        implications as we go through the book.</para><para id="para_scala_and_java_are_statically_">Scala and Java are
        statically typed languages, whereas Ruby, Python, Groovy, JavaScript,
        and Smalltalk are dynamically typed languages.<indexterm significance="normal"><primary>Java</primary><secondary>static typing</secondary></indexterm></para><para id="para_for_simplicity_we_will_often_">For simplicity, we will
        often use the terms <emphasis>static language</emphasis> and
        <emphasis>dynamic language</emphasis> as shorthands for
        <emphasis>statically typed language</emphasis> and
        <emphasis>dynamically typed language</emphasis>, respectively.</para><para id="para_an__orthogonal__design_conside">An
        <emphasis>orthogonal</emphasis> design consideration is
        <emphasis>strong versus weak</emphasis> typing. In strong typing,
        every variable (for static typing) or value (for dynamic typing) must
        have an unambiguous type. In weak typing, a specific type is not
        required. While most languages allow some mixture of strong versus
        weak typing, Scala, Java, and Ruby are
        <emphasis>predominantly</emphasis> strongly typed languages. Some
        languages, like C and Perl, are more weakly typed.<indexterm significance="normal"><primary>weak versus strong typing</primary></indexterm><indexterm significance="normal"><primary>strong versus weak typing</primary></indexterm></para></sidebar><para id="para_despite_their_productivity_adv">Despite their
      productivity advantages, <emphasis>dynamic</emphasis> languages may not
      be the best choices for all applications, particularly for very large
      code bases and high-performance applications. There is a longstanding,
      spirited debate in the programming community about the relative merits
      of dynamic versus static typing. Many of the points of comparison are
      somewhat subjective. We won’t go through all the arguments here, but we
      will offer a few thoughts for consideration.</para><para id="para_optimizing_the_performance_of_">Optimizing the
      performance of a dynamic language is more challenging than for a static
      language. In a static language, optimizers can exploit the type
      information to make decisions. In a dynamic language, fewer such clues
      are available for the optimizer, making optimization choices harder.
      While recent advancements in optimizations for dynamic languages are
      promising, they lag behind the state of the art for static languages.
      So, if you require very high performance, static languages are probably
      a safer choice.</para><para id="para_static_languages_can_also_bene">Static languages can also
      benefit the development process. Integrated development environment
      (IDE) features like <emphasis>autocompletion</emphasis> (sometimes
      called <emphasis>code sense</emphasis>) are <phrase role="keep-together">easier to implement</phrase> for static languages,
      again because of the extra type information available. The more explicit
      type information in static code promotes better “<phrase role="keep-together">self-</phrase><phrase role="keep-together">documentation</phrase>,” which can be important for
      communicating intent among developers, especially as a project
      grows.</para><para id="para_when_using_a_static_language_">When using a static
      language, you have to think about appropriate type choices more often,
      which forces you to weigh design choices more carefully. While this may
      slow down daily design decisions, thinking through the types in the
      application can result in a more coherent design over time.</para><para id="para_another_small_benefit_of_stati">Another small benefit of
      static languages is the extra checking the compiler performs. We think
      this advantage is often oversold, as type mismatch errors are a small
      fraction of the runtime errors you typically see. The compiler can’t
      find <emphasis>logic</emphasis> errors, which are far more significant.
      Only a comprehensive, automated test suite can find logic errors. For
      dynamically typed languages, the tests must cover possible type errors,
      too. If you are coming from a dynamically typed language, you may find
      that your test suites are a little smaller as a result, but not
      <emphasis>that</emphasis> much smaller.</para><para id="para_many_developers_who_find_stati">Many developers who find
      static languages too verbose often blame static typing for the verbosity
      when the real problem is a lack of <emphasis>type inference</emphasis>.
      In type inference, the compiler infers the types of values based on the
      context. For example, the compiler will recognize that <literal moreinfo="none">x = 1 +
      3</literal> means that <literal moreinfo="none">x</literal> must be an integer. Type
      inference reduces verbosity significantly, making the code feel more
      like code written in a dynamic <phrase role="keep-together">language</phrase>.</para><para id="para_we_have_worked_with_both_stati">We have worked with both
      static and dynamic languages, at various times. We find both kinds of
      languages compelling for different reasons. We believe the modern
      software developer must master a range of languages and tools.
      Sometimes, a dynamic language will be the right tool for the job. At
      other times, a static language like Scala is just what you need.</para></sect2><sect2 id="_introducing_scala"><title>Introducing Scala</title><para id="para__scala__is_a_language_that_add"><emphasis>Scala</emphasis> is a
      language that addresses the major needs of the modern developer. It is a
      statically typed, mixed-paradigm, JVM language with a succinct, elegant,
      and flexible syntax, a sophisticated type system, and idioms that
      promote scalability from small, interpreted scripts to large,
      sophisticated applications. That’s a mouthful, so let’s look at each of
      those ideas in more detail:<indexterm significance="normal"><primary>Scala</primary><secondary>introduction to</secondary></indexterm></para><variablelist id="para_scala_characteristics"><varlistentry id="varlistentry-statically-typed"><term>Statically typed</term><listitem><para>As we described in the previous section, a statically typed
            language binds the type to a <emphasis>variable</emphasis> for the
            lifetime of that variable. In contrast, <emphasis>dynamically
            typed</emphasis> languages bind the type to the actual
            <emphasis>value</emphasis> referenced by a variable, meaning that
            the type of a <emphasis>variable</emphasis> can change along with
            the value it references.</para><para id="para_of_the_set_of_newer_jvm_langua">Of the set of newer
            JVM languages, Scala is one of the few that is statically typed,
            and it is the best known among them.</para></listitem></varlistentry><varlistentry id="varlistentry-mixed-paradigm-object-oriented-programming"><term>Mixed paradigm—object-oriented programming</term><listitem><para>Scala fully supports <emphasis>object-oriented
            programming</emphasis> (OOP). Scala improves upon Java’s support
            for OOP with the addition of <emphasis>traits</emphasis>, a clean
            way of implementing classes using <emphasis>mixin
            composition</emphasis>. Scala’s traits work much like Ruby’s
            <emphasis>modules</emphasis>. If you’re a Java programmer, think
            of traits as unifying interfaces with their <phrase role="keep-together">implementations</phrase>.<indexterm significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>mixed paradigm in Scala</secondary></indexterm><indexterm significance="normal"><primary>mixin composition</primary></indexterm><indexterm significance="normal"><primary>traits</primary></indexterm></para><para id="para_everything_is_object">In Scala, everything is
            <emphasis>really</emphasis> an object. Scala does not have
            primitive types, like Java. Instead, all numeric types are true
            objects. However, for optimal <phrase role="keep-together">performance</phrase>, Scala uses the
            underlying primitives types of the runtime whenever possible.
            Also, Scala does not support “static” or class-level members of
            types, since they are not associated with an actual instance.
            Instead, Scala supports a singleton object construct to support
            those cases where exactly one instance of a type is
            needed.<indexterm significance="normal"><primary>FP</primary><see>functional programming</see></indexterm></para></listitem></varlistentry><varlistentry id="varlistentry-mixed-paradigm-functional-programming"><term>Mixed paradigm—functional programming</term><listitem><para>Scala fully supports <emphasis>functional
            programming</emphasis> (FP). FP is a programming paradigm that is
            older than OOP, but it has been sheltered in the ivory towers of
            academia until recently. Interest in FP is increasing because of
            the ways it simplifies certain design problems, especially
            concurrency. “Pure” functional languages don’t allow for any
            mutable state, thereby avoiding the need for synchronization on
            shared access to mutable state. Instead, programs written in pure
            functional languages communicate by passing messages between
            concurrent, autonomous processes. Scala supports this model with
            its Actors library, but it allows for both mutable and immutable
            variables.<indexterm significance="normal"><primary>immutable variables</primary></indexterm><indexterm significance="normal"><primary>Actors</primary></indexterm><indexterm significance="normal"><primary>variables</primary><secondary>mutable and immutable</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>mixed paradigm in Scala</secondary></indexterm></para><para id="para_functions_are_first_class_">Functions are
            “first-class” citizens in FP, meaning they can be assigned to
            variables, passed to other functions, etc., just like other
            values. This feature promotes composition of advanced behavior
            using primitive operations. Because Scala adheres to the dictum
            that <emphasis>everything is an object</emphasis>, functions are
            themselves objects in Scala.<indexterm significance="normal"><primary>objects</primary><secondary sortas="Scala">in Scala</secondary></indexterm></para><para id="para_scala_also_offers__closures__">Scala also offers
            <emphasis>closures</emphasis>, a feature that dynamic languages
            like Python and Ruby have adopted from the functional programming
            world, and one sadly absent from recent versions of Java. Closures
            are functions that reference variables from the scope enclosing
            the function definition. That is, the variables aren’t passed in
            as arguments or defined as local variables within the function. A
            closure “closes around” these references, so the function
            invocation can safely refer to the variables even when the
            variables have gone out of scope! Closures are such a powerful
            abstraction that object systems and fundamental control structures
            are often <phrase role="keep-together">implemented</phrase> using
            them.<indexterm significance="normal"><primary>closures</primary><secondary>defined</secondary></indexterm></para></listitem></varlistentry><varlistentry id="varlistentry-a-jvm-and-net-language"><term>A JVM and .NET language</term><listitem><para>While Scala is primarily known as a JVM language, meaning
            that Scala generates JVM byte code, a .NET version of Scala that
            generates Common Language Runtime (CLR) byte code is also under
            development. When we refer to the underlying “runtime,” we will
            usually discuss the JVM, but most of what we will say applies
            equally to both runtimes. When we discuss JVM-specific details,
            they generalize to the .NET version, except where noted.<indexterm significance="normal"><primary>CLR (Common Language Runtime), Scala running
                on</primary></indexterm><indexterm significance="normal"><primary>JVM version of Scala</primary></indexterm><indexterm significance="normal"><primary sortas="NET version of Scala">.NET version of
                Scala</primary></indexterm></para><para id="para_the_scala_parser_uses_clever_t">The Scala compiler
            uses clever techniques to map Scala extensions to valid byte code
            idioms. From Scala, you can easily invoke byte code that
            originated as Java source (for the JVM) or C# source (for .NET).
            Conversely, you can invoke Scala code from Java, C#, etc. Running
            on the JVM and CLR allows the Scala developer to leverage
            available libraries and to interoperate with other languages
            hosted on those runtimes.</para></listitem></varlistentry><varlistentry id="varlistentry-a-succinct-elegant-and-flexible-syntax"><term>A succinct, elegant, and flexible syntax</term><listitem><para>Java syntax can be verbose. Scala uses a number of
            techniques to minimize unnecessary syntax, making Scala code as
            succinct as code in most dynamically typed languages.
            <emphasis>Type inference</emphasis> minimizes the need for
            explicit type information in many contexts. Declarations of types
            and functions are very concise.</para><para id="para_scala_allows_function_names_to">Scala allows
            function names to include non-alphanumeric characters. Combined
            with some syntactic sugar, this feature permits the user to define
            methods that look and behave like operators. As a result,
            libraries outside the core of the language can feel “native” to
            users.</para></listitem></varlistentry><varlistentry id="varlistentry-a-sophisticated-type-system"><term>A sophisticated type system</term><listitem><para>Scala extends the type system of Java with more flexible
            generics and a number of more advanced typing constructs. The type
            system can be intimidating at first, but most of the time you
            won’t need to worry about the advanced constructs. Type inference
            helps by automatically inferring type signatures, so that the user
            doesn’t have to provide trivial type information manually. When
            you need them, though, the advanced type features provide you with
            greater flexibility for solving design problems in a type-safe
            way.<indexterm significance="normal"><primary>type system</primary><secondary>Scala</secondary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>Scala’s sophisticated type system</secondary></indexterm></para></listitem></varlistentry><varlistentry id="varlistentry-scalable-architectures"><term>Scalable—architectures</term><listitem><para>Scala is designed to scale from small, interpreted scripts
            to large, distributed applications. Scala provides four language
            mechanisms that promote scalable composition of systems: 1)
            explicit <emphasis>self types</emphasis>; 2) abstract type members
            and generics; 3) nested classes; and 4) <emphasis>mixin</emphasis>
            composition using <emphasis>traits</emphasis>.<indexterm significance="normal"><primary>scalability, Scala support for</primary></indexterm><indexterm significance="normal"><primary>generics</primary></indexterm><indexterm significance="normal"><primary>abstract type members</primary></indexterm><indexterm significance="normal"><primary>self types</primary></indexterm><indexterm significance="normal"><primary>mixin composition</primary><secondary>using traits</secondary></indexterm></para><para id="para_no_other_language_provides_all">No other language
            provides all these mechanisms. Together, they allow applications
            to be constructed from reusable “components” in a type-safe and
            succinct manner. As we will see, many common design patterns and
            architectural techniques like dependency injection are easy to
            implement in Scala without the boilerplate code or lengthy XML
            configuration files that can make Java development tedious.</para></listitem></varlistentry><varlistentry id="varlistentry-scalable-performance"><term>Scalable—performance</term><listitem><para>Because Scala code runs on the JVM and the CLR, it benefits
            from all the performance optimizations provided by those runtimes
            and all the third-party tools that support performance and
            scalability, such as profilers, distributed cache libraries,
            clustering mechanisms, etc. If you trust Java’s and C#’s
            performance, you can trust Scala’s performance. Of course, some
            particular constructs in the language and some parts of the
            library may perform significantly better or worse than alternative
            options in other languages. As always, you should profile your
            code and optimize it when necessary.<indexterm significance="normal"><primary>performance</primary></indexterm></para></listitem></varlistentry></variablelist><para id="para_it_might_appear_that_oop_and_f">It might appear that OOP
      and FP are incompatible. In fact, a design philosophy of Scala is that
      OOP and FP are more synergistic than opposed. The features of one
      approach can enhance the other.</para><para id="para_in_fp_functions_have_no_side_">In FP, functions have no
      side effects and variables are immutable, while in OOP, mutable state
      and side effects are common, even encouraged. Scala lets you choose the
      approach that best fits your design problems. Functional programming is
      especially useful for concurrency, since it eliminates the need to
      synchronize access to mutable state. However, “pure” FP can be
      restrictive. Some design problems are easier to solve with mutable
      objects.</para><para id="para_the_name__scala__is_a_contract">The name
      <emphasis>Scala</emphasis> is a contraction of the words
      <emphasis>scalable language</emphasis>. While this suggests that the
      pronunciation should be <emphasis>scale-ah</emphasis>, the creators of
      Scala actually pronounce it <emphasis>scah-lah</emphasis>, like the
      Italian word for “stairs.” The two “a”s are pronounced the
      same.<indexterm significance="normal"><primary>scalable language (Scala)</primary></indexterm></para><para id="para_scala_was_started_by_martin_od">Scala was started by
      Martin Odersky in 2001. Martin is a professor in the School of Computer
      and Communication Sciences at the Ecole Polytechnique Fédérale de
      Lausanne (EPFL). He spent his graduate years working in the group headed
      by Niklaus Wirth, of Pascal fame. Martin worked on Pizza, an early
      functional language on the JVM. He later worked on GJ, a prototype of
      what later became Generics in Java, with Philip Wadler of Haskell fame.
      Martin was hired by Sun Microsystems to produce the reference
      implementation of <literal moreinfo="none">javac</literal>, the Java compiler that ships
      with the Java Developer Kit (JDK) today.<indexterm significance="normal"><primary>Odersky, Martin</primary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>JDK (Java Development Kit)</secondary></indexterm><indexterm significance="normal"><primary>javac compiler</primary></indexterm><indexterm significance="normal"><primary>JDK (Java Development Kit)</primary></indexterm><indexterm significance="normal"><primary>Odersky, Martin</primary></indexterm></para><para id="para_martin_odersky_s_background_an">Martin Odersky’s
      background and experience are evident in the language. As you learn
      Scala, you come to understand that it is the product of carefully
      considered design decisions, exploiting the state of the art in type
      theory, OOP, and FP. Martin’s experience with the JVM is evident in
      Scala’s elegant integration with that platform. The synthesis it creates
      between OOP and FP is an excellent “best of both worlds”
      solution.</para></sect2><sect2 id="_the_seductions_of_scala"><title>The Seductions of Scala</title><para id="para_today_our_industry_is_fortuna">Today, our industry is
      fortunate to have a wide variety of language options. The power,
      flexibility, and elegance of dynamically typed languages have made them
      very popular again. Yet the wealth of Java and .NET libraries and the
      performance of the JVM and CLR meet many practical needs for enterprise
      and Internet projects.<indexterm significance="normal"><primary>Scala</primary><secondary>benefits of</secondary></indexterm></para><para id="para_scala_is_compelling_because_it">Scala is compelling
      because it feels like a dynamically typed scripting language, due to its
      succinct syntax and type inference. Yet Scala gives you all the benefits
      of static typing, a modern object model, functional programming, and an
      advanced type system. These tools let you build scalable, modular
      applications that can reuse legacy Java and .NET APIs and leverage the
      performance of the JVM and CLR.</para><para id="para_scala_is_a_language_for__profe">Scala is a language for
      <emphasis>professional</emphasis> developers. Compared to languages like
      Java and Ruby, Scala is a more difficult language to master because it
      requires competency with OOP, FP, and static typing to use it most
      effectively. It is tempting to prefer the relative simplicity of
      dynamically typed languages. Yet this simplicity can be deceptive. In a
      dynamically typed language, it is often necessary to use metaprogramming
      features to implement advanced designs. While metaprogramming is
      powerful, using it well takes experience and the resulting code tends to
      be hard to understand, maintain, and debug. In Scala, many of the same
      design goals can be achieved in a type-safe manner by exploiting its
      type system and mixin composition through
      <emphasis>traits</emphasis>.<indexterm significance="normal"><primary>metaprogramming</primary></indexterm></para><para id="para_we_feel_that_the_extra_effort_">We feel that the extra
      effort required day to day to use Scala will promote more careful
      reflection about your designs. Over time, this discipline will yield
      more coherent, modular, and maintainable applications. Fortunately, you
      don’t need all of the sophistication of Scala all of the time. Much of
      your code will have the simplicity and clarity of code written in your
      favorite dynamically typed language.</para><para id="para_an_alternative_strategy_is_to_">An alternative strategy
      is to combine several, simpler languages, e.g., Java for object-oriented
      code and Erlang for functional, concurrent code. Such a decomposition
      can work, but only if your system decomposes cleanly into such discrete
      parts and your team can manage a heterogeneous environment. Scala is
      attractive for situations in which a single, all-in-one language is
      preferred. That said, Scala code can happily coexist with other
      languages, especially on the JVM or .NET.<indexterm significance="normal"><primary>Scala</primary><secondary>combining with other languages</secondary></indexterm></para></sect2></sect1><sect1 id="InstallingScala"><title>Installing Scala</title><para id="para_to_get_up_and_running_as_quick">To get up and running as
    quickly as possible, this section describes how to install the
    command-line tools for Scala, which are all you need to work with the
    examples in the book. For details on using Scala in various editors and
    IDEs, see <xref linkend="IntegrationWithIDEs"/>. The examples used in
    this book were written and compiled using Scala version 2.7.5.final, the
    latest release at the time of this writing, and “nightly builds” of Scala
    version 2.8.0, which may be finalized by the time you read this.<indexterm significance="normal"><primary>Scala</primary><secondary>installing</secondary></indexterm></para><note id="para_v28_new_features"><para>Version 2.8 introduces many new features, which we will highlight
      throughout the book.</para></note><para id="para_we_will_work_with_the_jvm_vers">We will work with the JVM
    version of Scala in this book. First, you must have Java 1.4 or greater
    installed (1.5 or greater is recommended). If you need to install Java, go
    to <ulink url="http://www.java.com/en/download/manual.jsp"/> and
    follow the instructions to install Java on your machine.<indexterm significance="normal"><primary>JVM version of Scala</primary><secondary>installing</secondary></indexterm></para><para id="para_the_official_scala_web_site_is">The official Scala website
    is <ulink url="http://www.scala-lang.org/"/>. To install Scala, go
    to the <ulink url="http://www.scala-lang.org/downloads">downloads
    page</ulink>. Download the installer for your environment and follow the
    instructions on the downloads page.<indexterm significance="normal"><primary>Scala</primary><secondary>official website</secondary></indexterm></para><para id="para_the_easiest_installer_to_use_f">The easiest cross-platform
    installer is the <emphasis>IzPack</emphasis> installer. Download the Scala
    JAR file, either <filename moreinfo="none">scala-2.7.5.final-installer.jar</filename> or
    <filename moreinfo="none">scala-2.8.0.N-installer.jar</filename>, where
    <replaceable>N</replaceable> is the latest release of the 2.8.0 version.
    Go to the download directory in a terminal <phrase role="keep-together">window</phrase>, and install Scala with the
    <literal moreinfo="none">java</literal> command. Assuming you downloaded <filename role="keep-together" moreinfo="none">scala-2.8.0.final-</filename><filename moreinfo="none">in⁠staller.jar</filename>,
    run the following command, which will guide you through the
    process:<indexterm significance="normal"><primary>Mac OS X</primary><secondary>installing Scala</secondary></indexterm><indexterm significance="normal"><primary>cross-platform installer (lzPack)</primary></indexterm></para><screen format="linespecific">java -jar scala-2.8.0.final-installer.jar</screen><tip id="para_tip_on_mac_os_x_the_easiest_"><para>On Mac OS X, the easiest route to a working Scala installation is
      via MacPorts. Follow the installation instructions at <ulink url="http://www.macports.org/"/>, then <literal moreinfo="none">sudo port install
      scala</literal>. You’ll be up and running in a few minutes.</para></tip><para id="para_throughout_this_book_we_will_">Throughout this book, we
    will use the symbol <replaceable>scala-home</replaceable> to refer to the
    “root” directory of your Scala installation.</para><note id="para_note_on_unix_linux_and_maco"><para>On Unix, Linux, and Mac OS X systems, you will need to run this
      <phrase role="keep-together">command</phrase> as the
      <literal moreinfo="none">root</literal> user or using the <literal moreinfo="none">sudo</literal>
      command if you want to <phrase role="keep-together">install
      Scala</phrase> under a system directory, e.g.,
      <replaceable>scala-home</replaceable> <filename moreinfo="none">=
      /usr/local/scala-2.8.0.final</filename>.</para></note><para id="para_as_an_alternative_you_can_dow">As an alternative, you can
    download and expand the compressed TAR file (e.g.,
    <filename moreinfo="none">scala-2.8.0.final.tgz</filename>) or ZIP file
    (<filename moreinfo="none">scala-2.8.0.final.zip</filename>). On Unix-like systems, expand
    the compressed file into a location of your choosing. Afterward, add the
    <replaceable>scala-home</replaceable><filename moreinfo="none">/bin</filename>
    subdirectory in the new directory to your <literal moreinfo="none">PATH</literal>. For
    example, if you installed into <filename role="keep-together" moreinfo="none">/usr/local/scala-2.8.0.final</filename>, then add
    <filename moreinfo="none">/usr/local/scala-2.8.0.final/bin</filename> to your
    <literal moreinfo="none">PATH</literal>.</para><para id="para_to_test_your_installation_run">To test your installation,
    run the following command on the command line:</para><screen format="linespecific">scala -version</screen><para id="para_we_ll_learn_more_about_the_sc">We’ll learn more about the
    <literal moreinfo="none">scala</literal> command-line tool later. You should get something
    like the following output:</para><screen format="linespecific">Scala code runner version 2.8.0.final -- Copyright 2002-2009, LAMP/EPFL</screen><para id="para_of_course_the_version_number_">Of course, the version
    number you see will be different if you installed a different release.
    From now on, when we show command output that contains the version number,
    we’ll show it as <literal moreinfo="none">version 2.8.0.final</literal>.<indexterm significance="normal"><primary>versions, Scala</primary></indexterm></para><para id="para_congratulations_you_have_installed_scala">Congratulations,
    you have installed Scala! If you get an error message along the lines of
    <literal moreinfo="none">scala: command not found</literal>, make sure your environment’s
    <literal moreinfo="none">PATH</literal> is set properly to include the correct
    <filename moreinfo="none">bin</filename> directory.<indexterm significance="normal"><primary>classes</primary><secondary>JDK and .NET, use in Scala</secondary></indexterm></para><note id="para_note_scala_versions_2_7_x_and"><para>Scala versions 2.7.X and earlier are compatible with JDK 1.4 and
      later. Scala version 2.8 drops 1.4 compatibility. Note that Scala uses
      many JDK classes as its own, for example, the <literal moreinfo="none">String</literal>
      class. On .NET, Scala uses the corresponding .NET classes.</para></note><para id="para_you_can_also_find_downloads_fo">You can also find downloads
    for the API documentation and the sources for Scala itself on the same
    downloads page.</para></sect1><sect1 id="ForMoreInformation"><title>For More Information</title><para id="para_as_you_explore_scala_you_will">As you explore Scala, you
    will find other useful resources that are available on <ulink url="http://scala-lang.org"/>. You will find links for development
    support tools and libraries, tutorials, the language specification <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>,
    and academic papers that describe features of the language.<indexterm significance="normal"><primary>Scala</primary><secondary>resources for more information</secondary></indexterm></para><para id="para_the_documentation_for_the_scal">The documentation for the
    Scala tools and APIs are especially useful. You can browse the API at
    <ulink url="http://www.scala-lang.org/docu/files/api/index.html"/>.
    This documentation was generated using the <literal moreinfo="none">scaladoc</literal>
    tool, analogous to Java’s <literal moreinfo="none">javadoc</literal> tool. See <xref linkend="CommandLineToolScaladoc"/> for more information.<indexterm significance="normal"><primary>documentation</primary><secondary>Scala tools and APIs</secondary></indexterm><indexterm significance="normal"><primary>scaladoc tool</primary></indexterm></para><para id="para_you_can_also_download_a_compre">You can also download a
    compressed file of the API documentation for local browsing using the
    appropriate link on the <ulink url="http://www.scala-lang.org/downloads">downloads page</ulink>, or you
    can install it with the <literal moreinfo="none">sbaz</literal> package tool, as
    follows:<indexterm significance="normal"><primary>sbaz tool</primary></indexterm><indexterm significance="normal"><primary>code examples in this book</primary></indexterm><indexterm significance="normal"><primary>web page for this book</primary><secondary>code examples</secondary></indexterm></para><screen format="linespecific">sbaz install scala-devel-docs</screen><para id="para__sbaz_is_installed_in_the_sam"><literal moreinfo="none">sbaz</literal> is
    installed in the same <filename moreinfo="none">bin</filename> directory as the
    <literal moreinfo="none">scala</literal> and <literal moreinfo="none">scalac</literal> command-line tools.
    The installed documentation also includes details on the scala tool chain
    (including <literal moreinfo="none">sbaz</literal>) and code examples. For more
    information on the Scala command-line tools and other resources, see <xref linkend="ScalaToolsLibs"/>.<indexterm significance="normal"><primary>command-line tools</primary><secondary>information on</secondary></indexterm><indexterm significance="normal"><primary>scalac compiler</primary></indexterm><indexterm significance="normal"><primary>scala command</primary></indexterm></para></sect1><sect1 id="ATasteOfScala"><title>A Taste of Scala</title><para id="para_it_s_time_to_whet_your_appetit">It’s time to whet your
    appetite with some real Scala code. In the following examples, we’ll
    describe just enough of the details so you understand what’s going on. The
    goal is to give you a sense of what programming in Scala is like. We’ll
    explore the details of the features in subsequent chapters.<indexterm class="startofrange" id="ch01_Scalaexamples" significance="normal"><primary>Scala</primary><secondary>code examples</secondary></indexterm></para><para id="para_for_our_first_example_you_cou">For our first example, you
    could run it one of two ways: interactively, or as a “script.”<indexterm significance="normal"><primary>scala command</primary><secondary>interactive mode</secondary></indexterm><indexterm significance="normal"><primary>interpreter, starting</primary></indexterm></para><para id="para_let_s_start_with_the_interacti">Let’s start with the
    interactive mode. Start the scala interpreter by typing
    <literal moreinfo="none">scala</literal> and the return key on your command line. You’ll
    see the following output. (Some of the version numbers may vary.)</para><screen format="linespecific">Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt;</screen><para id="para_the_last_line_is_the_prompt_th">The last line is the prompt
    that is waiting for your input. The interactive mode of the
    <literal moreinfo="none">scala</literal> command is very convenient for experimentation
    (see <xref linkend="CommandLineToolScala"/> for more details). An
    interactive interpreter like this is called a REPL: <emphasis>Read,
    Evaluate, Print, Loop</emphasis>.<indexterm significance="normal"><primary>interactive mode, scala command</primary></indexterm></para><?dbfo-need height=”2in”
?><para id="para_type_in_the_following_two_line">Type in the following two
    lines of code:</para><screen format="linespecific">val book = "Programming Scala"
println(book)</screen><para id="para_the_actual_input_and_output_sh">The actual input and output
    should look like the following:</para><screen format="linespecific">scala&gt; val book = "Programming Scala"
book: java.lang.String = Programming Scala

scala&gt; println(book)
Programming Scala

scala&gt;</screen><para id="para_the_first_line_used_the_val_">The first line uses the
    <literal moreinfo="none">val</literal> keyword to declare a read-only variable named
    <literal moreinfo="none">book</literal>. Note that the output returned from the
    interpreter shows you the type and value of <literal moreinfo="none">book</literal>. This
    can be very handy for understanding complex declarations. The second line
    prints the value of <literal moreinfo="none">book</literal>, which is “Programming
    Scala”.<indexterm significance="normal"><primary>val keyword</primary><secondary sortas="declaration">in declaration of read-only
        variable</secondary></indexterm></para><tip id="para_note_experimenting_with_the_"><para>Experimenting with the <literal moreinfo="none">scala</literal> command in the
      interactive mode (REPL) is a great way to learn the details of
      Scala.</para></tip><para id="para_many_of_the_examples_in_this_b">Many of the examples in
    this book can be executed in the interpreter like this. However, it’s
    often more convenient to use the second option we mentioned, writing Scala
    scripts in a text editor or IDE and executing them with the same
    <literal moreinfo="none">scala</literal> command. We’ll do that for most of the remaining
    examples in this chapter.</para><para id="para_in_your_text_editor_of_choice_">In your text editor of
    choice, save the Scala code in the following example to a file named
    <filename moreinfo="none">upper1-script.scala</filename> in a directory of your
    choosing:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/IntroducingScala/upper1-script.scala</code>

<code role="statement">class</code> <code role="special">Upper</code> {
  <code role="statement">def</code> <code role="identifier">upper</code>(strings:<code role="type"> String</code>*):<code role="type"> Seq[String]</code> = {
    strings.map((s:<code role="type">String</code>) <code role="statement">=&gt;</code> s.toUpperCase())
  }
}

<code role="statement">val</code> up = <code role="statement">new</code> <code role="special">Upper</code>
Console.println(up.upper(<code role="constant">"A"</code>, <code role="constant">"First"</code>, <code role="constant">"Scala"</code>, <code role="constant">"Program"</code>))
</programlisting><para id="para_this_scala_script_converts_str">This Scala script converts
    strings to uppercase.</para><para id="para_by_the_way_that_s_a_comment_o">By the way, that’s a comment
    on the first line (with the name of the source file for the code example).
    Scala follows the same comment conventions as Java, C#, C++, etc. A
    <literal moreinfo="none">// <replaceable>comment</replaceable></literal> goes to the end
    of a line, while a <literal moreinfo="none">/* <replaceable>comment</replaceable>
    */</literal> can cross line boundaries.<indexterm significance="normal"><primary>/ (slash)</primary><secondary>/* */ in multi-line comments</secondary></indexterm><indexterm significance="normal"><primary>/ (slash)</primary><secondary>// in single-line comments</secondary></indexterm><indexterm significance="normal"><primary>comments</primary></indexterm></para><?dbfo-need height=”2in”
?><para id="para_to_run_this_script_go_to_a_co">To run this script, go to a
    command window, change to the same directory, and run the following
    command:</para><screen format="linespecific">scala upper1-script.scala</screen><para id="para_the_file_is_interpreted_meani">The file is interpreted,
    meaning it is compiled and executed in one step. You should get the
    following output:</para><programlisting language="scala" format="linespecific"><code role="special">Array</code>(<code role="special">A</code>, <code role="special">FIRST</code>, <code role="special">SCALA</code>, <code role="special">PROGRAM</code>)
</programlisting><sidebar><title>Interpreting Versus Compiling and Running Scala Code</title><para id="para_to_summarize_if_you_type_sca">To summarize, if you type
      <literal moreinfo="none">scala</literal> on the command line without a file argument,
      the interpreter runs in interactive mode. You type in definitions and
      statements that are evaluated on the fly. If you give the command a
      scala source file argument, it compiles and runs the file as a script,
      as in our <literal moreinfo="none">scala upper1-script.scala</literal> example. Finally,
      you can compile Scala files separately and execute the
      <literal moreinfo="none">class</literal> file, as long as it has a
      <literal moreinfo="none">main</literal> method, just as you would normally do with the
      <literal moreinfo="none">java</literal> command. (We’ll show an example
      shortly.)<indexterm significance="normal"><primary>scala command</primary></indexterm><indexterm significance="normal"><primary>compiling versus interpreting</primary></indexterm><indexterm significance="normal"><primary>interpreting versus compiling</primary></indexterm></para><para id="para_there_are_some_subtleties_you_">There are some subtleties
      you’ll need to understand about the limitations of using the interpreter
      modes versus separate compilation and execution steps. We discuss these
      subtleties in <xref linkend="CommandLineTools"/>.</para><para id="para_whenever_we_refer_to__executin">Whenever we refer to
      <emphasis>executing a script</emphasis>, we mean running a Scala source
      file with the <literal moreinfo="none">scala</literal> command.<indexterm significance="normal"><primary>executing a script</primary></indexterm></para></sidebar><para id="para_in_this_example_the_upper_m">In the current example, the
    <literal moreinfo="none">upper</literal> method in the <literal moreinfo="none">Upper</literal> class (no
    pun intended) converts the input strings to uppercase and returns them in
    an array. The last line in the example converts four strings and prints
    the resulting <literal moreinfo="none">Array</literal>.</para><para id="para_let_s_examine_the_code_in_deta">Let’s examine the code in
    detail, so we can begin to learn Scala syntax. There are a lot of details
    in just six lines of code! We’ll explain the general ideas here. All the
    ideas used in this example will be explained more thoroughly in later
    sections of the book.<indexterm significance="normal"><primary>classes</primary><secondary>Upper class (example)</secondary></indexterm></para><para id="para_in_the_example_the_upper_cl">In the example, the
    <literal moreinfo="none">Upper</literal> class begins with the <literal moreinfo="none">class</literal>
    keyword. The class body is inside the outermost curly braces
    (<literal moreinfo="none">{...}</literal>).<indexterm significance="normal"><primary>class keyword</primary></indexterm><indexterm significance="normal"><primary>{ } (curly braces)</primary><secondary>enclosing class body</secondary></indexterm></para><para id="para_the_upper_method_definition_">The <literal moreinfo="none">upper</literal>
    method definition begins on the second line with the
    <literal moreinfo="none">def</literal> keyword, followed by the method name and an
    argument list, the return type of the method, an equals sign
    (<literal moreinfo="none">=</literal>), and then the method body.<indexterm significance="normal"><primary>methods</primary><secondary>defining</secondary></indexterm><indexterm significance="normal"><primary>def keyword</primary></indexterm></para><para id="para_the_argument_list_in_parenthes">The argument list in
    parentheses is actually a <emphasis>variable-length argument
    list</emphasis> of <literal moreinfo="none">String</literal>s, indicated by the
    <literal moreinfo="none">String*</literal> type following the colon. That is, you can pass
    in as many comma-separated strings as you want (including an empty list).
    These strings are stored in a parameter named <literal moreinfo="none">strings</literal>.
    Inside the method, <literal moreinfo="none">strings</literal> is actually an
    <literal moreinfo="none">Array</literal>.<indexterm significance="normal"><primary>: (colon)</primary><secondary>separator between identifiers and type
        annotations</secondary></indexterm><indexterm significance="normal"><primary>type annotations</primary></indexterm><indexterm significance="normal"><primary>variable-length argument lists</primary></indexterm></para><note id="para_note_when_explicit_type_infor"><para>When explicit type information for variables is written in the
      code, these <emphasis>type annotations</emphasis> follow the colon after
      the item name (i.e., Pascal-like syntax). Why doesn’t Scala follow Java
      conventions? Recall that type information is often
      <emphasis>inferred</emphasis> in Scala (unlike Java), meaning we don’t
      always show type annotations explicitly. Compared to Java’s <literal role="keep-together" moreinfo="none">type item</literal> convention, the <literal moreinfo="none">item:
      type</literal> convention is easier for the compiler to analyze
      unambiguously when you omit the colon and the type annotation and just
      write <literal moreinfo="none">item</literal>.</para></note><para id="para_the_method_return_type_appears">The method return type
    appears after the argument list. In this case, the return type is
    <literal moreinfo="none">Seq[String]</literal>, where <literal moreinfo="none">Seq</literal> (“sequence”)
    is a particular kind of collection. It is a <emphasis>parameterized
    type</emphasis> (like a <emphasis>generic</emphasis> type in Java),
    parameterized here with <literal moreinfo="none">String</literal>. Note that Scala uses
    square brackets (<literal moreinfo="none">[...]</literal>) for parameterized types,
    whereas Java uses angle brackets
    (<literal moreinfo="none">&lt;...&gt;</literal>).<indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary sortas="method names">in method names</secondary></indexterm><indexterm significance="normal"><primary>[ ] (square brackets)</primary><secondary>use with parameterized types</secondary></indexterm><indexterm significance="normal"><primary>parameterized types</primary></indexterm></para><note id="para_note_scala_allows_angle_brack"><para>Scala allows angle brackets to be used in method names, e.g.,
      naming a “less than” method <literal moreinfo="none">&lt;</literal> is common. So, to
      avoid ambiguities, Scala uses square brackets instead for parameterized
      types. They can’t be used in method names. Allowing
      <literal moreinfo="none">&lt;</literal> and <literal moreinfo="none">&gt;</literal> in method names is
      why Scala doesn’t follow Java’s convention for angle brackets.</para></note><para id="para_the_body_of_the_upper_method">The body of the
    <literal moreinfo="none">upper</literal> method comes after the equals sign
    (<literal moreinfo="none">=</literal>). Why an equals sign? Why not just curly braces
    (<literal moreinfo="none">{...}</literal>), like in Java? Because semicolons, function
    return types, method arguments lists, and even the curly braces are
    sometimes omitted, using an equals sign prevents several possible parsing
    ambiguities. Using an equals sign also reminds us that even functions are
    values in Scala, which is consistent with Scala’s support of
    <emphasis>functional programming</emphasis>, described in more detail in
    <xref linkend="FunctionalProgramming"/>.<indexterm significance="normal"><primary>= (equals sign)</primary><secondary sortas="method definitions">in method
        definitions</secondary></indexterm></para><para id="para_the_method_body_calls_the_map">The method body calls the
    <literal moreinfo="none">map</literal> method on the <literal moreinfo="none">strings</literal> array,
    which takes a <emphasis>function literal</emphasis> as an argument.
    Function literals are “anonymous” functions. They are similar to
    <emphasis>lambdas</emphasis>, <emphasis>closures</emphasis>,
    <emphasis>blocks</emphasis>, or <emphasis>procs</emphasis> in other
    languages. In Java, you would have to use an anonymous inner class here
    that implements a method defined by an interface, etc.<indexterm significance="normal"><primary>function literals</primary><secondary>defined</secondary></indexterm></para><para id="para_in_this_case_the_function_lit">In this case, we passed in
    the following function literal:</para><programlisting language="scala" format="linespecific">(s:<code role="type">String</code>) <code role="statement">=&gt;</code> s.toUpperCase()
</programlisting><para id="para_takes_a_single_string_argume">It takes an argument list
    with a single <literal moreinfo="none">String</literal> argument named
    <literal moreinfo="none">s</literal>. The body of the function literal is after the
    “arrow,” <literal moreinfo="none">=&gt;</literal>. It calls
    <literal moreinfo="none">toUpperCase()</literal> on <literal moreinfo="none">s</literal>. The result of
    this call is returned by the function literal. In Scala, the last
    <emphasis>expression</emphasis> in a function is the return value,
    although you can have <literal moreinfo="none">return</literal> statements elsewhere, too.
    The <literal moreinfo="none">return</literal> keyword is optional here and is rarely used,
    except when returning out of the middle of a block (e.g., in an
    <literal moreinfo="none">if</literal> statement).<indexterm significance="normal"><primary>return keyword</primary></indexterm></para><note id="para_note_the_value_of_the_last_ex"><para>The value of the last expression is the default return value of a
      function. No <literal moreinfo="none">return</literal> is required.</para></note><para id="para_so_map_passes_each_string_">So, <literal moreinfo="none">map</literal>
    passes each <literal moreinfo="none">String</literal> in <literal moreinfo="none">strings</literal> to the
    function literal and builds up a new collection with the results returned
    by the function literal.</para><para id="para_to_exercise_the_code_we_creat">To exercise the code, we
    create a new <literal moreinfo="none">Upper</literal> instance and assign it to a variable
    named <literal moreinfo="none">up</literal>. As in Java, C#, and similar languages, the
    syntax <literal moreinfo="none">new Upper</literal> creates a new instance. The
    <literal moreinfo="none">up</literal> variable is declared as a read-only “value” using
    the <literal moreinfo="none">val</literal> keyword.<indexterm significance="normal"><primary>println function</primary></indexterm><indexterm significance="normal"><primary>new operator</primary></indexterm><indexterm significance="normal"><primary>val keyword</primary></indexterm></para><para id="para_finally_we_call_the_upper_m">Finally, we call the
    <literal moreinfo="none">upper</literal> method on a list of strings, and print out the
    result with <literal moreinfo="none">Console.println(...)</literal>, which is equivalent
    to Java’s <literal moreinfo="none">System.out.println(...)</literal>.<indexterm significance="normal"><primary>Console.println( ) method</primary></indexterm></para><para id="para_we_can_actually_simplify_this_">We can actually simplify
    our script even further. Consider this simplified version of the
    script:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/IntroducingScala/upper2-script.scala</code>

<code role="statement">object</code> <code role="special">Upper</code> {
  <code role="statement">def</code> <code role="identifier">upper</code>(strings:<code role="type"> String</code>*) = strings.map(<code role="statement">_</code>.toUpperCase())
}

println(Upper.upper(<code role="constant">"A"</code>, <code role="constant">"First"</code>, <code role="constant">"Scala"</code>, <code role="constant">"Program"</code>))
</programlisting><para id="para_this_code_does_exactly_the_sam">This code does exactly the
    same thing, but with a third fewer characters.<indexterm significance="normal"><primary>singleton objects</primary></indexterm><indexterm significance="normal"><primary>objects</primary><secondary sortas="Scala">in Scala</secondary><tertiary>versus class-level members</tertiary></indexterm></para><para id="para_on_the_first_line_upper_is_">On the first line,
    <literal moreinfo="none">Upper</literal> is now declared as an <literal moreinfo="none">object</literal>,
    which is a <emphasis>singleton</emphasis>. We are declaring a class, but
    the Scala runtime will only ever create one instance of
    <literal moreinfo="none">Upper</literal>. (You can’t write <literal moreinfo="none">new Upper</literal>,
    for example.) Scala uses <literal moreinfo="none">objects</literal> for situations where
    other languages would use “class-level” members, like
    <literal moreinfo="none">static</literal>s in Java. We don’t really need more than one
    <emphasis>instance</emphasis> here, so a singleton is fine.</para><note id="para_note_why_doesn_t_scala_suppor"><para>Why doesn’t Scala support <literal moreinfo="none">static</literal>s? Since
      <emphasis>everything</emphasis> is an object in Scala, the
      <literal moreinfo="none">object</literal> construct keeps this policy consistent. Java’s
      <literal moreinfo="none">static</literal> methods and fields are not tied to an actual
      instance.</para></note><para id="para_note_that_this_code_is_fully_t">Note that this code is
    fully thread-safe. We don’t declare any variables that might cause
    thread-safety issues. The API methods we use are also thread-safe.
    Therefore, we don’t need multiple instances. A singleton
    <literal moreinfo="none">object</literal> works fine.</para><para id="para_the_implementation_of_upper_">The implementation of
    <literal moreinfo="none">upper</literal> on the second line is also simpler. Scala can
    usually infer the return type of the method (but not the types of the
    method arguments), so we drop the explicit declaration. Also, because
    there is only one expression in the method body, we drop the braces and
    put the entire method definition on one line. The equals sign before the
    method body tells the compiler, as well as the human reader, where the
    method body begins.</para><para id="para_we_have_also_exploited_a_short">We have also exploited a
    shorthand for the function literal. Previously we wrote it as
    follows:</para><programlisting language="scala" format="linespecific">(s:<code role="type">String</code>) <code role="statement">=&gt;</code> s.toUpperCase()
</programlisting><para id="para_we_can_shorten_it_to_the_follo">We can shorten it to the
    following expression:</para><programlisting language="scala" format="linespecific"><code role="statement">_</code>.toUpperCase()
</programlisting><para id="para_because_map_takes_one_argume">Because
    <literal moreinfo="none">map</literal> takes one argument, a function, we can use the
    “placeholder” indicator <literal moreinfo="none">_</literal> instead of a named parameter.
    That is, the <literal moreinfo="none">_</literal> acts like an anonymous variable, to
    which each string will be assigned before <literal moreinfo="none">toUpperCase</literal>
    is called. Note that the <literal moreinfo="none">String</literal> type is inferred for
    us, too. As we will see, Scala uses <literal moreinfo="none">_</literal> as a “wildcard”
    in several contexts.<indexterm significance="normal"><primary>_ (underscore)</primary><secondary>placeholder in imports, function literals, etc.</secondary></indexterm></para><para id="para_you_can_also_use_this_short_ha">You can also use this
    shorthand syntax in some more complex function literals, as we will see in
    <xref linkend="RoundingOutTheEssentials"/>.</para><para id="para_on_the_last_line_using_an_ob">On the last line, using an
    <literal moreinfo="none">object</literal> rather than a <literal moreinfo="none">class</literal>
    simplifies the code. Instead of creating an instance with <literal moreinfo="none">new
    Upper</literal>, we can just call the <literal moreinfo="none">upper</literal> method on
    the <literal moreinfo="none">Upper</literal> object directly (note how this looks like the
    syntax you would use when calling static methods in a Java class).</para><para id="para_finally_scala_automatically_i">Finally, Scala automatically
    imports many methods for I/O, like <literal moreinfo="none">println</literal>, so we don’t
    need to call <literal moreinfo="none">Console.println()</literal>. We can just use
    <literal moreinfo="none">println</literal> by itself. (See <xref linkend="PredefObject"/>
    for details on the types and methods that are automatically imported or
    defined.)<indexterm significance="normal"><primary>println function</primary></indexterm><indexterm significance="normal"><primary>I/O (input/output)</primary><secondary>automatic importation of methods by Scala</secondary></indexterm></para><para id="para_let_s_do_one_last__refactoring">Let’s do one last
    <emphasis>refactoring</emphasis>. Convert the script into a compiled,
    command-line tool:<indexterm significance="normal"><primary>main method</primary></indexterm><indexterm significance="normal"><primary>compiled, command-line tool, converting script to</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/IntroducingScala/upper3.scala</code>

<code role="statement">object</code> <code role="special">Upper</code> {
  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) = {
    args.map(<code role="statement">_</code>.toUpperCase()).foreach(printf(<code role="constant">"%s "</code>,<code role="statement">_</code>))
    println(<code role="constant">""</code>)
  }
}
</programlisting><para id="para_now_the_upper_method_has_bee">Now the
    <literal moreinfo="none">upper</literal> method has been renamed <literal moreinfo="none">main</literal>.
    Because <literal moreinfo="none">Upper</literal> is an <literal moreinfo="none">object</literal>, this
    <literal moreinfo="none">main</literal> method works exactly like a <literal moreinfo="none">static
    main</literal> method in a Java class. It is the entry point to the
    <literal moreinfo="none">Upper</literal> <emphasis>application</emphasis>.</para><note id="para_note_in_scala_main_must_be"><para>In Scala, <literal moreinfo="none">main</literal> must be a method in an
      <literal moreinfo="none">object</literal>. (In Java, <literal moreinfo="none">main</literal> must be a
      <literal moreinfo="none">static</literal> method in a <literal moreinfo="none">class</literal>.) The
      command-line arguments for the application are passed to
      <literal moreinfo="none">main</literal> in an array of strings, e.g., <literal moreinfo="none">args:
      Array[String]</literal>.</para></note><para id="para_the_first_line_inside_the_mai">The first line inside the
    <literal moreinfo="none">main</literal> method uses the same shorthand notation for
    <literal moreinfo="none">map</literal> that we just examined:</para><programlisting language="scala" format="linespecific">args.map(<code role="statement">_</code>.toUpperCase())...
</programlisting><para id="para_the_call_to_map_returns_a_ne">The call to
    <literal moreinfo="none">map</literal> returns a new collection. We iterate through it
    with <literal moreinfo="none">foreach</literal>. We use a <literal moreinfo="none">_</literal> placeholder
    shortcut again in another <emphasis>function literal</emphasis> that we
    pass to <literal moreinfo="none">foreach</literal>. In this case, each string in the
    collection is passed as an argument to
    <literal moreinfo="none">printf</literal>:<indexterm significance="normal"><primary>function literals</primary><secondary>passing to foreach</secondary></indexterm></para><programlisting language="scala" format="linespecific">...foreach(printf(<code role="constant">"%s "</code>,<code role="statement">_</code>))
</programlisting><para id="para_to_be_clear_these_two_uses_of">To be clear, these two uses
    of <literal moreinfo="none">_</literal> are completely independent of each other. Method
    chaining and function-literal shorthands, as in this example, can take
    some getting used to, but once you are comfortable with them, they yield
    very readable code with minimal use of temporary variables.<indexterm significance="normal"><primary>_ (underscore)</primary><secondary>method chaining and function-literal shorthands</secondary></indexterm></para><para id="para_the_last_line_in_main_adds_a">The last line in
    <literal moreinfo="none">main</literal> adds a final line feed to the output.</para><para id="para_this_time_you_must_first_comp">This time, you must first
    compile the code to a JVM <filename moreinfo="none">.class</filename> file using
    <literal moreinfo="none">scalac</literal>:<indexterm significance="normal"><primary>scalac compiler</primary><secondary>compiling code into JVM .class file</secondary></indexterm></para><screen format="linespecific">scalac upper3.scala</screen><para id="para_you_should_now_have_a_file_nam">You should now have a file
    named <filename moreinfo="none">Upper.class</filename>, just as if you had just compiled a
    Java class.</para><note id="para_note_you_may_have_noticed_tha"><para>You may have noticed that the compiler did not complain when the
      <phrase role="keep-together">file was</phrase> named
      <filename moreinfo="none">upper3.scala</filename> and the <literal moreinfo="none">object</literal> was
      named <literal moreinfo="none">Upper</literal>. Unlike <phrase role="keep-together">Java, the</phrase> file name doesn’t have to match
      the name of the type with <literal moreinfo="none">public</literal> scope. (We’ll
      explore the visibility rules in <xref linkend="VisibilityRules"/>.) In
      fact, unlike Java, you can have as many public types in a single file as
      you want. Furthermore, the directory location of a file doesn’t have to
      match the package declaration. However, you can certainly follow the
      Java conventions, if you want to.</para></note><para id="para_now_you_can_execute_this_comm">Now, you can execute this
    command for any list of strings. Here is an example:<indexterm significance="normal"><primary>scala command</primary><secondary>-cp option</secondary></indexterm></para><screen format="linespecific">scala -cp . Upper Hello World!</screen><para id="para_the_cp_option_adds_he_cur">The <literal moreinfo="none">-cp .</literal>
    option adds the current directory to the search “class path.” You should
    get the following output:</para><screen format="linespecific"> HELLO WORLD!</screen><para id="para_therefore_we_have_met_the_req">Therefore, we have met the
    requirement that a programming language book must start with a “hello
    world” program.<indexterm class="endofrange" startref="ch01_Scalaexamples" significance="normal"/></para></sect1><sect1 id="ATasteOfConcurrency"><title>A Taste of Concurrency</title><para id="para_there_are_many_reasons_to_be_s">There are many reasons to
    be seduced by Scala. One reason is the Actors API included in the Scala
    library, which is based on the robust Actors concurrency model built into
    Erlang (see <link linkend="Haller2007" xrefstyle="select:nopage">[Haller2007]</link>). Here is an example to whet
    your appetite.<indexterm class="startofrange" id="ch01_concurrency" significance="normal"><primary>concurrency</primary></indexterm></para><para id="para_in_the_actor_model_of_concurre">In the Actor model of
    concurrency (<link linkend="Agha1987" xrefstyle="select:nopage">[Agha1987]</link>), independent software
    entities called <emphasis>Actors</emphasis> share no state information
    with each other. Instead, they communicate by <phrase role="keep-together">exchanging</phrase> messages. By eliminating the need
    to synchronize access to shared, mutable state, it is far easier to write
    robust, concurrent applications.<indexterm class="startofrange" id="ch01_actors" significance="normal"><primary>Actors</primary><secondary>example</secondary></indexterm></para><para id="para_in_this_example_instances_in_a_">In this example, instances
    in a geometric <literal moreinfo="none">Shape</literal> hierarchy are sent to an Actor for
    drawing on a display. Imagine a scenario where a rendering “farm”
    generates scenes in an animation. As the rendering of a scene is
    completed, the shape “primitives” that are part of the scene are sent to
    an Actor for a display subsystem.</para><para id="para_to_begin_we_define_a_shape_">To begin, we define a
    <literal moreinfo="none">Shape</literal> class hierarchy:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/IntroducingScala/shapes.scala</code>

<code role="preproc">package</code> shapes {
  <code role="statement">class</code> <code role="special">Point</code>(<code role="statement">val</code> x:<code role="type"> Double</code>, <code role="statement">val</code> y:<code role="type"> Double</code>) {
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"Point("</code> + x + <code role="constant">","</code> + y + <code role="constant">")"</code>
  }

  <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  }

  <code role="statement">class</code> <code role="special">Circle</code>(<code role="statement">val</code> center:<code role="type"> Point</code>, <code role="statement">val</code> radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Circle.draw: "</code> + <code role="statement">this</code>)
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"Circle("</code> + center + <code role="constant">","</code> + radius + <code role="constant">")"</code>
  }

  <code role="statement">class</code> <code role="special">Rectangle</code>(<code role="statement">val</code> lowerLeft:<code role="type"> Point</code>, <code role="statement">val</code> height:<code role="type"> Double</code>, <code role="statement">val</code> width:<code role="type"> Double</code>)
        <code role="statement">extends</code> <code role="special">Shape</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Rectangle.draw: "</code> + <code role="statement">this</code>)
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() =
      <code role="constant">"Rectangle("</code> + lowerLeft + <code role="constant">","</code> + height + <code role="constant">","</code> + width + <code role="constant">")"</code>
  }

  <code role="statement">class</code> <code role="special">Triangle</code>(<code role="statement">val</code> point1:<code role="type"> Point</code>, <code role="statement">val</code> point2:<code role="type"> Point</code>, <code role="statement">val</code> point3:<code role="type"> Point</code>)
        <code role="statement">extends</code> <code role="special">Shape</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Triangle.draw: "</code> + <code role="statement">this</code>)
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() =
      <code role="constant">"Triangle("</code> + point1 + <code role="constant">","</code> + point2 + <code role="constant">","</code> + point3 + <code role="constant">")"</code>
  }
}
</programlisting><para id="para_the_shape_class_hierarchy_is">The <literal moreinfo="none">Shape</literal>
    class hierarchy is defined in a <literal moreinfo="none">shapes</literal> package. You can
    declare the package using Java syntax, but Scala also supports a syntax
    similar to C#’s “namespace” syntax, where the entire declaration is scoped
    using curly braces, as used here. The Java-style package declaration
    syntax is far more commonly used, however, being both compact and
    readable.</para><para id="para_the_point_class_represents_a">The <literal moreinfo="none">Point</literal>
    class represents a two-dimensional point on a plane. Note the argument
    list after the class name. Those are constructor parameters. In Scala, the
    <emphasis>whole</emphasis> class body is the constructor, so you list the
    arguments for the <emphasis>primary</emphasis> constructor after the class
    name and before the class body. (We’ll see how to define auxiliary
    constructors in <xref linkend="Constructors"/>.) Because we put the
    <literal moreinfo="none">val</literal> keyword before each parameter declaration, they are
    automatically converted to read-only fields with the same names with
    public reader methods of the same name. That is, when you instantiate a
    <literal moreinfo="none">Point</literal> instance, e.g., <literal moreinfo="none">point</literal>, you can
    read the fields using <literal moreinfo="none">point.x</literal> and
    <literal moreinfo="none">point.y</literal>. If you want <emphasis>mutable</emphasis>
    fields, then use the keyword <literal moreinfo="none">var</literal>. We’ll explore
    variable declarations and the <literal moreinfo="none">val</literal> and
    <literal moreinfo="none">var</literal> keywords in <xref linkend="VariableDeclarationsAndDefinitions"/>.<indexterm significance="normal"><primary>fields</primary><secondary>mutable</secondary></indexterm><indexterm significance="normal"><primary>mutable fields</primary></indexterm><indexterm significance="normal"><primary>var keyword</primary></indexterm><indexterm significance="normal"><primary>constructors</primary></indexterm></para><para id="para_the_body_of_point_defines_on">The body of
    <literal moreinfo="none">Point</literal> defines one method, an
    <emphasis>override</emphasis> of the familiar <literal moreinfo="none">toString</literal>
    method in Java (like <literal moreinfo="none">ToString</literal> in C#). Note that Scala,
    like C#, requires the <literal moreinfo="none">override</literal> keyword whenever you
    override a concrete method. Unlike C#, you don’t have to use a <literal role="keep-together" moreinfo="none">virtual</literal> keyword on the original concrete
    method. In fact, there is no <literal moreinfo="none">virtual</literal> keyword in Scala.
    As before, we omit the curly braces (<literal moreinfo="none">{...}</literal>) around the
    body of <literal moreinfo="none">toString</literal>, since it has only one
    expression.<indexterm significance="normal"><primary>C#</primary><secondary>override keyword for concrete methods</secondary></indexterm><indexterm significance="normal"><primary>override keyword</primary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>abstract</secondary></indexterm><indexterm significance="normal"><primary>abstract classes</primary></indexterm></para><para id="para__shape_is_an_abstract_class_"><literal moreinfo="none">Shape</literal> is
    an abstract class. Abstract classes in Scala are similar to those in Java
    and C#. We can’t instantiate instances of abstract classes, even when all
    their field and method members are concrete.</para><para id="para_in_this_case_shape_declares_a">In this case, Shape declares
    an <emphasis>abstract</emphasis> <literal moreinfo="none">draw</literal> method. We know
    it is abstract because it has no body. No <literal moreinfo="none">abstract</literal>
    keyword is required on the method. Abstract methods in Scala are just like
    abstract methods in Java and C#. (See <xref linkend="OverridingMembers"/>
    for more details.)<indexterm significance="normal"><primary>C#</primary><secondary>abstract methods</secondary></indexterm></para><para>The <literal moreinfo="none">draw</literal> method returns <literal moreinfo="none">Unit</literal>,
    which is a type that is roughly equivalent to <literal moreinfo="none">void</literal> in
    C-derived languages like Java, etc. (See <xref linkend="ScalaTypeHierarchy"/> for more details.)</para><para id="para__circle_is_declared_as_a_conc"><literal moreinfo="none">Circle</literal> is
    declared as a concrete subclass of <literal moreinfo="none">Shape</literal>. It defines
    the <literal moreinfo="none">draw</literal> method to simply print a message to the
    console. <literal moreinfo="none">Circle</literal> also overrides
    <literal moreinfo="none">toString</literal>.</para><para id="para__rectangle_is_also_a_concrete"><literal moreinfo="none">Rectangle</literal>
    is also a concrete subclass of <literal moreinfo="none">Shape</literal> that defines
    <literal moreinfo="none">draw</literal> and overrides <literal moreinfo="none">toString</literal>. For
    simplicity, we assume it is not rotated relative to the
    <emphasis>x</emphasis> and <emphasis>y</emphasis> axes. Hence, all we need
    is one point, the lower lefthand point will do, and the height and width
    of the rectangle.</para><para id="para__triangle_follows_the_same_pa"><literal moreinfo="none">Triangle</literal>
    follows the same pattern. It takes three <literal moreinfo="none">Points</literal> as its
    constructor arguments.<indexterm significance="normal"><primary>this keyword</primary></indexterm></para><para id="para_both_draw_methods_in_circle">Both <literal moreinfo="none">draw</literal>
    methods in <literal moreinfo="none">Circle</literal>, <literal moreinfo="none">Rectangle</literal>, and
    <literal moreinfo="none">Triangle</literal> use <literal moreinfo="none">this</literal>. As in Java and
    C#, <literal moreinfo="none">this</literal> is how an instance refers to itself. In this
    context, where <literal moreinfo="none">this</literal> is the righthand side of a String
    concatenation expression (using the plus sign),
    <literal moreinfo="none">this.toString</literal> is invoked implicitly.<indexterm significance="normal"><primary>C#</primary><secondary>this keyword</secondary></indexterm></para><note id="para_note_of_course_in_a_real_app"><para>Of course, in a real application, you would not implement drawing
      in “domain model” classes like this, since the implementations would
      depend on details like the operating system platform, graphics API, etc.
      We will see a better design approach when we discuss
      <emphasis>traits</emphasis> in <xref linkend="Traits"/>.</para></note><para id="para_now_that_we_have_defined_our_s">Now that we have defined
    our shapes types, let’s return to Actors. We define an Actor that receives
    “messages” that are shapes to draw:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/IntroducingScala/shapes-actor.scala</code>

<code role="preproc">package</code> shapes {
  <code role="preproc">import</code> scala.actors._
  <code role="preproc">import</code> scala.actors.Actor._

  <code role="statement">object</code> <code role="special">ShapeDrawingActor</code> <code role="statement">extends</code> <code role="special">Actor</code> {
    <code role="statement">def</code> <code role="identifier">act</code>() {
      loop {
        receive {
          <code role="statement">case</code> s:<code role="type"> Shape =&gt; s.draw</code>()
          <code role="statement">case</code> <code role="constant">"exit"</code>   <code role="statement">=&gt;</code> println(<code role="constant">"exiting..."</code>); exit
          <code role="statement">case</code> x:<code role="type"> Any   =&gt; println</code>(<code role="constant">"Error: Unknown message! "</code> + x)
        }
      }
    }
  }
}
</programlisting><para id="para_the_actor_is_declared_to_be_pa">The Actor is declared to be
    part of the <literal moreinfo="none">shapes</literal> package. Next, we have two import
    <phrase role="keep-together">statements</phrase>.<indexterm significance="normal"><primary>import statements</primary></indexterm></para><para id="para_the_first_import_statement_imp">The first import statement
    imports all the types in the <literal moreinfo="none">scala.actors</literal> package. In
    Scala, the underscore <literal moreinfo="none">_</literal> is used the way the star
    <literal moreinfo="none">*</literal> is used in Java.<indexterm significance="normal"><primary>_ (underscore)</primary><secondary>wildcard character in Scala</secondary></indexterm></para><note id="para_note_because_is_a_valid_cha"><para>Because <literal moreinfo="none">*</literal> is a valid character for a function
      name, it can’t be used as the <literal moreinfo="none">import</literal> wildcard.
      Instead, <literal moreinfo="none">_</literal> is reserved for this purpose.</para></note><para id="para_all_the_methods_and_public_fie">All the methods and public
    fields from <literal moreinfo="none">Actor</literal> are imported by the second
    <literal moreinfo="none">import</literal>. These are not <literal moreinfo="none">static</literal> imports
    from the <literal moreinfo="none">Actor</literal> type, as they would be in Java. Rather,
    they are imported from an <literal moreinfo="none">object</literal> that is also named
    <literal moreinfo="none">Actor</literal>. The <literal moreinfo="none">class</literal> and
    <literal moreinfo="none">object</literal> can have the same name, as we will see in <xref linkend="CompanionObjects"/>.<indexterm significance="normal"><primary>Actors</primary><secondary>Actor class and object</secondary></indexterm></para><para id="para_our_actor_class_definition_s">Our Actor class definition,
    <literal moreinfo="none">ShapeDrawingActor</literal>, is an <literal moreinfo="none">object</literal> that
    extends <literal moreinfo="none">Actor</literal> (the type, not the
    <literal moreinfo="none">object</literal>). The <literal moreinfo="none">act</literal> method is
    overridden to do the unique work of the Actor. Because
    <literal moreinfo="none">act</literal> is an abstract method, we don’t need to explicitly
    override it with the <literal moreinfo="none">override</literal> keyword. Our Actor loops
    indefinitely, waiting for incoming messages.</para><para id="para_during_each_pass_in_the_loop_">During each pass in the
    loop, the <literal moreinfo="none">receive</literal> method is called. It blocks until a
    new message arrives. Why is the code after <literal moreinfo="none">receive</literal>
    enclosed in curly braces <literal moreinfo="none">{...}</literal> and not parentheses
    <literal moreinfo="none">(...)</literal>? We will learn later that there are cases where
    this substitution is allowed and is quite useful (see <xref linkend="RoundingOutTheEssentials"/>). For now, what you need to know is
    that the expressions inside the braces constitute a single
    <emphasis>function literal</emphasis> that is passed to
    <literal moreinfo="none">receive</literal>. This function literal does a <emphasis>pattern
    match</emphasis> on the message instance to decide how to handle the
    message. Because of the <literal moreinfo="none">case</literal> clauses, it looks like a
    typical switch statement in Java, for example, and the behavior is very
    similar.<indexterm significance="normal"><primary>function literals</primary><secondary>passing to method for pattern matching</secondary></indexterm><indexterm significance="normal"><primary>{ } (curly braces)</primary><secondary>substituting for parentheses in method call</secondary></indexterm><indexterm significance="normal"><primary>( ) (parentheses)</primary><secondary>substituting curly braces for in method call</secondary></indexterm><indexterm significance="normal"><primary>pattern matching</primary></indexterm></para><para id="para_the_first_case_does_a_type_c">The first
    <literal moreinfo="none">case</literal> does a type comparison with the message. (There is
    no explicit variable for the message instance in the code; it is
    inferred.) If the message is of type <literal moreinfo="none">Shape</literal>, the first
    <literal moreinfo="none">case</literal> matches. The message instance is cast to a
    <literal moreinfo="none">Shape</literal> and assigned to the variable
    <literal moreinfo="none">s</literal>, and then the <literal moreinfo="none">draw</literal> method is
    called on it.</para><para id="para_if_the_message_is_not_a_shape">If the message is not a
    <literal moreinfo="none">Shape</literal>, the second <literal moreinfo="none">case</literal> is tried. If
    the message is the string <literal moreinfo="none">"exit"</literal>, the Actor prints a
    message and terminates execution. Actors should usually have a way to exit
    gracefully!</para><para id="para_the_last_case_handles_any_ot">The last
    <literal moreinfo="none">case</literal> clause handles any other message instance, thereby
    functioning as the <emphasis>default</emphasis> case. The Actor reports an
    error and then drops the message. <literal moreinfo="none">Any</literal> is the parent of
    all types in the Scala type hierarchy, like <literal moreinfo="none">Object</literal> is
    the root type in Java and other languages. Hence, this case clause will
    match any message of any type. Pattern matching is eager; we have to put
    this case clause at the end, so it doesn’t consume the messages we are
    expecting!</para><para id="para_recall_that_we_declared_draw_">Recall that we declared
    <literal moreinfo="none">draw</literal> as an abstract method in <literal moreinfo="none">Shape</literal>
    and we implemented <literal moreinfo="none">draw</literal> in the concrete subclasses.
    Hence, the code in the first <literal moreinfo="none">case</literal> statement invokes a
    polymorphic operation.</para><sidebar><title>Pattern Matching Versus Polymorphism</title><para id="para__pattern_matching__plays_a_cen"><emphasis>Pattern
      matching</emphasis> plays a central role in functional programming just
      as polymorphism plays a central role in object-oriented programming.
      Functional pattern matching is much more important and sophisticated
      than the corresponding <literal moreinfo="none">switch/case</literal> statements found
      in most <emphasis>imperative</emphasis> languages, like Java. We will
      examine Scala’s support for pattern matching in more detail in <xref linkend="FunctionalProgramming"/>. In our example here, we can begin to
      see that joining functional-style pattern matching with object-oriented
      polymorphic dispatching is a powerful combination that is a benefit of
      mixed paradigm languages like Scala.<indexterm significance="normal"><primary>imperative languages</primary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary>polymorphism versus</secondary></indexterm><indexterm significance="normal"><primary>polymorphism</primary><secondary>pattern matching versus</secondary></indexterm></para></sidebar><para id="para_finally_here_is_a_script_that">Finally, here is a script
    that uses the <literal moreinfo="none">ShapeDrawingActor</literal> Actor:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/IntroducingScala/shapes-actor-script.scala</code>

<code role="preproc">import</code> shapes._

ShapeDrawingActor.start()

<code role="special">ShapeDrawingActor</code> ! <code role="statement">new</code> <code role="special">Circle</code>(<code role="statement">new</code> <code role="special">Point</code>(<code role="constant">0.0</code>,<code role="constant">0.0</code>), <code role="constant">1.0</code>)
<code role="special">ShapeDrawingActor</code> ! <code role="statement">new</code> <code role="special">Rectangle</code>(<code role="statement">new</code> <code role="special">Point</code>(<code role="constant">0.0</code>,<code role="constant">0.0</code>), <code role="constant">2</code>, <code role="constant">5</code>)
<code role="special">ShapeDrawingActor</code> ! <code role="statement">new</code> <code role="special">Triangle</code>(<code role="statement">new</code> <code role="special">Point</code>(<code role="constant">0.0</code>,<code role="constant">0.0</code>),
                                 <code role="statement">new</code> <code role="special">Point</code>(<code role="constant">1.0</code>,<code role="constant">0.0</code>),
                                 <code role="statement">new</code> <code role="special">Point</code>(<code role="constant">0.0</code>,<code role="constant">1.0</code>))
<code role="special">ShapeDrawingActor</code> ! <code role="constant">3.14159</code>

<code role="special">ShapeDrawingActor</code> ! <code role="constant">"exit"</code>
</programlisting><?dbfo-need height=”1in”
?><para id="para_the_shapes_in_the_shapes_pac">The shapes in the
    <literal moreinfo="none">shapes</literal> package are imported.</para><para id="para_the_shapedrawingactor_actor_">The
    <literal moreinfo="none">ShapeDrawingActor</literal> Actor is started. By default, it runs
    in its own thread (there are alternatives we will discuss in <xref linkend="Concurrency"/>), waiting for messages.</para><para id="para_five_messages_are_sent_to_the_">Five messages are sent to
    the Actor, using the syntax <literal moreinfo="none">actor ! message</literal>. The first
    message sends a <literal moreinfo="none">Circle</literal> instance. The Actor “draws” the
    circle. The second message sends a <literal moreinfo="none">Rectangle</literal> message.
    The Actor “draws” the rectangle. The third message does the same thing for
    a <literal moreinfo="none">Triangle</literal>. The fourth message sends a
    <literal moreinfo="none">Double</literal> that is approximately equal to
    <emphasis>Pi</emphasis>. This is an unknown message for the Actor, so it
    just prints an error message. The final message sends an “exit” string,
    which causes the Actor to terminate.<indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>! method, sending messages to Actors</secondary></indexterm></para><para id="para_to_try_out_the_actor_example_">To try out the Actor
    example, start by compiling the first two files. You can get <phrase role="keep-together">the sources</phrase> from the <ulink url="http://examples.oreilly.com/9780596155964/">O’Reilly download
    site</ulink> (see <xref linkend="GettingCodeExamples"/> for details), or
    you can create them yourself.</para><para id="para_use_the_following_command_to_c">Use the following command
    to compile the files:</para><screen format="linespecific"> scalac shapes.scala shapes-actor.scala</screen><para id="para_while_the_source_file_names_an">While the source file names
    and locations don’t have to match the file contents, you will notice that
    the generated class files are written to a <filename moreinfo="none">shapes</filename>
    directory and there is one class file for each class we defined. The class
    file names and locations must conform to the JVM requirements.</para><para id="para_now_you_can_run_the_script_to_">Now you can run the script
    to see the Actor in action:</para><screen format="linespecific"> scala -cp . shapes-actor-script.scala</screen><para id="para_you_should_see_the_following_o">You should see the
    following output:</para><screen format="linespecific">Circle.draw: Circle(Point(0.0,0.0),1.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,5.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))
Error: Unknown message! 3.14159
exiting...</screen><para id="para_for_more_on_actors_see_co">For more on Actors, see <xref linkend="Concurrency"/>.<indexterm class="endofrange" startref="ch01_actors" significance="normal"/><indexterm class="endofrange" startref="ch01_concurrency" significance="normal"/></para></sect1><sect1 id="_recap_and_what_8217_s_next"><title>Recap and What’s Next</title><para id="para_we_made_the_case_for_scala_and">We made the case for Scala
    and got you started with two sample Scala programs, one of which gave you
    a taste of Scala’s Actors library for concurrency. Next, we’ll dive into
    more Scala syntax, emphasizing various keystroke-economical ways of
    getting lots of work done.</para></sect1></chapter><chapter id="TypeLessDoMore"><title>Type Less, Do More</title><sect1 id="_in_this_chapter"><title>In This Chapter</title><para id="para_we_ended_the_last_chapter_with">We ended the previous
    chapter with a few “teaser” examples of Scala code. This chapter discusses
    uses of Scala that promote succinct, flexible code. We’ll discuss
    organization of files and packages, importing other types, variable
    declarations, miscellaneous syntax conventions, and a few other concepts.
    We’ll emphasize how the concise syntax of Scala helps you work better and
    faster.</para><para id="para_scala_s_syntax_is_especially_u">Scala’s syntax is
    especially useful when writing scripts. Separate compile and run steps
    aren’t required for simple programs that have few dependencies on
    libraries outside of what Scala provides. You compile and run such
    programs in one shot with the <literal moreinfo="none">scala</literal> command. If you’ve
    <ulink role="orm:hideurl" url="http://examples.oreilly.com/9780596155964/">downloaded the example
    code</ulink> for this book, many of the smaller examples can be run using
    the <literal moreinfo="none">scala</literal> command, e.g., <literal moreinfo="none">scala
    </literal><replaceable>filename</replaceable><literal moreinfo="none">.scala</literal>.
    See the <filename moreinfo="none">README.txt</filename> files in each chapter’s code
    examples for more details. See also <xref linkend="CommandLineTools"/>
    for more information about using the <literal moreinfo="none">scala</literal>
    command.</para></sect1><sect1 id="Semicolons"><title>Semicolons</title><para id="para_you_may_have_already_noticed_t">You may have already
    noticed that there were very few semicolons in the code examples in the
    previous chapter. You can use semicolons to separate statements and
    expressions, as in Java, C, PHP, and similar languages. In most cases,
    though, Scala behaves like many scripting languages in treating the end of
    the line as the end of a statement or an expression. When a statement or
    expression is too long for one line, Scala can usually infer when you are
    continuing on to the next line, as shown in this example:<indexterm significance="normal"><primary>; (semicolon)</primary><secondary>ending statements in Scala code</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/semicolon-example-script.scala</code>

<code role="comment">// Trailing equals sign indicates more code on next line</code>
<code role="statement">def</code> <code role="identifier">equalsign</code> = {
  <code role="statement">val</code> reallySuperLongValueNameThatGoesOnForeverSoYouNeedANewLine =
    <code role="constant">"wow that was a long value name"</code>

  println(reallySuperLongValueNameThatGoesOnForeverSoYouNeedANewLine)
}

<code role="comment">// Trailing opening curly brace indicates more code on next line</code>
<code role="statement">def</code> <code role="identifier">equalsign2</code>(s:<code role="type"> String</code>) = {
  println(<code role="constant">"equalsign2: "</code> + s)
}

<code role="comment">// Trailing comma, operator, etc. indicates more code on next line</code>
<code role="statement">def</code> <code role="identifier">commas</code>(s1:<code role="type"> String</code>,
           s2:<code role="type"> String</code>) = {
  println(<code role="constant">"comma: "</code> + s1 +
          <code role="constant">", "</code> + s2)
}
</programlisting><para id="para_when_you_want_to_put_multiple_">When you want to put
    multiple statements or expressions on the same line, you can use
    semicolons to separate them. We used this technique in the
    <literal moreinfo="none">ShapeDrawingActor</literal> example in <xref linkend="ATasteOfConcurrency"/>:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="constant">"exit"</code> <code role="statement">=&gt;</code> println(<code role="constant">"exiting..."</code>); exit
</programlisting><para id="para_this_line_could_also_be_writte">This code could also be
    written as follows:</para><programlisting language="scala" format="linespecific">...
<code role="statement">case</code> <code role="constant">"exit"</code> <code role="statement">=&gt;</code>
      println(<code role="constant">"exiting..."</code>)
      exit
...
</programlisting><para id="para_why_no_curly_braces">You might wonder why you don’t need
    curly braces (<literal moreinfo="none">{...}</literal>) around the two statements after
    the <literal moreinfo="none">case ... =&gt;</literal> line. You can put them in if you
    want, but the compiler knows when you’ve reached the end of the “block”
    when it finds the next <literal moreinfo="none">case</literal> clause or the curly brace
    (<literal moreinfo="none">}</literal>) that ends the enclosing block for all the
    <literal moreinfo="none">case</literal> clauses.<indexterm significance="normal"><primary>{ } (curly braces)</primary><secondary>{ indicating more code on next line</secondary></indexterm></para><para id="para_omitting_optional_semicolons_m">Omitting optional
    semicolons means fewer characters to type and fewer characters to clutter
    your code. Breaking separate statements onto their own lines increases
    your code’s readability.</para></sect1><sect1 id="VariableDeclarationsAndDefinitions"><title>Variable Declarations</title><para id="para_scala_allows_you_to_decide_whe">Scala allows you to decide
    whether a variable is immutable (read-only) or not (read-write) when you
    declare it. An immutable “variable” is declared with the keyword
    <literal moreinfo="none">val</literal> (think <emphasis>value
    object</emphasis>):<indexterm significance="normal"><primary>val keyword</primary><secondary>using in declaration of immutable variable</secondary></indexterm><indexterm significance="normal"><primary>immutable variables</primary><secondary>declaring</secondary></indexterm><indexterm significance="normal"><primary>variables</primary><secondary>declarations</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">val</code> array:<code role="type"> Array[String]</code> = <code role="statement">new</code> <code role="special">Array</code>(<code role="constant">5</code>)
</programlisting><para id="para_immutable_precise">To be more precise, the
    <literal moreinfo="none">array</literal> reference cannot be changed to point to a
    different <literal moreinfo="none">Array</literal>, but the array itself can be modified,
    as shown in the following <literal moreinfo="none">scala</literal> session:</para><programlisting language="scala" format="linespecific">scala&gt; <code role="statement">val</code> array:<code role="type"> Array[String]</code> = <code role="statement">new</code> <code role="special">Array</code>(<code role="constant">5</code>)
array:<code role="type"> Array[String]</code> = <code role="special">Array</code>(<code role="statement">null</code>, <code role="statement">null</code>, <code role="statement">null</code>, <code role="statement">null</code>, <code role="statement">null</code>)

scala&gt; array = <code role="statement">new</code> <code role="special">Array</code>(<code role="constant">2</code>)
<code role="preproc">&lt;console&gt;</code><code role="constant">:5: error: reassignment to val</code>
<code role="constant">       array = new Array(2)</code>
<code role="constant">             ^</code>

<code role="constant">scala&gt; array(0) = "Hello"</code>

<code role="constant">scala&gt; array</code>
<code role="constant">res3: Array[String] = Array(Hello, null, null, null, null)</code>

<code role="constant">scala&gt;</code>
</programlisting><para id="para_an_immutable_object_must_be_in">An immutable
    <literal moreinfo="none">val</literal> must be initialized—that is, defined—when it is
    declared.</para><para id="para_a_mutable_variable_is_declared">A mutable variable is
    declared with the keyword <literal moreinfo="none">var</literal>:</para><programlisting language="scala" format="linespecific">scala&gt; <code role="statement">var</code> stockPrice:<code role="type"> Double</code> = <code role="constant">100.</code>
stockPrice:<code role="type"> Double</code> = <code role="constant">100.0</code>

scala&gt; stockPrice = <code role="constant">10.</code>
stockPrice:<code role="type"> Double</code> = <code role="constant">10.0</code>

scala&gt;
</programlisting><para id="para_scala_also_requires_you_to_ini">Scala also requires you to
    initialize a <literal moreinfo="none">var</literal> when it is declared. You can assign a
    new value to a <literal moreinfo="none">var</literal> as often as you want. Again, to be
    precise, the <literal moreinfo="none">stockPrice</literal> reference can be changed to
    point to a different <literal moreinfo="none">Double</literal> object (e.g.,
    <literal moreinfo="none">10.</literal>). In this case, the object that
    <literal moreinfo="none">stockPrice</literal> refers to can’t be changed, because
    <literal moreinfo="none">Doubles</literal> in Scala are immutable.</para><para id="para_there_s_one_exception_to_the_r">There are a few exceptions
    to the rule that you must initialize <literal moreinfo="none">val</literal>s and
    <literal moreinfo="none">var</literal>s when they are declared. Both keywords can be used
    with constructor parameters. When used as constructor parameters, the
    mutable or immutable variables specified will be initialized when an
    object is instantiated. Both keywords can be used to declare “abstract”
    (uninitialized) variables in abstract types. Also, derived types can
    override <literal moreinfo="none">val</literal>s declared inside parent types. We’ll
    discuss these exceptions in <xref linkend="BasicObjectOrientedProgramming"/>.<indexterm significance="normal"><primary>parameters</primary><secondary>constructor, initialization of vals and vars</secondary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>derived, overriding vals declared in parent
        classes</secondary></indexterm></para><para id="para_scala_encourages_you_to_use_im">Scala encourages you to use
    immutable values whenever possible. As we will see, this promotes better
    object-oriented design and is consistent with the principles of “pure”
    functional programming. It may take some getting used to, but you’ll find
    a newfound confidence in your code when it is written in an immutable
    style.</para><note id="para_note_the_var_and_val_keyw"><para>The <literal moreinfo="none">var</literal> and <literal moreinfo="none">val</literal> keywords
      only specify whether the reference can be changed to refer to a
      different object (<literal moreinfo="none">var</literal>) or not
      (<literal moreinfo="none">val</literal>). They don’t specify whether or not the object
      they reference is mutable.</para></note></sect1><sect1 id="MethodDeclarationsAndDefinitions"><title>Method Declarations</title><para id="para_method_declarations">In <xref linkend="IntroducingScala"/>
    we saw several examples of how to define <emphasis>methods</emphasis>,
    which are functions that are members of a class. Method
    <emphasis>definitions</emphasis> start with the <literal moreinfo="none">def</literal>
    keyword, followed by optional argument lists, a colon character
    (<literal moreinfo="none">:</literal>) and the return type of the method, an equals sign
    (<literal moreinfo="none">=</literal>), and finally the method body. Methods are
    implicitly <emphasis>declared</emphasis> “abstract” if you leave off the
    equals sign and method body. The enclosing type is then itself abstract.
    We’ll discuss abstract types in more detail in <xref linkend="BasicObjectOrientedProgramming"/>.<indexterm significance="normal"><primary>= (equals sign)</primary><secondary sortas="method definitions">in method
        definitions</secondary></indexterm><indexterm significance="normal"><primary>def keyword</primary></indexterm><indexterm significance="normal"><primary>definitions, method</primary></indexterm><indexterm class="startofrange" id="ch02_methodsdeclare" significance="normal"><primary>methods</primary><secondary>declarations</secondary></indexterm></para><para id="para_multiple_arg_lists">We said “optional argument lists,”
    meaning more than one. Scala lets you define more than one argument list
    for a method. This is required for <emphasis>currying</emphasis> methods,
    which we’ll discuss in <xref linkend="Currying"/>. It is also very useful
    for defining your own Domain-Specific Languages (DSLs), as we’ll see in
    <xref linkend="DomainSpecificLanguages"/>. Note that each argument list
    is surrounded by parentheses and the arguments are separated by
    commas.</para><para id="para_if_a_method_body_has_more_than">If a method body has more
    than one expression, you must surround it with curly braces
    (<literal moreinfo="none">{...}</literal>). You can omit the braces if the method body has
    just one expression.<indexterm significance="normal"><primary>{ } (curly braces)</primary><secondary sortas="method declarations">in method
        declarations</secondary></indexterm></para><sect2 id="MethodDefaultAndNamedArguments"><title>Method Default and Named Arguments (Scala Version 2.8)</title><para id="para_many_languages_let_you_define_">Many languages let you
      define default values for some or all of the arguments to a method.
      Consider the following script with a <literal moreinfo="none">StringUtil</literal>
      object that lets you join a list of strings with a user-specified
      separator:<indexterm significance="normal"><primary>methods</primary><secondary>declarations</secondary><tertiary>default and named arguments</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/string-util-v1-script.scala</code>
<code role="comment">// Version 1 of "StringUtil".</code>

<code role="statement">object</code> <code role="special">StringUtil</code> {
  <code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>, separator:<code role="type"> String</code>):<code role="type"> String</code> =
    strings.mkString(separator)

  <code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>):<code role="type"> String</code> = joiner(strings, <code role="constant">" "</code>)
}
<code role="preproc">import</code> StringUtil._    <code role="comment">// Import the joiner methods.</code>

println( joiner(<code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>)) )
</programlisting><para id="para_there_are_actually_two_joiner">There are actually two,
      “overloaded” <literal moreinfo="none">joiner</literal> methods. The second one uses a
      single space as the “default” separator. Having two methods seems a bit
      wasteful. It would be nice if we could eliminate the second
      <literal moreinfo="none">joiner</literal> method and declare that the <literal role="keep-together" moreinfo="none">separator</literal> argument in the first
      <literal moreinfo="none">joiner</literal> has a default value. In fact, in Scala version
      2.8, you can now do this:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/string-util-v2-v28-script.scala</code>
<code role="comment">// Version 2 of "StringUtil" for Scala v2.8 only.</code>

<code role="statement">object</code> <code role="special">StringUtil</code> {
  <code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>, separator:<code role="type"> String</code> = <code role="constant">" "</code>):<code role="type"> String</code> =
    strings.mkString(separator)
}
<code role="preproc">import</code> StringUtil._    <code role="comment">// Import the joiner methods.</code>

println(joiner(<code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>)))
</programlisting><para id="para_there_are_two_workarounds_for_">There is another
      alternative for earlier versions of Scala. You can use
      <emphasis>implicit</emphasis> arguments, which we will discuss in <xref linkend="ImplicitFunctionParameters"/>.</para><para id="para_scala_version_2_8_offers_anoth">Scala version 2.8 offers
      another enhancement for method argument lists, <emphasis>named
      arguments</emphasis>. We could actually write the last line of the
      previous example in several ways. All of the following
      <literal moreinfo="none">println</literal> statements are functionally
      equivalent:<indexterm significance="normal"><primary>named arguments</primary></indexterm></para><programlisting language="scala" format="linespecific">println(joiner(<code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>)))
println(joiner(strings = <code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>)))
println(joiner(<code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>), <code role="constant">" "</code>))   <code role="comment">// #1</code>
println(joiner(<code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>), separator = <code role="constant">" "</code>)) <code role="comment">// #2</code>
println(joiner(strings = <code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>), separator = <code role="constant">" "</code>))
</programlisting><para id="para_why_is_this_useful_first_if_">Why is this useful? First,
      if you choose good names for the method arguments, then your calls to
      those methods document each argument with a name. For example, compare
      the two lines with comments #1 and #2. In the first line, it may not be
      obvious what the second <literal moreinfo="none">" "</literal> argument is for. In the
      second case, we supply the name <literal role="keep-together" moreinfo="none">separator</literal>, which suggests the purpose of
      the argument.<indexterm significance="normal"><primary>parameters</primary><secondary>order of, named arguments and</secondary></indexterm></para><para id="para_the_second_benefit_is_that_you">The second benefit is
      that you can specify the parameters in any order when you specify them
      by name. Combined with default values, you can write code like the
      following:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/user-profile-v28-script.scala</code>
<code role="comment">// Scala v2.8 only.</code>

<code role="statement">object</code> <code role="special">OptionalUserProfileInfo</code> {
  <code role="statement">val</code> UnknownLocation = <code role="constant">""</code>
  <code role="statement">val</code> UnknownAge = -<code role="constant">1</code>
  <code role="statement">val</code> UnknownWebSite = <code role="constant">""</code>
}

<code role="statement">class</code> <code role="special">OptionalUserProfileInfo</code>(
  location:<code role="type"> String</code> = OptionalUserProfileInfo.<code role="special">UnknownLocation</code>,
  age:<code role="type"> Int</code>         = OptionalUserProfileInfo.<code role="special">UnknownAge</code>,
  webSite:<code role="type"> String</code>  = OptionalUserProfileInfo.<code role="special">UnknownWebSite</code>)

println( <code role="statement">new</code> <code role="special">OptionalUserProfileInfo</code> )
println( <code role="statement">new</code> <code role="special">OptionalUserProfileInfo</code>(age = <code role="constant">29</code>) )
println( <code role="statement">new</code> <code role="special">OptionalUserProfileInfo</code>(age = <code role="constant">29</code>, location=<code role="constant">"Earth"</code>) )
</programlisting><para id="para__optionaluserprofileinfo_repr"><literal moreinfo="none">OptionalUserProfileInfo</literal>
      represents all the “optional” user profile data in your next Web 2.0
      social networking site. It defines default values for all its fields.
      The script creates instances with zero or more named parameters. The
      order of those parameters is arbitrary.</para><para id="para_the_examples_we_have_shown_use">The examples we have
      shown use constant values as the defaults. Most languages with default
      argument values only allow constants or other values that can be
      determined at parse time. However, in Scala, any expression can be used
      as the default, as long as it can compile where used. For example, an
      expression could not refer to an instance field that will be computed
      inside the class or object body, but it could invoke a method on a
      singleton object.<indexterm significance="normal"><primary>constants</primary><secondary>default argument values</secondary></indexterm></para><para id="para_a_related_limitation_is_that_a">A related limitation is
      that a default expression for one parameter can’t refer to another
      parameter in the list, unless the parameter that is referenced appears
      earlier in the list <emphasis>and</emphasis> the parameters are
      <emphasis>curried</emphasis>, a concept we’ll discuss in <xref linkend="Currying"/>.</para><para id="para_finally_another_constraint_on">Finally, another
      constraint on named parameters is that once you provide a name for a
      parameter in a method invocation, the rest of the parameters appearing
      after it must also be named. For example, <literal role="keep-together" moreinfo="none">new OptionalUserProfileInfo(age = 29,
      "Earth")</literal> would not compile because the second argument is not
      invoked by name.</para><para id="para_we_ll_see_another_useful_examp">We’ll see another useful
      example of named and default arguments when we discuss <emphasis>case
      classes</emphasis> in <xref linkend="CaseClasses"/>.</para></sect2><sect2 id="NestingMethodDefinitions"><title>Nesting Method Definitions</title><para id="param_method_nesting">Method definitions can also be nested.
      Here is an implementation of a factorial calculator, where we use a
      conventional technique of calling a second, nested method to do the
      work:<indexterm significance="normal"><primary>methods</primary><secondary>declarations</secondary><tertiary>nesting method definitions</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/factorial-script.scala</code>

<code role="statement">def</code> <code role="identifier">factorial</code>(i:<code role="type"> Int</code>):<code role="type"> Int</code> = {
  <code role="statement">def</code> <code role="identifier">fact</code>(i:<code role="type"> Int</code>, accumulator:<code role="type"> Int</code>):<code role="type"> Int</code> = {
    <code role="statement">if</code> (i &lt;= <code role="constant">1</code>)
      accumulator
    <code role="statement">else</code>
      fact(i - <code role="constant">1</code>, i * accumulator)
  }

  fact(i, <code role="constant">1</code>)
}

println( factorial(<code role="constant">0</code>) )
println( factorial(<code role="constant">1</code>) )
println( factorial(<code role="constant">2</code>) )
println( factorial(<code role="constant">3</code>) )
println( factorial(<code role="constant">4</code>) )
println( factorial(<code role="constant">5</code>) )
</programlisting><para id="para_the_second_method_is_nested_in">The second method calls
      itself recursively, passing an <literal moreinfo="none">accumulator</literal> parameter,
      where the result of the calculation is “accumulated.” Note that we
      return the accumulated value when the counter <literal moreinfo="none">i</literal>
      reaches 1. (We’re ignoring invalid negative integers. The function
      actually returns 1 for <literal moreinfo="none">i &lt; 0</literal>.) After the
      definition of the nested method, <literal role="keep-together" moreinfo="none">factorial</literal> calls it with the passed-in
      value <literal moreinfo="none">i</literal> and the initial accumulator value of
      1.<indexterm significance="normal"><primary>recursion</primary></indexterm></para><para id="para_like_a_local_variable_declarat">Like a local variable
      declaration in many languages, a nested method is only visible inside
      the enclosing method. If you try to call <literal moreinfo="none">fact</literal> outside
      of <literal moreinfo="none">factorial</literal>, you will get a compiler error.</para><para id="para_shadowing_variables">Did you notice that we use
      <literal moreinfo="none">i</literal> as a parameter name twice, first in the
      <literal moreinfo="none">factorial</literal> method and again in the nested
      <literal moreinfo="none">fact</literal> method? As in many languages, the use of
      <literal moreinfo="none">i</literal> as a parameter name for <literal moreinfo="none">fact</literal>
      “shadows” the outer use of <literal moreinfo="none">i</literal> as a parameter name for
      <literal moreinfo="none">factorial</literal>. This is fine, because we don’t need the
      outer value of <literal moreinfo="none">i</literal> inside <literal moreinfo="none">fact</literal>. We
      only use it the first time we call <literal moreinfo="none">fact</literal>, at the end
      of <literal moreinfo="none">factorial</literal>.</para><para id="para_what_if_we_need_to_use_a_varia">What if we need to use a
      variable that is defined outside a nested function? Consider this
      contrived example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/count-to-script.scala</code>

<code role="statement">def</code> <code role="identifier">countTo</code>(n:<code role="type"> Int</code>):<code role="type">Unit</code> = {
  <code role="statement">def</code> <code role="identifier">count</code>(i:<code role="type"> Int</code>):<code role="type"> Unit</code> = {
    <code role="statement">if</code> (i &lt;= n) {
      println(i)
      count(i + <code role="constant">1</code>)
    }
  }
  count(<code role="constant">1</code>)
}

countTo(<code role="constant">5</code>)
</programlisting><para id="para_note_that_the_nested_count_m">Note that the nested
      <literal moreinfo="none">count</literal> method uses the <literal moreinfo="none">n</literal> value that
      is passed as a parameter to <literal moreinfo="none">countTo</literal>. There is no need
      to pass <literal moreinfo="none">n</literal> as an argument to <literal moreinfo="none">count</literal>.
      Because <literal moreinfo="none">count</literal> is nested inside
      <literal moreinfo="none">countTo</literal>, <literal moreinfo="none">n</literal> is visible to
      it.</para><para id="para_when_a_variable_or_method_defi">The declaration of a
      field (member variable) can be prefixed with keywords indicating the
      <emphasis>visibility</emphasis>, just as in languages like Java and C#.
      Similarly the declaration of a non-nested method can be prefixed with
      the same keywords. We will discuss the visibility rules and keywords in
      <xref linkend="VisibilityRules"/>.<indexterm class="endofrange" startref="ch02_methodsdeclare" significance="normal"/></para></sect2></sect1><sect1 id="InferringTypes"><title>Inferring Type Information</title><para id="para_statically_typed_languages_can">Statically typed languages
    can be very verbose. Consider this typical declaration in Java:<indexterm class="startofrange" id="ch02_typeinfer" significance="normal"><primary>type inference</primary></indexterm><indexterm class="startofrange" id="ch02_datatypesinfer" significance="normal"><primary>data types</primary><secondary>inferring type information</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="preproc">import</code> java.util.Map;
<code role="preproc">import</code> java.util.HashMap;
...
<code role="special">Map</code><code role="preproc">&lt;Integer, String&gt;</code><code role="constant"> intToStringMap = new HashMap</code><code role="preproc">&lt;Integer, String&gt;</code><code role="constant">();</code>
</programlisting><para id="para_we_have_to_specify_the_type_pa">We have to specify the type
    parameters <literal moreinfo="none">&lt;Integer, String&gt;</literal> twice. (Scala uses
    the term <emphasis>type annotations</emphasis> for explicit type
    declarations like <literal moreinfo="none">HashMap&lt;Integer,
    String&gt;</literal>.)</para><para id="para_scala_supports__type_inferenci">Scala supports
    <emphasis>type inference</emphasis> (see, for example, <link linkend="TypeInference" xrefstyle="select:nopage">[TypeInference]</link>
    and <link linkend="Pierce2002" xrefstyle="select:nopage">[Pierce2002]</link>). The language’s compiler
    can discern quite a bit of type information from the context, without
    explicit type annotations. Here’s the same declaration rewritten in Scala,
    with inferred type information:</para><programlisting language="scala" format="linespecific"><code role="preproc">import</code> java.util.Map
<code role="preproc">import</code> java.util.HashMap
...
<code role="statement">val</code> intToStringMap:<code role="type"> Map[Integer, String]</code> = <code role="statement">new</code> <code role="special">HashMap</code>
</programlisting><para id="para_recall_from_chapter_1_that_sca">Recall from <xref linkend="IntroducingScala"/> that Scala uses square brackets
    (<literal moreinfo="none">[...]</literal>) for generic type parameters. We specify
    <literal moreinfo="none">Map[Integer, String]</literal> on the lefthand side of the equals
    sign. (We are sticking with Java types for the example.) On the righthand
    side, we instantiate the actual type we want, a
    <literal moreinfo="none">HashMap</literal>, but we don’t have to repeat the type
    parameters.<indexterm significance="normal"><primary>[ ] (square brackets)</primary><secondary>use with parameterized types</secondary></indexterm></para><para id="para_for_completeness_suppose_we_d">For completeness, suppose we
    don’t actually care if the instance is of type <literal moreinfo="none">Map</literal> (the
    Java interface type). It can be of type <literal moreinfo="none">HashMap</literal> for all
    we care:</para><programlisting language="scala" format="linespecific"><code role="preproc">import</code> java.util.Map
<code role="preproc">import</code> java.util.HashMap
...
<code role="statement">val</code> intToStringMap2 = <code role="statement">new</code> <code role="special">HashMap</code><code role="special">[Integer, String]</code>
</programlisting><para id="para_this_declaration_requires_no_t">This declaration requires
    no type annotations on the lefthand side because all of the type
    information needed is on the righthand side. The compiler automatically
    makes <literal moreinfo="none">intToStringMap2</literal> a
    <literal moreinfo="none">HashMap[Integer,String]</literal>.</para><para id="para_method_type_inference">Type inference is used for methods,
    too. In most cases, the return type of the method can be inferred, so the
    <literal moreinfo="none">:</literal> and return type can be omitted. However, type
    annotations are required for all method parameters.<indexterm significance="normal"><primary>recursion</primary><secondary>explicit return type annotation</secondary></indexterm><indexterm class="startofrange" id="cg02_returntype" significance="normal"><primary>return type for methods</primary></indexterm><indexterm significance="normal"><primary>parameters</primary><secondary>required return type annotations</secondary></indexterm></para><para id="para_functional_languages_like_hask">Pure functional languages
    like Haskell (see, e.g., <link linkend="OSullivan2009" xrefstyle="select:nopage">[O’Sullivan2009]</link>) use type inference
    algorithms like <emphasis>Hindley-Milner</emphasis> (see <link linkend="Spiewak2008" xrefstyle="select:nopage">[Spiewak2008]</link> for
    an easily digested explanation). Code written in these languages require
    type annotations less often than in Scala, because Scala’s type inference
    algorithm has to support object-oriented typing as well as functional
    typing. So, Scala requires more type annotations than languages like
    Haskell. Here is a summary of the rules for when explicit type annotations
    are required in Scala.</para><sidebar><title>When Explicit Type Annotations Are Required</title><para id="para_in_practical_terms_you_have_t">In practical terms, you
      have to provide explicit type annotations for the following <phrase role="keep-together">situations</phrase>:<indexterm significance="normal"><primary>type annotations</primary><secondary>required explicit type annotations</secondary></indexterm></para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>A variable declaration, unless you assign a value to the
          variable (e.g., <literal moreinfo="none">val name = "Programming
          Scala"</literal>)</para></listitem><listitem><para>All method parameters (e.g., <literal moreinfo="none">def deposit(amount:
          Money)...</literal>)</para></listitem><listitem><para>Method return values in the following cases:</para><orderedlist numeration="loweralpha" inheritnum="ignore" continuation="restarts"><listitem><para>When you explicitly call <literal moreinfo="none">return</literal> in a
              method (even at the end)</para></listitem><listitem><para>When a method is recursive</para></listitem><listitem><para>When a method is overloaded and one of the methods calls
              another; the <emphasis>calling</emphasis> method needs a return
              type annotation</para></listitem><listitem><para>When the inferred return type would be more general than
              you intended, e.g., <literal moreinfo="none">Any</literal></para></listitem></orderedlist></listitem></orderedlist></sidebar><note id="para_note_the_any_type_is_the_su"><para>The <literal moreinfo="none">Any</literal> type is the root of the Scala type
      hierarchy (see <xref linkend="ScalaTypeHierarchy"/> for more details).
      If a block of code returns a value of type <literal moreinfo="none">Any</literal>
      unexpectedly, chances are good that the type inferencer couldn’t figure
      out what type to return, so it chose the most generic type
      possible.</para></note><para id="para_method_return_value_cases">Let’s look at examples where
    explicit declarations of method return types are required. In the
    following script, the <literal moreinfo="none">upCase</literal> method has a conditional
    return statement for zero-length strings:<indexterm significance="normal"><primary>return type for methods</primary><secondary>required explicit declarations of</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/method-nested-return-script.scala</code>
<code role="comment">// ERROR: Won't compile until you put a String return type on upCase.</code>

<code role="statement">def</code> <code role="identifier">upCase</code>(s:<code role="type"> String</code>) = {
  <code role="statement">if</code> (s.length == <code role="constant">0</code>)
    <code role="statement">return</code> s
  <code role="statement">else</code>
    s.toUpperCase()
}

println( upCase(<code role="constant">""</code>) )
println( upCase(<code role="constant">"Hello"</code>) )
</programlisting><para id="para_running_this_script_gives_you_">Running this script gives
    you the following error:</para><screen format="linespecific">... 6: error: method upCase has return statement; needs result type
        return s
         ^</screen><para>You can fix this error by changing the first line of the method to
    the following:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">upCase</code>(s:<code role="type"> String</code>):<code role="type"> String</code> = {
</programlisting><para id="para_actually_for_this_particular_">Actually, for this
    particular script, an alternative fix is to remove the
    <literal moreinfo="none">return</literal> keyword from the line. It is not needed for the
    code to work properly, but it illustrates our point.<indexterm significance="normal"><primary>return keyword</primary></indexterm></para><para id="para_recursive_methods_require_a_re">Recursive methods also
    require an explicit return type. Recall our <literal moreinfo="none">factorial</literal>
    method in <xref linkend="NestingMethodDefinitions"/>. Let’s remove the
    <literal moreinfo="none">: Int</literal> return type on the nested <literal moreinfo="none">fact</literal>
    method:<indexterm significance="normal"><primary>recursion</primary><secondary>explicit return type annotation</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/method-recursive-return-script.scala</code>
<code role="comment">// ERROR: Won't compile until you put an Int return type on "fact".</code>

<code role="statement">def</code> <code role="identifier">factorial</code>(i:<code role="type"> Int</code>) = {
  <code role="statement">def</code> <code role="identifier">fact</code>(i:<code role="type"> Int</code>, accumulator:<code role="type"> Int</code>) = {
    <code role="statement">if</code> (i &lt;= <code role="constant">1</code>)
      accumulator
    <code role="statement">else</code>
      fact(i - <code role="constant">1</code>, i * accumulator)
  }

  fact(i, <code role="constant">1</code>)
}
</programlisting><para id="para_now_it_fails_to_compile_">Now it fails to compile:</para><screen format="linespecific">... 9: error: recursive method fact needs result type
            fact(i - 1, i * accumulator)
             ^</screen><para id="para_like_recursive_method_calls_w"><emphasis>Overloaded</emphasis>
    methods can sometimes require an explicit return type. When one such
    method calls another, we have to add a return type to the one doing the
    calling, as in this example:<indexterm significance="normal"><primary>overloaded methods</primary><secondary>explicit return type requirement</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/method-overloaded-return-script.scala</code>
<code role="comment">// Version 1 of "StringUtil" (with a compilation error).</code>
<code role="comment">// ERROR: Won't compile: needs a String return type on the second "joiner".</code>

<code role="statement">object</code> <code role="special">StringUtil</code> {
  <code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>, separator:<code role="type"> String</code>):<code role="type"> String</code> =
    strings.mkString(separator)

  <code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>) = joiner(strings, <code role="constant">" "</code>)
}
<code role="preproc">import</code> StringUtil._    <code role="comment">// Import the joiner methods.</code>

println( joiner(<code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>)) )
</programlisting><para id="para_the_two_joiner_methods_conca">The two
    <literal moreinfo="none">joiner</literal> methods concatenate a <literal moreinfo="none">List</literal> of
    strings together. The first method also takes an argument for the
    separator string. The second method calls the first with a “default”
    separator of a single space.</para><para id="para_string_util_error">If you run this script, you get the
    following error:</para><screen format="linespecific">... 9: error: overloaded method joiner needs result type
    def joiner(strings: List[String]) = joiner(strings, "")
                                         ^</screen><para id="para_the_second_joiner_method_calls_the_first">Since the
    <emphasis>second</emphasis> <literal moreinfo="none">joiner</literal> method calls the
    first, it requires an explicit <literal moreinfo="none">String</literal> return type. It
    should look like this:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>):<code role="type"> String</code> = joiner(strings, <code role="constant">" "</code>)
</programlisting><para id="para_note_that_any_is_the_root_of">The final scenario can be
    subtle, when a more general return type is inferred than what you
    expected. You usually see this error when you assign a value returned from
    a function to a variable with a more specific type. For example, you were
    expecting a <literal moreinfo="none">String</literal>, but the function inferred an
    <literal moreinfo="none">Any</literal> for the returned object. Let’s see a contrived
    example that reflects a bug where this scenario can occur:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/method-broad-inference-return-script.scala</code>
<code role="comment">// ERROR: Won't compile; needs a String return type on the second "joiner".</code>

<code role="statement">def</code> <code role="identifier">makeList</code>(strings:<code role="type"> String</code>*) = {
  <code role="statement">if</code> (strings.length == <code role="constant">0</code>)
    <code role="special">List</code>(<code role="constant">0</code>)  <code role="comment">// #1</code>
  <code role="statement">else</code>
    strings.toList
}

<code role="statement">val</code> list:<code role="type"> List[String]</code> = makeList()
</programlisting><para id="para_script_return_error">Running this script returns the
    following error:</para><screen format="linespecific">...11: error: type mismatch;
 found   : List[Any]
 required: List[String]
val list: List[String] = makeList()
                          ^</screen><para id="para_we_intended_for_makelist_to_">We intended for
    <literal moreinfo="none">makeList</literal> to return a <literal moreinfo="none">List[String]</literal>,
    but when <literal moreinfo="none">strings.length</literal> equals zero, we returned
    <literal moreinfo="none">List(0)</literal>, incorrectly “assuming” that this expression is
    the correct way to create an empty list. In fact, we returned a
    <literal moreinfo="none">List[Int]</literal> with one element, <literal moreinfo="none">0</literal>. We
    should have returned <literal moreinfo="none">List()</literal>. Since the
    <literal moreinfo="none">else</literal> expression returns a
    <literal moreinfo="none">List[String]</literal>, the result of
    <literal moreinfo="none">strings.toList</literal>, the inferred return type for the method
    is the closest common supertype of <literal moreinfo="none">List[Int]</literal> and
    <literal moreinfo="none">List[String]</literal>, which is <literal moreinfo="none">List[Any]</literal>.
    Note that the compilation error doesn’t occur in the function definition.
    We only see it when we attempt to assign the value returned from
    <literal moreinfo="none">makeList</literal> to a <literal moreinfo="none">List[String]</literal>
    variable.</para><para id="para_in_this_case_fixing_the_bug_i">In this case, fixing the bug
    is the solution. Alternatively, when there isn’t a bug, it may be that the
    compiler just needs the “help” of an explicit return type declaration.
    Investigate the method that appears to return the unexpected type. In our
    experience, you often find that you modified that method (or another one
    in the call path) in such a way that the compiler now infers a more
    general return type than necessary. Add the explicit return type in this
    case.</para><para id="para_declare_method_returns">Another way to prevent these
    problems is to always declare return types for methods, especially when
    defining methods for a public API. Let’s revisit our
    <literal moreinfo="none">StringUtil</literal> example and see why explicit declarations
    are a good idea (adapted from <link linkend="Smith2009a" xrefstyle="select:nopage">[Smith2009a]</link>).</para><para id="para_imagine_that_we_extend_our_na">Here is our
    <literal moreinfo="none">StringUtil</literal> “API” again with a new method,
    <literal moreinfo="none">toCollection</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/string-util-v3.scala</code>
<code role="comment">// Version 3 of "StringUtil" (for all versions of Scala).</code>

<code role="statement">object</code> <code role="special">StringUtil</code> {
  <code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>, separator:<code role="type"> String</code>):<code role="type"> String</code> =
    strings.mkString(separator)

  <code role="statement">def</code> <code role="identifier">joiner</code>(strings:<code role="type"> List[String]</code>):<code role="type"> String</code> = strings.mkString(<code role="constant">" "</code>)

  <code role="statement">def</code> <code role="identifier">toCollection</code>(string:<code role="type"> String</code>) = string.split(<code role="constant">' '</code>)
}
</programlisting><para id="para_the_pairsstringtomap_method_">The
    <literal moreinfo="none">toCollection</literal> method splits a string on spaces and
    returns an <literal moreinfo="none">Array</literal> containing the substrings. The return
    type is inferred, which is a potential problem, as we will see. The method
    is somewhat contrived, but it will illustrate our point. Here is a client
    of <literal role="keep-together" moreinfo="none">StringUtil</literal> that uses this
    method:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/string-util-client.scala</code>

<code role="preproc">import</code> StringUtil._

<code role="statement">object</code> <code role="special">StringUtilClient</code> {
  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) = {
    args foreach { s <code role="statement">=&gt;</code> toCollection(s).foreach { x <code role="statement">=&gt;</code> println(x) } }
  }
}
</programlisting><?dbfo-need height=”1in”
?><para id="para_if_you_compile_these_files_yo">If you compile these files
    with <literal moreinfo="none">scala</literal>, you can run the client as follows:</para><screen format="linespecific">$ scala -cp ... StringUtilClient "Programming Scala"
Programming
Scala</screen><note id="para_cp_current_dir"><para>For the <literal moreinfo="none">-cp ...</literal> class path argument, use the
      directory where <literal moreinfo="none">scalac</literal> wrote the class files, which
      defaults to the current directory (i.e., use <literal role="keep-together" moreinfo="none">-cp .</literal>). If you used the build process in
      the downloaded code examples, the class files are written to the
      <filename moreinfo="none">build</filename> directory (using <literal moreinfo="none">scalac -d build
      ...</literal>). In this case, use <literal moreinfo="none">-cp build</literal>.</para></note><para id="para_everything_is_fine_at_this_poi">Everything is fine at this
    point, but now imagine that the code base has grown. <literal role="keep-together" moreinfo="none">StringUtil</literal> and its clients are now built
    separately and bundled into different JARs. Imagine also that the
    maintainers of <literal moreinfo="none">StringUtil</literal> decide to return a
    <literal moreinfo="none">List</literal> instead of the default:</para><programlisting language="scala" format="linespecific"><code role="statement">object</code> <code role="special">StringUtil</code> {
  ...

  <code role="statement">def</code> <code role="identifier">toCollection</code>(string:<code role="type"> String</code>) = string.split(<code role="constant">' '</code>).toList  <code role="comment">// changed!</code>
}
</programlisting><para id="para_you_recompile_stringutil_and">The only difference is the
    final call to <literal moreinfo="none">toList</literal> that converts the computed
    <literal moreinfo="none">Array</literal> to a <literal moreinfo="none">List</literal>. You recompile
    <literal moreinfo="none">StringUtil</literal> and redeploy its JAR. Then you run the same
    client, <emphasis>without</emphasis> recompiling it first:</para><screen format="linespecific">$ scala -cp ... StringUtilClient "Programming Scala"
java.lang.NoSuchMethodError: StringUtil$.toCollection(...
  at StringUtilClient$$anonfun$main$1.apply(string-util-client.scala:6)
  at StringUtilClient$$anonfun$main$1.apply(string-util-client.scala:6)
...</screen><para id="para_what_happened_when_the_client">What happened? When the
    client was compiled, <literal moreinfo="none">StringUtil.toCollection</literal> returned
    an <literal moreinfo="none">Array</literal>. Then <literal moreinfo="none">toCollection</literal> was
    changed to return <literal moreinfo="none">List</literal>. In both versions, the method
    return value was inferred. Therefore, the client should have been
    recompiled, too.</para><para id="para_however_had_an_explicit_retur">However, had an explicit
    return type of <literal moreinfo="none">Seq</literal> been declared, which is a parent for
    both <literal moreinfo="none">Array</literal> and <literal moreinfo="none">List</literal>, then the
    implementation change would not have forced a recompilation of the
    client.</para><note id="para_note_when_developing_apis_tha"><para>When developing APIs that are built separately from their clients,
      declare method return types explicitly and use the most general return
      type you can. This is especially important when APIs declare
      <emphasis>abstract</emphasis> methods (see, e.g., <xref linkend="Traits"/>).</para></note><para id="para_another_scenario_to_watch_for_">There is another scenario
    to watch for when using declarations of collections like <literal role="keep-together" moreinfo="none">val map = Map()</literal>, as in the following
    example:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> map = <code role="special">Map</code>()

map.update(<code role="constant">"book"</code>, <code role="constant">"Programming Scala"</code>)
</programlisting><screen format="linespecific">... 3: error: type mismatch;
 found   : java.lang.String("book")
 required: Nothing
map.update("book", "Programming Scala")
            ^</screen><para id="para_what_happened_the__type_param">What happened? The
    <emphasis>type parameters</emphasis> of the generic type
    <literal moreinfo="none">Map</literal> were inferred as <literal role="keep-together" moreinfo="none">[Nothing,Nothing]</literal> when the map was created.
    (We’ll discuss <literal moreinfo="none">Nothing</literal> in <xref linkend="ScalaTypeHierarchy"/>, but its name is suggestive!) We attempted
    to insert an incompatible key-value pair of types
    <literal moreinfo="none">String</literal> and <literal moreinfo="none">String</literal>. Call it a
    <literal moreinfo="none">Map</literal> to nowhere! The solution is to parameterize the
    initial map declaration, e.g., <literal moreinfo="none">val map = Map[String,
    String]()</literal>, or to specify initial values so that the map
    parameters are inferred, e.g., <literal moreinfo="none">val map = Map("Programming" →
    "Scala")</literal>.</para><para id="para_finally_there_is_a_subtle_beh">Finally, there is a subtle
    behavior with inferred return types that can cause unexpected and baffling
    results (see <link linkend="ScalaTips" xrefstyle="select:nopage">[ScalaTips]</link>). Consider the following
    example <literal moreinfo="none">scala</literal> session:</para><screen format="linespecific">scala&gt; def double(i: Int) { 2 * i }
double: (Int)Unit

scala&gt; println(double(2))
()</screen><para id="para_why_did_the_second_command_pri">Why did the second command
    print <literal moreinfo="none">()</literal> instead of <literal moreinfo="none">4</literal>? Look
    carefully at what the <literal moreinfo="none">scala</literal> interpreter said the first
    command returned: <literal moreinfo="none">double (Int)Unit</literal>. We defined a method
    named <literal moreinfo="none">double</literal> that takes an <literal moreinfo="none">Int</literal>
    argument and returns <literal moreinfo="none">Unit</literal>. The method doesn’t return an
    <literal moreinfo="none">Int</literal> as we would expect.</para><para id="para_the_cause_of_this_unexpected_b">The cause of this
    unexpected behavior is a missing equals sign in the method definition.
    Here is the definition we actually intended:<indexterm significance="normal"><primary>= (equals sign)</primary><secondary sortas="method definitions">in method
        definitions</secondary><tertiary>missing</tertiary></indexterm></para><screen format="linespecific">scala&gt; def double(i: Int) = { 2 * i }
double: (Int)Int

scala&gt; println(double(2))
4</screen><para id="para_note_the_equals_sign_before_th">Note the equals sign before
    the body of <literal moreinfo="none">double</literal>. Now, the output says we have
    defined <literal moreinfo="none">double</literal> to return an <literal moreinfo="none">Int</literal> and
    the second command does what we expect it to do.</para><para id="para_methods_with_without_equals">There is a reason for this
    behavior. Scala regards a method with the equals sign before the body as a
    function definition and a function always returns a value in functional
    programming. On the other hand, when Scala sees a method body without the
    leading equals sign, it assumes the programmer intended the method to be a
    “procedure” <phrase role="keep-together">definition</phrase>, meant for
    performing side effects only with the return value
    <literal moreinfo="none">Unit</literal>. In practice, it is more likely that the
    programmer simply forgot to insert the equals sign!</para><warning id="para_warning_when_the_return_type_"><para>When the return type of a method is inferred and you don’t use an
      equals sign before the opening parenthesis for the method body, Scala
      infers a <literal moreinfo="none">Unit</literal> return type, even when the last
      expression in the method is a value of another type.</para></warning><para id="para_by_the_way_the_that_was_">By the way, where did that
    <literal moreinfo="none">()</literal> come from that was printed before we fixed the bug?
    It is actually the real name of the <emphasis>singleton</emphasis>
    instance of the <literal moreinfo="none">Unit</literal> type! (This name is a functional
    programming convention.)<indexterm class="endofrange" startref="cg02_returntype" significance="normal"/><indexterm class="endofrange" startref="ch02_datatypesinfer" significance="normal"/><indexterm class="endofrange" startref="ch02_typeinfer" significance="normal"/></para></sect1><sect1 id="Literals"><title>Literals</title><para id="para_often_a_new_object_is_initial">Often, a new object is
    initialized with a <emphasis>literal</emphasis> value, such as
    <literal moreinfo="none">val book = "Programming Scala"</literal>. Let’s discuss the kinds
    of literal values supported by Scala. Here, we’ll limit ourselves to
    lexical syntax literals. We’ll cover literal syntax for functions (used as
    <emphasis>values</emphasis>, not member methods), tuples, and certain
    types like <literal moreinfo="none">Lists</literal> and <literal moreinfo="none">Maps</literal> as we come
    to them.<indexterm class="startofrange" id="ch02_literals" significance="normal"><primary>literals</primary></indexterm></para><sect2 id="IntegerLiterals"><title>Integer Literals</title><para id="para_integer_literals_can_be_expres">Integer literals can be
      expressed in decimal, hexadecimal, or octal. The details are summarized
      in <xref linkend="integer-literals-table"/>.<indexterm significance="normal"><primary>octal integer literals</primary></indexterm><indexterm significance="normal"><primary>hexadecimal integer literals</primary></indexterm><indexterm significance="normal"><primary>decimal integer literals</primary></indexterm><indexterm significance="normal"><primary>integer literals</primary></indexterm><indexterm significance="normal"><primary>literals</primary><secondary>integer</secondary></indexterm></para><table id="integer-literals-table"><title>Integer literals</title><tgroup cols="3"><colspec colnum="1" colwidth=".75in"/><colspec colnum="2" colwidth="2.75in"/><colspec colnum="3" colwidth=".75in"/><thead valign="top"><row><entry>Kind</entry><entry>Format</entry><entry>Examples</entry></row></thead><tbody valign="top"><row><entry><para>Decimal</para></entry><entry><para>0 <emphasis>or</emphasis> a nonzero digit followed
              by zero or more digits (0–9)</para></entry><entry><para>0, 1, 321</para></entry></row><row><entry><para>Hexadecimal</para></entry><entry><para>0x followed by one or more hexadecimal digits (0–9,
              A–F, a–f)</para></entry><entry><para>0xFF, 0x1a3b</para></entry></row><row><entry><para>Octal</para></entry><entry><para>0 followed by one or more octal digits
              (0–7)</para></entry><entry><para>013, 077</para></entry></row></tbody></tgroup></table><para id="para_for_long_literals_it_is_nec">For <literal moreinfo="none">Long</literal>
      literals, it is necessary to append the <literal moreinfo="none">L</literal> or
      <literal moreinfo="none">l</literal> character at the end of the literal. Otherwise, an
      <literal moreinfo="none">Int</literal> is used. The valid values for an integer literal
      are bounded by the type of the variable to which the value will be
      assigned. <xref linkend="integer-boundaries-table"/> defines the
      limits, which are inclusive.</para><table id="integer-boundaries-table"><title>Ranges of allowed values for integer literals (boundaries are
        inclusive)</title><tgroup cols="3"><colspec colnum="1" colwidth="1.42in"/><colspec colnum="2" colwidth="1.42in"/><colspec colnum="3" colwidth="1.42in"/><thead valign="top"><row><entry>Target type</entry><entry>Minimum (inclusive)</entry><entry>Maximum (inclusive)</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">Long</literal></para></entry><entry><para>−2<superscript>63</superscript></para></entry><entry><para>2<superscript>63</superscript> − 1</para></entry></row><row><entry><para><literal moreinfo="none">Int</literal></para></entry><entry><para>−2<superscript>31</superscript></para></entry><entry><para>2<superscript>31</superscript> − 1</para></entry></row><row><entry><para><literal moreinfo="none">Short</literal></para></entry><entry><para>−2<superscript>15</superscript></para></entry><entry><para>2<superscript>15</superscript> − 1</para></entry></row><row><entry><para><literal moreinfo="none">Char</literal></para></entry><entry><para>0</para></entry><entry><para>2<superscript>16</superscript> − 1</para></entry></row><row><entry><para><literal moreinfo="none">Byte</literal></para></entry><entry><para>−2<superscript>7</superscript></para></entry><entry><para>2<superscript>7</superscript> − 1</para></entry></row></tbody></tgroup></table><para id="para_a_compile_time_error_occurs_if">A compile-time error
      occurs if an integer literal number is specified that is outside these
      ranges, as in the following examples:</para><screen format="linespecific">scala &gt; val i = 12345678901234567890
&lt;console&gt;:1: error: integer number too large
       val i = 12345678901234567890
scala&gt; val b: Byte = 128
&lt;console&gt;:4: error: type mismatch;
 found   : Int(128)
 required: Byte
       val b: Byte = 128
                     ^

scala&gt; val b: Byte = 127
b: Byte = 127</screen></sect2><sect2 id="FloatingPointLiterals"><title>Floating-Point Literals</title><para id="para_floating_point_literals_are_ex">Floating-point literals
      are expressions with zero or more digits, followed by a <phrase role="keep-together">period</phrase> (<literal moreinfo="none">.</literal>), followed by
      zero or more digits. If there are no digits before the period, i.e., the
      number is less than 1.0, then there must be one or more digits after the
      period. For <literal moreinfo="none">Float</literal> literals, append the
      <literal moreinfo="none">F</literal> or <literal moreinfo="none">f</literal> character at the end of the
      literal. Otherwise, a <literal role="keep-together" moreinfo="none">Double</literal> is
      assumed. You can optionally append a <literal moreinfo="none">D</literal> or
      <literal moreinfo="none">d</literal> for a <literal role="keep-together" moreinfo="none">Double</literal>.<indexterm significance="normal"><primary>floating-point literals</primary></indexterm><indexterm significance="normal"><primary>literals</primary><secondary>floating-point</secondary></indexterm></para><para id="para_floating_point_literals_can_be">Floating-point literals
      can be expressed with or without exponentials. The format of the
      exponential part is <literal moreinfo="none">e</literal> or <literal moreinfo="none">E</literal>,
      followed by an optional <literal moreinfo="none">+</literal> or <literal moreinfo="none">-</literal>,
      followed by one or more digits.<indexterm significance="normal"><primary>exponentials with floating-point literals</primary></indexterm></para><para id="para_here_are_some_example_floating">Here are some example
      floating-point literals:</para><programlisting language="scala" format="linespecific"><code role="constant">0.</code>
<code role="constant">.0</code>
<code role="constant">0.0</code>
<code role="constant">3.</code>
<code role="constant">3.14</code>
<code role="constant">.14</code>
<code role="constant">0.14</code>
<code role="constant">3e5</code>
<code role="constant">3E5</code>
<code role="constant">3.E5</code>
<code role="constant">3.e5</code>
<code role="constant">3.e+5</code>
<code role="constant">3.e-5</code>
<code role="constant">3.14e-5</code>
<code role="constant">3.14e-5f</code>
<code role="constant">3.14e-5F</code>
<code role="constant">3.14e-5d</code>
<code role="constant">3.14e-5D</code>
</programlisting><para id="para__float_consists_of_all_ieee_7"><literal moreinfo="none">Float</literal>
      consists of all IEEE 754 32-bit, single-precision binary floating-point
      values. <literal moreinfo="none">Double</literal> consists of all IEEE 754 64-bit,
      double-precision binary floating-point values.</para><warning id="para_warning_to_avoid_parsing_ambi"><para>To avoid parsing ambiguities, you must have at least one space
        after a floating-point literal, if it is followed by a token that
        starts with a letter. Also, the expression
        <literal moreinfo="none">1.toString</literal> returns the integer value
        <literal moreinfo="none">1</literal> as a string, while <literal moreinfo="none">1. toString</literal>
        uses the <emphasis>operator notation</emphasis> to invoke
        <literal moreinfo="none">toString</literal> on the floating-point literal
        <literal moreinfo="none">1.</literal>.</para></warning></sect2><sect2 id="BooleanLiterals"><title>Boolean Literals</title><para id="para_the_boolean_literals_are_true">The boolean literals are
      <literal moreinfo="none">true</literal> and <literal moreinfo="none">false</literal>. The type of the
      variable to which they are assigned will be inferred to be
      <literal moreinfo="none">Boolean</literal>:<indexterm significance="normal"><primary>literals</primary><secondary>boolean</secondary></indexterm><indexterm significance="normal"><primary>boolean literals</primary></indexterm></para><screen format="linespecific">scala&gt; val b1 = true
b1: Boolean = true

scala&gt; val b2 = false
b2: Boolean = false</screen></sect2><sect2 id="CharacterLiterals"><title>Character Literals</title><para id="para_a_character_literal_is_either_">A character literal is
      either a printable Unicode character or an escape sequence, written
      between single quotes. A character with a Unicode value between 0 and
      255 may also be represented by an octal escape, i.e., a backslash
      (<literal moreinfo="none">\</literal>) followed by a sequence of up to three octal
      characters. It is a compile-time error if a backslash character in a
      character or string literal does not start a valid escape
      sequence.<indexterm significance="normal"><primary>" " (quotation marks, double)</primary><secondary>escaping in character literals</secondary></indexterm><indexterm significance="normal"><primary>\ (backslash)</primary><secondary sortas="character escape sequences">in character escape
          sequences</secondary></indexterm><indexterm significance="normal"><primary>' ' (quotation marks, single)</primary><secondary>enclosing character literals</secondary></indexterm><indexterm significance="normal"><primary>Unicode characters</primary></indexterm><indexterm significance="normal"><primary>literals</primary><secondary>character</secondary></indexterm><indexterm significance="normal"><primary>character literals</primary></indexterm></para><para id="para_character_literal_examples_">Here are some
      examples:</para><programlisting language="scala" format="linespecific"><code role="constant">'A'</code>
<code role="constant">'\u0041'</code>  <code role="comment">// 'A' in Unicode</code>
<code role="constant">'\n'</code>
'\<code role="constant">012</code>'    <code role="comment">// '\n' in octal</code>
<code role="constant">'\t'</code>
</programlisting><para id="para_the_valid_escape_sequences_are">The valid escape
      sequences are shown in <xref linkend="char-escape-sequences-table"/>.</para><table id="char-escape-sequences-table"><title>Character escape sequences</title><tgroup cols="3"><thead valign="top"><row><entry>Sequence</entry><entry>Unicode</entry><entry>Meaning</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">\b</literal></para></entry><entry><para><literal moreinfo="none">\u0008</literal></para></entry><entry><para>Backspace (BS)</para></entry></row><row><entry><para><literal moreinfo="none">\t</literal></para></entry><entry><para><literal moreinfo="none">\u0009</literal></para></entry><entry><para>Horizontal tab (HT)</para></entry></row><row><entry><para><literal moreinfo="none">\n</literal></para></entry><entry><para><literal moreinfo="none">\u000a</literal></para></entry><entry><para>Line feed (LF)</para></entry></row><row><entry><para><literal moreinfo="none">\f</literal></para></entry><entry><para><literal moreinfo="none">\u000c</literal></para></entry><entry><para>Form feed (FF)</para></entry></row><row><entry><para><literal moreinfo="none">\r</literal></para></entry><entry><para><literal moreinfo="none">\u000d</literal></para></entry><entry><para>Carriage return (CR)</para></entry></row><row><entry><para><literal moreinfo="none">\"</literal></para></entry><entry><para><literal moreinfo="none">\u0022</literal></para></entry><entry><para>Double quote (<literal moreinfo="none">"</literal>)</para></entry></row><row><entry><para><literal moreinfo="none">\’</literal></para></entry><entry><para><literal moreinfo="none">\u0027</literal></para></entry><entry><para>Single quote (<literal moreinfo="none">’</literal>)</para></entry></row><row><entry><para><literal moreinfo="none">\\</literal></para></entry><entry><para><literal moreinfo="none">\u0009</literal></para></entry><entry><para>Backslash (<literal moreinfo="none">\</literal>)</para></entry></row></tbody></tgroup></table></sect2><sect2 id="StringLiterals"><title>String Literals</title><para id="para_a_string_literal_is_a_sequence">A string literal is a
      sequence of characters enclosed in double quotes or
      <emphasis>triples</emphasis> of double quotes, i.e.,
      <literal moreinfo="none">"""..."""</literal>.<indexterm significance="normal"><primary>" " (quotation marks, double)</primary><secondary>enclosing string literals</secondary></indexterm><indexterm significance="normal"><primary>string literals</primary></indexterm><indexterm significance="normal"><primary>literals</primary><secondary>string</secondary></indexterm></para><para id="para_for_string_literals_in_double_">For string literals in
      double quotes, the allowed characters are the same as the character
      literals. However, if a double quote <literal moreinfo="none">"</literal> character
      appears in the string, it must be “<phrase role="keep-together">escaped</phrase>” with a <literal moreinfo="none">\</literal>
      character. Here are some examples:<indexterm significance="normal"><primary>\ (backslash)</primary><secondary>escaping double quotes in string literals</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="constant">"Programming</code><code role="special">\n</code><code role="constant">Scala"</code>
<code role="constant">"He exclaimed, </code><code role="special">\"</code><code role="constant">Scala is great!</code><code role="special">\"</code><code role="constant">"</code>
<code role="constant">"First\tSecond"</code>
</programlisting><para id="para_the_string_literals_bounded_by">The string literals
      bounded by triples of double quotes are also called
      <emphasis>multi-line</emphasis> string literals. These strings can cover
      several lines; the line feeds will be part of the string. They can
      include any characters, including one or two double quotes together, but
      not three together. They are useful for strings with
      <literal moreinfo="none">\</literal> characters that don’t form valid Unicode or escape
      sequences, like the valid sequences listed in <xref linkend="char-escape-sequences-table"/>. Regular expressions are a
      typical example, which we’ll discuss in <xref linkend="RoundingOutTheEssentials"/>. However, if escape <phrase role="keep-together">sequences</phrase> appear, they aren’t
      interpreted.<indexterm significance="normal"><primary>" " (quotation marks, double)</primary><secondary>triples of double quotes, bounding multi-line string
          literals</secondary></indexterm></para><para id="para_3quote_string_literal_examples_">Here are three example
      strings:</para><programlisting language="scala" format="linespecific"><code role="constant">"""Programming\nScala"""</code>
<code role="constant">"""He exclaimed, "Scala is great!" """</code>
<code role="constant">"""First line\n</code>
<code role="constant">Second line\t</code>

<code role="constant">Fourth line"""</code>
</programlisting><para id="para_note_trailing_quotes">Note that we had to add a space
      before the trailing <literal moreinfo="none">"""</literal> in the second example to
      prevent a parse error. Trying to escape the second <literal moreinfo="none">"</literal>
      that ends the <literal moreinfo="none">"Scala is great!"</literal> quote, i.e.,
      <literal moreinfo="none">"Scala is great!\"</literal>, doesn’t work.</para><para id="para_copy_and_past_these_strings_in">Copy and paste these
      strings into the <literal moreinfo="none">scala</literal> interpreter. Do the same for
      the previous string examples. How are they interpreted
      differently?</para></sect2><sect2 id="SymbolLiterals"><title>Symbol Literals</title><para id="para_scala_supports_symbols_which_">Scala supports symbols,
      which are <emphasis>interned</emphasis> strings, meaning that two
      symbols with the same “name” (i.e., the same character sequence) will
      actually refer to the same object in memory. Symbols are used less often
      in Scala than in some other languages, like Ruby, Smalltalk, and Lisp.
      They are useful as map keys instead of strings.<indexterm significance="normal"><primary>interned strings</primary></indexterm><indexterm significance="normal"><primary>symbol literals</primary></indexterm><indexterm significance="normal"><primary>literals</primary><secondary>symbol</secondary></indexterm></para><para id="para_a_symbol_literal_is_a_single_q">A symbol literal is a
      single quote (<literal moreinfo="none">'</literal>), followed by a letter, followed by
      zero or more digits and letters. Note that an expression like
      <literal moreinfo="none">'1</literal> is invalid, because the compiler thinks it is an
      incomplete character literal.</para><para id="para_a_symbol_literal_id_is_a_sh">A symbol literal
      <literal moreinfo="none">'</literal><replaceable>id</replaceable> is a shorthand for the
      expression <literal moreinfo="none">scala.Symbol("id")</literal>.<indexterm significance="normal"><primary>' ' (quotation marks, single)</primary><secondary sortas="symbol literals">in symbol literals</secondary></indexterm></para><note id="para_note_if_you_want_to_create_a_"><para>If you want to create a symbol that contains whitespace, use
        e.g., <literal moreinfo="none">scala.Symbol(" Programming Scala ")</literal>. All the
        whitespace is preserved.<indexterm class="endofrange" startref="ch02_literals" significance="normal"/></para></note></sect2></sect1><sect1 id="TheTroubleWithTuples"><title>Tuples</title><para id="para_how_many_times_have_you_wanted">How many times have you
    wanted to return <emphasis>two</emphasis> or more values from a method? In
    many languages, like Java, you only have a few options, none of which is
    very appealing. You could pass in parameters to the method that will be
    modified for all or some of the “return” values, which is ugly. Or you
    could declare some small “structural” class that holds the two or more
    values, then return an instance of that class.<indexterm significance="normal"><primary>tuples</primary></indexterm></para><para id="para_scala_supports__tuples__a_gr">Scala, supports
    <emphasis>tuples</emphasis>, a grouping of two or more items, usually
    created with the literal syntax of a comma-separated list of the items
    inside parentheses, e.g., <literal moreinfo="none">(x1, x2, ...)</literal>. The types of
    the <literal moreinfo="none">x</literal><subscript>i</subscript> elements are unrelated to
    each other; you can mix and match types. These literal “groupings” are
    instantiated as <literal moreinfo="none">scala.TupleN</literal> instances, where
    <literal moreinfo="none">N</literal> is the number of items in the tuple. The Scala API
    defines separate <literal moreinfo="none">TupleN</literal> classes for
    <literal moreinfo="none">N</literal> between 1 and 22, inclusive. Tuple instances are
    immutable, <emphasis>first-class</emphasis> values, so you can assign them
    to variables, pass them as values, and return them from methods.</para><para id="para_the_following_example_demonstr">The following example
    demonstrates the use of tuples:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/tuple-example-script.scala</code>

<code role="statement">def</code> <code role="identifier">tupleator</code>(x1:<code role="type"> Any</code>, x2:<code role="type"> Any</code>, x3:<code role="type"> Any</code>) = (x1, x2, x3)

<code role="statement">val</code> t = tupleator(<code role="constant">"Hello"</code>, <code role="constant">1</code>, <code role="constant">2.3</code>)
println( <code role="constant">"Print the whole tuple: "</code> + t )
println( <code role="constant">"Print the first item:  "</code> + t._1 )
println( <code role="constant">"Print the second item: "</code> + t._2 )
println( <code role="constant">"Print the third item:  "</code> + t._3 )

<code role="statement">val</code> (t1, t2, t3) = tupleator(<code role="constant">"World"</code>, <code role="constant">'!'</code>, <code role="constant">0x22</code>)
println( t1 + <code role="constant">" "</code> + t2 + <code role="constant">" "</code> + t3 )
</programlisting><para id="para_running2">Running this script with <literal moreinfo="none">scala</literal>
    produces the following output:</para><screen format="linespecific">Print the whole tuple: (Hello,1,2.3)
Print the first item:  Hello
Print the second item: 1
Print the third item:  2.3
World ! 34</screen><para id="para_tupleator">The <literal moreinfo="none">tupleator</literal> method simply
    returns a “3-tuple” with the input arguments. The first statement that
    uses this method assigns the returned tuple to a single variable
    <literal moreinfo="none">t</literal>. The next four statements print <literal moreinfo="none">t</literal>
    in various ways. The first print statement calls
    <literal moreinfo="none">Tuple3.toString</literal>, which wraps parentheses around the
    item list. The following three statements print each item in
    <literal moreinfo="none">t</literal> separately. The expression <literal moreinfo="none">t._N</literal>
    retrieves the <literal moreinfo="none">N</literal> item, starting at 1,
    <emphasis>not</emphasis> 0 (this choice follows functional programming
    conventions).</para><para id="para_tupleator_one_lhs">The last two lines show that we can use
    a tuple expression on the lefthand side of the assignment. We declare
    three <literal moreinfo="none">val</literal>s—<literal moreinfo="none">t1</literal>,
    <literal moreinfo="none">t2</literal>, and <literal moreinfo="none">t3</literal>—to hold the individual
    items in the tuple. In essence, the tuple items are extracted
    automatically.</para><para id="para_notice_how_we_mixed_types_in_t">Notice how we mixed types
    in the tuples. You can see the types more clearly if you use the
    interactive mode of the <literal moreinfo="none">scala</literal> command, which we
    introduced in <xref linkend="IntroducingScala"/>.</para><para id="para_try_typing_in_val_t_hello">Invoke the
    <literal moreinfo="none">scala</literal> command with no script argument. At the
    <literal moreinfo="none">scala&gt;</literal> prompt, enter <literal role="keep-together" moreinfo="none">val t = ("Hello",1,2.3)</literal> and see that you
    get the following result, which shows you the type of each element in the
    tuple:</para><screen format="linespecific">scala&gt; val t = ("Hello",1,2.3)
t: (java.lang.String, Int, Double) = (Hello,1,2.3)</screen><para id="para_it_s_worth_noting_that_there_s">It’s worth noting that
    there’s more than one way to define a tuple. We’ve been using the more
    common parenthesized syntax, but you can also use the arrow operator
    between two values, as well as special factory methods on the
    tuple-related classes:<indexterm significance="normal"><primary>-&gt; (right arrow) operator</primary></indexterm></para><screen format="linespecific">scala&gt; 1 -&gt; 2
res0: (Int, Int) = (1,2)

scala&gt; Tuple2(1, 2)
res1: (Int, Int) = (1,2)

scala&gt; Pair(1, 2)
res2: (Int, Int) = (1,2)</screen></sect1><sect1 id="OptionSomeNone"><title>Option, Some, and None: Avoiding nulls</title><para id="para_we_ll_discuss_the_standard_typ">We’ll discuss the standard
    type hierarchy for Scala in <xref linkend="ScalaTypeHierarchy"/>.
    However, three useful classes to understand now are the
    <literal moreinfo="none">Option</literal> class and its two subclasses,
    <literal moreinfo="none">Some</literal> and <literal moreinfo="none">None</literal>.<indexterm class="startofrange" id="ch02_nullsavoid" significance="normal"><primary>nulls</primary><secondary>avoiding using Option, Some, and None classes</secondary></indexterm><indexterm significance="normal"><primary>None class</primary></indexterm><indexterm significance="normal"><primary>Some class</primary></indexterm><indexterm class="startofrange" id="ch02_Optionclass" significance="normal"><primary>Option class</primary></indexterm></para><para id="para_most_languages_have_a_special_">Most languages have a
    special keyword or object that’s assigned to reference variables when
    there’s nothing else for them to refer to. In Java, this is
    <literal moreinfo="none">null</literal>; in Ruby, it’s <literal moreinfo="none">nil</literal>. In Java,
    <literal moreinfo="none">null</literal> is a keyword, not an object, and thus it’s illegal
    to call any methods on it. But this is a confusing choice on the language
    designer’s part. Why return a keyword when the programmer expects an
    object?</para><para id="para_to_be_more_consistent_with_the">To be more consistent with
    the goal of making everything an object, as well as to conform with
    functional programming conventions, Scala encourages you to use the
    <literal moreinfo="none">Option</literal> type for variables and function return values
    when they may or may not refer to a value. When there is no value, use
    <literal moreinfo="none">None</literal>, an <literal moreinfo="none">object</literal> that is a subclass
    of <literal moreinfo="none">Option</literal>. When there is a value, use
    <literal moreinfo="none">Some</literal>, which wraps the value. <literal moreinfo="none">Some</literal> is
    also a subclass of <literal moreinfo="none">Option</literal>.<indexterm significance="normal"><primary>return type for methods</primary><secondary>using Option, Some, and None types</secondary></indexterm></para><note id="para_note_none_is_declared_as_an"><para><literal moreinfo="none">None</literal> is declared as an
      <literal moreinfo="none">object</literal>, not a <literal moreinfo="none">class</literal>, because we
      really only need one instance of it. In that sense, it’s like the
      <literal moreinfo="none">null</literal> keyword, but it is a real object with
      methods.</para></note><para id="para_you_can_see_option_some_">You can see
    <literal moreinfo="none">Option</literal>, <literal moreinfo="none">Some</literal>, and
    <literal moreinfo="none">None</literal> in action in the following example, where we
    create a map of state capitals in the United States:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/state-capitals-subset-script.scala</code>

<code role="statement">val</code> stateCapitals = <code role="special">Map</code>(
  <code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>,
  <code role="constant">"Alaska"</code>  -&gt; <code role="constant">"Juneau"</code>,
  <code role="comment">// ...</code>
  <code role="constant">"Wyoming"</code> -&gt; <code role="constant">"Cheyenne"</code>)

println( <code role="constant">"Get the capitals wrapped in Options:"</code> )
println( <code role="constant">"Alabama: "</code> + stateCapitals.get(<code role="constant">"Alabama"</code>) )
println( <code role="constant">"Wyoming: "</code> + stateCapitals.get(<code role="constant">"Wyoming"</code>) )
println( <code role="constant">"Unknown: "</code> + stateCapitals.get(<code role="constant">"Unknown"</code>) )

println( <code role="constant">"Get the capitals themselves out of the Options:"</code> )
println( <code role="constant">"Alabama: "</code> + stateCapitals.get(<code role="constant">"Alabama"</code>).get )
println( <code role="constant">"Wyoming: "</code> + stateCapitals.get(<code role="constant">"Wyoming"</code>).getOrElse(<code role="constant">"Oops!"</code>) )
println( <code role="constant">"Unknown: "</code> + stateCapitals.get(<code role="constant">"Unknown"</code>).getOrElse(<code role="constant">"Oops2!"</code>) )
</programlisting><para id="para_the_convenient_gt_syntax_">The convenient
    <literal moreinfo="none">-&gt;</literal> syntax for defining name-value pairs to
    initialize a <literal moreinfo="none">Map</literal> will be discussed in <xref linkend="PredefObject"/>. For now, we want to focus on the two groups of
    <literal moreinfo="none">println</literal> statements, where we show what happens when you
    retrieve the values from the map. If you run this script with the
    <literal moreinfo="none">scala</literal> command, you’ll get the following output:</para><screen format="linespecific">Get the capitals wrapped in Options:
Alabama: Some(Montgomery)
Wyoming: Some(Cheyenne)
Unknown: None
Get the capitals themselves out of the Options:
Alabama: Montgomery
Wyoming: Cheyenne
Unknown: Oops2!</screen><para id="para_the_first_group_of_println_s">The first group of
    <literal moreinfo="none">println</literal> statements invoke <literal moreinfo="none">toString</literal>
    implicitly on the instances returned by <literal moreinfo="none">get</literal>. We are
    calling <literal moreinfo="none">toString</literal> on <literal moreinfo="none">Some</literal> or
    <literal moreinfo="none">None</literal> instances because the values returned by
    <literal moreinfo="none">Map.get</literal> are automatically wrapped in a
    <literal moreinfo="none">Some</literal>, when there is a value in the map for the
    specified key. Note that the Scala library doesn’t store the
    <literal moreinfo="none">Some</literal> in the map; it wraps the value in a
    <literal moreinfo="none">Some</literal> upon retrieval. Conversely, when we ask for a map
    entry that doesn’t exist, the <literal moreinfo="none">None</literal> object is returned,
    rather than <literal moreinfo="none">null</literal>. This occurred in the last
    <literal moreinfo="none">println</literal> of the three.</para><para id="para_the_second_group_of_println_">The second group of
    <literal moreinfo="none">println</literal> statements goes a step further. After calling
    <literal moreinfo="none">Map.get</literal>, they call <literal moreinfo="none">get</literal> or
    <literal moreinfo="none">getOrElse</literal> on each <literal moreinfo="none">Option</literal> instance to
    retrieve the value it contains. <literal moreinfo="none">Option.get</literal> requires
    that the <literal moreinfo="none">Option</literal> is not empty—that is, the
    <literal moreinfo="none">Option</literal> instance must actually be a
    <literal moreinfo="none">Some</literal>. In this case, <literal moreinfo="none">get</literal> returns the
    value wrapped by the <literal moreinfo="none">Some</literal>, as demonstrated in the
    <literal moreinfo="none">println</literal> where we print the capital of Alabama. However,
    if the <literal moreinfo="none">Option</literal> <phrase role="keep-together">is
    actually</phrase> <literal moreinfo="none">None</literal>, then
    <literal moreinfo="none">None.get</literal> throws a
    <literal moreinfo="none">NoSuchElementException</literal>.</para><para id="para_we_also_show_the_alternative_m">We also show the
    alternative method, <literal moreinfo="none">getOrElse</literal>, in the last two
    <literal moreinfo="none">println</literal> statements. This method returns either the
    value in the <literal moreinfo="none">Option</literal>, if it is a <literal moreinfo="none">Some</literal>
    instance, or it returns the second argument we passed to
    <literal moreinfo="none">getOrElse</literal>, if it is a <literal moreinfo="none">None</literal> instance.
    In other words, the second argument to <literal moreinfo="none">getOrElse</literal>
    functions as the default return value.</para><para id="para_we_ll_discuss_the_merits_of_al">So,
    <literal moreinfo="none">getOrElse</literal> is the more defensive of the two methods. It
    avoids a potential thrown exception. We’ll discuss the merits of
    alternatives like <literal moreinfo="none">get</literal> versus
    <literal moreinfo="none">getOrElse</literal> in <xref linkend="ExceptionsAndTheAlternatives"/>.</para><para id="para_note_that_because_the_map_get">Note that because the
    <literal moreinfo="none">Map.get</literal> method returns an <literal moreinfo="none">Option</literal>, it
    automatically documents the fact that there may not be an item matching
    the specified key. The map handles this situation by returning a
    <literal moreinfo="none">None</literal>. Most languages would return
    <literal moreinfo="none">null</literal> (or the equivalent) when there is no “real” value
    to return. You learn from experience to expect a possible
    <literal moreinfo="none">null</literal>. Using <literal moreinfo="none">Option</literal> makes the
    behavior more explicit in the method signature, so it’s more
    self-documenting.</para><para id="para_also_thanks_to_scala_s_static">Also, thanks to Scala’s
    static typing, you can’t make the mistake of attempting to call a method
    on a value that might actually be <literal moreinfo="none">null</literal>. While this
    mistake is easy to do in Java, it won’t compile in Scala because you must
    first extract the value from the <literal moreinfo="none">Option</literal>. So, the use of
    <literal moreinfo="none">Option</literal> strongly encourages more resilient
    programming.</para><para id="para_because_scala_runs_on_the_jvm_">Because Scala runs on the
    JVM and .NET and because it must interoperate with other libraries, Scala
    has to support <literal moreinfo="none">null</literal>. Still, you should avoid using
    <literal moreinfo="none">null</literal> in your code. Tony Hoare, who invented the null
    reference in 1965 while working on an object-oriented language called
    ALGOL W, called its invention his “billion dollar mistake” (see <link linkend="Hoare2009" xrefstyle="select:nopage">[Hoare2009]</link>). Don’t
    contribute to that figure.</para><para id="para_so_how_would_you_write_a_func">So, how would you write a
    method that returns an <literal moreinfo="none">Option</literal>? Here is a possible
    implementation of <literal moreinfo="none">get</literal> that could be used by a concrete
    subclass of <literal moreinfo="none">Map</literal> (<literal moreinfo="none">Map.get</literal> itself is
    <emphasis>abstract</emphasis>). For a more sophisticated version, see the
    implementation of <literal moreinfo="none">get</literal> in
    <literal moreinfo="none">scala.col⁠lection.immutable.HashMap</literal> in the Scala
    library source code distribution:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">get</code>(key:<code role="type"> A</code>):<code role="type"> Option[B]</code> = {
  <code role="statement">if</code> (contains(key))
    <code role="statement">new</code> <code role="special">Some</code>(getValue(key))
  <code role="statement">else</code>
    <code role="special">None</code>
}
</programlisting><para id="para_the_contains_method_is_also_">The
    <literal moreinfo="none">contains</literal> method is also defined for
    <literal moreinfo="none">Map</literal>. It returns <literal moreinfo="none">true</literal> if the map
    contains a value for the specified key. The <literal moreinfo="none">getValue</literal>
    method is intended to be an internal method that retrieves the value from
    the underlying storage, whatever it is.</para><para id="para_note_how_the_value_returned_by">Note how the value returned
    by <literal moreinfo="none">getValue</literal> is wrapped in a <literal moreinfo="none">Some[B]</literal>,
    where the type <literal moreinfo="none">B</literal> is inferred. However, if the call to
    <literal moreinfo="none">contains(key)</literal> returns <literal moreinfo="none">false</literal>, then
    the <literal moreinfo="none">object None</literal> is returned.</para><para id="para_you_can_use_this_same_idiom_wh">You can use this same idiom
    when your methods return an <literal moreinfo="none">Option</literal>. We’ll explore other
    uses for <literal moreinfo="none">Option</literal> in subsequent sections. Its pervasive
    use in Scala code makes it an important concept to grasp.<indexterm class="endofrange" startref="ch02_Optionclass" significance="normal"/><indexterm class="endofrange" startref="ch02_nullsavoid" significance="normal"/></para></sect1><sect1 id="Packages"><title>Organizing Code in Files and Namespaces</title><para id="para_scala_adopts_the_package_conce">Scala adopts the package
    concept that Java uses for namespaces, but Scala offers a more flexible
    syntax. Just as file names don’t have to match the type names, the package
    structure does not have to match the directory structure. So, you can
    define packages in files independent of their “physical”
    location.<indexterm significance="normal"><primary>Java</primary><secondary>package concept for namespaces</secondary></indexterm><indexterm significance="normal"><primary>packages</primary></indexterm><indexterm significance="normal"><primary>namespaces</primary></indexterm><indexterm significance="normal"><primary>code, organizing in files and namespaces</primary></indexterm></para><para id="para_the_following_example_defines_">The following example
    defines a class <literal moreinfo="none">MyClass</literal> in a package
    <literal moreinfo="none">com.example.mypkg</literal> using the conventional Java
    syntax:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/package-example1.scala</code>

<code role="preproc">package</code> com.example.mypkg

<code role="statement">class</code> <code role="special">MyClass</code> {
  <code role="comment">// ...</code>
}
</programlisting><para id="para_the_next_example_shows_a_contr">The next example shows a
    contrived example that defines packages using the nested package syntax in
    Scala, which is similar to the <literal moreinfo="none">namespace</literal> syntax in C#
    and the use of <literal moreinfo="none">modules</literal> as namespaces in Ruby:<indexterm significance="normal"><primary>namespaces</primary><secondary>relationship to Scala’s nested package syntax</secondary></indexterm><indexterm significance="normal"><primary>packages</primary><secondary>defining using nested package syntax in Scala</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/package-example2.scala</code>

<code role="preproc">package</code> com {
  <code role="preproc">package</code> example {
    <code role="preproc">package</code> pkg1 {
      <code role="statement">class</code> <code role="special">Class11</code> {
        <code role="statement">def</code> <code role="identifier">m</code> = <code role="constant">"m11"</code>
      }
      <code role="statement">class</code> <code role="special">Class12</code> {
        <code role="statement">def</code> <code role="identifier">m</code> = <code role="constant">"m12"</code>
      }
    }

    <code role="preproc">package</code> pkg2 {
      <code role="statement">class</code> <code role="special">Class21</code> {
        <code role="statement">def</code> <code role="identifier">m</code> = <code role="constant">"m21"</code>
        <code role="statement">def</code> <code role="identifier">makeClass11</code> = {
          <code role="statement">new</code> pkg1.<code role="special">Class11</code>
        }
        <code role="statement">def</code> <code role="identifier">makeClass12</code> = {
          <code role="statement">new</code> pkg1.<code role="special">Class12</code>
        }
      }
    }

    <code role="preproc">package</code> pkg3.pkg31.pkg311 {
      <code role="statement">class</code> <code role="special">Class311</code> {
        <code role="statement">def</code> <code role="identifier">m</code> = <code role="constant">"m21"</code>
      }
    }
  }
}
</programlisting><para id="para_two_packages_pkg1_and_pkg2_">Two packages,
    <literal moreinfo="none">pkg1</literal> and <literal moreinfo="none">pkg2</literal>, are defined under the
    <literal moreinfo="none">com.example</literal> package. A total <phrase role="keep-together">of three classes</phrase> are defined between the two
    packages. The <literal moreinfo="none">makeClass11</literal> and <literal role="keep-together" moreinfo="none">makeClass12</literal> methods in
    <literal moreinfo="none">Class21</literal> illustrate how to reference a type in the
    “sibling” <phrase role="keep-together">package,
    <literal moreinfo="none">pkg1</literal></phrase>. You can also reference these classes by
    their full paths, <literal role="keep-together" moreinfo="none">com.example.pkg1.Class11</literal> and
    <literal moreinfo="none">com.example.pkg1.Class12</literal>, respectively.</para><para id="para_the_package_pkg3_pkg31_pkg311">The package
    <literal moreinfo="none">pkg3.pkg31.pkg311</literal> shows that you can “chain” several
    packages together in one clause. It is not necessary to use a separate
    <literal moreinfo="none">package</literal> clause for each package.</para><para id="para_following_the_conventions_of_j">Following the conventions
    of Java, the root package for Scala’s library classes is named
    <literal moreinfo="none">scala</literal>.<indexterm significance="normal"><primary>packages</primary><secondary>root package for Scala library classes</secondary></indexterm></para><warning id="para_note_scala_does_not_allow_pac"><para>Scala does not allow package declarations in scripts that are
      executed directly with the <literal moreinfo="none">scala</literal> interpreter. The
      reason has to do with the way the interpreter converts statements in
      scripts to valid Scala code <phrase role="keep-together">before
      compiling</phrase> to byte code. See <xref linkend="CommandLineToolScala"/> for more details.</para></warning></sect1><sect1 id="Importing"><title>Importing Types and Their Members</title><para id="para_to_use_declarations_in_package">To use declarations in
    packages, you have to import them, just as you do in Java and similarly
    for other languages. However, compared to Java, Scala greatly expands your
    options. The following example illustrates several ways to import Java
    types:<indexterm significance="normal"><primary>members</primary><secondary>importing</secondary></indexterm><indexterm significance="normal"><primary>import statements</primary><secondary>importing Java types and their members</secondary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>importation of data types into Scala</secondary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>importing types and their members</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/import-example1.scala</code>

<code role="preproc">import</code> java.awt._
<code role="preproc">import</code> java.io.File
<code role="preproc">import</code> java.io.File._
<code role="preproc">import</code> java.util.{Map, HashMap}
</programlisting><para id="para_you_can_import_all_types_in_a_">You can import all types in
    a package, using the underscore ( <literal moreinfo="none">_</literal> ) as a wildcard, as
    shown on the first line. You can also import individual Scala or Java
    types, as shown on the second line.<indexterm significance="normal"><primary>_ (underscore)</primary><secondary>wildcard character in Scala</secondary></indexterm></para><para id="para_star_vs_underscore">Java uses the “star” character
    (<literal moreinfo="none">*</literal>) as the wildcard for matching all types in a package
    or all static members of a type when doing “static imports.” In Scala,
    this character is allowed in method names, so <literal moreinfo="none">_</literal> is used
    as a wildcard, as we saw previously.</para><para id="para_as_shown_on_the_third_line_yo">As shown on the third line,
    you can import all the static methods and fields in Java types. If
    <literal moreinfo="none">java.io.File</literal> were actually a Scala
    <literal moreinfo="none">object</literal>, as discussed previously, then this line would
    import the fields and methods from the object.</para><para id="para_finally_you_can_selectively_i">Finally, you can selectively
    import just the types you care about. On the fourth line, we import just
    the <literal moreinfo="none">java.util.Map</literal> and
    <literal moreinfo="none">java.util.HashMap</literal> types from the
    <literal moreinfo="none">java.util</literal> package. Compare this one-line import
    statement with the two-line import statements we used in our first example
    in <xref linkend="InferringTypes"/>. They are <phrase role="keep-together">functionally</phrase> equivalent.</para><para id="para_the_next_example_shows_more_ad">The next example shows more
    advanced options for import statements:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/import-example2-script.scala</code>

<code role="statement">def</code> <code role="identifier">writeAboutBigInteger</code>() = {

  <code role="preproc">import</code> java.math.BigInteger.{
    ONE =&gt; _,
    TEN,
    ZERO =&gt; JAVAZERO }

  <code role="comment">// ONE is effectively undefined</code>
  <code role="comment">// println( "ONE: "+ONE )</code>
  println( <code role="constant">"TEN: "</code>+<code role="special">TEN</code> )
  println( <code role="constant">"ZERO: "</code>+<code role="special">JAVAZERO</code> )
}

writeAboutBigInteger()
</programlisting><para id="para_this_example_demonstrates_two_">This example demonstrates
    two features. First, we can put import statements almost anywhere we want,
    not just at the top of the file, as required by Java. This feature allows
    us to scope the imports more narrowly. For example, we can’t reference the
    imported <literal moreinfo="none">BigInteger</literal> definitions outside the scope of
    the method. Another advantage of this feature is that it puts an import
    statement closer to where the imported items are actually used.</para><para id="para_the_second_feature_shown_is_th">The second feature shown is
    the ability to <emphasis>rename</emphasis> imported items. First, the
    <literal moreinfo="none">java.math.BigInteger.ONE</literal> constant is renamed to the
    underscore wildcard. This effectively makes it invisible and unavailable
    to the importing scope. This is a useful technique when you want to import
    everything <emphasis>except</emphasis> a few particular items.</para><para id="para_next_the_java_math_bigintege">Next, the
    <literal moreinfo="none">java.math.BigInteger.TEN</literal> constant is imported without
    renaming, so it can be referenced simply as <literal moreinfo="none">TEN</literal>.</para><para id="para_finally_the_java_math_bigint">Finally, the
    <literal moreinfo="none">java.math.BigInteger.ZERO</literal> constant is given the “alias”
    <literal moreinfo="none">JAVAZERO</literal>.</para><para id="para_renaming_is_useful_if_you_want">Aliasing is useful if you
    want to give the item a more convenient name or you want to avoid
    ambiguities with other items in scope that have the same name.</para><sect2 id="ImportsAreRelative"><title>Imports are Relative</title><para id="para_there_s_one_other_important_th">There’s one other
      important thing to know about imports: they are
      <emphasis>relative</emphasis>. Note the comments for the following
      imports:<indexterm significance="normal"><primary>import statements</primary><secondary>relative path used in</secondary></indexterm><indexterm significance="normal"><primary>relative imports</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/relative-imports.scala</code>
<code role="preproc">import</code> scala.collection.mutable._
<code role="preproc">import</code> collection.immutable._         <code role="comment">// Since "scala" is already imported</code>
<code role="preproc">import</code> _root_.scala.collection.jcl._  <code role="comment">// full path from real "root"</code>
<code role="preproc">package</code> scala.actors {
  <code role="preproc">import</code> remote._                     <code role="comment">// We're in the scope of "scala.actors"</code>
}
</programlisting><para id="para_this_is_useful_for_importing_f">Note that the last import
      statement nested in the <literal moreinfo="none">scala.actor</literal> package scope is
      relative to that scope.</para><para id="para_the_scalawiki_has_other_ex">The <link linkend="ScalaWiki" xrefstyle="select:nopage">[ScalaWiki]</link> has other examples at
      <ulink url="http://scala.sygneca.com/faqs/language#how-do-i-import"/>.</para><para id="para_it_s_fairly_rare_that_you_ll_h">It’s fairly rare that
      you’ll have problems with relative imports, but the problem with this
      convention is that they sometimes cause surprises, especially if you are
      accustomed to languages like Java, where imports are absolute. If you
      get a mystifying compiler error that a package wasn’t found, check that
      the statement is properly relative to the last import statement or add
      the <literal moreinfo="none">_root_.</literal> prefix. Also, you might see an IDE or
      other tool insert an <literal moreinfo="none">import _root_...</literal> statement in
      your code. Now you know what it means.</para><warning id="para_warning_remember_that_import_"><para>Remember that import statements are relative, not absolute. To
        create an absolute path, start with <literal moreinfo="none">_root_</literal>.</para></warning></sect2></sect1><sect1 id="AbstractTypesAndParameterizedTypes"><title>Abstract Types And Parameterized Types</title><para id="para_we_mentioned_in_atasteofscal">We mentioned in <xref linkend="ATasteOfScala"/> that Scala supports <emphasis>parameterized
    types</emphasis>, which are very similar to <emphasis>generics</emphasis>
    in Java. (We could use the two terms interchangeably, but it’s more common
    to use “parameterized types” in the Scala community and “generics” in the
    Java community.) The most obvious difference is in the syntax, where Scala
    uses square brackets (<literal moreinfo="none">[...]</literal>), while Java uses angle
    brackets (<literal moreinfo="none">&lt;...&gt;</literal>).<indexterm significance="normal"><primary>generics</primary><secondary>Java</secondary></indexterm><indexterm significance="normal"><primary>[ ] (square brackets)</primary><secondary>use with parameterized types</secondary></indexterm><indexterm significance="normal"><primary>parameterized types</primary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>parameterized types</secondary></indexterm></para><para id="para_for_example_a_list_of_strings">For example, a list of
    strings would be declared as follows:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> languages:<code role="type"> List[String]</code> = ...
</programlisting><para id="para_there_are_other_important_diff">There are other important
    differences with Java’s generics, which we’ll explore in <xref linkend="ParameterizedTypes"/>.</para><para id="para_for_now_we_ll_mention_one_oth">For now, we’ll mention one
    other useful detail that you’ll encounter before we can explain it in
    depth in <xref linkend="ScalasTypeSystem"/>. If you look at the
    declaration of <literal moreinfo="none">scala.List</literal> in the Scaladocs, you’ll see
    that the declaration is written as <literal moreinfo="none">... class List[+A]</literal>.
    The <literal moreinfo="none">+</literal> in front of the <literal moreinfo="none">A</literal> means that
    <literal moreinfo="none">List[B]</literal> is a <emphasis>subtype</emphasis> of
    <literal moreinfo="none">List[A]</literal> for any <literal moreinfo="none">B</literal> that is a subtype
    of <literal moreinfo="none">A</literal>. If there is a <literal moreinfo="none">-</literal> in front of a
    type parameter, then the relationship goes the other way;
    <literal moreinfo="none">Foo[B]</literal> would be a <emphasis>supertype</emphasis> of
    <literal moreinfo="none">Foo[A]</literal>, if the declaration is
    <literal moreinfo="none">Foo[-A]</literal>.<indexterm significance="normal"><primary>List class</primary><secondary>declaration</secondary></indexterm></para><para id="para_scala_supports_another_type_ab">Scala supports another type
    abstraction mechanism called <emphasis>abstract types</emphasis>, used in
    many <emphasis>functional programming</emphasis> languages, such as
    Haskell. Abstract types were also considered for inclusion in Java when
    generics were adopted. We want to introduce them now because you’ll see
    many examples of them before we dive into their details in <xref linkend="ScalasTypeSystem"/>. For a very detailed comparison of these two
    mechanisms, see <link linkend="Bruce1998" xrefstyle="select:nopage">[Bruce1998]</link>.<indexterm significance="normal"><primary>data types</primary><secondary>abstract</secondary></indexterm><indexterm significance="normal"><primary>abstract types</primary></indexterm></para><para id="para_abstract_types_can_be_applied_">Abstract types can be
    applied to many of the same design problems for which parameterized types
    are used. However, while the two mechanisms overlap, they are not
    redundant. Each has strengths and weaknesses for certain design
    problems.</para><?dbfo-need height=”1in”
?><para id="para_here_is_an_example_that_uses_a">Here is an example that
    uses an abstract type:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/abstract-types-script.scala</code>

<code role="preproc">import</code> java.io._

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code>
  <code role="statement">val</code> source:<code role="type"> In</code>
  <code role="statement">def</code> <code role="identifier">read</code>:<code role="type"> String</code>
}

<code role="statement">class</code> <code role="special">StringBulkReader</code>(<code role="statement">val</code> source:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code> = <code role="special">String</code>
  <code role="statement">def</code> <code role="identifier">read</code> = source
}

<code role="statement">class</code> <code role="special">FileBulkReader</code>(<code role="statement">val</code> source:<code role="type"> File</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code> = <code role="special">File</code>
  <code role="statement">def</code> <code role="identifier">read</code> = {
    <code role="statement">val</code> in = <code role="statement">new</code> <code role="special">BufferedInputStream</code>(<code role="statement">new</code> <code role="special">FileInputStream</code>(source))
    <code role="statement">val</code> numBytes = in.available()
    <code role="statement">val</code> bytes = <code role="statement">new</code> <code role="special">Array</code><code role="special">[Byte]</code>(numBytes)
    in.read(bytes, <code role="constant">0</code>, numBytes)
    <code role="statement">new</code> <code role="special">String</code>(bytes)
  }
}

println( <code role="statement">new</code> <code role="special">StringBulkReader</code>(<code role="constant">"Hello Scala!"</code>).read )
println( <code role="statement">new</code> <code role="special">FileBulkReader</code>(<code role="statement">new</code> <code role="special">File</code>(<code role="constant">"abstract-types-script.scala"</code>)).read )
</programlisting><para id="para_running_1">Running this script with
    <literal moreinfo="none">scala</literal> produces the following output:</para><screen format="linespecific">Hello Scala!
import java.io._

abstract class BulkReader {
...</screen><para id="para_the_bulkreader__abstract__cl">The
    <literal moreinfo="none">BulkReader</literal> <emphasis>abstract</emphasis> class declares
    three abstract members: a <literal moreinfo="none">type</literal> named
    <literal moreinfo="none">In</literal>, a <literal moreinfo="none">val</literal> field
    <literal moreinfo="none">source</literal>, and a <literal moreinfo="none">read</literal> method. As in
    Java, instances in Scala can only be created from
    <emphasis>concrete</emphasis> classes, which must have definitions for all
    members.<indexterm significance="normal"><primary>classes</primary><secondary>abstract</secondary></indexterm></para><para id="para_the_derived_classes_stringbu">The derived classes,
    <literal moreinfo="none">StringBulkReader</literal> and <literal moreinfo="none">FileBulkReader</literal>,
    provide concrete definitions for these abstract members. We’ll cover the
    details of class declarations in <xref linkend="BasicObjectOrientedProgramming"/> and the particulars of
    overriding member declarations in <xref linkend="OverridingMembers"/> in
    <xref linkend="AdvancedObjectOrientedProgramming"/>.</para><para id="para_for_now_note_that_the_type_">For now, note that the
    <literal moreinfo="none">type</literal> field works very much like a type parameter in a
    parameterized type. In fact, we could rewrite this example as follows,
    where we show only what would be different:</para><programlisting language="scala" format="linespecific"><code role="statement">abstract</code> <code role="statement">class</code> <code role="special">BulkReader</code><code role="special">[In]</code> {
  <code role="statement">val</code> source:<code role="type"> In</code>
  ...
}

<code role="statement">class</code> <code role="special">StringBulkReader</code>(<code role="statement">val</code> source:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">BulkReader</code><code role="special">[String]</code> {...}

<code role="statement">class</code> <code role="special">FileBulkReader</code>(<code role="statement">val</code> source:<code role="type"> File</code>) <code role="statement">extends</code> <code role="special">BulkReader</code><code role="special">[File]</code> {...}
</programlisting><para id="para_just_as_for_parameterized_type">Just as for parameterized
    types, if we define the <literal moreinfo="none">In</literal> type to be
    <literal moreinfo="none">String</literal>, then the <literal moreinfo="none">source</literal> field must
    also be defined as a <literal moreinfo="none">String</literal>. Note that the
    <literal moreinfo="none">StringBulkReader</literal>’s <literal moreinfo="none">read</literal> method
    simply returns the <literal moreinfo="none">source</literal> field, while the
    <literal moreinfo="none">FileBulkReader</literal>’s <literal moreinfo="none">read</literal> method reads
    the contents of the file.</para><para id="para_as_demonstrated_by_bruce1998">As demonstrated by <link linkend="Bruce1998" xrefstyle="select:nopage">[Bruce1998]</link>,
    parameterized types tend to be best for collections, which is how they are
    most often used in Java code, whereas abstract types are most useful for
    type “families” and other type scenarios.</para><para id="para_we_ll_explore_the_details_of_s">We’ll explore the details
    of Scala’s abstract types in <xref linkend="ScalasTypeSystem"/>. For
    example, we’ll see how to constrain the possible concrete types that can
    be used.</para></sect1><sect1 id="ReservedWords"><title>Reserved Words</title><para id="para_reserved_words_table_lists_the_reserved_words"><xref linkend="reserved-words-table"/> lists the reserved words in Scala, which
    we sometimes call “keywords,” and briefly describes how they are used (see
    <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>).<indexterm significance="normal"><primary>reserved words</primary><secondary>listing of reserved words in Scala</secondary></indexterm></para><table id="reserved-words-table"><title>Reserved words</title><tgroup cols="3"><thead valign="top"><row><entry>Word</entry><entry>Description</entry><entry>See …</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">abstract</literal></para></entry><entry><para>Makes a declaration abstract. Unlike Java, the
            keyword is usually not required for abstract
            members.</para></entry><entry><para><xref linkend="ClassBasics"/></para></entry></row><row><entry><para><literal moreinfo="none">case</literal></para></entry><entry><para>Start a case clause in a match
            expression.</para></entry><entry><para><xref linkend="PatternMatching"/></para></entry></row><row><entry><para><literal moreinfo="none">catch</literal></para></entry><entry><para>Start a clause for catching thrown
            exceptions.</para></entry><entry><para><xref linkend="TryCatchFinally"/></para></entry></row><row><entry><para><literal moreinfo="none">class</literal></para></entry><entry><para>Start a class declaration.</para></entry><entry><para><xref linkend="ClassBasics"/></para></entry></row><row><entry><para><literal moreinfo="none">def</literal></para></entry><entry><para>Start a method declaration.</para></entry><entry><para><xref linkend="MethodDeclarationsAndDefinitions"/></para></entry></row><row><entry><para><literal moreinfo="none">do</literal></para></entry><entry><para>Start a <literal moreinfo="none">do...while</literal>
            loop.</para></entry><entry><para><xref linkend="OtherLoopingConstructs"/></para></entry></row><row><entry><para><literal moreinfo="none">else</literal></para></entry><entry><para>Start an <literal moreinfo="none">else</literal> clause for an
            <literal moreinfo="none">if</literal> clause.</para></entry><entry><para><xref linkend="IfStatements"/></para></entry></row><row><entry><para><literal moreinfo="none">extends</literal></para></entry><entry><para>Indicates that the class or trait that follows is the
            parent type of the class or trait being declared.</para></entry><entry><para><xref linkend="ParentClasses"/></para></entry></row><row><entry><para><literal moreinfo="none">false</literal></para></entry><entry><para><literal moreinfo="none">Boolean</literal>
            <emphasis>false</emphasis>.</para></entry><entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry></row><row><entry><para><literal moreinfo="none">final</literal></para></entry><entry><para>Applied to a class or trait to prohibit deriving
            child types from it. Applied to a member to prohibit overriding it
            in a derived class or trait.</para></entry><entry><para><xref linkend="FinalDeclarations"/></para></entry></row><row><entry><para><literal moreinfo="none">finally</literal></para></entry><entry><para>Start a clause that is executed after the
            corresponding <literal moreinfo="none">try</literal> clause, whether or not an
            exception is thrown by the <literal moreinfo="none">try</literal>
            clause.</para></entry><entry><para><xref linkend="TryCatchFinally"/></para></entry></row><row><entry><para><literal moreinfo="none">for</literal></para></entry><entry><para>Start a <literal moreinfo="none">for</literal> comprehension
            (loop).</para></entry><entry><para><xref linkend="ForComprehensions"/></para></entry></row><row><entry><para><literal moreinfo="none">forSome</literal></para></entry><entry><para>Used in <emphasis>existential type</emphasis>
            declarations to <phrase role="keep-together">constrain</phrase>
            the allowed <phrase role="keep-together">concrete</phrase> types
            that can be used.</para></entry><entry><para><xref linkend="ExistentialTypes"/></para></entry></row><row><entry><para><literal moreinfo="none">if</literal></para></entry><entry><para>Start an <literal moreinfo="none">if</literal> clause.</para></entry><entry><para><xref linkend="IfStatements"/></para></entry></row><row><entry><para><literal moreinfo="none">implicit</literal></para></entry><entry><para>Marks a method as eligible to be used as an
            <emphasis>implicit</emphasis> type converter. Marks a method
            parameter as optional, as long as a <phrase role="keep-together">type-</phrase><phrase role="keep-together">compatible</phrase> substitute object is in
            the scope where the method is called.</para></entry><entry><para><xref linkend="ImplicitConversions"/></para></entry></row><row><entry><para><literal moreinfo="none">import</literal></para></entry><entry><para>Import one or more types or members of types into the
            current scope.</para></entry><entry><para><xref linkend="Importing"/></para></entry></row><row><entry><para><literal moreinfo="none">lazy</literal></para></entry><entry><para>Defer evaluation of a
            <literal moreinfo="none">val</literal>.</para></entry><entry><para><xref linkend="LazyVals"/></para></entry></row><row><entry><para><literal moreinfo="none">match</literal></para></entry><entry><para>Start a pattern matching clause.</para></entry><entry><para><xref linkend="PatternMatching"/></para></entry></row><row><entry><para><literal moreinfo="none">new</literal></para></entry><entry><para>Create a new instance of a class.</para></entry><entry><para><xref linkend="ClassBasics"/></para></entry></row><row><entry><para><literal moreinfo="none">null</literal></para></entry><entry><para>Value of a reference variable that has not been
            assigned a value.</para></entry><entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry></row><row><entry><para><literal moreinfo="none">object</literal></para></entry><entry><para>Start a <emphasis>singleton</emphasis> declaration: a
            <literal moreinfo="none">class</literal> with only one <phrase role="keep-together">instance</phrase>.</para></entry><entry><para><xref linkend="ClassesAndObjects"/></para></entry></row><row><entry><para><literal moreinfo="none">override</literal></para></entry><entry><para>Override a <emphasis>concrete</emphasis> member of a
            class or trait, as long as the original is not marked
            <literal moreinfo="none">final</literal>.</para></entry><entry><para><xref linkend="OverridingMembers"/></para></entry></row><row><entry><para><literal moreinfo="none">package</literal></para></entry><entry><para>Start a package scope declaration.</para></entry><entry><para><xref linkend="Packages"/></para></entry></row><row><entry><para><literal moreinfo="none">private</literal></para></entry><entry><para>Restrict visibility of a declaration.</para></entry><entry><para><xref linkend="VisibilityRules"/></para></entry></row><row><entry><para><literal moreinfo="none">protected</literal></para></entry><entry><para>Restrict visibility of a declaration.</para></entry><entry><para><xref linkend="VisibilityRules"/></para></entry></row><row><entry><para><literal moreinfo="none">requires</literal></para></entry><entry><para>Deprecated. Was used for <emphasis>self
            typing</emphasis>.</para></entry><entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry></row><row><entry><para><literal moreinfo="none">return</literal></para></entry><entry><para>Return from a function.</para></entry><entry><para><xref linkend="ATasteOfScala"/></para></entry></row><row><entry><para><literal moreinfo="none">sealed</literal></para></entry><entry><para>Applied to a parent class to require all directly
            derived <phrase role="keep-together">classes to be
            declared</phrase> in the same source file.</para></entry><entry><para><xref linkend="CaseClasses"/></para></entry></row><row><entry><para><literal moreinfo="none">super</literal></para></entry><entry><para>Analogous to <literal moreinfo="none">this</literal>, but binds to
            the parent type.</para></entry><entry><para><xref linkend="OverridingMethods"/></para></entry></row><row><entry><para><literal moreinfo="none">this</literal></para></entry><entry><para>How an object refers to itself. The method name for
            <emphasis>auxiliary con⁠structors</emphasis>.</para></entry><entry><para><xref linkend="ClassBasics"/></para></entry></row><row><entry><para><literal moreinfo="none">throw</literal></para></entry><entry><para>Throw an exception.</para></entry><entry><para><xref linkend="TryCatchFinally"/></para></entry></row><row><entry><para><literal moreinfo="none">trait</literal></para></entry><entry><para>A <emphasis>mixin module</emphasis> that adds
            additional state and behavior to an <phrase role="keep-together">instance</phrase> of a class.</para></entry><entry><para><xref linkend="Traits"/></para></entry></row><row><entry><para><literal moreinfo="none">try</literal></para></entry><entry><para>Start a block that may throw an
            exception.</para></entry><entry><para><xref linkend="TryCatchFinally"/></para></entry></row><row><entry><para><literal moreinfo="none">true</literal></para></entry><entry><para><literal moreinfo="none">Boolean</literal>
            <emphasis>true</emphasis>.</para></entry><entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry></row><row><entry><para><literal moreinfo="none">type</literal></para></entry><entry><para>Start a <emphasis>type</emphasis>
            declaration.</para></entry><entry><para><xref linkend="AbstractTypesAndParameterizedTypes"/></para></entry></row><row><entry><para><literal moreinfo="none">val</literal></para></entry><entry><para>Start a read-only “variable”
            declaration.</para></entry><entry><para><xref linkend="VariableDeclarationsAndDefinitions"/></para></entry></row><row><entry><para><literal moreinfo="none">var</literal></para></entry><entry><para>Start a read-write variable
            declaration.</para></entry><entry><para><xref linkend="VariableDeclarationsAndDefinitions"/></para></entry></row><row><entry><para><literal moreinfo="none">while</literal></para></entry><entry><para>Start a <literal moreinfo="none">while</literal> loop.</para></entry><entry><para><xref linkend="OtherLoopingConstructs"/></para></entry></row><row><entry><para><literal moreinfo="none">with</literal></para></entry><entry><para>Include the trait that follows in the class being
            declared or the object being instantiated.</para></entry><entry><para><xref linkend="Traits"/></para></entry></row><row><entry><para><literal moreinfo="none">yield</literal></para></entry><entry><para>Return an element in a <literal moreinfo="none">for</literal>
            comprehension that becomes part of a sequence.</para></entry><entry><para><xref linkend="Yielding"/></para></entry></row><row><entry><para><literal moreinfo="none">_</literal></para></entry><entry><para>A placeholder, used in imports, function literals,
            etc.</para></entry><entry><para><emphasis>Many</emphasis></para></entry></row><row><entry><para><literal moreinfo="none">:</literal></para></entry><entry><para>Separator between identifiers and type
            annotations.</para></entry><entry><para><xref linkend="ATasteOfScala"/></para></entry></row><row><entry><para><literal moreinfo="none">=</literal></para></entry><entry><para>Assignment.</para></entry><entry><para><xref linkend="ATasteOfScala"/></para></entry></row><row><entry><para><literal moreinfo="none">=&gt;</literal></para></entry><entry><para>Used in <emphasis>function literals</emphasis> to
            separate the argument list from the function body.</para></entry><entry><para><xref linkend="FunctionLiteralsAndClosures"/></para></entry></row><row><entry><para><literal moreinfo="none">&lt;-</literal></para></entry><entry><para>Used in <literal moreinfo="none">for</literal> comprehensions in
            <emphasis>generator</emphasis> expressions.</para></entry><entry><para><xref linkend="ForComprehensions"/></para></entry></row><row><entry><para><literal moreinfo="none">&lt;:</literal></para></entry><entry><para>Used in <emphasis>parameterized</emphasis> and
            <emphasis>abstract type</emphasis> declarations to <phrase role="keep-together">constrain</phrase> the allowed
            types.</para></entry><entry><para><xref linkend="TypeBounds"/></para></entry></row><row><entry><para><literal moreinfo="none">&lt;%</literal></para></entry><entry><para>Used in <emphasis>parameterized</emphasis> and
            <emphasis>abstract type</emphasis> “view bounds” <phrase role="keep-together">declarations</phrase>.</para></entry><entry><para><xref linkend="TypeBounds"/></para></entry></row><row><entry><para><literal moreinfo="none">&gt;:</literal></para></entry><entry><para>Used in <emphasis>parameterized</emphasis> and
            <emphasis>abstract type</emphasis> declarations to <phrase role="keep-together">constrain</phrase> the allowed
            types.</para></entry><entry><para><xref linkend="TypeBounds"/></para></entry></row><row><entry><para><literal moreinfo="none">#</literal></para></entry><entry><para>Used in <emphasis>type
            projections.</emphasis></para></entry><entry><para><xref linkend="PathDependentTypes"/></para></entry></row><row><entry><para><literal moreinfo="none">@</literal></para></entry><entry><para>Marks an
            <emphasis>annotation.</emphasis></para></entry><entry><para><xref linkend="Annotations"/></para></entry></row><row><entry><para><literal moreinfo="none">⇒</literal></para></entry><entry><para>(Unicode \u21D2) Same as =&gt;.</para></entry><entry><para><xref linkend="FunctionLiteralsAndClosures"/></para></entry></row><row><entry><para><literal moreinfo="none">←</literal></para></entry><entry><para>(Unicode \u2190) Same as &lt;-.</para></entry><entry><para><xref linkend="ForComprehensions"/></para></entry></row></tbody></tgroup></table><para id="para_no_break_and_continue">Notice that <literal moreinfo="none">break</literal>
    and <literal moreinfo="none">continue</literal> are not listed. These control keywords
    don’t exist in Scala. Instead, Scala encourages you to use functional
    programming idioms that are usually more succinct and less error-prone.
    We’ll discuss alternative approaches when we discuss
    <literal moreinfo="none">for</literal> loops (see <xref linkend="GeneratorExpressions"/>).<indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt;- (left-arrow) operator, generators</secondary></indexterm><indexterm significance="normal"><primary>@ (at sign)</primary><secondary>marking annotations</secondary></indexterm><indexterm significance="normal"><primary># (pound sign)</primary><secondary>use in type projections</secondary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&gt;:, constraining allowed types in parameterized and
        abstract type declarations</secondary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt;% indicating view bound in type declaration</secondary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt;:, use in parameterized and abstract type
        declarations</secondary></indexterm><indexterm significance="normal"><primary>= (equals sign)</primary><secondary>=&gt; in function literals</secondary></indexterm><indexterm significance="normal"><primary>= (equals sign)</primary><secondary>assignment operator</secondary></indexterm><indexterm significance="normal"><primary>: (colon)</primary><secondary>separator between identifiers and type
        annotations</secondary></indexterm><indexterm significance="normal"><primary>_ (underscore)</primary><secondary>placeholder in imports, function literals, etc.</secondary></indexterm></para><para id="para_some_java_methods_use_names_th">Some Java methods use names
    that are reserved by Scala, for example,
    <literal moreinfo="none">java.util.Scan⁠ner.match</literal>. To avoid a compilation error,
    surround the name with single back quotes, e.g.,
    <literal moreinfo="none">java.util.Scanner.‵match‵</literal>.</para></sect1><sect1 id="_recap_and_what_8217_s_next_2"><title>Recap and What’s Next</title><para id="para_we_covered_several_ways_that_s">We covered several ways
    that Scala’s syntax is concise, flexible, and productive. We also
    described many Scala features. In the next chapter, we will round out some
    Scala essentials before we dive into Scala’s support for object-oriented
    programming and functional programming.</para></sect1></chapter><chapter id="RoundingOutTheEssentials"><title>Rounding Out the Essentials</title><para id="para_before_we_dive_into_scala_s_su">Before we dive into Scala’s
  support for object-oriented and functional programming, let’s finish our
  discussion of the essential features you’ll use in most of your
  programs.</para><sect1 id="_operator_operator"><title>Operator? Operator?</title><para id="para_an_important_fundamental_conce">An important fundamental
    concept in Scala is that all operators are actually methods. Consider this
    most basic of examples:<indexterm significance="normal"><primary>methods</primary><secondary>operators as</secondary></indexterm><indexterm significance="normal"><primary>operators</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/one-plus-two-script.scala</code>

<code role="constant">1</code> + <code role="constant">2</code>
</programlisting><para id="para_that_plus_sign_between_the_num">That plus sign between the
    numbers? It’s a method. First, Scala allows non-<phrase role="keep-together">alphanumeric</phrase> method names. You can call
    methods <literal moreinfo="none">+</literal>, <literal moreinfo="none">-</literal>, <literal moreinfo="none">$</literal>,
    or whatever you desire. Second, this expression is identical to <literal moreinfo="none">1
    .+(2)</literal>. (We put a space after the <literal moreinfo="none">1</literal> because
    <literal moreinfo="none">1.</literal> would be interpreted as a
    <literal moreinfo="none">Double</literal>.) When a method takes one argument, Scala lets
    you drop both the period and the parentheses, so the method invocation
    looks like an operator invocation. This is called “infix” notation, where
    the operator is between the instance and the argument. We’ll find out more
    about this shortly.<indexterm significance="normal"><primary>operator notation</primary><secondary>infix operator notation</secondary></indexterm><indexterm significance="normal"><primary>methods</primary><secondary>operators as</secondary><tertiary>infix notation</tertiary></indexterm><indexterm significance="normal"><primary>symbols</primary><secondary sortas="method names">in method names and other
        identifiers</secondary></indexterm><indexterm significance="normal"><primary>infix notation</primary></indexterm><indexterm significance="normal"><primary>( ) (parentheses)</primary><secondary sortas="method invocations">in method invocations,
        dropping</secondary></indexterm></para><para id="para_similarly_a_method_with_no_ar">Similarly, a method with no
    arguments can be invoked without the period. This is called “postfix”
    notation.<indexterm significance="normal"><primary>. (dot)</primary><secondary>omitting in method calls</secondary></indexterm><indexterm significance="normal"><primary>postfix notation</primary></indexterm></para><para id="para_ruby_and_smalltalk_programmers">Ruby and Smalltalk
    programmers should now feel right at home. As users of those languages
    know, these simple rules have far-reaching benefits when it comes to
    creating programs that flow naturally and elegantly.</para><para id="para_here_is_a_summary_of_the_rules">So, what characters can you
    use in identifiers? Here is a summary of the rules for identifiers, used
    for method and type names, variables, etc. For the precise details, see
    <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>. Scala allows all the
    printable ASCII characters, such as letters, digits, the underscore
    ( <literal moreinfo="none">_</literal> ), and the dollar sign (<literal moreinfo="none">$</literal>), with
    the exceptions of the “parenthetical” characters—<literal moreinfo="none">(</literal>,
    <literal moreinfo="none">)</literal>, <literal moreinfo="none">[</literal>, <literal moreinfo="none">]</literal>,
    <literal moreinfo="none">{</literal>, and <literal moreinfo="none">}</literal>—and the “delimiter”
    characters—<literal moreinfo="none">`</literal>, <literal moreinfo="none">’</literal>,
    <literal moreinfo="none">'</literal>, <literal moreinfo="none">"</literal>, <literal moreinfo="none">.</literal>,
    <literal moreinfo="none">;</literal>, and <literal moreinfo="none">,</literal>. Scala allows the other
    characters between \u0020–\u007F that are not in the sets just shown, such
    as mathematical symbols and “other” symbols. These remaining characters
    are called <emphasis>operator characters</emphasis>, and they include
    characters such as <literal moreinfo="none">/</literal>, <literal moreinfo="none">&lt;</literal>,
    etc.<indexterm significance="normal"><primary>characters</primary><secondary>used in identifiers</secondary></indexterm><indexterm significance="normal"><primary>identifiers, characters allowed in</primary></indexterm><indexterm significance="normal"><primary>operator characters</primary></indexterm></para><variablelist id="para_identifier_rules"><varlistentry id="varlistentry-reserved-words-can-8217-t-be-used"><term>Reserved words can’t be used</term><listitem><para>As in most languages, you can’t reuse reserved words for
          identifiers. We listed the reserved words in <xref linkend="ReservedWords"/>. Recall that some of them are
          combinations of operator and punctuation characters. For example, a
          single underscore ( <literal moreinfo="none">_</literal> ) is a reserved
          word!<indexterm significance="normal"><primary>_ (underscore)</primary><secondary>reserved word</secondary></indexterm><indexterm significance="normal"><primary>reserved words</primary><secondary>not allowed in identifiers</secondary></indexterm></para></listitem></varlistentry><varlistentry id="varlistentry-plain-identifiers-combinations-of-letters-digits-8216-8217-8216-_-8217-and-operators"><term>Plain identifiers—combinations of letters, digits,
        <literal moreinfo="none">$</literal>, <literal moreinfo="none">_</literal>, and operators</term><listitem><para>Like Java and many languages, a <emphasis>plain
          identifier</emphasis> can begin with a letter or underscore,
          followed by more letters, digits, underscores, and dollar signs.
          Unicode-equivalent characters are also allowed. However, like Java,
          Scala reserves the dollar sign for internal use, so you shouldn’t
          use it in your own identifiers. After an <phrase role="keep-together">underscore</phrase>, you can have either
          letters and digits <emphasis>or</emphasis> a sequence of operator
          characters. The underscore is important. It tells the compiler to
          treat all the characters up to the next whitespace as part of the
          identifier. For example, <literal moreinfo="none">val xyz_++= = 1</literal> assigns
          the variable <literal moreinfo="none">xyz_++=</literal> the value
          <literal moreinfo="none">1</literal>, while the expression <literal moreinfo="none">val xyz++= =
          1</literal> won’t compile because the “identifier” could also be
          interpreted as <literal moreinfo="none">xyz ++=</literal>, which looks like an
          attempt to append something to <literal moreinfo="none">xyz</literal>. Similarly, if
          you have operator characters after the underscore, you can’t mix
          them with letters and digits. This restriction prevents ambiguous
          expressions like this: <literal moreinfo="none">abc_=123</literal>. Is that an
          identifier <literal moreinfo="none">abc_=123</literal> or an assignment of the value
          <literal moreinfo="none">123</literal> to <literal moreinfo="none">abc_</literal>?<indexterm significance="normal"><primary>_ (underscore)</primary><secondary>in identifiers</secondary></indexterm><indexterm significance="normal"><primary>$ (dollar sign) in identifiers</primary></indexterm><indexterm significance="normal"><primary>plain identifiers</primary></indexterm></para></listitem></varlistentry><varlistentry id="varlistentry-plain-identifiers-operators"><term>Plain identifiers—operators</term><listitem><para>If an identifier begins with an operator character, the rest
          of the characters must be operator characters.<indexterm significance="normal"><primary>operator characters</primary><secondary>in identifiers</secondary></indexterm></para></listitem></varlistentry><varlistentry id="varlistentry-8220-back-quote-8221-literals"><term>“Back-quote” literals</term><listitem><para>An identifier can also be an arbitrary string (subject to
          platform limitations) between two back quote characters, e.g.,
          <literal moreinfo="none">val `this is a valid identifier` = "Hello
          World!"</literal>. Recall that this syntax is also the way to invoke
          a method on a Java or .NET class when the method’s name is identical
          to a Scala reserved word, e.g.,
          <literal moreinfo="none">java.net.Proxy.‵type‵()</literal>.<indexterm significance="normal"><primary>Java</primary><secondary>invoking method name identical to Scala reserved
              word</secondary></indexterm><indexterm significance="normal"><primary sortas="NET">.NET</primary><secondary>invoking method name identical to Scala reserved
              word</secondary></indexterm><indexterm significance="normal"><primary>`` (back quotes) in literals</primary></indexterm></para></listitem></varlistentry><varlistentry id="varlistentry-pattern-matching-identifiers"><term>Pattern matching identifiers</term><listitem><para>In pattern matching expressions, tokens that begin with a
          lowercase letter are parsed as <emphasis>variable
          identifiers</emphasis>, while tokens that begin with an uppercase
          letter are parsed as <emphasis>constant identifiers</emphasis>. This
          restriction prevents some ambiguities because of the very succinct
          variable syntax that is used, e.g., no <literal moreinfo="none">val</literal>
          keyword is present.<indexterm significance="normal"><primary>constant identifiers</primary></indexterm><indexterm significance="normal"><primary>pattern matching identifiers</primary></indexterm><indexterm significance="normal"><primary>variable identifiers</primary></indexterm></para></listitem></varlistentry></variablelist><sect2 id="para_pattern_matching_identifiers_"><title>Syntactic Sugar</title><para id="para_once_you_know_that_all_operato">Once you know that all
      operators are methods, it’s easier to reason about unfamiliar Scala
      code. You don’t have to worry about special cases when you see new
      operators. When working with Actors in <xref linkend="ATasteOfConcurrency"/>, you may have noticed that we used an
      exclamation point (<literal moreinfo="none">!</literal>) to send a message to an Actor.
      Now you know that the <literal moreinfo="none">!</literal> is just another method, as
      are the other handy shortcut operators you can use to talk to Actors.
      Similarly, Scala’s XML library provides the <literal moreinfo="none">\</literal> and
      <literal moreinfo="none">\\</literal> operators to dive into document structures. These
      are just methods on the <literal moreinfo="none">scala.xml.NodeSeq</literal>
      class.<indexterm significance="normal"><primary>Actors</primary><secondary>shortcut operators used with</secondary></indexterm><indexterm significance="normal"><primary>NodeSeq class, \ and \\ methods</primary></indexterm><indexterm significance="normal"><primary>\ (backslash)</primary><secondary>\ and \\ operators for document structures</secondary></indexterm><indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>! method, sending messages to Actors</secondary></indexterm></para><para id="para_this_flexible_method_naming_gi">This flexible method
      naming gives you the power to write libraries that feel like a natural
      extension of Scala itself. You could write a new math library with
      numeric types that accept all the usual mathematical operators, like
      addition and subtraction. You could write a new concurrent messaging
      layer that behaves just like Actors. The possibilities are constrained
      only by Scala’s method naming limitations.</para><caution id="para_caution_just_because_you__can"><para>Just because you <emphasis>can</emphasis> doesn’t mean you
        <emphasis>should</emphasis>. When designing your own libraries and
        APIs in Scala, keep in mind that obscure punctuational operators are
        hard for programmers to remember. Overuse of these can contribute a
        “line noise” quality of unreadability to your code. Stick to
        conventions and err on the side of spelling method names out when a
        shortcut doesn’t come readily to mind.</para></caution></sect2></sect1><sect1 id="_methods_without_parentheses_and_dots"><title>Methods Without Parentheses and Dots</title><para id="para_to_facilitate_a_variety_of_rea">To facilitate a variety of
    readable programming styles, Scala is flexible about the use of
    parentheses in methods. If a method takes no parameters, you can define it
    without parentheses. Callers must invoke the method without parentheses.
    If you add empty parentheses, then callers may optionally add parentheses.
    For example, the <literal moreinfo="none">size</literal> method for
    <literal moreinfo="none">List</literal> has no parentheses, so you write <literal moreinfo="none">List(1,
    2, 3).size</literal>. If you try <literal moreinfo="none">List(1, 2, 3).size()</literal>,
    you’ll get an error. However, the <literal moreinfo="none">length</literal> method for
    <literal role="keep-together" moreinfo="none">java.lang.String</literal> does have
    parentheses in its definition, but Scala lets you write both
    <literal moreinfo="none">"hello".length()</literal> and
    <literal moreinfo="none">"hello".length</literal>.<indexterm significance="normal"><primary>methods</primary><secondary sortas="parentheses and dots">without parentheses and
        dots</secondary></indexterm></para><para id="para_the_convention_in_the_scala_co">The convention in the Scala
    community is to omit parentheses when calling a method that has no
    <emphasis>side effects</emphasis>. So, asking for the size of a sequence
    is fine without parentheses, but defining a method that transforms the
    elements in the sequence should be written with parentheses. This
    convention signals a potentially tricky method for users of your
    code.<indexterm significance="normal"><primary>. (dot)</primary><secondary>omitting in method calls</secondary></indexterm><indexterm significance="normal"><primary>( ) (parentheses)</primary><secondary>omitting in method invocations</secondary></indexterm></para><para id="para_it_s_also_possible_to_omit_the">It’s also possible to omit
    the dot (period) when calling a parameterless method or one that takes
    only one argument. With this in mind, our <literal moreinfo="none">List(1, 2,
    3).size</literal> example could be written as:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/no-dot-script.scala</code>

<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>) size
</programlisting><para id="para_neat_but_confusing_when_does">Neat, but confusing. When
    does this syntactical flexibility become useful? When chaining method
    calls together into expressive, self-explanatory “sentences” of
    code:</para><?dbfo-need height=”1in”
?><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/no-dot-better-script.scala</code>

<code role="statement">def</code> <code role="identifier">isEven</code>(n:<code role="type"> Int</code>) = (n % <code role="constant">2</code>) == <code role="constant">0</code>

<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>) filter isEven foreach println
</programlisting><para id="para_as_you_might_guess_running_th">As you might guess, running
    this produces the following output:</para><screen format="linespecific">2
4</screen><para id="para_scala_s_liberal_approach_to_pa">Scala’s liberal approach to
    parentheses and dots on methods provides one building block for writing
    <emphasis>Domain-Specific Languages</emphasis>. We’ll learn more about
    them after a brief discussion of operator precedence.</para><sect2 id="_precedence_rules"><title>Precedence Rules</title><para id="para_so_if_an_expression_like_2_0">So, if an expression like
      <literal moreinfo="none">2.0 * 4.0 / 3.0 * 5.0</literal> is actually a series of method
      calls on <literal moreinfo="none">Double</literal>s, what are the <emphasis>operator
      precedence</emphasis> rules? Here they are in order from lowest to
      highest precedence (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>):<indexterm significance="normal"><primary>methods</primary><secondary sortas="parentheses and dots">without parentheses and
          dots</secondary><tertiary>operator precedence</tertiary></indexterm><indexterm significance="normal"><primary>% (percent sign)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>/ (slash)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>* (asterisk)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>- (minus sign)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>+ (plus sign)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>: (colon)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>= (equals sign)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>&amp; (ampersand)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>^ (caret)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>| (vertical bar)</primary><secondary>operator precedence</secondary></indexterm><indexterm significance="normal"><primary>precedence, operator</primary></indexterm><indexterm significance="normal"><primary>operator precedence</primary></indexterm></para><orderedlist inheritnum="ignore" continuation="restarts"><listitem><para><emphasis>All letters</emphasis></para></listitem><listitem><para><literal moreinfo="none">|</literal></para></listitem><listitem><para><literal moreinfo="none">^</literal></para></listitem><listitem><para><literal moreinfo="none">&amp;</literal></para></listitem><listitem><para><literal moreinfo="none">&lt; &gt;</literal></para></listitem><listitem><para><literal moreinfo="none">= !</literal></para></listitem><listitem><para><literal moreinfo="none">:</literal></para></listitem><listitem><para><literal moreinfo="none">+ -</literal></para></listitem><listitem><para><literal moreinfo="none">* / %</literal></para></listitem><listitem><para><emphasis>All other special characters</emphasis></para></listitem></orderedlist><para id="para_characters_on_the_same_line_ha">Characters on the same
      line have the same precedence. An exception is <literal moreinfo="none">=</literal> when
      used for assignment, when it has the lowest precedence.</para><para id="para_since_042_and_have_the_sa">Since * and / have the same
      precedence, the two lines in the following <literal moreinfo="none">scala</literal>
      session behave the same:</para><programlisting language="scala" format="linespecific">scala&gt; <code role="constant">2.0</code> * <code role="constant">4.0</code> / <code role="constant">3.0</code> * <code role="constant">5.0</code>
res2:<code role="type"> Double</code> = <code role="constant">13.333333333333332</code>

scala&gt; (((<code role="constant">2.0</code> * <code role="constant">4.0</code>) / <code role="constant">3.0</code>) * <code role="constant">5.0</code>)
res3:<code role="type"> Double</code> = <code role="constant">13.333333333333332</code>
</programlisting><para id="para_in_a_sequence_of_left_associat">In a sequence of
      left-associative method invocations, they simply bind in left-to-right
      order. “Left-associative” you say? In Scala, any method with a name that
      ends with a colon <literal moreinfo="none">:</literal> actually binds to the
      <emphasis>right</emphasis>, while all other methods bind to the left.
      For example, you can prepend an element to a <literal moreinfo="none">List</literal>
      using the <literal moreinfo="none">::</literal> method (called “cons,” short for
      “constructor”):<indexterm significance="normal"><primary>right-associative method invocations</primary></indexterm><indexterm significance="normal"><primary>: (colon)</primary><secondary>:: (constructor) method</secondary><tertiary>prepending to a list</tertiary></indexterm><indexterm significance="normal"><primary>: (colon)</primary><secondary>methods ending in, right-associative
          invocation</secondary></indexterm><indexterm significance="normal"><primary>left-associative method invocations</primary></indexterm></para><programlisting language="scala" format="linespecific">scala&gt; <code role="statement">val</code> list = <code role="special">List</code>(<code role="constant">'b'</code>, <code role="constant">'c'</code>, <code role="constant">'d'</code>)
list:<code role="type"> List[Char]</code> = <code role="special">List</code>(b, c, d)

scala&gt; <code role="constant">'a'</code> :: list
res4:<code role="type"> List[Char]</code> = <code role="special">List</code>(a, b, c, d)
</programlisting><para id="para_the_second_expression_is_equiv">The second expression is
      equivalent to <literal moreinfo="none">list.::(<replaceable>a</replaceable>)</literal>.
      In a sequence of right-associative method invocations, they bind from
      right to left. What about a mixture of left-binding and right-binding
      expressions?</para><programlisting language="scala" format="linespecific">scala&gt; <code role="constant">'a'</code> :: list ++ <code role="special">List</code>(<code role="constant">'e'</code>, <code role="constant">'f'</code>)
res5:<code role="type"> List[Char]</code> = <code role="special">List</code>(a, b, c, d, e, f)
</programlisting><para>(The <literal moreinfo="none">++</literal> method appends two lists.) In this
      case, <literal moreinfo="none">list</literal> is added to the
      <literal moreinfo="none">List(<replaceable>e</replaceable>,
      <replaceable>f</replaceable>)</literal>, then
      <literal moreinfo="none"><replaceable>a</replaceable></literal> is prepended to create
      the final list. It’s usually better to add parentheses to remove any
      potential uncertainty.<indexterm significance="normal"><primary>+ (plus sign)</primary><secondary>++ method, appending to lists</secondary></indexterm></para><tip id="para_tip_any_method_whose_name_end"><para>Any method whose name ends with a <literal moreinfo="none">:</literal> binds to
        the <emphasis>right</emphasis>, not the
        <emphasis>left</emphasis>.</para></tip><para>Finally, note that when you use the <literal moreinfo="none">scala</literal>
      command, either interactively or with scripts, it may appear that you
      can define “global” variables and methods outside of types. This is
      actually an illusion; the interpreter wraps all definitions in an
      anonymous type before generating JVM or .NET CLR byte code.</para></sect2></sect1><sect1 id="_domain_specific_languages"><title>Domain-Specific Languages</title><para id="para_domain_specific_languages_or_"><emphasis>Domain-Specific
    Languages</emphasis>, or DSLs, provide a convenient syntactical means for
    expressing goals in a given problem domain. For example, SQL provides just
    enough of a programming language to handle the problems of working with
    databases, making it a Domain-Specific Language.<indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary></indexterm></para><para id="para_while_some_dsls_like_sql_are_s">While some DSLs like SQL
    are self-contained, it’s become popular to implement DSLs as subsets of
    full-fledged programming languages. This allows programmers to leverage
    the entirety of the host language for edge cases that the DSL does not
    cover, and saves the work of writing lexers, parsers, and the other
    building blocks of a language.<indexterm significance="normal"><primary>BDD (Behavior-Driven Development)</primary></indexterm><indexterm significance="normal"><primary>Specs library</primary></indexterm></para><para id="para_scala_s_rich_flexible_syntax_">Scala’s rich, flexible
    syntax makes writing DSLs a breeze. Consider this example of a style of
    test writing called <emphasis>Behavior-Driven Development</emphasis> (see
    <link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>) using the
    Specs library (see <xref linkend="ScalaSpecs"/>):</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/specs-script.scala</code>

<code role="constant">"nerd finder"</code> should {
  <code role="constant">"identify nerds from a List"</code> in {
    <code role="statement">val</code> actors = <code role="special">List</code>(<code role="constant">"Rick Moranis"</code>, <code role="constant">"James Dean"</code>, <code role="constant">"Woody Allen"</code>)
    <code role="statement">val</code> finder = <code role="statement">new</code> <code role="special">NerdFinder</code>(actors)
    finder.findNerds mustEqual <code role="special">List</code>(<code role="constant">"Rick Moranis"</code>, <code role="constant">"Woody Allen"</code>)
  }
}
</programlisting><para id="para_notice_how_much_this_code_read">Notice how much this code
    reads like English: “This should test that in the following scenario,”
    “This value must equal that value,” and so forth. This example uses the
    <phrase role="keep-together">superb</phrase> Specs library, which
    effectively provides a DSL for the Behavior-Driven Development testing and
    engineering methodology. By making maximum use of Scala’s liberal syntax
    and rich methods, Specs test suites are readable even by
    non-developers.</para><para id="para_this_is_just_a_taste_of_the_po">This is just a taste of the
    power of DSLs in Scala. We’ll see other examples later and learn how to
    write our own as we get more advanced (see <xref linkend="DomainSpecificLanguages"/>).</para></sect1><sect1 id="IfStatements"><title>Scala if Statements</title><para id="para_even_the_most_familiar_languag">Even the most familiar
    language features are supercharged in Scala. Let’s have a look at the
    lowly <literal moreinfo="none">if</literal> statement. As in most every language, Scala’s
    <literal moreinfo="none">if</literal> evaluates a conditional expression, then proceeds to
    a block if the result is <literal moreinfo="none">true</literal>, or branches to an
    alternate block if the result is <literal moreinfo="none">false</literal>. A simple
    example:<indexterm significance="normal"><primary>if statements</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/if-script.scala</code>

<code role="statement">if</code> (<code role="constant">2</code> + <code role="constant">2</code> == <code role="constant">5</code>) {
  println(<code role="constant">"Hello from 1984."</code>)
} <code role="statement">else</code> <code role="statement">if</code> (<code role="constant">2</code> + <code role="constant">2</code> == <code role="constant">3</code>) {
    println(<code role="constant">"Hello from Remedial Math class?"</code>)
} <code role="statement">else</code> {
  println(<code role="constant">"Hello from a non-Orwellian future."</code>)
}
</programlisting><para id="para_what_s_different_in_scala_is_t">What’s different in Scala
    is that <literal moreinfo="none">if</literal> and almost all other statements are actually
    expressions themselves. So, we can assign the result of an
    <literal moreinfo="none">if</literal> expression, as shown here:<indexterm significance="normal"><primary>expressions</primary><secondary>if statements as</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/assigned-if-script.scala</code>

<code role="statement">val</code> configFile = <code role="statement">new</code> java.io.<code role="special">File</code>(<code role="constant">"~/.myapprc"</code>)

<code role="statement">val</code> configFilePath = <code role="statement">if</code> (configFile.exists()) {
  configFile.getAbsolutePath()
} <code role="statement">else</code> {
  configFile.createNewFile()
  configFile.getAbsolutePath()
}
</programlisting><para id="para_note_that_if_statements_are_">Note that
    <literal moreinfo="none">if</literal> statements are expressions, meaning they have
    values. In this example, the value <literal moreinfo="none">configFilePath</literal> is
    the result of an <literal moreinfo="none">if</literal> expression that handles the case of
    a configuration file not existing internally, then returns the absolute
    path to that file. This value can now be reused throughout an application,
    and the <literal moreinfo="none">if</literal> expression won’t be reevaluated when the
    value is used.</para><para id="para_because_if_statements_are_ex">Because <literal moreinfo="none">if</literal>
    statements are expressions in Scala, there is no need for the special-case
    ternary conditional expressions that exist in C-derived languages. You
    won’t see <literal moreinfo="none">x ? doThis() : doThat()</literal> in Scala. Scala
    provides a mechanism that’s just as powerful and more readable.<indexterm significance="normal"><primary>else clause (if statements)</primary></indexterm></para><para id="para_what_if_we_forget_the_els">What if we omit the
    <literal moreinfo="none">else</literal> clause in the previous example? Typing the code in
    the <literal moreinfo="none">scala</literal> interpreter will tell us what happens:</para><programlisting language="scala" format="linespecific">scala&gt; <code role="statement">val</code> configFile = <code role="statement">new</code> java.io.<code role="special">File</code>(<code role="constant">"~/.myapprc"</code>)
configFile:<code role="type"> java.io.File</code> = ~/.myapprc

scala&gt; <code role="statement">val</code> configFilePath = <code role="statement">if</code> (configFile.exists()) {
     |   configFile.getAbsolutePath()
     | }
configFilePath:<code role="type"> Unit</code> = ()

scala&gt;
</programlisting><para id="para_note_that_configfilepath_is_">Note that
    <literal moreinfo="none">configFilePath</literal> is now <literal moreinfo="none">Unit</literal>. (It was
    <literal moreinfo="none">String</literal> before.) The type inference picks a type that
    works for all outcomes of the <literal moreinfo="none">if</literal> expression.
    <literal moreinfo="none">Unit</literal> is the only possibility, since no value is one
    possible outcome.</para></sect1><sect1 id="ForComprehensions"><title>Scala for Comprehensions</title><para id="para_another_familiar_control_struc">Another familiar control
    structure that’s particularly feature-rich in Scala is the
    <literal moreinfo="none">for</literal> loop, referred to in the Scala community as a
    <literal moreinfo="none">for</literal> <emphasis>comprehension</emphasis> or
    <literal moreinfo="none">for</literal> <emphasis>expression</emphasis>. This corner of the
    language deserves at least one fancy name, because it can do some great
    party tricks.<indexterm class="startofrange" id="ch03_loopsfor" significance="normal"><primary>loops</primary><secondary>for loops or comprehensions</secondary></indexterm><indexterm significance="normal"><primary>expressions</primary><secondary>for expression</secondary></indexterm><indexterm class="startofrange" id="ch03_forcomps" significance="normal"><primary>for comprehensions</primary></indexterm></para><para id="para_comprehension_description">Actually, the term
    <literal moreinfo="none">comprehension</literal> comes from functional programming. It
    expresses the idea that we are traversing a set of some kind,
    “comprehending” what we find, and computing something new from
    it.<indexterm significance="normal"><primary>comprehensions</primary></indexterm></para><sect2 id="_a_dog_simple_example"><title>A Dog-Simple Example</title><para id="para_let_s_start_with_a_basic_for_">Let’s start with a basic
      <literal moreinfo="none">for</literal> expression:<indexterm significance="normal"><primary>for comprehensions</primary><secondary>simple example</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/basic-for-script.scala</code>

<code role="statement">val</code> dogBreeds = <code role="special">List</code>(<code role="constant">"Doberman"</code>, <code role="constant">"Yorkshire Terrier"</code>, <code role="constant">"Dachshund"</code>,
                     <code role="constant">"Scottish Terrier"</code>, <code role="constant">"Great Dane"</code>, <code role="constant">"Portuguese Water Dog"</code>)

<code role="statement">for</code> (breed <code role="statement">&lt;-</code> dogBreeds)
  println(breed)
</programlisting><para id="para_as_you_might_guess_this_code_">As you might guess, this
      code says, “For every element in the list <literal moreinfo="none">dogBreeds</literal>,
      create a temporary variable called <literal moreinfo="none">breed</literal> with the
      value of that element, then print it.” Think of the
      <literal moreinfo="none">&lt;-</literal> operator as an arrow directing elements of a
      collection, one by one, to the scoped variable by which we’ll refer to
      them inside the <literal moreinfo="none">for</literal> expression. The left-arrow
      operator is called a <emphasis>generator</emphasis>, so named because
      it’s <emphasis>generating</emphasis> individual values from a collection
      for use in an expression.<indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt;- (left-arrow) operator, generators</secondary></indexterm><indexterm significance="normal"><primary>arrow operator (&lt;-)</primary></indexterm><indexterm significance="normal"><primary>generators</primary><secondary>&lt;- (left-arrow) operator</secondary></indexterm></para></sect2><sect2 id="_filtering"><title>Filtering</title><para id="para_what_if_we_want_to_get_more_gr">What if we want to get
      more granular? Scala’s <literal moreinfo="none">for</literal> expressions allow for
      <emphasis>filters</emphasis> that let us specify which elements of a
      collection we want to work with. So to find all terriers in our list of
      dog breeds, we could modify the previous example to the
      following:<indexterm significance="normal"><primary>filtering</primary><secondary sortas="for expressions">in for expressions</secondary></indexterm><indexterm significance="normal"><primary>for comprehensions</primary><secondary>filters in</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/filtered-for-script.scala</code>

<code role="statement">for</code> (breed <code role="statement">&lt;-</code> dogBreeds
  <code role="statement">if</code> breed.contains(<code role="constant">"Terrier"</code>)
) println(breed)
</programlisting><para id="para_to_add_more_than_one_filter_to">To add more than one
      filter to a <literal moreinfo="none">for</literal> expression, separate the filters with
      semicolons:<indexterm significance="normal"><primary>; (semicolon)</primary><secondary>separators in for expression</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/double-filtered-for-script.scala</code>

<code role="statement">for</code> (breed <code role="statement">&lt;-</code> dogBreeds
  <code role="statement">if</code> breed.contains(<code role="constant">"Terrier"</code>);
  <code role="statement">if</code> !breed.startsWith(<code role="constant">"Yorkshire"</code>)
) println(breed)
</programlisting><para id="para_you_ve_now_found_all_the_terri">You’ve now found all the
      terriers that don’t hail from Yorkshire, and hopefully learned just how
      useful filters can be in the process.</para></sect2><sect2 id="Yielding"><title>Yielding</title><para id="para_what_if_rather_than_printing_">What if, rather than
      printing your filtered collection, you needed to hand it off to <phrase role="keep-together">another</phrase> part of your program? The
      <literal moreinfo="none">yield</literal> keyword is your ticket to generating new
      <phrase role="keep-together">collections</phrase> with
      <literal moreinfo="none">for</literal> expressions. In the following example, note that
      we’re wrapping up the <literal moreinfo="none">for</literal> expression in curly braces,
      as we would when defining any block:<indexterm significance="normal"><primary>{ } (curly braces)</primary><secondary>enclosing for expressions</secondary></indexterm><indexterm significance="normal"><primary>for comprehensions</primary><secondary>yielding collections</secondary></indexterm><indexterm significance="normal"><primary>yield keyword</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/yielding-for-script.scala</code>

<code role="statement">val</code> filteredBreeds = <code role="statement">for</code> {
  breed <code role="statement">&lt;-</code> dogBreeds
  <code role="statement">if</code> breed.contains(<code role="constant">"Terrier"</code>)
  <code role="statement">if</code> !breed.startsWith(<code role="constant">"Yorkshire"</code>)
} <code role="statement">yield</code> breed
</programlisting><tip id="para_tip_for_expressions_may_be_"><para><literal moreinfo="none">for</literal> expressions may be defined with
        parentheses or curly braces, but using curly braces means you don’t
        have to separate your filters with semicolons. Most of the time,
        you’ll prefer using curly braces when you have more than one filter,
        assignment, etc.</para></tip><para id="para_every_time_through_the_for_e">Every time through the
      <literal moreinfo="none">for</literal> expression, the filtered result is yielded as a
      value named <literal moreinfo="none">breed</literal>. These results accumulate with
      every run, and the resulting collection is assigned to the value
      <literal moreinfo="none">filteredBreeds</literal> (as we did with <literal moreinfo="none">if</literal>
      statements earlier). The type of the collection resulting from a
      <literal moreinfo="none">for-yield</literal> expression is inferred from the type of the
      collection being iterated over. In this case,
      <literal moreinfo="none">filteredBreeds</literal> is of type
      <literal moreinfo="none">List[String]</literal>, since it is a subset of the
      <literal moreinfo="none">dogBreeds</literal> list, which is also of type
      <literal moreinfo="none">List[String]</literal>.</para></sect2><sect2 id="_expanded_scope"><title>Expanded Scope</title><para id="para_one_final_useful_feature_of_sc">One final useful feature
      of Scala’s <literal moreinfo="none">for</literal> comprehensions is the ability to
      define variables inside the first part of your <literal moreinfo="none">for</literal>
      expressions that can be used in the latter part. This is best
      illustrated with an example:<indexterm significance="normal"><primary>variables</primary><secondary>expanded scope in for expressions</secondary></indexterm><indexterm significance="normal"><primary>scope</primary><secondary>expanded variable scope in for comprehensions</secondary></indexterm><indexterm significance="normal"><primary>for comprehensions</primary><secondary>expanded variable scope</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/scoped-for-script.scala</code>

<code role="statement">for</code> {
  breed <code role="statement">&lt;-</code> dogBreeds
  upcasedBreed = breed.toUpperCase()
} println(upcasedBreed)
</programlisting><para id="para_note_that_without_declaring_u">Note that without
      declaring <literal moreinfo="none">upcasedBreed</literal> as a <literal moreinfo="none">val</literal>,
      you can reuse it within the body of your <literal moreinfo="none">for</literal>
      expression. This approach is ideal for transforming elements in a
      collection as you loop through them.</para><para id="para_finally_in_optionsandforcom">Finally, in <xref linkend="OptionsAndForComprehensions"/>, we’ll see how using
      <literal moreinfo="none">Options</literal> with <literal moreinfo="none">for</literal> comprehensions
      can greatly reduce code size by eliminating unnecessary “null” and
      “missing” checks.<indexterm class="endofrange" startref="ch03_loopsfor" significance="normal"/><indexterm class="endofrange" startref="ch03_forcomps" significance="normal"/></para></sect2></sect1><sect1 id="OtherLoopingConstructs"><title>Other Looping Constructs</title><para>Scala provides several other looping constructs.</para><sect2 id="_scala_while_loops"><title>Scala while Loops</title><para id="para_familiar_in_many_languages_th">Familiar in many
      languages, the <literal moreinfo="none">while</literal> loop executes a block of code as
      long as a condition is true. For example, the following code prints out
      a complaint once a day until the next Friday the 13th has
      arrived:<indexterm significance="normal"><primary>while loops</primary></indexterm><indexterm significance="normal"><primary>loops</primary><secondary>while</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/while-script.scala</code>
<code role="comment">// WARNING: This script runs for a LOOOONG time!</code>

<code role="preproc">import</code> java.util.Calendar

<code role="statement">def</code> <code role="identifier">isFridayThirteen</code>(cal:<code role="type"> Calendar</code>):<code role="type"> Boolean</code> = {
  <code role="statement">val</code> dayOfWeek = cal.get(Calendar.<code role="special">DAY_OF_WEEK</code>)
  <code role="statement">val</code> dayOfMonth = cal.get(Calendar.<code role="special">DAY_OF_MONTH</code>)

  <code role="comment">// Scala returns the result of the last expression in a method</code>
  (dayOfWeek == Calendar.<code role="special">FRIDAY</code>) &amp;&amp; (dayOfMonth == <code role="constant">13</code>)
}

<code role="statement">while</code> (!isFridayThirteen(Calendar.getInstance())) {
  println(<code role="constant">"Today isn't Friday the 13th. Lame."</code>)
  <code role="comment">// sleep for a day</code>
  Thread.sleep(<code role="constant">86400000</code>)
}
</programlisting><para id="para_you_can_find_a_table_of_the_co"><xref linkend="conditional-operators"/> later in this chapter shows the
      conditional operators that work in <literal moreinfo="none">while</literal>
      loops.</para></sect2><sect2 id="_scala_do_while_loops"><title>Scala do-while Loops</title><para id="para_like_the_while_loop_above_a">Like the
      <literal moreinfo="none">while</literal> loop, a <literal moreinfo="none">do-while</literal> loop
      executes some code while a conditional expression is true. The only
      difference that a <literal moreinfo="none">do-while</literal> checks to see if the
      condition is true <emphasis>after</emphasis> running the block. To count
      up to 10, we could write this:<indexterm significance="normal"><primary>loops</primary><secondary>do-while</secondary></indexterm><indexterm significance="normal"><primary>do-while loops</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/do-while-script.scala</code>

<code role="statement">var</code> count = <code role="constant">0</code>

<code role="statement">do</code> {
  count += <code role="constant">1</code>
  println(count)
} <code role="statement">while</code> (count &lt; <code role="constant">10</code>)
</programlisting><para id="para_as_it_turns_out_there_s_a_mor">As it turns out, there’s a
      more elegant way to loop through collections in Scala, as we’ll see in
      the next section.</para></sect2><sect2 id="GeneratorExpressions"><title>Generator Expressions</title><para id="para_remember_the_arrow_operator_">Remember the arrow operator
      (<literal moreinfo="none">&lt;-</literal>) from the discussion about
      <literal moreinfo="none">for</literal> loops? We can put it to work here, too. Let’s
      clean up the <literal moreinfo="none">do-while</literal> example just shown:<indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt;- (left-arrow) operator, generators</secondary></indexterm><indexterm significance="normal"><primary>loops</primary><secondary>generator expressions in</secondary></indexterm><indexterm significance="normal"><primary>generator expressions</primary></indexterm><indexterm significance="normal"><primary>arrow operator (&lt;-)</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/generator-script.scala</code>

<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">10</code>) println(i)
</programlisting><para>Yup, that’s all that’s necessary. This clean one-liner is possible
      because of Scala’s <literal moreinfo="none">RichInt</literal> class. An
      <emphasis>implicit conversion</emphasis> is invoked by the compiler to
      convert the <literal moreinfo="none">1</literal>, an <literal moreinfo="none">Int</literal>, into a
      <literal moreinfo="none">RichInt</literal>. (We’ll discuss these conversions in <xref linkend="ScalaTypeHierarchy"/> and in <xref linkend="ImplicitConversions"/>.) <literal moreinfo="none">RichInt</literal> defines a
      <literal moreinfo="none">to</literal> method that takes another integer and returns an
      instance of <literal moreinfo="none">Range.Inclusive</literal>. That is,
      <literal moreinfo="none">Inclusive</literal> is a nested class in the
      <literal moreinfo="none">Range</literal> <emphasis>companion object</emphasis> (a
      concept we introduced briefly in <xref linkend="IntroducingScala"/>;
      see <xref linkend="AdvancedObjectOrientedProgramming"/> for details).
      This subclass of the <emphasis>class</emphasis> <literal moreinfo="none">Range</literal>
      inherits a number of methods for working with sequences and iterable
      data structures, including those necessary to use it in a
      <literal moreinfo="none">for</literal> loop.<indexterm significance="normal"><primary>sequences</primary><secondary>Range.Inclusive class</secondary></indexterm><indexterm significance="normal"><primary>Range.Inclusive class</primary></indexterm><indexterm significance="normal"><primary>RichInt class</primary></indexterm><indexterm significance="normal"><primary>implicit conversions</primary><secondary>Int into RichInt</secondary></indexterm></para><para id="para_by_the_way_if_you_wanted_to_c">By the way, if you wanted
      to count from 1 up to but not including 10, you could use
      <literal moreinfo="none">until</literal> instead of <literal moreinfo="none">to</literal>. For example:
      <literal moreinfo="none">for (i &lt;- 0 until 10)</literal>.</para><para id="para_this_should_paint_a_clearer_pi">This should paint a
      clearer picture of how Scala’s internal libraries compose to form
      easy-to-use language constructs.</para><note id="para_note_when_working_with_loops_"><para>When working with loops in most languages, you can
        <literal moreinfo="none">break</literal> out of a loop or <literal moreinfo="none">continue</literal>
        the iterations. Scala doesn’t have either of these statements, but
        when writing idiomatic Scala code, they’re not necessary. Use
        conditional expressions to test if a loop should continue, or make use
        of recursion. Better yet, filter your collections ahead of time to
        eliminate complex conditions within your loops. However, because of
        demand for it, Scala version 2.8 includes support for
        <literal moreinfo="none">break</literal>, implemented as a library method, rather than
        a built-in <literal moreinfo="none">break</literal> keyword.<indexterm significance="normal"><primary>break method</primary></indexterm></para></note></sect2></sect1><sect1 id="_conditional_operators"><title>Conditional Operators</title><para id="para_scala_borrows_most_of_the_cond">Scala borrows most of the
    conditional operators from Java and its predecessors. You’ll find the ones
    listed in <xref linkend="conditional-operators"/> in
    <literal moreinfo="none">if</literal> statements, <literal moreinfo="none">while</literal> loops, and
    everywhere else conditions apply.<indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>!= (not equal) operator</secondary></indexterm><indexterm significance="normal"><primary>equals operator (==)</primary></indexterm><indexterm significance="normal"><primary>= (equals sign)</primary><secondary>== (equals) operator</secondary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt; (less than) operator</secondary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&gt; (greater than) operator</secondary></indexterm><indexterm significance="normal"><primary>and operator (&amp;&amp;)</primary></indexterm><indexterm significance="normal"><primary>or operator (||)</primary></indexterm><indexterm significance="normal"><primary>| (vertical bar)</primary><secondary>|| (or) operator</secondary></indexterm><indexterm significance="normal"><primary>&amp; (ampersand)</primary><secondary>&amp;&amp; (and) operator</secondary></indexterm><indexterm significance="normal"><primary>operators</primary><secondary>conditional</secondary></indexterm><indexterm significance="normal"><primary>conditional operators</primary></indexterm></para><table id="conditional-operators"><title>Conditional operators</title><tgroup cols="3"><thead valign="top"><row><entry>Operator</entry><entry>Operation</entry><entry>Description</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">&amp;&amp;</literal></para></entry><entry><para>and</para></entry><entry><para>The values on the left and right of the operator are
            true. The righthand side is <emphasis>only</emphasis> evaluated if
            the lefthand side is <emphasis>true</emphasis>.</para></entry></row><row><entry><para><literal moreinfo="none">||</literal></para></entry><entry><para>or</para></entry><entry><para>At least one of the values on the left or right is
            true. The righthand side is <emphasis>only</emphasis> evaluated if
            the lefthand side is <emphasis>false</emphasis>.</para></entry></row><row><entry><para><literal moreinfo="none">&gt;</literal></para></entry><entry><para>greater than</para></entry><entry><para>The value on the left is greater than the value on
            the right.</para></entry></row><row><entry><literal moreinfo="none">&gt;=</literal></entry><entry>greater than or equals</entry><entry>The value on the left is greater than or equal to the value
            on the right.</entry></row><row><entry><para><literal moreinfo="none">&lt;</literal></para></entry><entry><para>less than</para></entry><entry><para>The value on the left is less than the value on the
            right.</para></entry></row><row><entry><literal moreinfo="none">&lt;=</literal></entry><entry>less than or equals</entry><entry>The value on the left is less than or equal to the value on
            the right.</entry></row><row><entry><para><literal moreinfo="none">==</literal></para></entry><entry><para>equals</para></entry><entry><para>The value on the left is the same as the value on the
            right.</para></entry></row><row><entry><para><literal moreinfo="none">!=</literal></para></entry><entry><para>not equal</para></entry><entry><para>The value on the left is not the same as the value on
            the right.</para></entry></row></tbody></tgroup></table><para id="para_note_that_and_are_">Note that <literal moreinfo="none">&amp;&amp;</literal>
    and <literal moreinfo="none">||</literal> are “short-circuiting” operators. They stop
    evaluating expressions as soon as the answer is known.<indexterm significance="normal"><primary>short-circuiting operators (&amp;&amp; and ||)</primary></indexterm></para><para id="para_we_ll_discuss_object_equality_">We’ll discuss object
    equality in more detail in <xref linkend="EqualityOfObjects"/>. For
    example, we’ll see that <literal moreinfo="none">==</literal> has a different meaning in
    Scala versus Java. Otherwise, these operators should all be familiar, so
    let’s move on to something new and exciting.</para></sect1><sect1 id="PatternMatching"><title>Pattern Matching</title><para id="para_an_idea_borrowed_from_function">An idea borrowed from
    functional languages, <emphasis>pattern matching</emphasis> is a powerful
    yet concise way to make a programmatic choice between multiple conditions.
    Pattern matching is the familiar <literal moreinfo="none">case</literal> statement from
    your favorite C-like language, but on steroids. In the typical
    <literal moreinfo="none">case</literal> statement you’re limited to matching against
    values of ordinal types, yielding trivial expressions like this: “In the
    case that <literal moreinfo="none">i</literal> is 5, print a message; in the case that
    <literal moreinfo="none">i</literal> is 6, exit the program.” With Scala’s pattern
    matching, your cases can include types, wildcards, sequences, regular
    expressions, and even deep inspections of an object’s variables.<indexterm class="startofrange" id="ch03_patternmatching" significance="normal"><primary>pattern matching</primary></indexterm></para><sect2 id="ASimpleMatch"><title>A Simple Match</title><para id="para_to_begin_with_let_s_simulate_">To begin with, let’s
      simulate flipping a coin by matching the value of a boolean:<indexterm significance="normal"><primary>pattern matching</primary><secondary>simple match of boolean values</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-boolean-script.scala</code>

<code role="statement">val</code> bools = <code role="special">List</code>(<code role="constant">true</code>, <code role="constant">false</code>)

<code role="statement">for</code> (bool <code role="statement">&lt;-</code> bools) {
  bool <code role="statement">match</code> {
    <code role="statement">case</code> <code role="constant">true</code> <code role="statement">=&gt;</code> println(<code role="constant">"heads"</code>)
    <code role="statement">case</code> <code role="constant">false</code> <code role="statement">=&gt;</code> println(<code role="constant">"tails"</code>)
    <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> println(<code role="constant">"something other than heads or tails (yikes!)"</code>)
  }
}
</programlisting><para id="para_it_looks_just_like_a_c_style_">It looks just like a
      C-style <literal moreinfo="none">case</literal> statement, right? The only difference is
      the last <literal moreinfo="none">case</literal> with the underscore
      ( <literal moreinfo="none">_</literal> ) wildcard. It matches anything not defined in
      the cases above it, so it serves the same purpose as the
      <literal moreinfo="none">default</literal> keyword in Java and C#
      <literal moreinfo="none">switch</literal> statements.<indexterm significance="normal"><primary>case statements</primary><secondary>pattern matching versus</secondary></indexterm></para><para id="para_pattern_matching_is__eager__t">Pattern matching is
      <emphasis>eager</emphasis>; the first match wins. So, if you try to put
      a <literal moreinfo="none">case _</literal> clause before any other
      <literal moreinfo="none">case</literal> clauses, the compiler will throw an “unreachable
      code” error on the next clause, because nothing will get past the
      default clause!<indexterm significance="normal"><primary>_ (underscore)</primary><secondary>wildcard character in Scala</secondary></indexterm><indexterm significance="normal"><primary>cases in pattern matching</primary><secondary>unreachable case</secondary></indexterm><indexterm significance="normal"><primary>eager matching</primary></indexterm></para><tip id="para_tip_use_case___for_the_defa"><para>Use <literal moreinfo="none">case _</literal> for the default, “catch-all”
        match.</para></tip><para id="para_what_if_we_want_to_work_with_m">What if we want to work
      with matches as variables?</para></sect2><sect2 id="VariablesInMatches"><title>Variables in Matches</title><para id="para_in_this_example_we_assign_the">In the following example,
      we assign the wildcard case to a variable called
      <literal moreinfo="none">otherNum⁠ber</literal>, then print it in the subsequent
      expression. If we generate a 7, we’ll extol that number’s virtues.
      Otherwise, we’ll curse fate for making us suffer an unlucky
      number:<indexterm significance="normal"><primary>variables</primary><secondary sortas="matches">in matches</secondary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary>variables in matches</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-variable-script.scala</code>

<code role="preproc">import</code> scala.util.Random

<code role="statement">val</code> randomInt = <code role="statement">new</code> <code role="special">Random</code>().nextInt(<code role="constant">10</code>)

randomInt <code role="statement">match</code> {
  <code role="statement">case</code> <code role="constant">7</code> <code role="statement">=&gt;</code> println(<code role="constant">"lucky seven!"</code>)
  <code role="statement">case</code> otherNumber <code role="statement">=&gt;</code> println(<code role="constant">"boo, got boring ol' "</code> + otherNumber)
}
</programlisting></sect2><sect2 id="MatchingOnType"><title>Matching on Type</title><para id="para_these_simple_examples_don_t_ev">These simple examples
      don’t even begin to scratch the surface of Scala’s pattern matching
      features. Let’s try matching based on type:<indexterm significance="normal"><primary>data types</primary><secondary>pattern matching on type</secondary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary sortas="type">on type</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-type-script.scala</code>

<code role="statement">val</code> sundries = <code role="special">List</code>(<code role="constant">23</code>, <code role="constant">"Hello"</code>, <code role="constant">8.5</code>, <code role="constant">'q'</code>)

<code role="statement">for</code> (sundry <code role="statement">&lt;-</code> sundries) {
  sundry <code role="statement">match</code> {
    <code role="statement">case</code> i:<code role="type"> Int =&gt; println</code>(<code role="constant">"got an Integer: "</code> + i)
    <code role="statement">case</code> s:<code role="type"> String =&gt; println</code>(<code role="constant">"got a String: "</code> + s)
    <code role="statement">case</code> f:<code role="type"> Double =&gt; println</code>(<code role="constant">"got a Double: "</code> + f)
    <code role="statement">case</code> other <code role="statement">=&gt;</code> println(<code role="constant">"got something else: "</code> + other)
  }
}
</programlisting><para id="para_here_we_pull_each_element_out_">Here we pull each element
      out of a <literal moreinfo="none">List</literal> of <literal moreinfo="none">Any</literal> type of
      element, in this case containing a <literal moreinfo="none">String</literal>, a
      <literal moreinfo="none">Double</literal>, an <literal moreinfo="none">Int</literal>, and a
      <literal moreinfo="none">Char</literal>. For the first three of those types, we let the
      user know specifically which type we got and what the value was. When we
      get something else (the <literal moreinfo="none">Char</literal>), we just let the user
      know the value. We could add further elements to the list of other types
      and they’d be caught by the <literal moreinfo="none">other</literal> wildcard
      case.</para></sect2><sect2 id="MatchingOnSequences"><title>Matching on Sequences</title><para id="para_since_working_in_scala_often_m">Since working in Scala
      often means working with sequences, wouldn’t it be handy to be able to
      match against the length and contents of lists and arrays? The following
      example does just that, testing two lists to see if they contain four
      elements, the second of which is the integer
      <literal moreinfo="none">3</literal>:<indexterm significance="normal"><primary>pattern matching</primary><secondary sortas="sequences">on sequences</secondary></indexterm><indexterm significance="normal"><primary>sequences</primary><secondary>matching on</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-seq-script.scala</code>

<code role="statement">val</code> willWork = <code role="special">List</code>(<code role="constant">1</code>, <code role="constant">3</code>, <code role="constant">23</code>, <code role="constant">90</code>)
<code role="statement">val</code> willNotWork = <code role="special">List</code>(<code role="constant">4</code>, <code role="constant">18</code>, <code role="constant">52</code>)
<code role="statement">val</code> empty = <code role="special">List</code>()

<code role="statement">for</code> (l <code role="statement">&lt;-</code> <code role="special">List</code>(willWork, willNotWork, empty)) {
  l <code role="statement">match</code> {
    <code role="statement">case</code> <code role="special">List</code>(<code role="statement">_</code>, <code role="constant">3</code>, <code role="statement">_</code>, <code role="statement">_</code>) <code role="statement">=&gt;</code> println(<code role="constant">"Four elements, with the 2nd being '3'."</code>)
    <code role="statement">case</code> <code role="special">List</code>(<code role="statement">_</code>*) <code role="statement">=&gt;</code> println(<code role="constant">"Any other list with 0 or more elements."</code>)
  }
}
</programlisting><para id="para_in_the_second_case_of_we_ve_">In the second
      <literal moreinfo="none">case</literal> we’ve used a special wildcard pattern to match a
      <literal moreinfo="none">List</literal> of any size, even zero elements, and any element
      values. You can use this pattern at the end of any sequence match to
      remove length as a condition.<indexterm significance="normal"><primary>: (colon)</primary><secondary>:: (constructor) method</secondary><tertiary>extracting head and tail of list</tertiary></indexterm></para><para id="para_recall_that_we_mentioned_the_">Recall that we mentioned
      the “cons” method for <literal moreinfo="none">List</literal>, <literal moreinfo="none">::</literal>.
      The expression <literal moreinfo="none">a :: list</literal> prepends
      <literal moreinfo="none">a</literal> to a list. You can also use this operator to
      extract the head and tail of a list:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-list-script.scala</code>

<code role="statement">val</code> willWork = <code role="special">List</code>(<code role="constant">1</code>, <code role="constant">3</code>, <code role="constant">23</code>, <code role="constant">90</code>)
<code role="statement">val</code> willNotWork = <code role="special">List</code>(<code role="constant">4</code>, <code role="constant">18</code>, <code role="constant">52</code>)
<code role="statement">val</code> empty = <code role="special">List</code>()

<code role="statement">def</code> <code role="identifier">processList</code>(l:<code role="type"> List[Any]</code>):<code role="type"> Unit</code> = l <code role="statement">match</code> {
  <code role="statement">case</code> head :: tail <code role="statement">=&gt;</code>
    format(<code role="constant">"%s "</code>, head)
    processList(tail)
  <code role="statement">case</code> <code role="special">Nil</code> <code role="statement">=&gt;</code> println(<code role="constant">""</code>)
}

<code role="statement">for</code> (l <code role="statement">&lt;-</code> <code role="special">List</code>(willWork, willNotWork, empty)) {
  print(<code role="constant">"List: "</code>)
  processList(l)
}
</programlisting><para id="para_the_processlist_method_match">The
      <literal moreinfo="none">processList</literal> method matches on the
      <literal moreinfo="none">List</literal> argument l. It may look strange to start the
      method definition like the following:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">processList</code>(l:<code role="type"> List[Any]</code>):<code role="type"> Unit</code> = l <code role="statement">match</code> {
  ...
}
</programlisting><para id="para_hopefully_hiding_the_details_w">Hopefully hiding the
      details with the ellipsis makes the meaning a little clearer. The
      <literal moreinfo="none">processList</literal> method is actually one statement that
      crosses several lines.</para><para id="para_it_first_matches_on_head_05">It first matches on
      <literal moreinfo="none">head :: tail</literal>, where <literal moreinfo="none">head</literal> will be
      assigned the first element in the list and <literal moreinfo="none">tail</literal> will
      be assigned the rest of the list. That is, we’re extracting the head and
      tail from the list using <literal moreinfo="none">::</literal>. When this case matches,
      it prints the <literal moreinfo="none">head</literal> and calls
      <literal moreinfo="none">processList</literal> recursively to process the tail.</para><para id="para_the_second_case_matches_the_em">The second case matches
      the empty list, <literal moreinfo="none">Nil</literal>. It prints an end of line and
      terminates the recursion.</para></sect2><sect2 id="MatchingOnTuples"><title>Matching on Tuples (and Guards)</title><para id="para_alternately_if_we_just_wanted">Alternately, if we just
      wanted to test that we have a tuple of two items, we could do a tuple
      match:<indexterm significance="normal"><primary>tuples</primary><secondary>pattern matching on</secondary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary>matching on tuples and guards</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-tuple-script.scala</code>

<code role="statement">val</code> tupA = (<code role="constant">"Good"</code>, <code role="constant">"Morning!"</code>)
<code role="statement">val</code> tupB = (<code role="constant">"Guten"</code>, <code role="constant">"Tag!"</code>)

<code role="statement">for</code> (tup <code role="statement">&lt;-</code> <code role="special">List</code>(tupA, tupB)) {
  tup <code role="statement">match</code> {
    <code role="statement">case</code> (thingOne, thingTwo) <code role="statement">if</code> thingOne == <code role="constant">"Good"</code> <code role="statement">=&gt;</code>
        println(<code role="constant">"A two-tuple starting with 'Good'."</code>)
    <code role="statement">case</code> (thingOne, thingTwo) <code role="statement">=&gt;</code>
        println(<code role="constant">"This has two things: "</code> + thingOne + <code role="constant">" and "</code> + thingTwo)
  }
}
</programlisting><para id="para_in_the_second_case_in_this_e">In the second
      <literal moreinfo="none">case</literal> in this example, we’ve extracted the values
      inside the tuple to scoped variables, then reused these variables in the
      resulting expression.</para><para id="para_in_the_first_case_we_ve_added_">In the first case we’ve
      added a new concept: <emphasis>guards</emphasis>. The
      <literal moreinfo="none">if</literal> condition after the tuple is a guard. The guard is
      evaluated when matching, but only extracting any variables in the
      preceding part of the case. Guards provide additional granularity when
      constructing cases. In this example, the only difference between the two
      patterns is the guard expression, but that’s enough for the compiler to
      differentiate them.<indexterm significance="normal"><primary>cases in pattern matching</primary></indexterm><indexterm significance="normal"><primary>guards, pattern matching on</primary></indexterm></para><tip id="para_tip_the_cases_in_a_pattern_ma"><simpara>Recall that the cases in a pattern match are evaluated in
        order. For example, if your first case is broader than your second
        case, the second case will never be reached. (Unreachable cases will
        cause a compiler error.) You may include a “default” case at the end
        of a pattern match, either using the underscore wildcard character or
        a meaningfully named variable. When using a variable, it should have
        no explicit type or it should be declared as <literal moreinfo="none">Any</literal>,
        so it can match anything. On the other hand, try to design your code
        to avoid a catch-all clause by ensuring it only receives specific
        items that are expected.</simpara></tip></sect2><sect2 id="MatchingOnCaseClasses"><title>Matching on Case Classes</title><para id="para_finally_let_s_try_a__deep_mat">Let’s try a <emphasis>deep
      match</emphasis>, examining the contents of objects in our pattern
      match:<indexterm significance="normal"><primary>objects</primary><secondary>deep matching on contents</secondary></indexterm><indexterm significance="normal"><primary>case classes</primary><secondary>pattern matching on</secondary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary sortas="case classes">on case classes</secondary></indexterm><indexterm significance="normal"><primary>deep matching</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-deep-script.scala</code>

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Person</code>(name:<code role="type"> String</code>, age:<code role="type"> Int</code>)

<code role="statement">val</code> alice = <code role="statement">new</code> <code role="special">Person</code>(<code role="constant">"Alice"</code>, <code role="constant">25</code>)
<code role="statement">val</code> bob = <code role="statement">new</code> <code role="special">Person</code>(<code role="constant">"Bob"</code>, <code role="constant">32</code>)
<code role="statement">val</code> charlie = <code role="statement">new</code> <code role="special">Person</code>(<code role="constant">"Charlie"</code>, <code role="constant">32</code>)

<code role="statement">for</code> (person <code role="statement">&lt;-</code> <code role="special">List</code>(alice, bob, charlie)) {
  person <code role="statement">match</code> {
    <code role="statement">case</code> <code role="special">Person</code>(<code role="constant">"Alice"</code>, <code role="constant">25</code>) <code role="statement">=&gt;</code> println(<code role="constant">"Hi Alice!"</code>)
    <code role="statement">case</code> <code role="special">Person</code>(<code role="constant">"Bob"</code>, <code role="constant">32</code>) <code role="statement">=&gt;</code> println(<code role="constant">"Hi Bob!"</code>)
    <code role="statement">case</code> <code role="special">Person</code>(name, age) <code role="statement">=&gt;</code>
      println(<code role="constant">"Who are you, "</code> + age + <code role="constant">" year-old person named "</code> + name + <code role="constant">"?"</code>)
  }
}
</programlisting><para id="para_poor_charlie_gets_the_cold_sho">Poor Charlie gets the
      cold shoulder, as we can see in the output:</para><screen format="linespecific">Hi Alice!
Hi Bob!
Who are you, 32 year-old person named Charlie?</screen><?dbfo-need height=”1in”
?><para id="para_we_first_define_a__case_class_">We first define a
      <emphasis>case class</emphasis>, a special type of class that we’ll
      learn more about in <xref linkend="CaseClasses"/>. For now, it will
      suffice to say that a case class allows for very terse construction of
      simple objects with some predefined methods. Our <phrase role="keep-together">pattern</phrase> match then looks for Alice and Bob
      by inspecting the values passed to the <phrase role="keep-together">constructor</phrase> of the
      <literal moreinfo="none">Person</literal> case class. Charlie falls through to the
      catch-all case; even though he has the same <literal moreinfo="none">age</literal> value
      as Bob, we’re matching on the <literal moreinfo="none">name</literal> property as
      well.<indexterm significance="normal"><primary>case classes</primary><secondary>defining for pattern matching</secondary></indexterm></para><para id="para_this_type_pattern_match_become">This type of pattern
      match becomes extremely useful when working with Actors, as we’ll see
      later on. Case classes are frequently sent to Actors as messages, and
      deep pattern matching on an object’s contents is a convenient way to
      “parse” those messages.</para></sect2><sect2 id="MatchingOnRegularExpressions"><title>Matching on Regular Expressions</title><para id="para_regular_expressions_are_conven">Regular expressions are
      convenient for extracting data from strings that have an informal
      structure, but are not “structured data” (that is, in a format like XML
      or JSON, for example). Commonly referred to as
      <emphasis>regexes</emphasis>, regular expressions are a feature of
      nearly all modern programming languages. They provide a terse syntax for
      specifying complex matches, one that is typically translated into a
      state machine behind the scenes for optimum performance.<indexterm significance="normal"><primary>pattern matching</primary><secondary sortas="regular expressions">on regular
          expressions</secondary></indexterm><indexterm significance="normal"><primary>regular expressions</primary><secondary>matching on</secondary></indexterm></para><para id="para_regexes_in_scala_should_contai">Regexes in Scala should
      contain no surprises if you’ve used them in other programming languages.
      Let’s see an example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-regex-script.scala</code>

<code role="statement">val</code> BookExtractorRE = <code role="constant">"""Book: title=([^,]+),\s+authors=(.+)"""</code>.r
<code role="statement">val</code> MagazineExtractorRE = <code role="constant">"""Magazine: title=([^,]+),\s+issue=(.+)"""</code>.r

<code role="statement">val</code> catalog = <code role="special">List</code>(
  <code role="constant">"Book: title=Programming Scala, authors=Dean Wampler, Alex Payne"</code>,
  <code role="constant">"Magazine: title=The New Yorker, issue=January 2009"</code>,
  <code role="constant">"Book: title=War and Peace, authors=Leo Tolstoy"</code>,
  <code role="constant">"Magazine: title=The Atlantic, issue=February 2009"</code>,
  <code role="constant">"BadData: text=Who put this here??"</code>
)

<code role="statement">for</code> (item <code role="statement">&lt;-</code> catalog) {
  item <code role="statement">match</code> {
    <code role="statement">case</code> <code role="special">BookExtractorRE</code>(title, authors) <code role="statement">=&gt;</code>
      println(<code role="constant">"Book </code><code role="special">\"</code><code role="constant">"</code> + title + <code role="constant">"</code><code role="special">\"</code><code role="constant">, written by "</code> + authors)
    <code role="statement">case</code> <code role="special">MagazineExtractorRE</code>(title, issue) <code role="statement">=&gt;</code>
      println(<code role="constant">"Magazine </code><code role="special">\"</code><code role="constant">"</code> + title + <code role="constant">"</code><code role="special">\"</code><code role="constant">, issue "</code> + issue)
    <code role="statement">case</code> entry <code role="statement">=&gt;</code> println(<code role="constant">"Unrecognized entry: "</code> + entry)
  }
}
</programlisting><para id="para_this_example_starts_with_two_r">We start with two regular
      expressions, one for records of books and another for records of
      magazines. Calling <literal moreinfo="none">.r</literal> on a string turns it into a
      regular expression; we use raw (triple-quoted) strings here to avoid
      having to double-escape backslashes. Should you find the
      <literal moreinfo="none">.r</literal> transformation method on strings unclear, you can
      also define regexes by creating new instances of the
      <literal moreinfo="none">Regex</literal> class, as in: <literal moreinfo="none">new
      Regex("""\W""")</literal>.<indexterm significance="normal"><primary>raw strings in regular expression pattern
          matching</primary></indexterm></para><para id="para_notice_that_each_of_our_regexe">Notice that each of our
      regexes defines two <emphasis>capture groups</emphasis>, connoted by
      parentheses. Each group captures the value of a single field in the
      record, such as a book’s title or author. Regexes in Scala translate
      those capture groups to <emphasis>extractors</emphasis>. Every match
      sets a field to the captured result; every miss is set to
      <literal moreinfo="none">null</literal>.<indexterm significance="normal"><primary>extractors</primary><secondary>translating regular expression capture groups
          to</secondary></indexterm><indexterm significance="normal"><primary>( ) (parentheses)</primary><secondary>capture groups in regular expressions</secondary></indexterm><indexterm significance="normal"><primary>capture groups, defining in regular expressions</primary></indexterm></para><para id="para_the_case_clauses_look_similar_">What does this mean in
      practice? If the text fed to the regular expression matches, <literal role="keep-together" moreinfo="none">case BookExtractorRE(title, authors)</literal> will
      assign the first capture group to <literal moreinfo="none">title</literal> and the
      second to <literal moreinfo="none">authors</literal>. We can then use those values on
      the righthand side of the <literal moreinfo="none">case</literal> clause, as we have in
      the previous example. The variable names <literal moreinfo="none">title</literal> and
      <literal moreinfo="none">author</literal> within the extractor are arbitrary; matches
      from capture groups are simply <phrase role="keep-together">assigned</phrase> from left to right, and you can
      call them whatever you’d like.</para><para id="para_that_s_regexes_in_scala_in_nut">That’s regexes in Scala
      in nutshell. The <literal moreinfo="none">scala.util.matching.Regex</literal> class
      supplies several handy methods for finding and replacing matches in
      strings, both all occurrences of a match and just the first occurrence,
      so be sure to make use of them.<indexterm significance="normal"><primary>Regex class</primary></indexterm></para><para id="para_we_won_t_cover_the_details_of_">What we won’t cover in
      this section is the details of writing regular expressions. Scala’s
      <literal moreinfo="none">Regex</literal> class uses the underlying platform’s regular
      expression APIs (that is, Java’s or .NET’s). Consult references on those
      APIs for the hairy details, as they may be subtly different from the
      regex support in your language of choice.<indexterm significance="normal"><primary sortas="NET">.NET</primary><secondary>regular expressions</secondary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>regular expressions</secondary></indexterm></para></sect2><sect2 id="BindingNestedVariablesInCaseClauses"><title>Binding Nested Variables in Case Clauses</title><para id="para_finally_lets_bind_inner_variables">Sometimes you want to
      bind a variable to an object enclosed in a match, where you are also
      specifying match criteria on the nested object. Suppose we modify a
      previous example so we’re matching on the key-value pairs from a map.
      We’ll store our same <literal moreinfo="none">Person</literal> objects as the values and
      use an employee ID as the key. We’ll also add another attribute to
      <literal moreinfo="none">Person</literal>, a <literal moreinfo="none">role</literal> field that points
      to an instance from a type hierarchy:<indexterm significance="normal"><primary>variables</primary><secondary>binding nested variables in case clauses</secondary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary>binding nested variables in case clauses</secondary></indexterm><indexterm significance="normal"><primary>case clauses, binding nested variables in</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/match-deep-pair-script.scala</code>

<code role="statement">class</code> <code role="special">Role</code>
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Manager</code> <code role="statement">extends</code> <code role="special">Role</code>
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Developer</code> <code role="statement">extends</code> <code role="special">Role</code>

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Person</code>(name:<code role="type"> String</code>, age:<code role="type"> Int</code>, role:<code role="type"> Role</code>)

<code role="statement">val</code> alice = <code role="statement">new</code> <code role="special">Person</code>(<code role="constant">"Alice"</code>, <code role="constant">25</code>, <code role="special">Developer</code>)
<code role="statement">val</code> bob = <code role="statement">new</code> <code role="special">Person</code>(<code role="constant">"Bob"</code>, <code role="constant">32</code>, <code role="special">Manager</code>)
<code role="statement">val</code> charlie = <code role="statement">new</code> <code role="special">Person</code>(<code role="constant">"Charlie"</code>, <code role="constant">32</code>, <code role="special">Developer</code>)

<code role="statement">for</code> (item <code role="statement">&lt;-</code> <code role="special">Map</code>(<code role="constant">1</code> -&gt; alice, <code role="constant">2</code> -&gt; bob, <code role="constant">3</code> -&gt; charlie)) {
  item <code role="statement">match</code> {
    <code role="statement">case</code> (id, p @ <code role="special">Person</code>(<code role="statement">_</code>, <code role="statement">_</code>, <code role="special">Manager</code>)) <code role="statement">=&gt;</code> format(<code role="constant">"%s is overpaid.</code><code role="special">\n</code><code role="constant">"</code>, p)
    <code role="statement">case</code> (id, p @ <code role="special">Person</code>(<code role="statement">_</code>, <code role="statement">_</code>, <code role="statement">_</code>)) <code role="statement">=&gt;</code> format(<code role="constant">"%s is underpaid.</code><code role="special">\n</code><code role="constant">"</code>, p)
  }
}
</programlisting><para id="para_the_case_objects_are_just_si">The <literal moreinfo="none">case
      objects</literal> are just singleton objects like we’ve seen before, but
      with the special <literal moreinfo="none">case</literal> behavior. We’re most interested
      in the embedded <literal moreinfo="none">p @ Person(...)</literal> inside the case
      clause. We’re matching on particular kinds of <literal moreinfo="none">Person</literal>
      objects inside the enclosing tuple. We also want to assign the
      <literal moreinfo="none">Person</literal> to a variable <literal moreinfo="none">p</literal>, so we can
      use it for printing:</para><screen format="linespecific">Person(Alice,25,Developer) is underpaid.
Person(Bob,32,Manager) is overpaid.
Person(Charlie,32,Developer) is underpaid.</screen><para id="para_if_we_weren_t_using_matching_c">If we weren’t using
      matching criteria in <literal moreinfo="none">Person</literal> itself, we could just
      write <literal moreinfo="none">p: Person</literal>. For example, the previous
      <literal moreinfo="none">match</literal> clause could be written this way:</para><programlisting language="scala" format="linespecific">item <code role="statement">match</code> {
  <code role="statement">case</code> (id, p:<code role="type"> Person</code>) <code role="statement">=&gt;</code> p.role <code role="statement">match</code> {
    <code role="statement">case</code> <code role="special">Manager</code> <code role="statement">=&gt;</code> format(<code role="constant">"%s is overpaid.</code><code role="special">\n</code><code role="constant">"</code>, p)
    <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> format(<code role="constant">"%s is underpaid.</code><code role="special">\n</code><code role="constant">"</code>, p)
  }
}
</programlisting><para id="para_note_that_the_p_person_">Note that the <literal moreinfo="none">p @
      Person(...)</literal> syntax gives us a way to flatten this nesting of
      match statements into one statement. It is analogous to using “capture
      groups” in a regular expression to pull out substrings we want, instead
      of splitting the string in several successive steps to extract the
      substrings we want. Use whichever technique you prefer.</para></sect2><sect2 id="TryCatchFinally"><title>Using try, catch, and finally Clauses</title><para id="para_through_its_use_of_functional_">Through its use of
      functional constructs and strong typing, Scala encourages a coding style
      that lessens the need for exceptions and exception handling. But where
      Scala interacts with Java, exceptions are still prevalent.<indexterm significance="normal"><primary>exception handling, pattern matching using try, catch, and
          finally clauses</primary></indexterm><indexterm significance="normal"><primary>try, catch, and finally clauses</primary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary>using try, catch, and finally clauses</secondary></indexterm></para><note id="para_note_scala_does_not_have_chec"><para>Scala does not have checked exceptions, like Java. Even Java’s
        checked exceptions are treated as unchecked by Scala. There is also no
        <literal moreinfo="none">throws</literal> clause on method declarations. However,
        there is a <literal moreinfo="none">@throws</literal> annotation that is useful for
        Java interoperability. See the section <xref linkend="Annotations"/>.</para></note><para id="para_thankfully_scala_treats_excep">Thankfully, Scala treats
      exception handling as just another pattern match, allowing us to make
      smart choices when presented with a multiplicity of potential
      exceptions. Let’s see this in action:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/try-catch-script.scala</code>

<code role="preproc">import</code> java.util.Calendar

<code role="statement">val</code> then = <code role="statement">null</code>
<code role="statement">val</code> now = Calendar.getInstance()

<code role="statement">try</code> {
  now.compareTo(then)
} <code role="statement">catch</code> {
  <code role="statement">case</code> e:<code role="type"> NullPointerException =&gt; println</code>(<code role="constant">"One was null!"</code>); System.exit(-<code role="constant">1</code>)
  <code role="statement">case</code> unknown <code role="statement">=&gt;</code> println(<code role="constant">"Unknown exception "</code> + unknown); System.exit(-<code role="constant">1</code>)
} <code role="statement">finally</code> {
  println(<code role="constant">"It all worked out."</code>)
  System.exit(<code role="constant">0</code>)
}
</programlisting><para id="para_in_the_above_example_we_expli">In this example, we
      explicitly catch the <literal moreinfo="none">NullPointerException</literal> thrown when
      trying to compare a <literal moreinfo="none">Calendar</literal> instance with
      <literal moreinfo="none">null</literal>. We also define <literal moreinfo="none">unknown</literal> as a
      catch-all case, just to be safe. If we weren’t hardcoding this program
      to fail, the <literal moreinfo="none">finally</literal> block would be reached and the
      user would be informed that everything worked out just fine.</para><note id="para_note_you_can_use_an_underscor"><para>You can use an underscore (Scala’s standard wildcard character)
        as a placeholder to catch any type of exception (really, to match any
        case in a pattern matching expression). However, you won’t be able to
        refer to the exception in the subsequent expression. Name the
        exception variable if you need it; for example, if you need to print
        the exception as we do in the catch-all case of the previous
        example.</para></note><para id="para_pattern_matching_aside_scala_">Pattern matching aside,
      Scala’s treatment of exception handling should be familiar to those
      fluent in Java, Ruby, Python, and most other mainstream languages. And
      yes, you throw an exception by writing <literal moreinfo="none">throw new
      MyBadException(...)</literal>. That’s all there is to it.<indexterm significance="normal"><primary>exceptions</primary><secondary>throwing</secondary></indexterm></para></sect2><sect2 id="ConcludingRemarksOnPatternMatching"><title>Concluding Remarks on Pattern Matching</title><para id="para_pattern_matching_is_a_powerful">Pattern matching is a
      powerful and elegant way of extracting information from objects, when
      used appropriately. Recall from <xref linkend="IntroducingScala"/> that
      we highlighted the synergy between pattern matching and polymorphism.
      Most of the time, you want to avoid the problems of “switch” statements
      that know a class hierarchy, because they have to be modified every time
      the hierarchy is changed.<indexterm significance="normal"><primary>polymorphism</primary><secondary>pattern matching versus</secondary></indexterm></para><para id="para_in_our_drawing_actor_example_">In our drawing Actor
      example, we used pattern matching to separate different “categories” of
      messages, but we used polymorphism to draw the shapes sent to it. We
      could change the <literal moreinfo="none">Shape</literal> hierarchy and the Actor code
      would not require changes.</para><para id="para_pattern_matching_is_also_usefu">Pattern matching is also
      useful for the design problem where you need to get at data inside an
      object, but only in special circumstances. One of the unintended
      consequences of the <emphasis>JavaBeans</emphasis> (see <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>) specification was that
      it encouraged people to expose fields in their objects through getters
      and setters. This should <emphasis>never</emphasis> be a default
      decision. Access to “state information” should be encapsulated and
      exposed only in ways that make logical sense for the type, as viewed
      from the abstraction it exposes.</para><para id="para_instead_consider_using_patter">Instead, consider using
      pattern matching for those “rare” times when you need to extract
      information in a controlled way. As we will see in <xref linkend="UnapplyMethod"/>, the pattern matching examples we have shown
      use <literal moreinfo="none">unapply</literal> methods defined to extract information
      from instances. These methods let you extract that information while
      hiding the implementation details. In fact, the information returned by
      <literal moreinfo="none">unapply</literal> might be a transformation of the actual
      information in the type.</para><para id="para_note_be_wary_of_relying_on_a_">Finally, when designing
      pattern matching statements, be wary of relying on a default case
      clause. Under what circumstances would “none of the above” be the
      correct answer? It may indicate that the design should be refined so you
      know more precisely all the possible matches that might occur. We’ll
      learn one technique that helps when we discuss
      <emphasis>sealed</emphasis> class hierarchies in <xref linkend="SealedClassHierarchies"/>.<indexterm class="endofrange" startref="ch03_patternmatching" significance="normal"/></para></sect2></sect1><sect1 id="Enumerations"><title>Enumerations</title><para id="para_remember_our_examples_above_in">Remember our examples
    involving various breeds of dog? In thinking about the types in these
    programs, we might want a top-level <literal moreinfo="none">Breed</literal> type that
    keeps track of a number of breeds. Such a type is called an
    <emphasis>enumerated type</emphasis>, and the values it contains are
    called <emphasis>enumerations</emphasis>.<indexterm significance="normal"><primary>enumerated types</primary></indexterm><indexterm significance="normal"><primary>enumerations</primary></indexterm></para><para id="para_while_enumerations_are_a_built">While enumerations are a
    built-in part of many programming languages, Scala takes a different route
    and implements them as a class in its standard library. This means there
    is no special syntax for enumerations in Scala, as in Java and C#.
    Instead, you just define an object that extends the
    <literal moreinfo="none">Enumeration</literal> class. Hence, at the byte code level, there
    is no connection between Scala enumerations and the
    <literal moreinfo="none">enum</literal> constructs in Java and C#.<indexterm significance="normal"><primary>Enumeration class</primary></indexterm></para><para id="para_enumeration_example">Here is an example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/enumeration-script.scala</code>

<code role="statement">object</code> <code role="special">Breed</code> <code role="statement">extends</code> <code role="special">Enumeration</code> {
  <code role="statement">val</code> doberman = <code role="special">Value</code>(<code role="constant">"Doberman Pinscher"</code>)
  <code role="statement">val</code> yorkie = <code role="special">Value</code>(<code role="constant">"Yorkshire Terrier"</code>)
  <code role="statement">val</code> scottie = <code role="special">Value</code>(<code role="constant">"Scottish Terrier"</code>)
  <code role="statement">val</code> dane = <code role="special">Value</code>(<code role="constant">"Great Dane"</code>)
  <code role="statement">val</code> portie = <code role="special">Value</code>(<code role="constant">"Portuguese Water Dog"</code>)
}

<code role="comment">// print a list of breeds and their IDs</code>
println(<code role="constant">"ID\tBreed"</code>)
<code role="statement">for</code> (breed <code role="statement">&lt;-</code> <code role="special">Breed</code>) println(breed.id + <code role="constant">"\t"</code> + breed)

<code role="comment">// print a list of Terrier breeds</code>
println(<code role="constant">"</code><code role="special">\n</code><code role="constant">Just Terriers:"</code>)
Breed.filter(<code role="statement">_</code>.toString.endsWith(<code role="constant">"Terrier"</code>)).foreach(println)
</programlisting><para id="para_when_run_you_ll_get_the_follo">When run, you’ll get the
    following output:</para><screen format="linespecific">ID      Breed
0       Doberman Pinscher
1       Yorkshire Terrier
2       Scottish Terrier
3       Great Dane
4       Portuguese Water Dog

Just Terriers:
Yorkshire Terrier
Scottish Terrier</screen><para id="para_we_can_see_in_the_source_that_">We can see that our
    <literal moreinfo="none">Breed</literal> enumerated type contains several variables of
    type <literal moreinfo="none">Value</literal>, as in the following example:</para><screen format="linespecific">val doberman = Value("Doberman Pinscher")</screen><para id="para_value_method_with_name_arg_for_enumerations">Each
    declaration is actually calling a method named <literal moreinfo="none">Value</literal>
    that takes a string argument. We use this method to assign a long-form
    breed name to each enumeration value, which is what the
    <literal moreinfo="none">Value.toString</literal> method returned in the output.<indexterm significance="normal"><primary>Value.toString method</primary></indexterm></para><para id="para_value_methods_for_enumerations">Note that there is no
    namespace collision between the type and method that both have the name
    <literal moreinfo="none">Value</literal>. There are other overloaded versions of the
    <literal moreinfo="none">Value</literal> method. One of them takes no arguments, another
    takes an <literal moreinfo="none">Int</literal> ID value, and another takes both an
    <literal moreinfo="none">Int</literal> and <literal moreinfo="none">String</literal>. These
    <literal moreinfo="none">Value</literal> methods return a <literal moreinfo="none">Value</literal> object,
    and they add the value to the enumeration’s collection of values.</para><para id="para_since_scala_s_enumeration_cl">In fact, Scala’s
    <literal moreinfo="none">Enumeration</literal> class supports the usual methods for
    working with collections, so we can easily iterate through the breeds with
    a <literal moreinfo="none">for</literal> loop and <literal moreinfo="none">filter</literal> them by name.
    The output above also demonstrated that every <literal moreinfo="none">Value</literal> in
    an enumeration is automatically assigned a numeric identifier, unless you
    call one of the <literal moreinfo="none">Value</literal> methods where you specify your
    own ID value explicitly.</para><para id="para_enumeration_no_name_values">You’ll often want to give your
    enumeration values human-readable names, as we did here. However,
    sometimes you may not need them. Here’s another enumeration example
    adapted from the Scaladoc entry for <literal moreinfo="none">Enumeration</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Rounding/days-enumeration-script.scala</code>

<code role="statement">object</code> <code role="special">WeekDay</code> <code role="statement">extends</code> <code role="special">Enumeration</code> {
  <code role="statement">type</code> <code role="special">WeekDay</code> = <code role="special">Value</code>
  <code role="statement">val</code> Mon, <code role="special">Tue</code>, <code role="special">Wed</code>, <code role="special">Thu</code>, <code role="special">Fri</code>, <code role="special">Sat</code>, <code role="special">Sun</code> = <code role="special">Value</code>
}
<code role="preproc">import</code> WeekDay._

<code role="statement">def</code> <code role="identifier">isWorkingDay</code>(d:<code role="type"> WeekDay</code>) = ! (d == <code role="special">Sat</code> || d == <code role="special">Sun</code>)

<code role="special">WeekDay</code> filter isWorkingDay foreach println
</programlisting><para id="para_days_enumeration_scala_output">Running this script with
    <literal moreinfo="none">scala</literal> yields the following output:</para><screen format="linespecific">Main$$anon$1$WeekDay(0)
Main$$anon$1$WeekDay(1)
Main$$anon$1$WeekDay(2)
Main$$anon$1$WeekDay(3)
Main$$anon$1$WeekDay(4)</screen><para id="para_enumeration_no_name_tostring">When a name isn’t assigned
    using one of the <literal moreinfo="none">Value</literal> methods that takes a
    <literal moreinfo="none">String</literal> argument, <literal moreinfo="none">Value.toString</literal>
    prints the name of the type that is synthesized by the compiler, along
    with the ID value that was generated automatically.</para><para id="para_note_that_we_imported_weekday">Note that we imported
    <literal moreinfo="none">WeekDay._</literal>. This made each enumeration value
    (<literal moreinfo="none">Mon</literal>, <literal moreinfo="none">Tues</literal>, etc.) in scope.
    Otherwise, you would have to write <literal moreinfo="none">WeekDay.Mon</literal>,
    <literal moreinfo="none">WeekDay.Tues</literal>, etc.</para><para id="para_also_the_import_made_the__typ">Also, the import made the
    <emphasis>type alias</emphasis>, <literal moreinfo="none">type Weekday = Value</literal>,
    in scope, which we used as the type for the argument for the
    <literal moreinfo="none">isWorkingDay</literal> method. If you don’t define a type alias
    like this, then you would declare the method as <literal moreinfo="none">def
    isWorkingDay(d: WeekDay.Value)</literal>.<indexterm significance="normal"><primary>type alias</primary></indexterm></para><para id="para_enumerations_vs_objects_with_vals">Since Scala enumerations
    are just regular objects, you could use any object with
    <literal moreinfo="none">vals</literal> to indicate different “enumeration values.”
    However, extending <literal moreinfo="none">Enumeration</literal> has several advantages.
    It automatically manages the values as a collection that you can iterate
    over, etc., as in our examples. It also automatically assigns unique
    integer IDs to each value.</para><para id="para_we_ll_revisit_enumerations_in_">Case classes (see <xref linkend="CaseClasses"/>) are often used instead of enumerations in Scala
    because the “use case” for them often involves pattern matching. We’ll
    revisit this topic in <xref linkend="EnumerationsVsPatternMatching"/>.</para></sect1><sect1 id="_recap_and_what_8217_s_next_3"><title>Recap and What’s Next</title><para id="para_we_ve_covered_a_lot_of_ground_">We’ve covered a lot of
    ground in this chapter. We learned how flexible Scala’s syntax can be, and
    how it facilitates the creation of Domain-Specific Languages. Then we
    explored Scala’s enhancements to looping constructs and conditional
    expressions. We experimented with different uses for pattern matching, a
    powerful improvement on the familiar <literal moreinfo="none">case-switch</literal>
    statement. Finally, we learned how to encapsulate values in <phrase role="keep-together">enumerations</phrase>.</para><para>You should now be prepared to read a fair bit of Scala code, but
    there’s plenty more about the language to put in your tool belt. In the
    next four chapters, we’ll explore Scala’s approach to object-oriented
    programming, starting with <emphasis>traits</emphasis>.</para></sect1></chapter><chapter id="Traits"><title>Traits</title><sect1 id="IntroducingTraits"><title>Introducing Traits</title><para id="para_before_we_dive_into_object_ori">Before we dive into
    object-oriented programming, there’s one more essential feature of Scala
    that you should get acquainted with: <emphasis>traits</emphasis>.
    Understanding the value of this feature requires a little
    backstory.<indexterm class="startofrange" id="ch04_traits" significance="normal"><primary>traits</primary></indexterm></para><para id="para_a_java_class_can__implement__a">In Java, a class can
    implement an arbitrary number of <emphasis>interfaces</emphasis>. This
    model is very useful for declaring that a class exposes multiple
    abstractions. Unfortunately, it has one major drawback.</para><para id="para_for_many_interfaces_much_of_t">For many interfaces, much of
    the functionality can be implemented with boilerplate code that will be
    valid for all classes that use the interface. Java provides no built-in
    mechanism for defining and using such reusable code. Instead, Java
    programmers must use ad hoc conventions to reuse implementation code for a
    given interface. In the worst case, the developer just copies and pastes
    the same code into every class that needs it.</para><para id="para_often_the_implementation_of_a">Often, the implementation of
    an interface has members that are unrelated (“orthogonal”) to the rest of
    the instance’s members. The term <emphasis>mixin</emphasis> is often used
    for such focused and potentially reusable parts of an instance that could
    be independently maintained.<indexterm significance="normal"><primary>mixins</primary></indexterm></para><para id="para_look_at_gui_text_field_class">Have a look at the following
    code for a button in a graphical user interface, which uses callbacks for
    “clicks”:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button-callbacks.scala</code>

<code role="preproc">package</code> ui

<code role="statement">class</code> <code role="special">ButtonWithCallbacks</code>(<code role="statement">val</code> label:<code role="type"> String</code>,
    <code role="statement">val</code> clickedCallbacks:<code role="type"> List[() =&gt; Unit]</code>) <code role="statement">extends</code> <code role="special">Widget</code> {

  require(clickedCallbacks != <code role="statement">null</code>, <code role="constant">"Callback list can't be null!"</code>)

  <code role="statement">def</code> <code role="identifier">this</code>(label:<code role="type"> String</code>, clickedCallback: () <code role="statement">=&gt;</code> <code role="special">Unit</code>) =
    <code role="statement">this</code>(label, <code role="special">List</code>(clickedCallback))

  <code role="statement">def</code> <code role="identifier">this</code>(label:<code role="type"> String</code>) = {
    <code role="statement">this</code>(label, <code role="special">Nil</code>)
    println(<code role="constant">"Warning: button has no click callbacks!"</code>)
  }

  <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="comment">// ... logic to give the appearance of clicking a physical button ...</code>
    clickedCallbacks.foreach(f <code role="statement">=&gt;</code> f())
  }
}
</programlisting><para id="para_there_s_a_lot_going_on_here_n">There’s a lot going on here.
    The primary constructor takes a <literal moreinfo="none">label</literal> argument and a
    list of <literal moreinfo="none">callbacks</literal> that are invoked when the button’s
    <literal moreinfo="none">click</literal> method is invoked. We’ll explore this class in
    greater detail in <xref linkend="BasicObjectOrientedProgramming"/>. For
    now, we want to focus on one particular problem. Not only does
    <literal moreinfo="none">ButtonWithCallbacks</literal> handle behaviors essential to
    buttons (like clicking), it also handles notification of click events by
    invoking the callback functions. This goes against the <emphasis>Single
    Responsibility Principle</emphasis> (see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>), a means to the design goal
    of <emphasis>separation of concerns</emphasis>. We would like to separate
    the button-specific logic from the callback logic, such that each logical
    component becomes simpler, more modular, and more reusable. The callback
    logic is a good example of a <emphasis>mixin</emphasis>.<indexterm significance="normal"><primary>Single Responsibility Principle</primary></indexterm></para><para id="para_this_separation_is_difficult_t">This separation is
    difficult to do in Java, even if we define an interface for the callback
    behavior. We still have to embed the implementation code in the class
    somehow, <phrase role="keep-together">compromising</phrase> modularity.
    The only other alternative is to use a specialized tool like
    <emphasis>aspect-oriented programming</emphasis> (AOP; see <link linkend="AOSD" xrefstyle="select:nopage">[AOSD]</link>), as implemented by
    AspectJ (see <link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link>), an extension of Java. AOP is
    primarily designed to separate the implementations of “<phrase role="keep-together">pervasive</phrase>” concerns that are repeated
    throughout an application. It seeks to modularize these concerns, yet
    enable the fine-grained “mixing” of their behaviors with other concerns,
    including the core domain logic of the application, either at build or
    runtime.<indexterm significance="normal"><primary>Java</primary><secondary>aspect-oriented programming, AspectJ</secondary></indexterm><indexterm significance="normal"><primary>aspect-oriented programming (AOP)</primary></indexterm></para><sect2 id="TraitsAsMixins"><title>Traits As Mixins</title><para id="para_scala_provides_a_complete__mix">Scala provides a complete
      mixin solution, called <emphasis>traits</emphasis>. In our example, we
      can define the callback <emphasis>abstraction</emphasis> in a trait, as
      in a Java interface, but we can also implement the abstraction in the
      trait (or a derived trait). We can declare classes that “mix in” the
      trait, much the way you can declare classes that implement an interface
      in Java. However, in Scala we can even mix in traits at the same time we
      create instances. That is, we don’t have to declare a class first that
      mixes in all the traits we want. So, Scala traits preserve separation of
      concerns while giving us the ability to compose behavior on
      demand.<indexterm class="startofrange" id="ch04_traitsmixins" significance="normal"><primary>traits</primary><secondary sortas="mixins">as mixins</secondary></indexterm><indexterm class="startofrange" id="ch04_mixinstraits" significance="normal"><primary>mixins</primary><secondary>traits as</secondary></indexterm></para><para id="para_if_you_come_from_a_java_background">If you come from a
      Java background, you can think of traits as interfaces with optional
      implementations. Or, if you prefer, you can think of traits as a
      “constrained” form of multiple inheritance. Other languages provide
      constructs that are similar to traits, such as
      <emphasis>modules</emphasis> in Ruby, for example.</para><para id="para_let_s_use_a_trait_to_separate_">Let’s use a trait to
      separate the callback handling from the button logic. We’ll generalize
      our approach a little bit. Callbacks are really a special case of the
      <emphasis>Observer Pattern</emphasis> (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>). So, let’s create a trait
      that implements this pattern, and then use it to <phrase role="keep-together">handle</phrase> callback behavior. To simplify
      things, we’ll start with a single callback that counts the number of
      button clicks.<indexterm significance="normal"><primary>Observer Pattern</primary></indexterm></para><para id="para_first_let_s_simplify_our_butt">First, let’s define a
      simple <literal moreinfo="none">Button</literal> class:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button.scala</code>

<code role="preproc">package</code> ui

<code role="statement">class</code> <code role="special">Button</code>(<code role="statement">val</code> label:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Widget</code> {
  <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="comment">// Logic to give the appearance of clicking a button...</code>
  }
}
</programlisting><para id="para_simplified_widget">Here is the parent class,
      <literal moreinfo="none">Widget</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/widget.scala</code>

<code role="preproc">package</code> ui

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Widget</code>
</programlisting><para id="para_the_logic_for_managing_callbac">The logic for managing
      callbacks (i.e., the <literal moreinfo="none">clickedCallbacks</literal> list) is
      omitted, as are the two auxiliary constructors. Only the button’s
      <literal moreinfo="none">label</literal> field and <literal moreinfo="none">click</literal> method
      remain. The <literal moreinfo="none">click</literal> method now only cares about the
      visual appearance of a “physical” button being clicked.
      <literal moreinfo="none">Button</literal> has only one concern, handling the “essence”
      of being a button.</para><para id="para_here_is_a__trait__that_impleme">Here is a trait that
      implements the logic of the <emphasis>Observer
      Pattern</emphasis>:<indexterm significance="normal"><primary>Observer Pattern</primary><secondary>trait implementing</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/observer/observer.scala</code>

<code role="preproc">package</code> observer

<code role="statement">trait</code> <code role="special">Subject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = { <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> Any</code>) }

  <code role="statement">private</code> <code role="statement">var</code> observers = <code role="special">List</code><code role="special">[Observer]</code>()
  <code role="statement">def</code> <code role="identifier">addObserver</code>(observer:<code role="type">Observer</code>) = observers ::= observer
  <code role="statement">def</code> <code role="identifier">notifyObservers</code> = observers foreach (<code role="statement">_</code>.receiveUpdate(<code role="statement">this</code>))
}
</programlisting><para id="para_except_for_the_trait_keyword">Except for the
      <literal moreinfo="none">trait</literal> keyword, <literal moreinfo="none">Subject</literal> looks like
      a normal class. <literal moreinfo="none">Subject</literal> defines all the members it
      declares. Traits can declare <emphasis>abstract</emphasis> members,
      <emphasis>concrete</emphasis> members, or both, just as classes can (see
      <xref linkend="OverridingMembers"/> for more details). Also like
      classes, traits can contain nested trait and class definitions, and
      classes can contain nested trait definitions.<indexterm significance="normal"><primary>trait keyword</primary></indexterm></para><para id="para_the_first_line_defines_a_type">The first line defines a
      <literal moreinfo="none">type</literal> for an <literal moreinfo="none">Observer</literal>. This is a
      <emphasis>structural type</emphasis> of the form <literal role="keep-together" moreinfo="none">{ def receiveUpdate(subject:Any) }</literal>.
      Structural types specify only the structure a type must support; you
      could think of them as “anonymous” types.<indexterm significance="normal"><primary>data types</primary><secondary>structural types</secondary></indexterm><indexterm significance="normal"><primary>structural types</primary></indexterm></para><para id="para_in_this_case_the_structural_t">In this case, the
      structural type is defined by a method with a particular signature. Any
      type that has a method with this signature can be used as an observer.
      We’ll learn more about structural types in <xref linkend="ScalasTypeSystem"/>. If you’re wondering why we didn’t use
      <literal moreinfo="none">Subject</literal> as the type of the argument, instead of
      <literal moreinfo="none">Any</literal>, we’ll revisit that issue in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>.</para><para id="para_the_main_thing_to_notice_for_n">The main thing to notice
      for now is how this structural type minimizes the coupling between the
      <literal moreinfo="none">Subject</literal> trait and any potential users of the
      trait.</para><note id="para_note_subject_is_still_coupl"><para><literal moreinfo="none">Subject</literal> is still coupled by the name of the
        method in <literal moreinfo="none">Observer</literal> through the structural type,
        i.e., to a method named <literal moreinfo="none">receiveUpdate</literal>. There are
        several ways we can reduce this remaining coupling. We’ll see how in
        <xref linkend="OverridingAbstractTypes"/>.</para></note><para id="para_next_we_declare_a_list_of_obs">Next, we declare a list of
      observers. We make it a <literal moreinfo="none">var</literal>, rather than a
      <literal moreinfo="none">val</literal>, because <literal moreinfo="none">List</literal> is immutable, so
      we must create a new list when an observer is added using the <literal role="keep-together" moreinfo="none">addObserver</literal> method.</para><para id="para_we_ll_discuss_scala_list_s_m">We’ll discuss Scala
      <literal moreinfo="none">List</literal>s more in <xref linkend="ScalaTypeHierarchy"/>
      and also in <xref linkend="FunctionalProgramming"/>. For now, notice
      that <literal moreinfo="none">addObserver</literal> uses the list cons “operator” method
      <phrase role="keep-together">(<literal moreinfo="none">::</literal>)</phrase> to
      <emphasis>prepend</emphasis> an <literal moreinfo="none">observer</literal> to the list
      of <literal moreinfo="none">observers</literal>. The <literal moreinfo="none">scala</literal> compiler
      is smart enough to turn the following statement:</para><programlisting language="scala" format="linespecific">observers ::= observer
</programlisting><para id="para_into_this_statement_">into this statement:</para><programlisting language="scala" format="linespecific">observers = observer :: observers
</programlisting><para id="para_note_that_we_wrote_observer_">Note that we wrote
      <literal moreinfo="none">observer :: observers</literal>, with the existing
      <literal moreinfo="none">observers</literal> list on the <emphasis>right</emphasis>hand
      side. Recall that any method that ends with <literal moreinfo="none">:</literal> binds
      to the <emphasis>right</emphasis>. So, the previous statement is
      equivalent to the following statement:</para><programlisting language="scala" format="linespecific">observers = observers.::(observer)
</programlisting><para id="para_the_notifyobservers_method_i">The
      <literal moreinfo="none">notifyObservers</literal> method iterates through the
      <literal moreinfo="none">observers</literal>, using the <literal moreinfo="none">foreach</literal>
      method and calls <literal moreinfo="none">receiveUpdate</literal> on each one. (Note
      that we are using the “infix” operator notation instead of
      <literal moreinfo="none">observers.foreach</literal>.) We use the placeholder
      <literal moreinfo="none">_</literal> to shorten the following expression:</para><programlisting language="scala" format="linespecific">(obs) <code role="statement">=&gt;</code> obs.receiveUpdate(<code role="statement">this</code>)
</programlisting><para id="para_into_this_expression_">into this expression:</para><programlisting language="scala" format="linespecific"><code role="statement">_</code>.receiveUpdate(<code role="statement">this</code>)
</programlisting><para id="para_this_expression_is_actually_th">This expression is
      actually the body of an “anonymous function,” called a
      <emphasis>function literal</emphasis> in Scala. This is similar to a
      <emphasis>lambda</emphasis> and like constructs used in many other
      languages. Function literals and the related concept of a
      <emphasis>closure</emphasis> are discussed in <xref linkend="FunctionLiteralsAndClosures"/>.<indexterm significance="normal"><primary>function literals</primary></indexterm></para><para id="para_in_java_the_foreach_method_">In Java, the
      <literal moreinfo="none">foreach</literal> method would probably take an interface, and
      you would pass an instance of a class that implements the interface
      (e.g., the way <literal moreinfo="none">Comparable</literal> is typically used).</para><para id="para_in_scala_the_list_a_foreach">In Scala, the
      <literal moreinfo="none">List[A].foreach</literal> method expects an argument of type
      <literal moreinfo="none">(A) =&gt; Unit</literal>, which is a function taking an
      instance of type <literal moreinfo="none">A</literal>—where <literal moreinfo="none">A</literal>
      represents the type of the elements of the list
      (<literal moreinfo="none">Observer</literal>, in this case)—and returning
      <literal moreinfo="none">Unit</literal> (like <literal moreinfo="none">void</literal> in
      Java).<indexterm significance="normal"><primary>foreach method</primary></indexterm></para><note id="para_note_we_chose_to_use_a_var_"><para>We chose to use a <literal moreinfo="none">var</literal> with immutable
        <literal moreinfo="none">Lists</literal> for the observers in this example. We could
        have used a <literal moreinfo="none">val</literal> with a mutable type, like <literal role="keep-together" moreinfo="none">ListBuffer</literal>. That choice would make a
        little more sense for a real <phrase role="keep-together">application</phrase>, but we wanted to avoid the
        distraction of explaining new <phrase role="keep-together">library</phrase> classes.</para></note><para id="para_once_again_we_learned_a_lot_o">Once again, we learned a
      lot of Scala from a small example. Now let’s put our <literal role="keep-together" moreinfo="none">Subject</literal> trait to use. Here is
      <literal moreinfo="none">ObservableButton</literal>, which subclasses
      <literal moreinfo="none">Button</literal> and mixes in <literal role="keep-together" moreinfo="none">Subject</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/observable-button.scala</code>

<code role="preproc">package</code> ui
<code role="preproc">import</code> observer._

<code role="statement">class</code> <code role="special">ObservableButton</code>(name:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Button</code>(name) <code role="statement">with</code> <code role="special">Subject</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="statement">super</code>.click()
    notifyObservers
  }
}
</programlisting><para id="para_we_start_by_importing_everythi">We start by importing
      everything in the <literal moreinfo="none">observer</literal> package, using the
      <literal moreinfo="none">_</literal> wildcard. <phrase role="keep-together">Actually</phrase>, we have only defined the
      <literal moreinfo="none">Subject</literal> trait in the package.</para><para id="para_the_new_class_uses_the_with_">The new class uses the
      <literal moreinfo="none">with</literal> keyword to add the <literal moreinfo="none">Subject</literal>
      trait to the class. <literal moreinfo="none">ObservableButton</literal> overrides the
      <literal moreinfo="none">click</literal> method. Using the <literal moreinfo="none">super</literal>
      keyword (see <xref linkend="OverridingMethods"/>), it first invokes the
      “superclass” method, <literal role="keep-together" moreinfo="none">Button.click</literal>, and then it notifies the
      observers. Since the new <literal moreinfo="none">click</literal> method overrides
      <literal moreinfo="none">Button</literal>’s concrete implementation, the
      <literal moreinfo="none">override</literal> keyword is required.<indexterm significance="normal"><primary>with keyword</primary></indexterm><indexterm significance="normal"><primary>override keyword</primary></indexterm></para><para id="para_the_with_keyword_is_analogou">The <literal moreinfo="none">with</literal>
      keyword is analogous to Java’s <literal moreinfo="none">implements</literal> keyword for
      interfaces. You can specify as many traits as you want, each with its
      own <literal moreinfo="none">with</literal> keyword.</para><para id="para_a_class_can_extend_a_trait_and">A class can extend a
      trait, and a trait can extend a class. In fact, our
      <literal moreinfo="none">Widget</literal> class earlier could have been declared to be a
      trait.<indexterm significance="normal"><primary>extends keyword</primary></indexterm></para><note id="para_note_if_you_declare_a_class_t"><para>If you declare a class that uses one or more traits and it
        <emphasis>doesn’t</emphasis> extend another class, you must use the
        <literal moreinfo="none">extends</literal> keyword for the first trait listed.</para></note><para id="para_if_you_don_t_use_extends_for">If you don’t use
      <literal moreinfo="none">extends</literal> for the first trait, e.g., you write the
      following:</para><programlisting language="scala" format="linespecific"><code role="comment">// ERROR:</code>
<code role="statement">class</code> <code role="special">ObservableButton</code>(name:<code role="type"> String</code>) <code role="statement">with</code> <code role="special">Button</code>(name) <code role="statement">with</code> <code role="special">Subject</code> {...}
</programlisting><para id="para_you_ll_get_an_error_like_this_">You’ll get an error like
      this:</para><screen format="linespecific">... error: ';' expected but 'with' found.
       class ObservableButton(name: String) with Button(name) with Subject {...}
                                            ^</screen><para id="para_the_error_should_really_say_">The error should really
      say, “<literal moreinfo="none">with</literal> found, but <literal moreinfo="none">extends</literal>
      expected.”</para><para id="para_to_demonstrate_this_code_let_">To demonstrate this code,
      let’s start with a class for observing button clicks that simply counts
      the number of clicks:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button-count-observer.scala</code>

<code role="preproc">package</code> ui
<code role="preproc">import</code> observer._

<code role="statement">class</code> <code role="special">ButtonCountObserver</code> {
  <code role="statement">var</code> count = <code role="constant">0</code>
  <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> Any</code>) = count += <code role="constant">1</code>
}
</programlisting><para id="para_finally_let_s_write_a_test_th">Finally, let’s write a
      test that exercises all these classes. We will use the Specs library
      (discussed in <xref linkend="ScalaSpecs"/>) to write a
      <emphasis>Behavior-Driven Development</emphasis> (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>) “specification” that exercises
      the combined <literal moreinfo="none">Button</literal> and <literal moreinfo="none">Subject</literal>
      types:<indexterm significance="normal"><primary>BDD (Behavior-Driven Development)</primary><secondary>specification exercising combined Button and Subject
          types</secondary></indexterm><indexterm significance="normal"><primary>Specs library</primary><secondary>using for BDD specification exercising combined Button
          and Subject types</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button-observer-spec.scala</code>

<code role="preproc">package</code> ui
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._

<code role="statement">object</code> <code role="special">ButtonObserverSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"A Button Observer"</code> should {
    <code role="constant">"observe button clicks"</code> in {
      <code role="statement">val</code> observableButton = <code role="statement">new</code> <code role="special">ObservableButton</code>(<code role="constant">"Okay"</code>)
      <code role="statement">val</code> buttonObserver = <code role="statement">new</code> <code role="special">ButtonCountObserver</code>
      observableButton.addObserver(buttonObserver)

      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      buttonObserver.count mustEqual <code role="constant">3</code>
    }
  }
}
</programlisting><para id="para_if_you_downloaded_the_code_exa">If you downloaded the
      <ulink role="orm:hideurl" url="http://oreilly.com/catalog/9780596155957/">code examples from the
      O’Reilly site</ulink>, you can follow the directions in its
      <filename moreinfo="none">README</filename> files for building and running the examples
      in this chapter. The output of the <literal moreinfo="none">specs</literal> “target” of
      the build should include the following text:</para><screen format="linespecific">Specification "ButtonCountObserverSpec"
  A Button Observer should
  + observe button clicks

Total for specification "ButtonCountObserverSpec":
Finished in 0 second, 10 ms
1 example, 1 expectation, 0 failure, 0 error</screen><para id="para_notice_that_the_strings_a_bu">Notice that the strings
      <literal moreinfo="none">A Button Observer should</literal> and <literal moreinfo="none">observe button
      clicks</literal> correspond to strings in the example. The output of a
      <emphasis>Specs</emphasis> run provides a nice summary of the
      requirements for the items being tested, assuming good choices were made
      for the strings.</para><para id="para_the_body_of_the_test_creates_a">The body of the test
      creates an “Okay” <literal moreinfo="none">ObservableButton</literal> and a
      <literal moreinfo="none">ButtonCountObserver</literal>, which gives the observer to the
      button. The button is clicked three times, using the
      <literal moreinfo="none">for</literal> loop. The last line requires the observer’s
      <literal moreinfo="none">count</literal> to equal 3. If you are accustomed to using an
      <emphasis>XUnit</emphasis>-style TDD tool, like <literal moreinfo="none">JUnit</literal>
      (see <link linkend="JUnit" xrefstyle="select:nopage">[JUnit]</link>) or
      <literal moreinfo="none">ScalaTest</literal> (see <link linkend="ScalaTestTool" xrefstyle="select:nopage">[ScalaTestTool]</link> and <xref linkend="ScalaTest"/>), then the last line is equivalent to the
      following <literal moreinfo="none">JUnit</literal> assertion:<indexterm significance="normal"><primary>JUnit</primary></indexterm><indexterm significance="normal"><primary>TDD (Test-Driven Development)</primary></indexterm></para><programlisting language="scala" format="linespecific">assertEquals(<code role="constant">3</code>, buttonObserver.count)
</programlisting><note id="para_note_the__specs__library_see"><para>The Specs library (see <xref linkend="ScalaSpecs"/>) and the
        ScalaTest library (see <xref linkend="ScalaTest"/>) both support
        <emphasis>Behavior-Driven Development</emphasis> (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>), a style of
        <emphasis>Test-Driven Development</emphasis> (<link linkend="TDD" xrefstyle="select:nopage">[TDD]</link>) that emphasizes the
        “specification” role of tests.</para></note><para id="para_suppose_we_only_need_one_obse">Suppose we need only one
      <literal moreinfo="none">ObservableButton</literal> instance? We actually don’t have to
      declare a class that subclasses <literal moreinfo="none">Button</literal> with
      <literal moreinfo="none">Subject</literal>. We can incorporate the trait when we create
      the instance.</para><para id="para_the_next_example_shows_a_revis">The next example shows a
      revised Specs file that instantiates a <literal moreinfo="none">Button</literal> with
      <literal moreinfo="none">Subject</literal> mixed in as part of the declaration:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button-observer-anon-spec.scala</code>

<code role="preproc">package</code> ui
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._

<code role="statement">object</code> <code role="special">ButtonObserverAnonSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"A Button Observer"</code> should {
    <code role="constant">"observe button clicks"</code> in {
      <code role="statement">val</code> observableButton = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"Okay"</code>) <code role="statement">with</code> <code role="special">Subject</code> {
        <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
          <code role="statement">super</code>.click()
          notifyObservers
        }
      }

      <code role="statement">val</code> buttonObserver = <code role="statement">new</code> <code role="special">ButtonCountObserver</code>
      observableButton.addObserver(buttonObserver)

      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      buttonObserver.count mustEqual <code role="constant">3</code>
    }
  }
}
</programlisting><para id="para_the_revised_declaration_of_ob">The revised declaration of
      <literal moreinfo="none">observableButton</literal> actually creates an anonymous class
      in which we override the <literal moreinfo="none">click</literal> method, as before. The
      main difference with creating anonymous classes in Java is that we can
      incorporate traits in this process. Java does not let you implement a
      new interface while instantiating a class.<indexterm significance="normal"><primary>anonymous classes</primary><secondary>creating</secondary></indexterm><indexterm class="endofrange" startref="ch04_traitsmixins" significance="normal"/><indexterm class="endofrange" startref="ch04_mixinstraits" significance="normal"/></para><para id="para_finally_note_that_the_inherit">Finally, note that the
      inheritance hierarchy for an instance can be complex if it mixes in
      traits that extend other traits, etc. We’ll discuss the details of the
      hierarchy in <xref linkend="Linearization"/>.</para></sect2></sect1><sect1 id="StackableTraits"><title>Stackable Traits</title><para id="para_there_are_a_couple_of_refineme">There are a couple of
    refinements we can do to improve the reusability of our work and to make
    it easier to use more than one trait at a time, i.e., to “stack”
    them.<indexterm significance="normal"><primary>traits</primary><secondary>stacking</secondary></indexterm></para><para id="para_first_let_s_introduce_a_new_t">First, let’s introduce a new
    trait, <literal moreinfo="none">Clickable</literal>, an abstraction for any widget that
    responds to clicks:<indexterm significance="normal"><primary>Clickable trait (example)</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui2/clickable.scala</code>

<code role="preproc">package</code> ui2

<code role="statement">trait</code> <code role="special">Clickable</code> {
  <code role="statement">def</code> <code role="identifier">click</code>()
}
</programlisting><note id="para_note_we_re_starting_with_a_ne"><para>We’re starting with a new package, <literal moreinfo="none">ui2</literal>, to make
      it easier to keep older and newer versions of the examples distinct in
      the downloadable code.</para></note><para id="para_the_clickable_trait_looks_ju">The
    <literal moreinfo="none">Clickable</literal> trait looks just like a Java interface; it is
    completely abstract. It defines a single, abstract method,
    <literal moreinfo="none">click</literal>. The method is abstract because it has no body.
    If <literal moreinfo="none">Clickable</literal> were a class, we would have to add the
    <literal moreinfo="none">abstract</literal> keyword in front of the
    <literal moreinfo="none">class</literal> keyword. This is not necessary for traits.</para><para id="para_here_is_the_refactored_button_">Here is the refactored
    button, which uses the trait:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui2/button.scala</code>

<code role="preproc">package</code> ui2

<code role="preproc">import</code> ui.Widget

<code role="statement">class</code> <code role="special">Button</code>(<code role="statement">val</code> label:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Widget</code> <code role="statement">with</code> <code role="special">Clickable</code> {
  <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="comment">// Logic to give the appearance of clicking a button...</code>
  }
}
</programlisting><para id="para_this_code_is_like_java_code_th">This code is like Java code
    that implements a <literal moreinfo="none">Clickable</literal> interface.</para><para id="para_previously_when_we_defined_o">When we previously defined
    <literal moreinfo="none">ObservableButton</literal> (in <xref linkend="TraitsAsMixins"/>), we overrode <literal moreinfo="none">Button.click</literal>
    to notify the observers. We had to duplicate that logic in <literal role="keep-together" moreinfo="none">ButtonObserverAnonSpec</literal> when we declared
    <literal moreinfo="none">observableButton</literal> as a <literal moreinfo="none">Button</literal>
    instance that mixed in the <literal moreinfo="none">Subject</literal> trait directly.
    Let’s eliminate this duplication.</para><para id="para_we_don_t_really_care_about_obs">When we refactor the code
    this way, we realize that we don’t really care about observing buttons; we
    care about observing clicks. Here is a trait that focuses solely on
    observing <literal moreinfo="none">Clickable</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui2/observable-clicks.scala</code>

<code role="preproc">package</code> ui2
<code role="preproc">import</code> observer._

<code role="statement">trait</code> <code role="special">ObservableClicks</code> <code role="statement">extends</code> <code role="special">Clickable</code> <code role="statement">with</code> <code role="special">Subject</code> {
  <code role="statement">abstract</code> <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="statement">super</code>.click()
    notifyObservers
  }
}
</programlisting><para id="para_the_observableclicks_trait_e">The
    <literal moreinfo="none">ObservableClicks</literal> trait extends
    <literal moreinfo="none">Clickable</literal> and mixes in <literal moreinfo="none">Subject</literal>. It
    then overrides the <literal moreinfo="none">click</literal> method with an implementation
    that looks almost the same as the overridden method shown in <xref linkend="TraitsAsMixins"/>. The important difference is the
    <literal moreinfo="none">abstract</literal> keyword.<indexterm significance="normal"><primary>abstract keyword</primary></indexterm><indexterm significance="normal"><primary>ObservableClicks trait (example)</primary></indexterm></para><para id="para_look_closely_at_this_method_i">Look closely at this method.
    It calls <literal moreinfo="none">super.click()</literal>, but what is
    <literal moreinfo="none">super</literal> in this case? At this point, it could only appear
    to be <literal moreinfo="none">Clickable</literal>, which <emphasis>declares</emphasis>
    but does not <emphasis>define</emphasis> the <literal moreinfo="none">click</literal>
    method, or it could be <literal moreinfo="none">Subject</literal>, which doesn’t have a
    <literal moreinfo="none">click</literal> method. So, <literal moreinfo="none">super</literal> can’t be
    bound, at least not yet.</para><para id="para_in_fact_super_will_be_bound">In fact,
    <literal moreinfo="none">super</literal> will be bound when this trait is mixed into an
    instance that defines a concrete <literal moreinfo="none">click</literal> method, such as
    <literal moreinfo="none">Button</literal>. Therefore, we need an
    <literal moreinfo="none">abstract</literal> keyword on
    <literal moreinfo="none">ObservableClicks.click</literal> to tell the compiler (and the
    reader) that <literal moreinfo="none">click</literal> is not yet fully implemented, even
    though <literal moreinfo="none">ObservableClicks.click</literal> has a body.</para><note id="para_note_except_for_declaring_abs"><para>Except for declaring abstract classes, the
      <literal moreinfo="none">abstract</literal> keyword is only required on a method in a
      trait when the method has a body, but it calls the
      <literal moreinfo="none">super</literal> method that doesn’t have a concrete
      implementation in <phrase role="keep-together">parents</phrase> of the
      trait.</para></note><para id="para_let_s_use_this_trait_with_but">Let’s use this trait with
    <literal moreinfo="none">Button</literal> and its concrete <literal moreinfo="none">click</literal> method
    in a <emphasis>Specs</emphasis> test:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui2/button-clickable-observer-spec.scala</code>

<code role="preproc">package</code> ui2
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._
<code role="preproc">import</code> ui.ButtonCountObserver

<code role="statement">object</code> <code role="special">ButtonClickableObserverSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"A Button Observer"</code> should {
    <code role="constant">"observe button clicks"</code> in {
      <code role="statement">val</code> observableButton = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"Okay"</code>) <code role="statement">with</code> <code role="special">ObservableClicks</code>
      <code role="statement">val</code> buttonClickCountObserver = <code role="statement">new</code> <code role="special">ButtonCountObserver</code>
      observableButton.addObserver(buttonClickCountObserver)

      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      buttonClickCountObserver.count mustEqual <code role="constant">3</code>
    }
  }
}
</programlisting><para id="para_compare_this_code_to_button_">Compare this code to
    <literal moreinfo="none">ButtonObserverAnonSpec</literal>. We instantiate a
    <literal moreinfo="none">Button</literal> with the <literal role="keep-together" moreinfo="none">ObservableClicks</literal> trait mixed in, but now
    there is no override of <literal moreinfo="none">click</literal> required. Hence, this
    client of <literal moreinfo="none">Button</literal> doesn’t have to worry about properly
    overriding <literal moreinfo="none">click</literal>. The hard work is already done by
    <literal moreinfo="none">ObservableClicks</literal>. The desired behavior is
    <emphasis>composed declaratively</emphasis> when needed.</para><para id="para_let_s_finish_our_example_by_ad">Let’s finish our example by
    adding a second trait. The JavaBeans specification (see <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>)
    has the idea of “vetoable” events, where listeners for changes to a
    JavaBean can veto the change. Let’s implement something similar with a
    trait that vetoes more than a set number of clicks:<indexterm significance="normal"><primary>traits</primary><secondary sortas="mixins">as mixins</secondary><tertiary>vetoing click events</tertiary></indexterm><indexterm significance="normal"><primary>JavaBeans</primary><secondary>vetoable events</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui2/vetoable-clicks.scala</code>

<code role="preproc">package</code> ui2
<code role="preproc">import</code> observer._

<code role="statement">trait</code> <code role="special">VetoableClicks</code> <code role="statement">extends</code> <code role="special">Clickable</code> {
  <code role="statement">val</code> maxAllowed = <code role="constant">1</code>  <code role="comment">// default</code>
  <code role="statement">private</code> <code role="statement">var</code> count = <code role="constant">0</code>

  <code role="statement">abstract</code> <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="statement">if</code> (count &lt; maxAllowed) {
      count += <code role="constant">1</code>
      <code role="statement">super</code>.click()
    }
  }
}
</programlisting><para id="para_once_again_we_override_the_c">Once again, we override the
    <literal moreinfo="none">click</literal> method. As before, the override must be declared
    <literal moreinfo="none">abstract</literal>. The maximum allowed number of clicks defaults
    to 1. You might wonder what we mean by “defaults” here. Isn’t the field
    declared to be a <literal moreinfo="none">val</literal>? There is no constructor defined
    to initialize it to another value. We’ll revisit these questions in <xref linkend="OverridingMembers"/>.</para><para id="para_this_trait_also_declares_a_co">This trait also declares a
    <literal moreinfo="none">count</literal> variable to keep track of the number of clicks
    seen. <phrase role="keep-together">It is declared</phrase>
    <literal moreinfo="none">private</literal>, so it is invisible outside the trait (see
    <xref linkend="VisibilityRules"/>). The overridden
    <literal moreinfo="none">click</literal> method increments <literal moreinfo="none">count</literal>. It
    only calls the <literal moreinfo="none">super.click()</literal> method if the count is
    less than or equal to the <literal moreinfo="none">maxAllowed</literal> count.<indexterm significance="normal"><primary>VetoableClicks trait (example)</primary></indexterm></para><para id="para_specs_object_for_obs_clicks">Here is a Specs object that
    demonstrates <literal moreinfo="none">ObservableClicks</literal> and
    <literal moreinfo="none">VetoableClicks</literal> working together. Note that a separate
    <literal moreinfo="none">with</literal> keyword is required for each trait, as opposed to
    using one keyword and separating the names with commas, as Java does for
    <literal role="keep-together" moreinfo="none">implements</literal> clauses:<indexterm significance="normal"><primary>ObservableClicks trait (example)</primary><secondary>working with VetoableClicks trait (example)</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui2/button-clickable-observer-vetoable-spec.scala</code>

<code role="preproc">package</code> ui2
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._
<code role="preproc">import</code> ui.ButtonCountObserver

<code role="statement">object</code> <code role="special">ButtonClickableObserverVetoableSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"A Button Observer with Vetoable Clicks"</code> should {
    <code role="constant">"observe only the first button click"</code> in {
      <code role="statement">val</code> observableButton =
          <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"Okay"</code>) <code role="statement">with</code> <code role="special">ObservableClicks</code> <code role="statement">with</code> <code role="special">VetoableClicks</code>
      <code role="statement">val</code> buttonClickCountObserver = <code role="statement">new</code> <code role="special">ButtonCountObserver</code>
      observableButton.addObserver(buttonClickCountObserver)

      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      buttonClickCountObserver.count mustEqual <code role="constant">1</code>
    }
  }
}
</programlisting><para id="para_the_expected_observer_count_is">The expected observer count
    is 1. The <literal moreinfo="none">observableButton</literal> is declared as
    follows:</para><programlisting language="scala" format="linespecific"><code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"Okay"</code>) <code role="statement">with</code> <code role="special">ObservableClicks</code> <code role="statement">with</code> <code role="special">VetoableClicks</code>
</programlisting><para id="para_we_can_infer_that_the_click_">We can infer that the
    <literal moreinfo="none">click</literal> override in <literal moreinfo="none">VetoableClicks</literal> is
    called <emphasis>before</emphasis> the <literal moreinfo="none">click</literal> override
    in <literal moreinfo="none">ObservableClicks</literal>. Loosely speaking, since our
    anonymous class doesn’t define <literal moreinfo="none">click</literal> itself, the method
    lookup proceeds <emphasis>right to left</emphasis>, as declared. It’s
    actually more complicated than that, as we’ll see later in <xref linkend="Linearization"/>.</para><para id="para_in_the_meantime_what_happens_">In the meantime, what
    happens if we use the traits in the reverse order?</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui2/button-vetoable-clickable-observer-spec.scala</code>

<code role="preproc">package</code> ui2
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._
<code role="preproc">import</code> ui.ButtonCountObserver

<code role="statement">object</code> <code role="special">ButtonVetoableClickableObserverSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"A Vetoable Button with Click Observer"</code> should {
    <code role="constant">"observe all the button clicks, even when some are vetoed"</code> in {
      <code role="statement">val</code> observableButton =
          <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"Okay"</code>) <code role="statement">with</code> <code role="special">VetoableClicks</code> <code role="statement">with</code> <code role="special">ObservableClicks</code>
      <code role="statement">val</code> buttonClickCountObserver = <code role="statement">new</code> <code role="special">ButtonCountObserver</code>
      observableButton.addObserver(buttonClickCountObserver)

      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      buttonClickCountObserver.count mustEqual <code role="constant">3</code>
    }
  }
}
</programlisting><para id="para_now_the_expected_observer_coun">Now the expected observer
    count is 3. <literal moreinfo="none">ObservableClicks</literal> now has precedence over
    <literal moreinfo="none">VetoableClicks</literal>, so the count of clicks is incremented,
    even when some clicks are subsequently vetoed!</para><para id="para_so_the_order_of_declaration_m">So, the order of declaration
    matters, which is important to remember for preventing unexpected behavior
    when traits impact each other. Perhaps another lesson to note is that
    splitting objects into too many fine-grained traits can obscure the order
    of execution in your code!<indexterm significance="normal"><primary>declarations</primary><secondary>order of declaration, traits and</secondary></indexterm></para><para id="para_breaking_up_your_application_i">Breaking up your
    application into small, focused traits is a powerful way to create
    reusable, scalable abstractions and “components.” Complex behaviors can be
    built up through <emphasis>declarative composition</emphasis> of traits.
    We will explore this idea in greater detail in <xref linkend="ScalableAbstractions"/>.<indexterm significance="normal"><primary>declarative composition of traits</primary></indexterm></para></sect1><sect1 id="ConstructingTraits"><title>Constructing Traits</title><para id="para_traits_don_t_support_auxiliary">Traits don’t support
    auxiliary constructors, nor do they accept an argument list for the
    primary constructor, the body of a trait. Traits can extend classes or
    other traits. However, they can’t pass arguments to the parent class
    constructor (even literal values), so traits can only extend classes that
    have a no-argument primary or auxiliary constructor.<indexterm significance="normal"><primary>traits</primary><secondary>constructing</secondary></indexterm></para><para id="para_however_like_classes_the_bod">However, like classes, the
    body of a trait is executed every time an instance is created that uses
    the trait, as demonstrated by the following script:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/trait-construction-script.scala</code>

<code role="statement">trait</code> <code role="special">T1</code> {
  println( <code role="constant">"  in T1: x = "</code> + x )
  <code role="statement">val</code> x=<code role="constant">1</code>
  println( <code role="constant">"  in T1: x = "</code> + x )
}
<code role="statement">trait</code> <code role="special">T2</code> {
  println( <code role="constant">"  in T2: y = "</code> + y )
  <code role="statement">val</code> y=<code role="constant">"T2"</code>
  println( <code role="constant">"  in T2: y = "</code> + y )
}

<code role="statement">class</code> <code role="special">Base12</code> {
  println( <code role="constant">"  in Base12: b = "</code> + b )
  <code role="statement">val</code> b=<code role="constant">"Base12"</code>
  println( <code role="constant">"  in Base12: b = "</code> + b )
}
<code role="statement">class</code> <code role="special">C12</code> <code role="statement">extends</code> <code role="special">Base12</code> <code role="statement">with</code> <code role="special">T1</code> <code role="statement">with</code> <code role="special">T2</code> {
  println( <code role="constant">"  in C12: c = "</code> + c )
  <code role="statement">val</code> c=<code role="constant">"C12"</code>
  println( <code role="constant">"  in C12: c = "</code> + c )
}
println( <code role="constant">"Creating C12:"</code> )
<code role="statement">new</code> <code role="special">C12</code>
println( <code role="constant">"After Creating C12"</code> )
</programlisting><para id="para_running_script_oop1a">Running this script with the
    <literal moreinfo="none">scala</literal> command yields the following output:</para><screen format="linespecific">Creating C12:
  in Base12: b = null
  in Base12: b = Base12
  in T1: x = 0
  in T1: x = 1
  in T2: y = null
  in T2: y = T2
  in C12: c = null
  in C12: c = C12
After Creating C12</screen><para>Notice the order of invocation of the class and trait constructors.
    Since the declaration of <literal moreinfo="none">C12</literal> is <literal moreinfo="none">extends Base12
    with T1 with T2</literal>, the order of construction for this simple class
    hierarchy is left to right, starting with the base class
    <literal moreinfo="none">Base12</literal>, followed by the traits <literal moreinfo="none">T1</literal>
    and <literal moreinfo="none">T2</literal>, and ending with the <literal moreinfo="none">C12</literal>
    constructor body. (For constructing arbitrarily <phrase role="keep-together">complex</phrase> hierarchies, see <xref linkend="Linearization"/>.)<indexterm significance="normal"><primary>traits</primary><secondary>constructing</secondary><tertiary>initializing values in traits</tertiary></indexterm></para><para id="para_so_while_you_can_t_pass_const">So, while you can’t pass
    construction parameters to traits, you can initialize fields with default
    values or leave them abstract. We actually saw this before in our
    <literal moreinfo="none">Subject</literal> trait, where the
    <literal moreinfo="none">Subject.observers</literal> field was initialized to an empty
    list.</para><para id="para_if_a_field_in_a_trait_does_not">If a concrete field in a
    trait does not have a suitable default value, there is no “fail-safe” way
    to initialize the value. All the alternative approaches require some ad
    hoc steps by users of the trait, which is error-prone because they might
    do it wrong or forget to do it all. Perhaps the field should be left
    abstract, so that classes or other traits that use this trait are forced
    to define the value appropriately. We’ll discuss overriding abstract and
    concrete members in detail in <xref linkend="AdvancedObjectOrientedProgramming"/>.</para><para id="para_another_solution_is_to_move_th">Another solution is to move
    that field to a separate class, where the construction process can
    guarantee that the correct initialization data is supplied by the user. It
    might be that the whole trait should actually be a class instead, so you
    can define a constructor for it that initializes the field.</para><sect2 id="ClassOrTrait"><title>Class or Trait?</title><para id="para_when_considering_whether_a_c">When considering whether a
      “concept” should be a trait or a class, keep in mind that traits as
      mixins make the most sense for “adjunct” behavior. If you find that a
      particular trait is used most often as a parent of other classes, so
      that the child classes <emphasis>behave as</emphasis> the parent trait,
      then consider defining the trait as a class instead, to make this
      logical relationship more clear. (We said <emphasis>behaves
      as</emphasis>, rather than <emphasis>is a</emphasis>, because the former
      is the more precise definition of inheritance, based on the
      <emphasis>Liskov Substitution Principle</emphasis>—see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>, for
      example.)<indexterm significance="normal"><primary>Liskov Substitution Principle</primary></indexterm><indexterm significance="normal"><primary>inheritance</primary><secondary>definition</secondary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>traits versus</secondary></indexterm><indexterm significance="normal"><primary>traits</primary><secondary>constructing</secondary><tertiary>class or trait</tertiary></indexterm></para><tip id="para_tip_avoid_fields_in_traits_th"><para>Avoid concrete fields in traits that can’t be initialized to
        suitable default values. Use abstract fields instead, or convert the
        trait to a class with <phrase role="keep-together">a
        constructor.</phrase> Of course, stateless traits don’t have any
        issues with <phrase role="keep-together">initialization</phrase>.</para></tip><para id="para_it_s_a_general_principle_of_go">It’s a general principle
      of good object-oriented design that an instance should always be in a
      known valid state, starting from the moment the construction process
      finishes.</para></sect2></sect1><sect1 id="TraitsRecapAndWhatsNext"><title>Recap and What’s Next</title><para id="para_in_this_chapter_we_learned_ho">In this chapter, we learned
    how to use traits to encapsulate and share cross-cutting concerns between
    classes. We covered when and how to use traits, how to “stack” multiple
    traits, and the rules for initializing values within traits.</para><para id="para_in_the_next_chapter_we_explor">In the next chapter, we
    explore how the fundamentals of object-oriented programming work in Scala.
    Even if you’re an old hand at object-oriented programming, you’ll want to
    read the next several chapters to understand the particulars of Scala’s
    approach to OOP.<indexterm class="endofrange" startref="ch04_traits" significance="normal"/></para></sect1></chapter><chapter id="BasicObjectOrientedProgramming"><title>Basic Object-Oriented Programming <phrase role="keep-together">in
  Scala</phrase></title><para id="para_scala_is_an_object_oriented_la">Scala is an object-oriented
  language like Java, Python, Ruby, Smalltalk, and others. If you’re coming
  from the Java world, you’ll notice some notable improvements over the
  limitations of Java’s object model.<indexterm class="startofrange" id="ch05_OOP" significance="normal"><primary>object-oriented programming (OOP)</primary></indexterm></para><para id="para_we_assume_you_have_some_prior_">We assume you have some prior
  experience with object-oriented programming (OOP), so we will not discuss
  the basic principles here, although some common terms and concepts are
  discussed in the <xref linkend="Glossary"/>. See <link linkend="Meyer1997" xrefstyle="select:nopage">[Meyer1997]</link> for a detailed introduction to
  OOP; see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link> for a recent treatment of OOP
  principles in the context of “agile software development”; see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link> to learn about
  <emphasis>design patterns</emphasis>; and see <link linkend="WirfsBrock2003" xrefstyle="select:nopage">[WirfsBrock2003]</link> for a discussion of
  object-oriented design concepts.<indexterm significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>classes and objects, basics of</secondary></indexterm><indexterm significance="normal"><primary>objects</primary><secondary>basics of</secondary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>basics of</secondary></indexterm></para><sect1 id="ClassBasics"><title>Class and Object Basics</title><para id="para_let_s_review_the_basic_terms_f">Let’s review the
    terminology of OOP in Scala.</para><note id="para_note_we_saw_previously_that_s"><para>We saw previously that Scala has the concept of a declared
      <literal moreinfo="none">object</literal>, <phrase role="keep-together">which we’ll
      dig</phrase> into in <xref linkend="ClassesAndObjects"/>. We’ll use the
      term <emphasis>instance</emphasis> to refer to a class instance
      generically, meaning either an <literal moreinfo="none">object</literal> or an instance
      of a <literal moreinfo="none">class</literal>, to avoid the potential for confusion
      between these two concepts.<indexterm significance="normal"><primary>instance</primary></indexterm></para></note><para id="para_classes_are_declared_with_a_cl">Classes are declared with
    the keyword <literal moreinfo="none">class</literal>. We will see later that additional
    keywords can also be used, like <literal moreinfo="none">final</literal> to prevent
    creation of <emphasis>derived</emphasis> classes and
    <literal moreinfo="none">abstract</literal> to indicate that the class can’t be
    instantiated, usually because it contains or inherits member declarations
    without providing concrete definitions for them.<indexterm significance="normal"><primary>class keyword</primary></indexterm></para><para id="para_an_instance_can_refer_to_itsel">An instance can refer to
    itself using the <literal moreinfo="none">this</literal> keyword, just as in Java and
    similar <phrase role="keep-together">languages</phrase>.<indexterm significance="normal"><primary>this keyword</primary></indexterm></para><para id="para_following_scala_s_convention_">Following Scala’s
    convention, we use the term <emphasis>method</emphasis> for a function
    that is tied to an instance. Some other object-oriented languages use the
    term “member function.” Method definitions start with the
    <literal moreinfo="none">def</literal> keyword.<indexterm significance="normal"><primary>methods</primary></indexterm></para><para id="para_like_java_but_unlike_ruby_sc">Like Java, but unlike Ruby
    and Python, Scala allows <emphasis>overloaded methods</emphasis>. Two or
    more methods can have the same name as long as their full
    <emphasis>signatures</emphasis> are unique. The
    <emphasis>signature</emphasis> includes the type name, the list of
    parameters with types, and the method’s return value.<indexterm significance="normal"><primary>overloaded methods</primary></indexterm><indexterm significance="normal"><primary>signature</primary></indexterm></para><para id="para_type_erasure_method_overloading">There is an exception to
    this rule due to <emphasis>type erasure</emphasis>, which is a feature of
    the JVM only, but is used by Scala on both the JVM and .NET platforms, to
    minimize incompatibilities. Suppose two methods are identical except that
    one takes a parameter of type <literal moreinfo="none">List[String]</literal> while the
    other takes a parameter of type <literal moreinfo="none">List[Int]</literal>, as
    follows:<indexterm significance="normal"><primary>type erasure</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/type-erasure-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="statement">object</code> <code role="special">Foo</code> {
  <code role="statement">def</code> <code role="identifier">bar</code>(list:<code role="type"> List[String]</code>) = list.toString
  <code role="statement">def</code> <code role="identifier">bar</code>(list:<code role="type"> List[Int]</code>) = list.size.toString
}
</programlisting><para id="para_you_ll_get_a_compilation_error">You’ll get a compilation
    error on the second method because the two methods will have an identical
    signature after type erasure.</para><warning id="para_warning_the_scala_interpret"><para>The <literal moreinfo="none">scala</literal> interpreter will let you type in both
      methods. It simply drops the first version. However, if you try to load
      the previous example using the <literal moreinfo="none">:load file</literal> command,
      you’ll get the same error <literal moreinfo="none">scalac</literal> raises.</para></warning><para id="para_we_ll_discuss_type_erasure_in_">We’ll discuss type erasure
    in more detail in <xref linkend="ScalasTypeSystem"/>.</para><para id="para_also_by_convention_we_use_the">Also by convention, we use
    the term <emphasis>field</emphasis> for a variable that is tied to an
    instance. The term <emphasis>attribute</emphasis> is often used in other
    languages (like Ruby). Note that the state of an instance is the union of
    all the values currently represented by the instance’s fields.<indexterm significance="normal"><primary>fields</primary></indexterm><indexterm significance="normal"><primary>attributes</primary></indexterm></para><para id="para_as_we_discussed_in_variabled">As we discussed in <xref linkend="VariableDeclarationsAndDefinitions"/>, read-only (“value”)
    fields are declared using the <literal moreinfo="none">val</literal> keyword, and
    read-write fields are declared using the <literal moreinfo="none">var</literal> <phrase role="keep-together">keyword</phrase>.</para><para id="para_scala_also_allows__types__to_b">Scala also allows types to
    be declared in classes, as we saw in <xref linkend="AbstractTypesAndParameterizedTypes"/>.</para><para id="para_we_use_the_term__member__to_re">We use the term
    <emphasis>member</emphasis> to refer to a field, method, or type in a
    generic way. Note that field and method members (but not type members)
    share the same <emphasis>namespace</emphasis>, unlike Java. We’ll discuss
    this more in <xref linkend="UniformAccessPrinciple"/>.<indexterm significance="normal"><primary>members</primary></indexterm></para><para id="para_new_instances_of_reference_types">Finally, new instances of
    <emphasis>reference types</emphasis> are created from a class using the
    <literal moreinfo="none">new</literal> keyword, as in languages like Java and C#. Note
    that you can drop the parentheses when using a
    <emphasis>default</emphasis> constructor (i.e., one that takes no
    arguments). In some cases, literal values can be used instead, e.g.,
    <literal moreinfo="none">val name = "Programming Scala"</literal> is equivalent to
    <literal moreinfo="none">val name = new String("Programming Scala")</literal>.<indexterm significance="normal"><primary>reference types</primary></indexterm></para><para id="para_new_instances_of_value_types">Instances of <emphasis>value
    types</emphasis> (<literal moreinfo="none">Int</literal>, <literal moreinfo="none">Double</literal>,
    etc.), which correspond to the primitives in languages like Java, are
    always created using literal values, e.g., <literal moreinfo="none">1</literal>,
    <literal moreinfo="none">3.14</literal>. In fact, there are no public constructors for
    these types, so an expression like <literal moreinfo="none">val i = new Int(1)</literal>
    won’t compile.<indexterm significance="normal"><primary>primitive data types</primary><secondary>instances of value types corresponding to</secondary></indexterm><indexterm significance="normal"><primary>value types</primary></indexterm></para><para id="para_we_ll_discuss__reference__vs_">We’ll discuss the difference
    between reference and value types in <xref linkend="ScalaTypeHierarchy"/>.<indexterm significance="normal"><primary>classes</primary><secondary>parent</secondary></indexterm><indexterm significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>parent classes</secondary></indexterm></para></sect1><sect1 id="ParentClasses"><title>Parent Classes</title><para id="para_scala_supports__single_inherit">Scala supports single
    inheritance, not multiple inheritance. A child (or derived) class can have
    one and only one parent (or base) class. The sole exception is the root of
    the Scala class hierarchy, <literal moreinfo="none">Any</literal>, which has no
    parent.<indexterm significance="normal"><primary>Any class</primary></indexterm><indexterm significance="normal"><primary>parent classes</primary></indexterm><indexterm significance="normal"><primary>base classes</primary></indexterm></para><para id="para_here_is_a_simple_example_from_">We’ve seen several examples
    of parent and child classes. Here are snippets of one of the first we saw,
    in <xref linkend="AbstractTypesAndParameterizedTypes"/>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/abstract-types-script.scala</code>

<code role="preproc">import</code> java.io._

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">BulkReader</code> {
  <code role="comment">// ...</code>
}

<code role="statement">class</code> <code role="special">StringBulkReader</code>(<code role="statement">val</code> source:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="comment">// ...</code>
}

<code role="statement">class</code> <code role="special">FileBulkReader</code>(<code role="statement">val</code> source:<code role="type"> File</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="comment">// ...</code>
}
</programlisting><para>As in Java, the keyword <literal moreinfo="none">extends</literal> indicates the
    parent class, in this case <literal moreinfo="none">BulkReader</literal>. In Scala,
    <literal moreinfo="none">extends</literal> is also used when a class inherits a trait as
    its parent (even when it mixes in other traits using the
    <literal moreinfo="none">with</literal> keyword). Also, <literal moreinfo="none">extends</literal> is used
    when one trait is the child of another trait or class. Yes, traits can
    inherit classes.<indexterm significance="normal"><primary>extends keyword</primary></indexterm></para><para id="para_if_you_don_t_extend_a_parent">If you don’t
    <literal moreinfo="none">extend</literal> a parent class, the default parent is
    <literal moreinfo="none">AnyRef</literal>, a direct child class of <literal moreinfo="none">Any</literal>.
    (We discuss the difference between <literal moreinfo="none">Any</literal> and
    <literal moreinfo="none">AnyRef</literal> when we discuss the Scala type hierarchy in
    <xref linkend="ScalaTypeHierarchy"/>.)</para></sect1><sect1 id="Constructors"><title>Constructors in Scala</title><para id="para_scala_distinguishes_between_a_">Scala distinguishes between
    a <emphasis>primary constructor</emphasis> and zero or more
    <emphasis>auxiliary constructors</emphasis>. In Scala, the primary
    constructor is the entire body of the class. Any parameters that the
    constructor requires are listed after the class name. We’ve seen many
    examples of this already, as in the <literal moreinfo="none">ButtonWithCallbacks</literal>
    example we used in <xref linkend="Traits"/>:<indexterm significance="normal"><primary>auxiliary constructors</primary></indexterm><indexterm significance="normal"><primary>primary constructor</primary></indexterm><indexterm class="startofrange" id="ch05_OOPconstructors" significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>constructors</secondary></indexterm><indexterm class="startofrange" id="ch05_constructors" significance="normal"><primary>constructors</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button-callbacks.scala</code>

<code role="preproc">package</code> ui

<code role="statement">class</code> <code role="special">ButtonWithCallbacks</code>(<code role="statement">val</code> label:<code role="type"> String</code>,
    <code role="statement">val</code> clickedCallbacks:<code role="type"> List[() =&gt; Unit]</code>) <code role="statement">extends</code> <code role="special">Widget</code> {

  require(clickedCallbacks != <code role="statement">null</code>, <code role="constant">"Callback list can't be null!"</code>)

  <code role="statement">def</code> <code role="identifier">this</code>(label:<code role="type"> String</code>, clickedCallback: () <code role="statement">=&gt;</code> <code role="special">Unit</code>) =
    <code role="statement">this</code>(label, <code role="special">List</code>(clickedCallback))

  <code role="statement">def</code> <code role="identifier">this</code>(label:<code role="type"> String</code>) = {
    <code role="statement">this</code>(label, <code role="special">Nil</code>)
    println(<code role="constant">"Warning: button has no click callbacks!"</code>)
  }

  <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="comment">// ... logic to give the appearance of clicking a physical button ...</code>
    clickedCallbacks.foreach(f <code role="statement">=&gt;</code> f())
  }
}
</programlisting><para id="para_the_buttonwithcallbacks_clas">The
    <literal moreinfo="none">ButtonWithCallbacks</literal> class represents a button on a
    graphical user interface. It has a label and a list of callback functions
    that are invoked if the button is clicked. Each callback function takes no
    arguments and returns <literal moreinfo="none">Unit</literal>. The
    <literal moreinfo="none">click</literal> method iterates through the list of callbacks and
    invokes each one.</para><para id="para__buttonwithcallbacks_defines_"><literal moreinfo="none">ButtonWithCallbacks</literal>
    defines three constructors. The primary constructor, which is the body of
    the entire class, has a parameter list that takes a label string and a
    list of callback functions. Because each parameter is declared as a
    <literal moreinfo="none">val</literal>, the compiler generates a private field
    corresponding to each parameter (a different internal name is used), along
    with a public reader method that has the same name as the parameter.
    “Private” and “public” have the same meaning here as in most
    object-oriented languages. We’ll discuss the various visibility rules and
    the keywords that control them in <xref linkend="VisibilityRules"/>.</para><para id="para_if_a_parameter_has_the_var_k">If a parameter has the
    <literal moreinfo="none">var</literal> keyword, a public writer method is also generated
    with the parameter’s name as a prefix, followed by <literal moreinfo="none">_=</literal>.
    For example, if <literal moreinfo="none">label</literal> were declared as a
    <literal moreinfo="none">var</literal>, the writer method would be named
    <literal moreinfo="none">label_=</literal> and it would take a single argument of type
    <literal moreinfo="none">String</literal>.</para><para id="para_suppress_accessors">There are times when you don’t want the
    accessor methods to be generated automatically. In other words, you want
    the field to be <emphasis>private</emphasis>. Add the
    <literal moreinfo="none">private</literal> keyword before the <literal moreinfo="none">val</literal> or
    <literal moreinfo="none">var</literal> keyword, and the accessor methods won’t be
    generated. (See <xref linkend="VisibilityRules"/> for more
    details.)<indexterm significance="normal"><primary>private keyword</primary></indexterm></para><note id="para_note_scala_doesn_t_follow_the"><para>For you Java programmers, Scala doesn’t follow the JavaBeans <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>
      convention that field reader and writer methods begin with
      <literal moreinfo="none">get</literal> and <literal moreinfo="none">set</literal>, respectively,
      followed by the field name with the first character capitalized. We’ll
      see why when we discuss the <emphasis>Uniform Access
      Principle</emphasis> in <xref linkend="UniformAccessPrinciple"/>.
      However, you can get JavaBeans-style <emphasis>getters</emphasis> and
      <emphasis>setters</emphasis> when you need them using the
      <literal moreinfo="none">scala.reflect.BeanProperty</literal> annotation, as we’ll
      discuss in <xref linkend="JavaBeanProperties"/>.</para></note><para id="para_when_an_instance_of_the_class_">When an instance of the
    class is created, each field corresponding to a parameter in the parameter
    list will be initialized with the parameter automatically. No constructor
    logic is required to initialize these fields, in contrast to most other
    object-oriented languages.</para><para id="para_the_first_statement_in_the_cla">The first statement in the
    <literal moreinfo="none">ButtonWithCallbacks</literal> class (i.e., the constructor) body
    is a test to ensure that a non-<literal moreinfo="none">null</literal> list has been
    passed to the constructor. (It does allow an empty <literal moreinfo="none">Nil</literal>
    list, however.) It uses the convenient <literal moreinfo="none">require</literal> function
    that is imported automatically into the current scope (as we’ll discuss in
    <xref linkend="PredefObject"/>). If the list is null,
    <literal moreinfo="none">require</literal> will throw an exception. The
    <literal moreinfo="none">require</literal> function and its companion
    <literal moreinfo="none">assume</literal> are very useful for <emphasis>Design by
    Contract</emphasis> programming, as discussed in <xref linkend="DesignByContractExample"/>.</para><para id="para_here_is_a_partial_specification">Here is part of a full
    specification for <literal moreinfo="none">ButtonWithCallbacks</literal> that demonstrates
    the <literal moreinfo="none">require</literal> statement in use:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button-callbacks-spec.scala</code>
<code role="preproc">package</code> ui
<code role="preproc">import</code> org.specs._

<code role="statement">object</code> <code role="special">ButtonWithCallbacksSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"A ButtonWithCallbacks"</code> should {
    <code role="comment">// ...</code>
    <code role="constant">"not be constructable with a null callback list"</code> in {
      <code role="statement">val</code> nullList:<code role="type">List[() =&gt; Unit]</code> = <code role="statement">null</code>
      <code role="statement">val</code> errorMessage =
        <code role="constant">"requirement failed: Callback list can't be null!"</code>
      (<code role="statement">new</code> <code role="special">ButtonWithCallbacks</code>(<code role="constant">"button1"</code>, nullList)) must throwA(
        <code role="statement">new</code> <code role="special">IllegalArgumentException</code>(errorMessage))
    }
  }
}
</programlisting><para id="para_scala_diff_pass_null">Scala even makes it difficult to pass
    <literal moreinfo="none">null</literal> as the second parameter to the constructor; it
    won’t type check when you compile it. However, you can assign
    <literal moreinfo="none">null</literal> to a value, as shown. If we didn’t have the
    <literal moreinfo="none">must throwA(...)</literal> clause, we would see the following
    exception thrown:</para><screen format="linespecific">java.lang.IllegalArgumentException: requirement failed: Callback list can't be null!
        at scala.Predef$.require(Predef.scala:112)
        at ui.ButtonWithCallbacks.&lt;init&gt;(button-callbacks.scala:7)
...</screen><para id="para_in_this_example_two_auxiliary"><literal moreinfo="none">ButtonWithCallbacks</literal>
    defines two auxiliary constructors for the user’s convenience. The first
    auxiliary constructor accepts a label and a single callback. It calls the
    primary constructor, passing the label and a new <literal moreinfo="none">List</literal>
    to wrap the single callback.</para><para id="para_the_second_auxiliary_construct">The second auxiliary
    constructor accepts just a label. It calls the primary constructor with
    <literal moreinfo="none">Nil</literal> (which represents an empty <literal moreinfo="none">List</literal>
    object). The constructor then prints a warning message that there are no
    callbacks, since lists are immutable and there is no way to replace the
    callback list <literal moreinfo="none">val</literal> with a new one.</para><para id="para_in_order_to_avoid_potential_in">To avoid infinite
    recursion, Scala requires each auxiliary constructor to invoke another
    constructor defined before it (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). The constructor invoked
    may be either another auxiliary constructor or the primary constructor,
    and it must be the first statement in the auxiliary constructor’s body.
    Additional processing can occur after this call, such as the warning
    message printed in our example.</para><note id="para_note_that_because_all_auxiliar"><para>Because all auxiliary constructors eventually invoke the primary
      constructor, logic checks and other initializations done in the body
      will be performed consistently for all instances created.</para></note><para id="para_there_are_a_few_advantages_of_">There are a few advantages
    of Scala’s constraints on constructors:<indexterm significance="normal"><primary>constructors</primary><secondary>constraints on, advantages and disadvantage of</secondary></indexterm></para><variablelist id="para_advantages_of_ctor_constraints_"><varlistentry id="varlistentry-elimination-of-duplication"><term>Elimination of duplication</term><listitem><para>Because auxiliary constructors invoke the primary constructor,
          potential duplication of construction logic is largely
          eliminated.</para></listitem></varlistentry><varlistentry id="varlistentry-code-size-reduction"><term>Code size reduction</term><listitem><para>As shown in the examples, when one or more of the primary
          constructor parameters is declared as a <literal moreinfo="none">val</literal> or a
          <literal moreinfo="none">var</literal>, Scala automatically generates a field, the
          appropriate accessor methods (unless they are declared
          <literal moreinfo="none">private</literal>), and the initialization logic for when
          instances are created.</para></listitem></varlistentry></variablelist><para id="para_there_is_also_at_least_one_dis">There is also at least one
    disadvantage of Scala’s constraints on constructors:</para><variablelist id="para_less_flexibility_"><varlistentry id="varlistentry-less-flexibility"><term>Less flexibility</term><listitem><para>Sometimes it’s just not convenient to have one constructor
          body that all constructors are forced to use. However, we find these
          circumstances to be rare. In such cases, it may simply be that the
          class has too many responsibilities and it should be refactored into
          smaller classes.</para></listitem></varlistentry></variablelist><sect2 id="CallingParentClassConstructors"><title>Calling Parent Class Constructors</title><para id="para_the_following_example_illustra">The primary constructor
      in a derived class must invoke one of the parent class constructors,
      either the primary constructor or an auxiliary constructor. In the
      following example, a class derived from
      <literal moreinfo="none">ButtonWithCallbacks</literal>, called
      <literal moreinfo="none">RadioButtonWithCallbacks</literal>, invokes the primary
      <literal moreinfo="none">ButtonWithCallbacks</literal> constructor. “Radio” buttons can
      be either on or off:<indexterm significance="normal"><primary>constructors</primary><secondary>parent class constructors, calling</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/ui/radio-button-callbacks.scala</code>

<code role="preproc">package</code> ui

<code role="comment">/**</code>
<code role="comment"> * Button with two states, on or off, like an old-style,</code>
<code role="comment"> * channel-selection button on a radio.</code>
<code role="comment"> */</code>
<code role="statement">class</code> <code role="special">RadioButtonWithCallbacks</code>(
  <code role="statement">var</code> on:<code role="type"> Boolean</code>, label:<code role="type"> String</code>, clickedCallbacks:<code role="type"> List[() =&gt; Unit]</code>)
      <code role="statement">extends</code> <code role="special">ButtonWithCallbacks</code>(label, clickedCallbacks) {

  <code role="statement">def</code> <code role="identifier">this</code>(on:<code role="type"> Boolean</code>, label:<code role="type"> String</code>, clickedCallback: () <code role="statement">=&gt;</code> <code role="special">Unit</code>) =
      <code role="statement">this</code>(on, label, <code role="special">List</code>(clickedCallback))

  <code role="statement">def</code> <code role="identifier">this</code>(on:<code role="type"> Boolean</code>, label:<code role="type"> String</code>) = <code role="statement">this</code>(on, label, <code role="special">Nil</code>)
}
</programlisting><para id="para_the_primary_constructor_for_r">The primary constructor
      for <literal moreinfo="none">RadioButtonWithCallbacks</literal> takes three parameters:
      an <literal moreinfo="none">on</literal> state (<literal moreinfo="none">true</literal> or
      <literal moreinfo="none">false</literal>), a label, and a list of callbacks. It passes
      the label and list of callbacks to its parent class,
      <literal moreinfo="none">ButtonWithCallbacks</literal>. The <literal moreinfo="none">on</literal>
      parameter is declared as a <literal moreinfo="none">var</literal>, so it is mutable.
      <literal moreinfo="none">on</literal> is also the one constructor parameter unique to a
      radio button, so it is kept as an attribute of
      <literal moreinfo="none">RadioButtonWithCallbacks</literal>.</para><para id="para_for_consistency_with_its_paren">For consistency with its
      parent class, <literal moreinfo="none">RadioButtonWithCallbacks</literal> also declares
      two auxiliary constructors. Note that they must invoke a preceding
      constructor in <literal moreinfo="none">RadioButtonWithCallbacks</literal>, as before.
      They can’t invoke a <literal moreinfo="none">ButtonWithCallbacks</literal> constructor
      directly. Declaring all these constructors in each class could get
      tedious after a while, but we explored techniques in <xref linkend="Traits"/> that can eliminate repetition.<indexterm class="endofrange" startref="ch05_constructors" significance="normal"/><indexterm class="endofrange" startref="ch05_OOPconstructors" significance="normal"/></para><note id="para_cant_super_class_constructor"><para>While <literal moreinfo="none">super</literal> is used to invoke overridden
        methods, as in Java, it cannot be used to invoke a super class
        constructor.</para></note></sect2></sect1><sect1 id="NestedClasses"><title>Nested Classes</title><para id="para_scala_lets_you_nest_class_decl">Scala lets you nest class
    declarations, like many object-oriented languages. Suppose we want all
    <literal moreinfo="none">Widgets</literal> to have a map of properties. These properties
    could be size, color, whether or not the widget is visible, etc. We might
    use a simple <literal moreinfo="none">map</literal> to hold the <phrase role="keep-together">properties</phrase>, but let’s assume that we also
    want to control access to the properties, and to perform other operations
    when they change.<indexterm significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>nested classes</secondary></indexterm><indexterm significance="normal"><primary>nested classes</primary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>nested</secondary></indexterm></para><para id="para_here_is_one_way_way_we_might_e">Here is one way we might
    expand our original <literal moreinfo="none">Widget</literal> example from <xref linkend="TraitsAsMixins"/> to add this feature:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/ui/widget.scala</code>

<code role="preproc">package</code> ui

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Widget</code> {
  <code role="statement">class</code> <code role="special">Properties</code> {
    <code role="preproc">import</code> scala.collection.immutable.HashMap

    <code role="statement">private</code> <code role="statement">var</code> values:<code role="type"> Map[String, Any]</code> = <code role="statement">new</code> <code role="special">HashMap</code>

    <code role="statement">def</code> <code role="identifier">size</code> = values.size

    <code role="statement">def</code> <code role="identifier">get</code>(key:<code role="type"> String</code>) = values.get(key)

    <code role="statement">def</code> <code role="identifier">update</code>(key:<code role="type"> String</code>, value:<code role="type"> Any</code>) = {
      <code role="comment">// Do some preprocessing, e.g., filtering.</code>
      values = values.update(key, value)
      <code role="comment">// Do some postprocessing.</code>
    }
  }

  <code role="statement">val</code> properties = <code role="statement">new</code> <code role="special">Properties</code>
}
</programlisting><para id="para_widget_with_properties">We added a
    <literal moreinfo="none">Properties</literal> class that has a private, mutable reference
    to an immutable <literal moreinfo="none">HashMap</literal>. We also added three public
    methods that retrieve the size (i.e., the number of properties defined),
    retrieve a single element in the map, and update the map with a new
    element, respectively. We might need to do additional work in the
    <literal moreinfo="none">update</literal> method, and we’ve indicated as much with
    comments.</para><note id="para_so_scala_allows_declarations_"><para>You can see from the previous example that Scala allows classes to
      be declared inside one another, or “nested.” A nested class make sense
      when you have enough related functionality to lump together in a class,
      but the functionality is only ever going to be used by its “outer”
      class.</para></note><para id="para_so_far_we_ve_covered_how_to_d">So far, we’ve covered how to
    declare classes, how to instantiate them, and some of the basics of
    inheritance. In the next section, we’ll discuss visibility rules within
    classes and objects.</para></sect1><sect1 id="VisibilityRules"><title>Visibility Rules</title><note id="para_for_convenience_we_ll_use_the"><para>For convenience, we’ll use the word “type” in this section to
      refer to classes and traits generically, as opposed to referring to
      member <literal moreinfo="none">type</literal> declarations. We’ll include those when we
      use the term “member” <phrase role="keep-together">generically</phrase>,
      unless otherwise indicated.</para></note><para id="para_most_object_oriented_languages">Most object-oriented
    languages have constructs to constrain the visibility (or scope) of type
    and type-member declarations. These constructs support the object-oriented
    form of encapsulation, where only the essential public abstraction of a
    class or trait is exposed and implementation information is hidden from
    view.<indexterm significance="normal"><primary>encapsulation</primary><secondary>visibility rules and</secondary></indexterm><indexterm class="startofrange" id="ch05_visibility" significance="normal"><primary>visibility</primary></indexterm><indexterm class="startofrange" id="ch05_OOPvisibility" significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>visibility rules</secondary></indexterm></para><para id="para_you_ll_want_to_use_public_visi">You’ll want to use public
    visibility for anything that users of your classes and objects should see
    and use. Keep in mind that the set of publicly visible members form the
    abstraction exposed by the type, along with the type’s name
    itself.<indexterm significance="normal"><primary>fields</primary><secondary>visibility and access to</secondary></indexterm></para><para id="para_the_conventional_wisdom_in_obj">The conventional wisdom in
    object-oriented design is that fields should be private or protected. If
    access is required, it should happen through methods, but not everything
    should be accessible by default. The virtue of the <emphasis>Uniform
    Access Principle</emphasis> (see <xref linkend="UniformAccessPrinciple"/>) is that we can give the user the
    semantics of public field access via either a method or direct access to a
    field, whichever is appropriate for the task.<indexterm significance="normal"><primary>Uniform Access Principle</primary></indexterm></para><tip id="para_tip_the_art_of_good_object_or"><para>The art of good object-oriented design includes defining minimal,
      clear, and cohesive public abstractions.</para></tip><para id="para_there_are_two_kinds_of_users">There are two kinds of
    “users” of a type: derived types, and code that works with instances of
    the type. Derived types usually need more access to the members of their
    parent types than users of instances do.<indexterm significance="normal"><primary>derived types</primary><secondary>access to members of parent types</secondary></indexterm></para><para id="para_scala_s_visibility_rules_are_s">Scala’s visibility rules
    are similar to Java’s, but tend to be both more consistently applied and
    more flexible. For example, in Java, if an inner class has a
    <literal moreinfo="none">private</literal> member, the enclosing class can see it. In
    Scala, the enclosing class can’t see a <literal moreinfo="none">private</literal> member,
    but Scala provides another way to declare it visible to the enclosing
    class.<indexterm significance="normal"><primary>access modifier keywords</primary></indexterm></para><para id="para_also_like_java_and_c_the_vis">As in Java and C#, the
    keywords that modify visibility, such as <literal moreinfo="none">private</literal> and
    <literal role="keep-together" moreinfo="none">protected</literal>, appear at the beginning
    of declarations. You’ll find them before the <literal moreinfo="none">class</literal> or
    <literal moreinfo="none">trait</literal> keywords for types, before the
    <literal moreinfo="none">val</literal> or <literal moreinfo="none">var</literal> for fields, and before
    the <literal moreinfo="none">def</literal> for methods.<indexterm significance="normal"><primary>declarations</primary><secondary>visibility modifiers in</secondary></indexterm><indexterm significance="normal"><primary>protected keyword</primary></indexterm><indexterm significance="normal"><primary>private keyword</primary></indexterm></para><note id="para_note_you_can_also_use_an_acce"><para>You can also use an access modifier keyword on the primary
      constructor of a class. Put it after the type name and type parameters,
      if any, and before the argument list, as in this example: <literal moreinfo="none">class
      Restricted[+A] pri⁠vate (name: String) {...}</literal></para></note><para id="para_visibility_scopes_table_summarizes_the_visibility_scopes"><xref linkend="visibility-scopes-table"/> summarizes the visibility
    scopes.<indexterm significance="normal"><primary>visibility</primary><secondary>summary of visibility scopes</secondary></indexterm></para><table id="visibility-scopes-table"><title>Visibility scopes</title><tgroup cols="3"><thead valign="top"><row><entry>Name</entry><entry>Keyword</entry><entry>Description</entry></row></thead><tbody valign="top"><row><entry><para>public</para></entry><entry><para><emphasis>none</emphasis></para></entry><entry><para>Public members and types are visible everywhere,
            across all boundaries.</para></entry></row><row><entry><para>protected</para></entry><entry><para><literal moreinfo="none">protected</literal></para></entry><entry><para>Protected members are visible to the defining type,
            to derived types, and to nested types. Protected types are visible
            only within the same package and subpackages.</para></entry></row><row><entry><para>private</para></entry><entry><para><literal moreinfo="none">private</literal></para></entry><entry><para>Private members are visible only within the defining
            type and nested types. Private types are visible only within the
            same package.</para></entry></row><row><entry><para><phrase role="keep-together">scoped
            protected</phrase></para></entry><entry><para><literal role="keep-together" moreinfo="none">protected[scope]</literal></para></entry><entry><para>Visibility is limited to <literal moreinfo="none">scope</literal>,
            which can be a package, type, or <literal moreinfo="none">this</literal> (meaning
            the same instance, when applied to members, or the enclosing
            package, when applied to types). See the text below for
            details.</para></entry></row><row><entry><para><phrase role="keep-together">scoped
            private</phrase></para></entry><entry><para><literal role="keep-together" moreinfo="none">private[scope]</literal></para></entry><entry><para>Synonymous with scoped protected visibility, except
            under inheritance (discussed below).</para></entry></row></tbody></tgroup></table><para id="para_let_s_explore_these_visibility">Let’s explore these
    visibility options in more detail. To keep things simple, we’ll use fields
    for member examples. Method and type declarations behave the same
    way.</para><note id="para_unfortunately_you_can_t_apply"><para>Unfortunately, you can’t apply any of the visibility modifiers to
      packages. Therefore, a package is always public, even when it contains
      no publicly visible types.</para></note><sect2 id="PublicVisibility"><title>Public Visibility</title><para id="para_any_declaration_without_a_visi">Any declaration without a
      visibility keyword is “public,” meaning it is visible everywhere. There
      is no <literal moreinfo="none">public</literal> keyword in Scala. This is in contrast to
      Java, which defaults to public visibility only within the enclosing
      package (i.e., “package private”). Other object-oriented languages, like
      Ruby, also default to public visibility:<indexterm significance="normal"><primary>public visibility</primary></indexterm><indexterm significance="normal"><primary>visibility</primary><secondary>public</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/public.scala</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">PublicClass1</code> {
    <code role="statement">val</code> publicField = <code role="constant">1</code>

    <code role="statement">class</code> <code role="special">Nested</code> {
      <code role="statement">val</code> nestedField = <code role="constant">1</code>
    }

    <code role="statement">val</code> nested = <code role="statement">new</code> <code role="special">Nested</code>
  }

  <code role="statement">class</code> <code role="special">PublicClass2</code> <code role="statement">extends</code> <code role="special">PublicClass1</code> {
    <code role="statement">val</code> field2  = publicField + <code role="constant">1</code>
    <code role="statement">val</code> nField2 = <code role="statement">new</code> <code role="special">Nested</code>().nestedField
  }
}

<code role="preproc">package</code> scopeB {
  <code role="statement">class</code> <code role="special">PublicClass1B</code> <code role="statement">extends</code> scopeA.<code role="special">PublicClass1</code>

  <code role="statement">class</code> <code role="special">UsingClass</code>(<code role="statement">val</code> publicClass:<code role="type"> scopeA.PublicClass1</code>) {
    <code role="statement">def</code> <code role="identifier">method</code> = <code role="constant">"UsingClass:"</code> +
      <code role="constant">" field: "</code> + publicClass.publicField +
      <code role="constant">" nested field: "</code> + publicClass.nested.nestedField
  }
}
</programlisting><para id="para_you_can_compile_this_file_with">You can compile this file
      with <literal moreinfo="none">scalac</literal>. It should compile without error.</para><para id="para_everything_is_public_in_these_">Everything is public in
      these packages and classes. Note that
      <literal moreinfo="none">scopeB.UsingClass</literal> can access
      <literal moreinfo="none">scopeA.PublicClass1</literal> and its members, including the
      instance of <literal moreinfo="none">Nested</literal> and its public field.</para></sect2><sect2 id="ProtectedVisibility"><title>Protected Visibility</title><para id="para_protected_visibility_is_for_th">Protected visibility is
      for the benefit of implementers of derived types, who need a little more
      access to the details of their parent types. Any member declared with
      the <literal role="keep-together" moreinfo="none">protected</literal> keyword is visible
      only to the defining type, including other instances of the same type
      and any derived types. When applied to a type,
      <literal moreinfo="none">protected</literal> limits visibility to the enclosing
      package.<indexterm significance="normal"><primary>protected visibility</primary></indexterm><indexterm significance="normal"><primary>visibility</primary><secondary>protected</secondary></indexterm></para><para id="para_java_in_contrast_makes_prote">Java, in contrast, makes
      protected members visible throughout the enclosing package. Scala
      handles this case with scoped private and protected access:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/protected-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">ProtectedClass1</code>(<code role="statement">protected</code> <code role="statement">val</code> protectedField1:<code role="type"> Int</code>) {
    <code role="statement">protected</code> <code role="statement">val</code> protectedField2 = <code role="constant">1</code>

    <code role="statement">def</code> <code role="identifier">equalFields</code>(other:<code role="type"> ProtectedClass1</code>) =
      (protectedField1 == other.protectedField1) &amp;&amp;
      (protectedField1 == other.protectedField1) &amp;&amp;
      (nested == other.nested)

    <code role="statement">class</code> <code role="special">Nested</code> {
      <code role="statement">protected</code> <code role="statement">val</code> nestedField = <code role="constant">1</code>
    }

    <code role="statement">protected</code> <code role="statement">val</code> nested = <code role="statement">new</code> <code role="special">Nested</code>
  }

  <code role="statement">class</code> <code role="special">ProtectedClass2</code> <code role="statement">extends</code> <code role="special">ProtectedClass1</code>(<code role="constant">1</code>) {
    <code role="statement">val</code> field1 = protectedField1
    <code role="statement">val</code> field2 = protectedField2
    <code role="statement">val</code> nField = <code role="statement">new</code> <code role="special">Nested</code>().nestedField  <code role="comment">// ERROR</code>
  }

  <code role="statement">class</code> <code role="special">ProtectedClass3</code> {
    <code role="statement">val</code> protectedClass1 = <code role="statement">new</code> <code role="special">ProtectedClass1</code>(<code role="constant">1</code>)
    <code role="statement">val</code> protectedField1 = protectedClass1.protectedField1 <code role="comment">// ERROR</code>
    <code role="statement">val</code> protectedField2 = protectedClass1.protectedField2 <code role="comment">// ERROR</code>
    <code role="statement">val</code> protectedNField = protectedClass1.nested.nestedField <code role="comment">// ERROR</code>
  }

  <code role="statement">protected</code> <code role="statement">class</code> <code role="special">ProtectedClass4</code>

  <code role="statement">class</code> <code role="special">ProtectedClass5</code> <code role="statement">extends</code> <code role="special">ProtectedClass4</code>
  <code role="statement">protected</code> <code role="statement">class</code> <code role="special">ProtectedClass6</code> <code role="statement">extends</code> <code role="special">ProtectedClass4</code>
}

<code role="preproc">package</code> scopeB {
  <code role="statement">class</code> <code role="special">ProtectedClass4B</code> <code role="statement">extends</code> scopeA.<code role="special">ProtectedClass4</code> <code role="comment">// ERROR</code>
}
</programlisting><para id="para_when_you_compile_this_file_wit">When you compile this
      file with <literal moreinfo="none">scalac</literal>, you get the following output. (The
      file names before the <literal moreinfo="none">N:</literal> line numbers have been
      removed from the output to better fit the space.)</para><screen format="linespecific">16: error: value nestedField cannot be accessed in ProtectedClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
20: error: value protectedField1 cannot be accessed in scopeA.ProtectedClass1
        val protectedField1 = protectedClass1.protectedField1
                                              ^
21: error: value protectedField2 cannot be accessed in scopeA.ProtectedClass1
        val protectedField2 = protectedClass1.protectedField2
                                              ^
22: error: value nested cannot be accessed in scopeA.ProtectedClass1
        val protectedNField = protectedClass1.nested.nestedField
                                              ^
32: error: class ProtectedClass4 cannot be accessed in package scopeA
    class ProtectedClass4B extends scopeA.ProtectedClass4
                                          ^
5 errors found</screen><para id="para_the_comments_in_the_li">The <literal moreinfo="none">// ERROR</literal>
      comments in the listing mark the lines that fail to parse.</para><para id="para__protectedclass2_can_access_p"><literal moreinfo="none">ProtectedClass2</literal>
      can access protected members of <literal moreinfo="none">ProtectedClass1</literal>,
      since it derives from it. However, it can’t access the protected
      <literal moreinfo="none">nestedField</literal> in
      <literal moreinfo="none">protectedClass1.nested</literal>. Also,
      <literal moreinfo="none">ProtectedClass3</literal> can’t access protected members of the
      <literal moreinfo="none">ProtectedClass1</literal> <phrase role="keep-together">instance</phrase> it uses.</para><para id="para_finally_because_protectedcla">Finally, because
      <literal moreinfo="none">ProtectedClass4</literal> is declared
      <literal moreinfo="none">protected</literal>, it is not visible in the
      <literal moreinfo="none">scopeB</literal> package.</para></sect2><sect2 id="PrivateVisibility"><title>Private Visibility</title><para id="para_private_visibility_is_for_comp">Private visibility
      completely hides implementation details, even from the implementers of
      derived classes. Any member declared with the <literal moreinfo="none">private</literal>
      keyword is visible only to the defining type, including other instances
      of the same type. When applied to a type, <literal moreinfo="none">private</literal>
      limits visibility to the enclosing package:<indexterm significance="normal"><primary>visibility</primary><secondary>private</secondary></indexterm><indexterm significance="normal"><primary>private visibility</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/private-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">PrivateClass1</code>(<code role="statement">private</code> <code role="statement">val</code> privateField1:<code role="type"> Int</code>) {
    <code role="statement">private</code> <code role="statement">val</code> privateField2 = <code role="constant">1</code>

    <code role="statement">def</code> <code role="identifier">equalFields</code>(other:<code role="type"> PrivateClass1</code>) =
      (privateField1 == other.privateField1) &amp;&amp;
      (privateField2 == other.privateField2) &amp;&amp;
      (nested == other.nested)

    <code role="statement">class</code> <code role="special">Nested</code> {
      <code role="statement">private</code> <code role="statement">val</code> nestedField = <code role="constant">1</code>
    }

    <code role="statement">private</code> <code role="statement">val</code> nested = <code role="statement">new</code> <code role="special">Nested</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass2</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>(<code role="constant">1</code>) {
    <code role="statement">val</code> field1 = privateField1  <code role="comment">// ERROR</code>
    <code role="statement">val</code> field2 = privateField2  <code role="comment">// ERROR</code>
    <code role="statement">val</code> nField = <code role="statement">new</code> <code role="special">Nested</code>().nestedField <code role="comment">// ERROR</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass3</code> {
    <code role="statement">val</code> privateClass1 = <code role="statement">new</code> <code role="special">PrivateClass1</code>(<code role="constant">1</code>)
    <code role="statement">val</code> privateField1 = privateClass1.privateField1 <code role="comment">// ERROR</code>
    <code role="statement">val</code> privateField2 = privateClass1.privateField2 <code role="comment">// ERROR</code>
    <code role="statement">val</code> privateNField = privateClass1.nested.nestedField <code role="comment">// ERROR</code>
  }

  <code role="statement">private</code> <code role="statement">class</code> <code role="special">PrivateClass4</code>

  <code role="statement">class</code> <code role="special">PrivateClass5</code> <code role="statement">extends</code> <code role="special">PrivateClass4</code>  <code role="comment">// ERROR</code>
  <code role="statement">protected</code> <code role="statement">class</code> <code role="special">PrivateClass6</code> <code role="statement">extends</code> <code role="special">PrivateClass4</code> <code role="comment">// ERROR</code>
  <code role="statement">private</code> <code role="statement">class</code> <code role="special">PrivateClass7</code> <code role="statement">extends</code> <code role="special">PrivateClass4</code>
}

<code role="preproc">package</code> scopeB {
  <code role="statement">class</code> <code role="special">PrivateClass4B</code> <code role="statement">extends</code> scopeA.<code role="special">PrivateClass4</code>  <code role="comment">// ERROR</code>
}
</programlisting><para id="para_compiling_yields1">Compiling this file yields the
      following output:</para><screen format="linespecific">14: error: not found: value privateField1
        val field1 = privateField1
                     ^
15: error: not found: value privateField2
        val field2 = privateField2
                     ^
16: error: value nestedField cannot be accessed in PrivateClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
20: error: value privateField1 cannot be accessed in scopeA.PrivateClass1
        val privateField1 = privateClass1.privateField1
                                          ^
21: error: value privateField2 cannot be accessed in scopeA.PrivateClass1
        val privateField2 = privateClass1.privateField2
                                          ^
22: error: value nested cannot be accessed in scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
27: error: private class PrivateClass4 escapes its defining scope as part
of type scopeA.PrivateClass4
    class PrivateClass5 extends PrivateClass4
                                ^
28: error: private class PrivateClass4 escapes its defining scope as part
of type scopeA.PrivateClass4
    protected class PrivateClass6 extends PrivateClass4
                                          ^
33: error: class PrivateClass4 cannot be accessed in package scopeA
    class PrivateClass4B extends scopeA.PrivateClass4
                                        ^
9 errors found</screen><para id="para_now_privateclass2_can_t_acc">Now,
      <literal moreinfo="none">PrivateClass2</literal> can’t access private members of its
      parent class <literal moreinfo="none">PrivateClass1</literal>. They are completely
      invisible to the subclass, as indicated by the error messages. Nor can
      it access a private field in a <literal moreinfo="none">Nested</literal> class.</para><para id="para_just_as_for_the_case_of_prote">Just as for the case of
      <literal moreinfo="none">protected</literal> access, <literal moreinfo="none">PrivateClass3</literal>
      can’t access private members of the <literal moreinfo="none">PrivateClass1</literal>
      instance it is using. Note, however, that the
      <literal moreinfo="none">equalFields</literal> method can access private members of the
      <literal moreinfo="none">other</literal> instance.</para><para id="para_the_declarations_of_privatecl">The declarations of
      <literal moreinfo="none">PrivateClass5</literal> and <literal moreinfo="none">PrivateClass6</literal>
      fail because, if allowed, they would enable
      <literal moreinfo="none">PrivateClass4</literal> to “escape its defining scope.”
      However, the declaration of <literal moreinfo="none">PrivateClass7</literal> succeeds
      because it is also declared to be private. Curiously, our previous
      example was able to declare a public class that subclassed a protected
      class without a similar error.</para><para id="para_finally_just_as_for_protecte">Finally, just as for
      <literal moreinfo="none">protected</literal> type declarations, the
      <literal moreinfo="none">private</literal> types can’t be subclassed outside the same
      package.</para></sect2><sect2 id="ScopedPrivateAndProtectedVisibility"><title>Scoped Private and Protected Visibility</title><para id="para_scala_allows_you_to_fine_tune_">Scala allows you to
      fine-tune the scope of visibility with the scoped
      <literal moreinfo="none">private</literal> and <literal role="keep-together" moreinfo="none">protected</literal> visibility declarations. Note
      that using <literal moreinfo="none">private</literal> or <literal moreinfo="none">protected</literal> in
      a scoped declaration is interchangeable, as they behave identically,
      except under inheritance when applied to members.<indexterm class="startofrange" id="ch05_protectedscope" significance="normal"><primary>protected visibility</primary><secondary>scoped</secondary></indexterm><indexterm class="startofrange" id="ch05_privatescoped" significance="normal"><primary>private visibility</primary><secondary>scoped</secondary></indexterm><indexterm class="startofrange" id="ch05_scopevisibility" significance="normal"><primary>scope</primary><secondary sortas="private and protected">of private and protected
          visibility</secondary></indexterm><indexterm class="startofrange" id="ch05_visibilityscoped" significance="normal"><primary>visibility</primary><secondary>scoped private and protected visibility</secondary></indexterm></para><tip id="para_tip_while_either_choice_is_fi"><para>While either choice behaves the same in most scenarios, it is
        more common to see <literal moreinfo="none">private[X]</literal> rather than
        <literal moreinfo="none">protected[X]</literal> used in code. In the core libraries
        included with Scala, the ratio is roughly five to one.</para></tip><para id="para_let_s_begin_by_considering_the">Let’s begin by
      considering the only differences in behavior between scoped private and
      scoped protected—how they behave under inheritance when members have
      these scopes:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/scope-inheritance-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">Class1</code> {
    <code role="statement">private</code>[scopeA]   <code role="statement">val</code> scopeA_privateField = <code role="constant">1</code>
    <code role="statement">protected</code>[scopeA] <code role="statement">val</code> scopeA_protectedField = <code role="constant">2</code>
    <code role="statement">private</code>[<code role="special">Class1</code>]   <code role="statement">val</code> class1_privateField = <code role="constant">3</code>
    <code role="statement">protected</code>[<code role="special">Class1</code>] <code role="statement">val</code> class1_protectedField = <code role="constant">4</code>
    <code role="statement">private</code>[<code role="statement">this</code>]     <code role="statement">val</code> this_privateField = <code role="constant">5</code>
    <code role="statement">protected</code>[<code role="statement">this</code>]   <code role="statement">val</code> this_protectedField = <code role="constant">6</code>
  }

  <code role="statement">class</code> <code role="special">Class2</code> <code role="statement">extends</code> <code role="special">Class1</code> {
    <code role="statement">val</code> field1 = scopeA_privateField
    <code role="statement">val</code> field2 = scopeA_protectedField
    <code role="statement">val</code> field3 = class1_privateField     <code role="comment">// ERROR</code>
    <code role="statement">val</code> field4 = class1_protectedField
    <code role="statement">val</code> field5 = this_privateField       <code role="comment">// ERROR</code>
    <code role="statement">val</code> field6 = this_protectedField
  }
}

<code role="preproc">package</code> scopeB {
  <code role="statement">class</code> <code role="special">Class2B</code> <code role="statement">extends</code> scopeA.<code role="special">Class1</code> {
    <code role="statement">val</code> field1 = scopeA_privateField     <code role="comment">// ERROR</code>
    <code role="statement">val</code> field2 = scopeA_protectedField
    <code role="statement">val</code> field3 = class1_privateField     <code role="comment">// ERROR</code>
    <code role="statement">val</code> field4 = class1_protectedField
    <code role="statement">val</code> field5 = this_privateField       <code role="comment">// ERROR</code>
    <code role="statement">val</code> field6 = this_protectedField
  }
}
</programlisting><para id="para_compiling_scoped_members_yields">Compiling this file
      yields the following output:</para><screen format="linespecific">17: error: not found: value class1_privateField
    val field3 = class1_privateField     // ERROR
                 ^
19: error: not found: value this_privateField
    val field5 = this_privateField       // ERROR
                 ^
26: error: not found: value scopeA_privateField
    val field1 = scopeA_privateField     // ERROR
                 ^
28: error: not found: value class1_privateField
    val field3 = class1_privateField     // ERROR
                 ^
30: error: not found: value this_privateField
    val field5 = this_privateField       // ERROR
                 ^
5 errors found</screen><para id="para_the_first_two_errors_inside_">The first two errors,
      inside <literal moreinfo="none">Class2</literal>, show us that a derived class inside
      the same package can’t reference a member that is scoped private to the
      parent class or <literal moreinfo="none">this</literal>, but it can reference a private
      member scoped to the package (or type) that encloses both
      <literal moreinfo="none">Class1</literal> and <literal moreinfo="none">Class2</literal>.</para><para id="para_in_contrast_for_a_derived_cla">In contrast, for a derived
      class outside the same package, it has no access to any of the scoped
      private members of <literal moreinfo="none">Class1</literal>.</para><para id="para_however_all_the_scoped_protec">However, all the scoped
      protected members are visible in both derived classes.</para><para id="para_we_ll_use_private_for_our_ex">We’ll use scoped private
      declarations for the rest of our examples and discussion, since use of
      scoped private is a little more common in the Scala library than scoped
      protected, when the previous inheritance scenarios aren’t a
      factor.</para><para id="para_first_let_s_start_with_the_mo">First, let’s start with
      the most restrictive visibility, <literal moreinfo="none">private[this]</literal>, as it
      affects type members:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/private-this-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">PrivateClass1</code>(<code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">val</code> privateField1:<code role="type"> Int</code>) {
    <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">val</code> privateField2 = <code role="constant">1</code>

    <code role="statement">def</code> <code role="identifier">equalFields</code>(other:<code role="type"> PrivateClass1</code>) =
      (privateField1 == other.privateField1) &amp;&amp; <code role="comment">// ERROR</code>
      (privateField2 == other.privateField2) &amp;&amp;
      (nested == other.nested)

    <code role="statement">class</code> <code role="special">Nested</code> {
      <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">val</code> nestedField = <code role="constant">1</code>
    }

    <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">val</code> nested = <code role="statement">new</code> <code role="special">Nested</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass2</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>(<code role="constant">1</code>) {
    <code role="statement">val</code> field1 = privateField1  <code role="comment">// ERROR</code>
    <code role="statement">val</code> field2 = privateField2  <code role="comment">// ERROR</code>
    <code role="statement">val</code> nField = <code role="statement">new</code> <code role="special">Nested</code>().nestedField  <code role="comment">// ERROR</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass3</code> {
    <code role="statement">val</code> privateClass1 = <code role="statement">new</code> <code role="special">PrivateClass1</code>(<code role="constant">1</code>)
    <code role="statement">val</code> privateField1 = privateClass1.privateField1  <code role="comment">// ERROR</code>
    <code role="statement">val</code> privateField2 = privateClass1.privateField2  <code role="comment">// ERROR</code>
    <code role="statement">val</code> privateNField = privateClass1.nested.nestedField <code role="comment">// ERROR</code>
  }
}
</programlisting><para id="para_compiling_yields2">Compiling this file yields the
      following output:</para><screen format="linespecific">5: error: value privateField1 is not a member of scopeA.PrivateClass1
            (privateField1 == other.privateField1) &amp;&amp;
                                    ^
14: error: not found: value privateField1
        val field1 = privateField1
                     ^
15: error: not found: value privateField2
        val field2 = privateField2
                     ^
16: error: value nestedField is not a member of PrivateClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
20: error: value privateField1 is not a member of scopeA.PrivateClass1
        val privateField1 = privateClass1.privateField1
                                          ^
21: error: value privateField2 is not a member of scopeA.PrivateClass1
        val privateField2 = privateClass1.privateField2
                                          ^
22: error: value nested is not a member of scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
7 errors found</screen><note id="para_note_lines_6_8_also_won_t_par"><para>Lines 6–8 also won’t parse. Since they are part of the
        expression that started on line 5, the compiler stopped after the
        first error.</para></note><para id="para_the_private_this_members_ar">The
      <literal moreinfo="none">private[this]</literal> members are only visible to the same
      instance. An instance of the same class can’t see
      <literal moreinfo="none">private[this]</literal> members of another instance, so the
      <literal moreinfo="none">equalFields</literal> method won’t parse.</para><para id="para_otherwise_the_visibility_of_c">Otherwise, the visibility
      of class members is the same as <literal moreinfo="none">private</literal> without a
      scope <phrase role="keep-together">specifier</phrase>.</para><para id="para_when_declaring_a_type_with_pr">When declaring a type with
      <literal moreinfo="none">private[this]</literal>, use of <literal moreinfo="none">this</literal>
      effectively binds to the enclosing package, as shown here:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/private-this-pkg-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">class</code> <code role="special">PrivateClass1</code>

  <code role="preproc">package</code> scopeA2 {
    <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">class</code> <code role="special">PrivateClass2</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass3</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>  <code role="comment">// ERROR</code>
  <code role="statement">protected</code> <code role="statement">class</code> <code role="special">PrivateClass4</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code> <code role="comment">// ERROR</code>
  <code role="statement">private</code> <code role="statement">class</code> <code role="special">PrivateClass5</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>
  <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">class</code> <code role="special">PrivateClass6</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>

  <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">class</code> <code role="special">PrivateClass7</code> <code role="statement">extends</code> scopeA2.<code role="special">PrivateClass2</code> <code role="comment">// ERROR</code>
}

<code role="preproc">package</code> scopeB {
  <code role="statement">class</code> <code role="special">PrivateClass1B</code> <code role="statement">extends</code> scopeA.<code role="special">PrivateClass1</code> <code role="comment">// ERROR</code>
}
</programlisting><para id="para_compiling_yields3">Compiling this file yields the
      following output:</para><screen format="linespecific">8: error: private class PrivateClass1 escapes its defining scope as part
of type scopeA.PrivateClass1
    class PrivateClass3 extends PrivateClass1
                                ^
9: error: private class PrivateClass1 escapes its defining scope as part
of type scopeA.PrivateClass1
    protected class PrivateClass4 extends PrivateClass1
                                          ^
13: error: type PrivateClass2 is not a member of package scopeA.scopeA2
    private[this] class PrivateClass7 extends scopeA2.PrivateClass2
                                                      ^
17: error: type PrivateClass1 is not a member of package scopeA
    class PrivateClass1B extends scopeA.PrivateClass1
                                        ^
four errors found</screen><para id="para_in_the_same_package_attemptin">In the same package,
      attempting to declare a <literal moreinfo="none">public</literal> or
      <literal moreinfo="none">protected</literal> subclass fails. Only
      <literal moreinfo="none">private</literal> and <literal moreinfo="none">private[this]</literal>
      subclasses are allowed. Also, <literal moreinfo="none">PrivateClass2</literal> is scoped
      to <literal moreinfo="none">scopeA2</literal>, so you can’t declare it outside
      <literal moreinfo="none">scopeA2</literal>. Similarly, an attempt to declare a class in
      unrelated <literal moreinfo="none">scopeB</literal> using
      <literal moreinfo="none">PrivateClass1</literal> also fails.</para><para id="para_hence_when_applied_to_types_">Hence, when applied to
      types, <literal moreinfo="none">private[this]</literal> is equivalent to Java’s
      <literal moreinfo="none">package private</literal> visibility.</para><para id="para_next_let_s_examine_type_level">Next, let’s examine
      type-level visibility, <literal moreinfo="none">private[T]</literal>, where
      <literal moreinfo="none">T</literal> is a type:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/private-type-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">PrivateClass1</code>(<code role="statement">private</code>[<code role="special">PrivateClass1</code>] <code role="statement">val</code> privateField1:<code role="type"> Int</code>) {
    <code role="statement">private</code>[<code role="special">PrivateClass1</code>] <code role="statement">val</code> privateField2 = <code role="constant">1</code>

    <code role="statement">def</code> <code role="identifier">equalFields</code>(other:<code role="type"> PrivateClass1</code>) =
      (privateField1 == other.privateField1) &amp;&amp;
      (privateField2 == other.privateField2) &amp;&amp;
      (nested  == other.nested)

    <code role="statement">class</code> <code role="special">Nested</code> {
      <code role="statement">private</code>[<code role="special">Nested</code>] <code role="statement">val</code> nestedField = <code role="constant">1</code>
    }

    <code role="statement">private</code>[<code role="special">PrivateClass1</code>] <code role="statement">val</code> nested = <code role="statement">new</code> <code role="special">Nested</code>
    <code role="statement">val</code> nestedNested = nested.nestedField   <code role="comment">// ERROR</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass2</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>(<code role="constant">1</code>) {
    <code role="statement">val</code> field1 = privateField1  <code role="comment">// ERROR</code>
    <code role="statement">val</code> field2 = privateField2  <code role="comment">// ERROR</code>
    <code role="statement">val</code> nField = <code role="statement">new</code> <code role="special">Nested</code>().nestedField  <code role="comment">// ERROR</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass3</code> {
    <code role="statement">val</code> privateClass1 = <code role="statement">new</code> <code role="special">PrivateClass1</code>(<code role="constant">1</code>)
    <code role="statement">val</code> privateField1 = privateClass1.privateField1  <code role="comment">// ERROR</code>
    <code role="statement">val</code> privateField2 = privateClass1.privateField2  <code role="comment">// ERROR</code>
    <code role="statement">val</code> privateNField = privateClass1.nested.nestedField <code role="comment">// ERROR</code>
  }
}
</programlisting><para id="para_compiling_yields4">Compiling this file yields the
      following output:</para><screen format="linespecific">12: error: value nestedField cannot be accessed in PrivateClass1.this.Nested
        val nestedNested = nested.nestedField
                                  ^
15: error: not found: value privateField1
        val field1 = privateField1
                     ^
16: error: not found: value privateField2
        val field2 = privateField2
                     ^
17: error: value nestedField cannot be accessed in PrivateClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
21: error: value privateField1 cannot be accessed in scopeA.PrivateClass1
        val privateField1 = privateClass1.privateField1
                                          ^
22: error: value privateField2 cannot be accessed in scopeA.PrivateClass1
        val privateField2 = privateClass1.privateField2
                                          ^
23: error: value nested cannot be accessed in scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
7 errors found</screen><para id="para_a_private_privateclass1_mem">A
      <literal moreinfo="none">private[PrivateClass1]</literal> member is visible to other
      instances, so the <literal moreinfo="none">equalFields</literal> method now parses.
      Hence, <literal moreinfo="none">private[T]</literal> is not as restrictive as
      <literal moreinfo="none">private[this]</literal>. Note <phrase role="keep-together">that
      <literal moreinfo="none">PrivateClass1</literal> can’t</phrase> see
      <literal moreinfo="none">Nested.nestedField</literal> because that field is declared
      <literal role="keep-together" moreinfo="none">private[Nes⁠ted]</literal>.</para><tip id="para_tip_when_members_of_t_are_d"><para>When members of <literal moreinfo="none">T</literal> are declared
        <literal moreinfo="none">private[T]</literal> the behavior is equivalent to
        <literal moreinfo="none">private</literal>. It is not equivalent to
        <literal moreinfo="none">private[this]</literal>, which is more <phrase role="keep-together">restrictive</phrase>.</para></tip><para id="para_what_if_we_change_the_scope_of">What if we change the
      scope of <literal moreinfo="none">Nested.nestedField</literal> to be
      <literal moreinfo="none">private[PrivateClass1]</literal>? Let’s see how
      <literal moreinfo="none">private[T]</literal> affects nested types:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/private-type-nested-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">PrivateClass1</code> {
    <code role="statement">class</code> <code role="special">Nested</code> {
      <code role="statement">private</code>[<code role="special">PrivateClass1</code>] <code role="statement">val</code> nestedField = <code role="constant">1</code>
    }

    <code role="statement">private</code>[<code role="special">PrivateClass1</code>] <code role="statement">val</code> nested = <code role="statement">new</code> <code role="special">Nested</code>
    <code role="statement">val</code> nestedNested = nested.nestedField
  }

  <code role="statement">class</code> <code role="special">PrivateClass2</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code> {
    <code role="statement">val</code> nField = <code role="statement">new</code> <code role="special">Nested</code>().nestedField   <code role="comment">// ERROR</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass3</code> {
    <code role="statement">val</code> privateClass1 = <code role="statement">new</code> <code role="special">PrivateClass1</code>
    <code role="statement">val</code> privateNField = privateClass1.nested.nestedField <code role="comment">// ERROR</code>
  }
}
</programlisting><para id="para_compiling_yields5">Compiling this file yields the
      following output:</para><screen format="linespecific">10: error: value nestedField cannot be accessed in PrivateClass2.this.Nested
        def nField = new Nested().nestedField
                                  ^
14: error: value nested cannot be accessed in scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
two errors found</screen><para id="para_now_nestedfield_is_visible_t">Now
      <literal moreinfo="none">nestedField</literal> is visible to
      <literal moreinfo="none">PrivateClass1</literal>, but it is still invisible outside of
      <literal moreinfo="none">PrivateClass1</literal>. This is how <literal moreinfo="none">private</literal>
      works in Java.</para><para id="para_let_s_examine_scoping_using_a_">Let’s examine scoping
      using a package name:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/private-pkg-type-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">private</code>[scopeA] <code role="statement">class</code> <code role="special">PrivateClass1</code>

  <code role="preproc">package</code> scopeA2 {
    <code role="statement">private</code> [scopeA2] <code role="statement">class</code> <code role="special">PrivateClass2</code>
    <code role="statement">private</code> [scopeA]  <code role="statement">class</code> <code role="special">PrivateClass3</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass4</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>
  <code role="statement">protected</code> <code role="statement">class</code> <code role="special">PrivateClass5</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>
  <code role="statement">private</code> <code role="statement">class</code> <code role="special">PrivateClass6</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>
  <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">class</code> <code role="special">PrivateClass7</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code>

  <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">class</code> <code role="special">PrivateClass8</code> <code role="statement">extends</code> scopeA2.<code role="special">PrivateClass2</code> <code role="comment">// ERROR</code>
  <code role="statement">private</code>[<code role="statement">this</code>] <code role="statement">class</code> <code role="special">PrivateClass9</code> <code role="statement">extends</code> scopeA2.<code role="special">PrivateClass3</code>
}

<code role="preproc">package</code> scopeB {
  <code role="statement">class</code> <code role="special">PrivateClass1B</code> <code role="statement">extends</code> scopeA.<code role="special">PrivateClass1</code> <code role="comment">// ERROR</code>
}
</programlisting><para id="para_compiling_yields6">Compiling this file yields the
      following output:</para><screen format="linespecific">14: error: class PrivateClass2 cannot be accessed in package scopeA.scopeA2
    private[this] class PrivateClass8 extends scopeA2.PrivateClass2
                                                      ^
19: error: class PrivateClass1 cannot be accessed in package scopeA
    class PrivateClass1B extends scopeA.PrivateClass1
                                        ^
two errors found</screen><para id="para_note_that_privateclass2_can_">Note that
      <literal moreinfo="none">PrivateClass2</literal> can’t be subclassed outside of
      <literal moreinfo="none">scopeA2</literal>, but <literal moreinfo="none">PrivateClass3</literal> can be
      subclassed in <literal moreinfo="none">scopeA</literal>, because it is declared
      <literal moreinfo="none">private[scopeA]</literal>.</para><para id="para_finally_let_s_look_at_the_eff">Finally, let’s look at the
      effect of package-level scoping of type members:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/BasicOOP/scoping/private-pkg-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> scopeA {
  <code role="statement">class</code> <code role="special">PrivateClass1</code> {
    <code role="statement">private</code>[scopeA] <code role="statement">val</code> privateField = <code role="constant">1</code>

    <code role="statement">class</code> <code role="special">Nested</code> {
      <code role="statement">private</code>[scopeA] <code role="statement">val</code> nestedField = <code role="constant">1</code>
    }

    <code role="statement">private</code>[scopeA] <code role="statement">val</code> nested = <code role="statement">new</code> <code role="special">Nested</code>
  }

  <code role="statement">class</code> <code role="special">PrivateClass2</code> <code role="statement">extends</code> <code role="special">PrivateClass1</code> {
    <code role="statement">val</code> field  = privateField
    <code role="statement">val</code> nField = <code role="statement">new</code> <code role="special">Nested</code>().nestedField
  }

  <code role="statement">class</code> <code role="special">PrivateClass3</code> {
    <code role="statement">val</code> privateClass1 = <code role="statement">new</code> <code role="special">PrivateClass1</code>
    <code role="statement">val</code> privateField  = privateClass1.privateField
    <code role="statement">val</code> privateNField = privateClass1.nested.nestedField
  }

  <code role="preproc">package</code> scopeA2 {
    <code role="statement">class</code> <code role="special">PrivateClass4</code> {
      <code role="statement">private</code>[scopeA2] <code role="statement">val</code> field1 = <code role="constant">1</code>
      <code role="statement">private</code>[scopeA]  <code role="statement">val</code> field2 = <code role="constant">2</code>
    }
  }

  <code role="statement">class</code> <code role="special">PrivateClass5</code> {
    <code role="statement">val</code> privateClass4 = <code role="statement">new</code> scopeA2.<code role="special">PrivateClass4</code>
    <code role="statement">val</code> field1 = privateClass4.field1  <code role="comment">// ERROR</code>
    <code role="statement">val</code> field2 = privateClass4.field2
  }
}

<code role="preproc">package</code> scopeB {
  <code role="statement">class</code> <code role="special">PrivateClass1B</code> <code role="statement">extends</code> scopeA.<code role="special">PrivateClass1</code> {
    <code role="statement">val</code> field1 = privateField   <code role="comment">// ERROR</code>
    <code role="statement">val</code> privateClass1 = <code role="statement">new</code> scopeA.<code role="special">PrivateClass1</code>
    <code role="statement">val</code> field2 = privateClass1.privateField  <code role="comment">// ERROR</code>
  }
}
</programlisting><para id="para_compiling_yields7">Compiling this file yields the
      following output:</para><screen format="linespecific">28: error: value field1 cannot be accessed in scopeA.scopeA2.PrivateClass4
        val field1 = privateClass4.field1
                                   ^
35: error: not found: value privateField
        val field1 = privateField
                     ^
37: error: value privateField cannot be accessed in scopeA.PrivateClass1
        val field2 = privateClass1.privateField
                                   ^
three errors found</screen><para id="para_the_only_errors_are_when_we_at">The only errors are when
      we attempt to access members scoped to <literal moreinfo="none">scopeA</literal> from
      the unrelated package <literal moreinfo="none">scopeB</literal> and when we attempt to
      access a member from a nested package <literal moreinfo="none">scopeA2</literal> that is
      scoped to that package.<indexterm class="endofrange" startref="ch05_protectedscope" significance="normal"/><indexterm class="endofrange" startref="ch05_privatescoped" significance="normal"/><indexterm class="endofrange" startref="ch05_visibilityscoped" significance="normal"/><indexterm class="endofrange" startref="ch05_scopevisibility" significance="normal"/></para><tip id="para_tip_when_a_type_or_member_is_"><para>When a type or member is declared <literal moreinfo="none">private[P]</literal>,
        where <literal moreinfo="none">P</literal> is the enclosing package, then it is
        equivalent to Java’s <literal moreinfo="none">package private</literal>
        visibility.</para></tip></sect2><sect2 id="FinalThoughtsVisibility"><title>Final Thoughts on Visibility</title><para id="para_scala_visibility_declarations_">Scala visibility
      declarations are very flexible, and they behave consistently. They
      provide fine-grained control over visibility at all possible scopes,
      from the instance level (<literal role="keep-together" moreinfo="none">private[this]</literal>) up to package-level
      visibility (<literal moreinfo="none">private[P]</literal>, for a package
      <literal moreinfo="none">P</literal>). For example, they make it easier to create
      “components” with types exposed outside of the component’s top-level
      package, while hiding implementation types and type members within the
      “component’s” packages.</para><para id="para_finally_we_have_observed_a_po">Finally, we have observed
      a potential “gotcha” with hidden members of traits.</para><tip id="para_tip_be_careful_when_choosing_"><para>Be careful when choosing the names of members of traits. If two
        traits have a member of the same name and the traits are used in the
        same instance, a name collision will occur even if both members are
        private.</para></tip><para id="para_fortunately_the_parser_catche">Fortunately, the compiler
      catches this problem.<indexterm class="endofrange" startref="ch05_OOPvisibility" significance="normal"/><indexterm class="endofrange" startref="ch05_visibility" significance="normal"/></para></sect2></sect1><sect1 id="BasicOOPRecapAndWhatsNext"><title>Recap and What’s Next</title><para id="para_we_introduced_scala_s_object_m">We introduced the basics of
    Scala’s object model, including constructors, inheritance, nesting of
    classes, and rules for visibility.</para><para id="para_in_the_next_chapter_we_round_">In the next chapter we’ll
    explore Scala’s more advanced OOP features, including overriding,
    companion objects, case classes, and rules for equality between
    objects.<indexterm class="endofrange" significance="normal"/></para></sect1></chapter><chapter id="AdvancedObjectOrientedProgramming"><title>Advanced Object-Oriented Programming In Scala</title><para id="para_we_finish_our_survey_of_scala_">We’ve got the basics of OOP
  in Scala under our belt, but there’s plenty more to learn.<indexterm class="startofrange" id="ch06_OOPoverriding" significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>overriding members of classes and traits</secondary></indexterm></para><sect1 id="OverridingMembers"><title>Overriding Members of Classes and Traits</title><para id="para_classes_and_traits_can_declare">Classes and traits can
    declare <emphasis>abstract</emphasis> members:
    <emphasis>fields</emphasis>, <emphasis>methods</emphasis>, and
    <emphasis>types</emphasis>. These members must be defined by a derived
    class or trait before an instance can be created. Most object-oriented
    languages support abstract methods, and some also support abstract fields
    and types.<indexterm significance="normal"><primary>abstract type members</primary></indexterm><indexterm class="startofrange" id="ch06_overriding" significance="normal"><primary>overriding class and trait members</primary></indexterm><indexterm significance="normal"><primary>override keyword</primary></indexterm></para><note id="para_note_when_overriding_a__concr"><para>When overriding a concrete member, Scala requires the
      <literal moreinfo="none">override</literal> keyword. It is optional when a subtype
      defines (“overrides”) an abstract member. Conversely, don’t use
      <literal moreinfo="none">override</literal> unless you are actually overriding a
      member.</para></note><para id="para_requiring_the_override_keywo">Requiring the
    <literal moreinfo="none">override</literal> keyword has several benefits:</para><itemizedlist><listitem><para>It catches misspelled members that were intended to be
        overrides. The compiler will throw an error that the member doesn’t
        override anything.</para></listitem><listitem><para>It catches a potentially subtle bug that can occur if a new
        member is added to a base class where the member’s name collides with
        an older derived class member that is unknown to the base class
        developer. That is, the derived-class member was never intended to
        override a base-class member. Because the derived class member won’t
        have the <literal moreinfo="none">override</literal> keyword, the compiler will throw
        an error when the new base-class member is introduced.</para></listitem><listitem><para>Having to add the keyword reminds you to consider what members
        should or should not be overridden.</para></listitem></itemizedlist><para id="para_java_has_an_optional_overrid">Java has an optional
    <literal moreinfo="none">@Override</literal> annotation for methods. It helps catch errors
    of the first type (misspellings), but it can’t help with errors of the
    second type, since using the annotation is optional.</para><sect2 id="FinalDeclarations"><title>Attempting to Override final Declarations</title><para id="para_however_if_a_declaration_incl">However, if a declaration
      includes the <literal moreinfo="none">final</literal> keyword, then overriding the
      declaration is prohibited. In the following example, the
      <literal moreinfo="none">fixedMethod</literal> is declared <literal moreinfo="none">final</literal> in
      the parent class. Attempting to compile the example will result in a
      compilation error:<indexterm significance="normal"><primary>final declarations, attempting to override</primary></indexterm><indexterm significance="normal"><primary>overriding class and trait members</primary><secondary>final declarations</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/final-member-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE.</code>

<code role="statement">class</code> <code role="special">NotFixed</code> {
  <code role="statement">final</code> <code role="statement">def</code> <code role="identifier">fixedMethod</code> = <code role="constant">"fixed"</code>
}

<code role="statement">class</code> <code role="special">Changeable2</code> <code role="statement">extends</code> <code role="special">NotFixed</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">fixedMethod</code> = <code role="constant">"not fixed"</code>   <code role="comment">// ERROR</code>
}
</programlisting><para id="para_this_constraint_applies_to_cla">This constraint applies
      to classes and traits as well as members. In this example, the class
      <literal moreinfo="none">Fixed</literal> is declared <literal moreinfo="none">final</literal>, so an
      attempt to derive a new type from it will also fail to compile:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/final-class-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE.</code>

<code role="statement">final</code> <code role="statement">class</code> <code role="special">Fixed</code> {
  <code role="statement">def</code> <code role="identifier">doSomething</code> = <code role="constant">"Fixed did something!"</code>
}

<code role="statement">class</code> <code role="special">Changeable1</code> <code role="statement">extends</code> <code role="special">Fixed</code>     <code role="comment">// ERROR</code>
</programlisting><note id="para_standard_final_classes"><para>Some of the types in the Scala library are final, including JDK
        classes like <literal moreinfo="none">String</literal> and all the “value” types
        derived from <literal moreinfo="none">AnyVal</literal> (see <xref linkend="ScalaTypeHierarchy"/>).</para></note><para id="para_declarations_that_arent_final">For declarations that
      aren’t final, let’s examine the rules and behaviors for overriding,
      starting with methods.</para></sect2><sect2 id="OverridingMethods"><title>Overriding Abstract and Concrete Methods</title><para id="para_let_s_extend_our_earlier_widg">Let’s extend our familiar
      <literal moreinfo="none">Widget</literal> base class with an abstract method
      <literal moreinfo="none">draw</literal>, to support “rendering” the widget to a display,
      web page, etc. We’ll also override a concrete method familiar to any
      Java programmer, <literal moreinfo="none">toString()</literal>, using an ad hoc format.
      As before, we will use a new package, <literal moreinfo="none">ui3</literal>.<indexterm significance="normal"><primary>classes</primary><secondary>overriding abstract and concrete methods</secondary></indexterm><indexterm significance="normal"><primary>methods</primary><secondary>overriding</secondary></indexterm><indexterm significance="normal"><primary>overriding class and trait members</primary><secondary>abstract and concrete methods</secondary></indexterm></para><note id="para_note_drawing_is_actually_a__c"><para>Drawing is actually a <emphasis>cross-cutting
        concern</emphasis>. The state of a <literal moreinfo="none">Widget</literal> is one
        thing; how it is rendered on different platforms, thick clients, web
        pages, mobile devices, etc., is a separate issue. So, drawing is a
        very good candidate for a trait, especially if you want your GUI
        abstractions to be portable. However, to keep things simple, we will
        handle drawing in the <literal moreinfo="none">Widget</literal> hierarchy
        itself.</para></note><para id="para_here_is_the_revised_widget_c">Here is the revised
      <literal moreinfo="none">Widget</literal> class, with <literal moreinfo="none">draw</literal> and
      <literal moreinfo="none">toString</literal> methods:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/ui3/widget.scala</code>

<code role="preproc">package</code> ui3

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Widget</code> {
  <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"(widget)"</code>
}
</programlisting><para id="para_the_draw_method_is_abstract_">The <literal moreinfo="none">draw</literal>
      method is abstract because it has no body; that is, the method isn’t
      followed by an equals sign (<literal moreinfo="none">=</literal>), nor any text after
      it. Therefore, <literal moreinfo="none">Widget</literal> has to be declared
      <literal moreinfo="none">abstract</literal> (it was optional before). Each concrete
      subclass of <literal moreinfo="none">Widget</literal> will have to implement
      <literal moreinfo="none">draw</literal> or rely on a parent class that implements it. We
      don’t need to return anything from <literal moreinfo="none">draw</literal>, so its
      return value is <literal moreinfo="none">Unit</literal>.<indexterm significance="normal"><primary>abstract type members</primary><secondary>overriding abstract methods</secondary></indexterm></para><para id="para_the_tostring_method_is_str">The
      <literal moreinfo="none">toString()</literal> method is straightforward. Since
      <literal moreinfo="none">AnyRef</literal> defines <literal moreinfo="none">toString</literal>, the
      <literal role="keep-together" moreinfo="none">override</literal> keyword is required for
      <literal moreinfo="none">Widget.toString</literal>.</para><para id="para_here_is_the_revised_button_c">Here is the revised
      <literal moreinfo="none">Button</literal> class, with <literal moreinfo="none">draw</literal> and
      <literal moreinfo="none">toString</literal> methods:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/ui3/button.scala</code>

<code role="preproc">package</code> ui3

<code role="statement">class</code> <code role="special">Button</code>(<code role="statement">val</code> label:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Widget</code> <code role="statement">with</code> <code role="special">Clickable</code> {

  <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="comment">// Logic to give the appearance of clicking a button...</code>
  }

  <code role="statement">def</code> <code role="identifier">draw</code>() = {
    <code role="comment">// Logic to draw the button on the display, web page, etc.</code>
  }

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() =
    <code role="constant">"(button: label="</code> + label + <code role="constant">", "</code> + <code role="statement">super</code>.toString() + <code role="constant">")"</code>
}
</programlisting><para id="para__button_implements_the_abstra"><literal moreinfo="none">Button</literal>
      implements the abstract method <literal moreinfo="none">draw</literal>. No
      <literal moreinfo="none">override</literal> keyword is required. <literal role="keep-together" moreinfo="none">Button</literal> also overrides
      <literal moreinfo="none">toString</literal>, so the <literal moreinfo="none">override</literal> keyword
      is required. Note that <literal moreinfo="none">super.toString</literal> is
      called.</para><para id="para_the_super_keyword_is_analogo">The
      <literal moreinfo="none">super</literal> keyword is analogous to
      <literal moreinfo="none">this</literal>, but it binds to the parent type, which is the
      aggregation of the parent class and any mixed-in traits. The search for
      <literal moreinfo="none">super.toString</literal> will find the “closest” parent type
      <literal moreinfo="none">toString</literal>, as determined by the <phrase role="keep-together">linearization</phrase> process (see <xref linkend="Linearization"/>). In this case, since
      <literal moreinfo="none">Clickable</literal> doesn’t define <literal moreinfo="none">toString</literal>,
      <literal moreinfo="none">Widget.toString</literal> will be called.<indexterm significance="normal"><primary>this keyword</primary><secondary>super versus</secondary></indexterm><indexterm significance="normal"><primary>super keyword</primary></indexterm></para><tip id="para_tip_overriding_a_concrete_met"><para>Overriding a concrete method should be done rarely, because it
        is error-prone. Should you invoke the parent method? If so, when? Do
        you call it before doing anything else, or afterward? While the writer
        of the parent method might document the overriding constraints for the
        method, it’s difficult to ensure that the writer of a derived class
        will honor those constraints. A much more robust approach is the
        <emphasis>Template Method Pattern</emphasis> (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>).</para></tip></sect2><sect2 id="OverridingFields"><title>Overriding Abstract and Concrete Fields</title><para id="para_fewer_object_oriented_language">Most object-oriented
      languages allow you to override mutable fields (<literal moreinfo="none">var</literal>).
      Fewer OO languages allow you to define abstract fields or override
      concrete immutable fields (<literal moreinfo="none">val</literal>). For example, it’s
      common for a base class constructor to initialize a mutable field and
      for a derived class constructor to change its value.<indexterm significance="normal"><primary>overriding class and trait members</primary><secondary>abstract and concrete fields</secondary></indexterm><indexterm significance="normal"><primary>fields</primary><secondary>overriding abstract and concrete fields</secondary></indexterm></para><para id="para_we_ll_discuss_overriding_field">We’ll discuss overriding
      fields in traits and classes separately, as traits have some particular
      issues.</para></sect2><sect2 id="OverridingFieldsInTraits"><title>Overriding Abstract and Concrete Fields in Traits</title><para id="para_recall_our_vetoableclicks_tr">Recall our
      <literal moreinfo="none">VetoableClicks</literal> trait in <xref linkend="StackableTraits"/>. It defines a <literal moreinfo="none">val</literal> named
      <literal moreinfo="none">maxAllowed</literal> and initializes it to
      <literal moreinfo="none">1</literal>. We would like the ability to override the value in
      a class that mixes in this trait.<indexterm class="startofrange" id="ch06_traitsoverridefields" significance="normal"><primary>traits</primary><secondary>overriding members of</secondary><tertiary>abstract and concrete fields</tertiary></indexterm><indexterm class="startofrange" id="ch06_fieldstrait" significance="normal"><primary>fields</primary><secondary>overriding abstract and concrete fields in
          traits</secondary></indexterm><indexterm class="startofrange" id="ch06_overridingfieldstrait" significance="normal"><primary>overriding class and trait members</primary><secondary>abstract and concrete fields</secondary><tertiary>in traits</tertiary></indexterm></para><para id="para_unfortunately_in_the_v2_7_x_v">Unfortunately, in Scala
      version 2.7.X, it is not possible to override a <literal moreinfo="none">val</literal>
      defined in a <emphasis>trait</emphasis>. However it is possible to
      override a <literal moreinfo="none">val</literal> defined in a parent
      <emphasis>class</emphasis>. Version 2.8 of Scala does support overriding
      a <literal moreinfo="none">val</literal> in a trait.</para><tip id="para_tip_because_the_override_beha"><para>Because the override behavior for a <literal moreinfo="none">val</literal> in a
        trait is changing, you should avoid relying on the ability to override
        it, if you are currently using Scala version 2.7.X. Use another
        approach instead.</para></tip><para id="para_unfortunately_the_v2_7_x_pars">Unfortunately, the version
      2.7 compiler accepts code that attempts to override a trait-defined
      <literal moreinfo="none">val</literal>, but the override does not actually happen, as
      illustrated by this example:</para><screen format="linespecific">// code-examples/AdvOOP/overrides/trait-val-script.scala
// DANGER! Silent failure to override a trait's "name" (V2.7.5 only).
// Works as expected in V2.8.0.

trait T1 {
  val name = "T1"
}

class Base

class ClassWithT1 extends Base with T1 {
  override val name = "ClassWithT1"
}

val c = new ClassWithT1()
println(c.name)

class ClassExtendsT1 extends T1 {
  override val name = "ClassExtendsT1"
}

val c2 = new ClassExtendsT1()
println(c2.name)</screen><para id="para_if_you_run_this_script_oo1a">If you run this script with
      <literal moreinfo="none">scala</literal> version 2.7.5, the output is the
      following:</para><screen format="linespecific">T1
T1</screen><para id="para_we_might_have_expected_the_two">Reading the script, we
      would have expected the two <literal moreinfo="none">T1</literal> strings to be
      <literal moreinfo="none">ClassWithT1</literal> and <literal moreinfo="none">ClassExtendsT1</literal>,
      respectively.</para><para id="para_however_if_you_run_this_scrip">However, if you run this
      script with <literal moreinfo="none">scala</literal> version 2.8.0, you get this
      output:</para><screen format="linespecific">ClassWithT1
ClassExtendsT1</screen><caution id="para_caution_attempts_to_override_"><para>Attempts to override a trait-defined <literal moreinfo="none">val</literal> will
        be accepted by the compiler, but have no effect in Scala version
        2.7.X.</para></caution><para id="para_there_are_two_workarounds_the">There are three
      workarounds you can use with Scala version 2.7. The first is to use some
      advanced options for <literal moreinfo="none">scala</literal> and
      <literal moreinfo="none">scalac</literal>. The <literal moreinfo="none">-Xfuture</literal> option will
      enable the override behavior supported in version 2.8. The
      <literal moreinfo="none">-Xcheckinit</literal> option will analyze your code and report
      whether the behavior change will break it. The option
      <literal moreinfo="none">-Xexperimental</literal>, which enables many experimental
      changes, will also warn you that the <literal moreinfo="none">val</literal> override
      <phrase role="keep-together">behavior</phrase> is different.</para><para id="para_second_val_override_workaround">The second workaround is
      to make the <literal moreinfo="none">val</literal> abstract in the trait. This forces an
      instance using the trait to assign a value. Declaring a
      <literal moreinfo="none">val</literal> in a trait abstract is a perfectly useful design
      approach for both versions of Scala. In fact, this will be the best
      design choice, when there is no appropriate default value to assign to
      the <literal moreinfo="none">val</literal> in the trait:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/trait-abs-val-script.scala</code>

<code role="statement">trait</code> <code role="special">AbstractT1</code> {
  <code role="statement">val</code> name:<code role="type"> String</code>
}

<code role="statement">class</code> <code role="special">Base</code>

<code role="statement">class</code> <code role="special">ClassWithAbstractT1</code> <code role="statement">extends</code> <code role="special">Base</code> <code role="statement">with</code> <code role="special">AbstractT1</code> {
  <code role="statement">val</code> name = <code role="constant">"ClassWithAbstractT1"</code>
}

<code role="statement">val</code> c = <code role="statement">new</code> <code role="special">ClassWithAbstractT1</code>()
println(c.name)

<code role="statement">class</code> <code role="special">ClassExtendsAbstractT1</code> <code role="statement">extends</code> <code role="special">AbstractT1</code> {
  <code role="statement">val</code> name = <code role="constant">"ClassExtendsAbstractT1"</code>
}

<code role="statement">val</code> c2 = <code role="statement">new</code> <code role="special">ClassExtendsAbstractT1</code>()
println(c2.name)
</programlisting><para id="para_this_script_produces_the_outpu">This script produces the
      output that we would expect:</para><screen format="linespecific">ClassWithAbstractT1
ClassExtendsAbstractT1</screen><para id="para_so_an_abstract_val_works_fi">So, an abstract
      <literal moreinfo="none">val</literal> works fine, <emphasis>unless</emphasis> the field
      is used in the trait body in a way that will fail until the field is
      properly initialized. Unfortunately, the proper initialization won’t
      occur until after the trait’s body has executed. Consider the following
      example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/trait-invalid-init-val-script.scala</code>
<code role="comment">// ERROR: "value" read before initialized.</code>

<code role="statement">trait</code> <code role="special">AbstractT2</code> {
  println(<code role="constant">"In AbstractT2:"</code>)
  <code role="statement">val</code> value:<code role="type"> Int</code>
  <code role="statement">val</code> inverse = <code role="constant">1.0</code>/value      <code role="comment">// ???</code>
  println(<code role="constant">"AbstractT2: value = "</code>+value+<code role="constant">", inverse = "</code>+inverse)
}

<code role="statement">val</code> c2b = <code role="statement">new</code> <code role="special">AbstractT2</code> {
  println(<code role="constant">"In c2b:"</code>)
  <code role="statement">val</code> value = <code role="constant">10</code>
}
println(<code role="constant">"c2b.value = "</code>+c2b.value+<code role="constant">", inverse = "</code>+c2b.inverse)
</programlisting><para id="para_while_it_appears_that_we_are_c">While it appears that we
      are creating an instance of the trait with <literal moreinfo="none">new AbstractT2
      ...</literal>, we are actually using an anonymous class that implicitly
      extends the trait. This script shows what happens when
      <literal moreinfo="none">inverse</literal> is calculated:</para><screen format="linespecific">In AbstractT2:
AbstractT2: value = 0, inverse = Infinity
In c2b:
c2b.value = 10, inverse = Infinity</screen><para id="para_as_you_might_expect_the_inve">As you might expect, the
      <literal moreinfo="none">inverse</literal> is calculated too early. Note that a divide
      by zero exception isn’t thrown; the compiler recognizes the value is
      infinite, but it hasn’t actually “tried” the division yet!</para><para id="para_the_behavior_of_this_script_is">The behavior of this
      script is actually quite subtle. As an exercise, try selectively
      removing (or commenting out) the different <literal moreinfo="none">println</literal>
      statements, one at a time. Observe what happens to the results.
      Sometimes <literal moreinfo="none">inverse</literal> is initialized properly! (Hint:
      remove the <literal moreinfo="none">println("In c2b:")</literal> statement. Then try
      putting it back, but after the <literal moreinfo="none">val value = 10</literal>
      line.)</para><para id="para_what_this_experiment_really_sh">What this experiment
      really shows is that side effects (i.e., from the
      <literal moreinfo="none">println</literal> statements) can be unexpected and subtle,
      especially during initialization. It’s best to avoid them.</para><para id="para_scala_provides_two_solutions_t">Scala provides two
      solutions to this problem: <emphasis>lazy values</emphasis>, which we
      discuss in <xref linkend="LazyVals"/>, and <emphasis>pre-initialized
      fields</emphasis>, which is demonstrated in the following refinement to
      the previous example:<indexterm significance="normal"><primary>pre-initialized fields</primary></indexterm><indexterm significance="normal"><primary>lazy values</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/trait-pre-init-val-script.scala</code>

<code role="statement">trait</code> <code role="special">AbstractT2</code> {
  println(<code role="constant">"In AbstractT2:"</code>)
  <code role="statement">val</code> value:<code role="type"> Int</code>
  <code role="statement">val</code> inverse = <code role="constant">1.0</code>/value
  println(<code role="constant">"AbstractT2: value = "</code>+value+<code role="constant">", inverse = "</code>+inverse)
}

<code role="statement">val</code> c2c = <code role="statement">new</code> {
  <code role="comment">// Only initializations are allowed in pre-init. blocks.</code>
  <code role="comment">// println("In c2c:")</code>
  <code role="statement">val</code> value = <code role="constant">10</code>
} <code role="statement">with</code> <code role="special">AbstractT2</code>

println(<code role="constant">"c2c.value = "</code>+c2c.value+<code role="constant">", inverse = "</code>+c2c.inverse)
</programlisting><para id="para_we_instantiate_an_anonymous_in">We instantiate an
      anonymous inner class, initializing the <literal moreinfo="none">value</literal> field
      in the block, before the <literal moreinfo="none">with AbstractT2</literal> clause. This
      guarantees that <literal moreinfo="none">value</literal> is initialized before the body
      of <literal moreinfo="none">AbstractT2</literal> is executed, as shown when you run the
      script:</para><screen format="linespecific">In AbstractT2:
AbstractT2: value = 10, inverse = 0.1
c2c.value = 10, inverse = 0.1</screen><para id="para_also_if_you_selectively_remov">Also, if you selectively
      remove any of the <literal moreinfo="none">println</literal> statements, you get the
      same expected and now predictable results.</para><para id="para_now_let_s_consider_the_second_">Now let’s consider the
      second workaround we described earlier, changing the declaration to
      <literal moreinfo="none">var</literal>. This solution is more suitable if a good default
      value exists and you don’t want to require instances that use the trait
      to always set the value. In this case, change the <literal moreinfo="none">val</literal>
      to a <literal moreinfo="none">var</literal>, either a public <literal moreinfo="none">var</literal> or a
      private <literal moreinfo="none">var</literal> hidden behind reader and writer methods.
      Either way, we can simply reassign the value in a derived trait or
      class.</para><para id="para_returning_to_our_vetoableclic">Returning to our
      <literal moreinfo="none">VetoableClicks</literal> example, here is the modified
      <literal moreinfo="none">VetoableClicks</literal> trait that uses a public
      <literal moreinfo="none">var</literal> for <literal moreinfo="none">maxAllowed</literal>:</para><?dbfo-need height=”1in”
?><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/ui3/vetoable-clicks.scala</code>

<code role="preproc">package</code> ui3
<code role="preproc">import</code> observer._

<code role="statement">trait</code> <code role="special">VetoableClicks</code> <code role="statement">extends</code> <code role="special">Clickable</code> {
  <code role="statement">var</code> maxAllowed = <code role="constant">1</code>       <code role="comment">// default</code>
  <code role="statement">private</code> <code role="statement">var</code> count = <code role="constant">0</code>
  <code role="statement">abstract</code> <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
    count += <code role="constant">1</code>
    <code role="statement">if</code> (count &lt;= maxAllowed)
      <code role="statement">super</code>.click()
  }
}
</programlisting><para id="para_here_is_a_new_specs_object">Here is a new
      <literal moreinfo="none">specs</literal> object,
      <literal moreinfo="none">ButtonClickableObserverVetoableSpec2</literal>, that
      demonstrates changing the value of <literal moreinfo="none">maxAllowed</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/ui3/button-clickable-observer-vetoable2-spec.scala</code>
<code role="preproc">package</code> ui3

<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._
<code role="preproc">import</code> ui.ButtonCountObserver

<code role="statement">object</code> <code role="special">ButtonClickableObserverVetoableSpec2</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"A Button Observer with Vetoable Clicks"</code> should {
    <code role="constant">"observe only the first 'maxAllowed' clicks"</code> in {
      <code role="statement">val</code> observableButton =
        <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"Okay"</code>) <code role="statement">with</code> <code role="special">ObservableClicks</code> <code role="statement">with</code> <code role="special">VetoableClicks</code> {
          maxAllowed = <code role="constant">2</code>
      }
      observableButton.maxAllowed mustEqual <code role="constant">2</code>
      <code role="statement">val</code> buttonClickCountObserver = <code role="statement">new</code> <code role="special">ButtonCountObserver</code>
      observableButton.addObserver(buttonClickCountObserver)
      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      buttonClickCountObserver.count mustEqual <code role="constant">2</code>
    }
  }
}
</programlisting><para id="para_no_override_var_is_required_">No <literal moreinfo="none">override
      var</literal> is required. We just assign a new value. Since the body of
      the trait is executed before the body of the class using it, reassigning
      the field value happens <emphasis>after</emphasis> the initial
      assignment in the trait’s body. However, as we saw before, that
      reassignment could happen too late if the field is used in the trait’s
      body in some calculation that will become invalid by a reassignment
      later! You can avoid this problem if you make the field private and
      define a public writer method that redoes any dependent
      calculations.</para><para id="para_another_disadvantage_of_using_">Another disadvantage of
      using a <literal moreinfo="none">var</literal> declaration is that
      <literal moreinfo="none">maxAllowed</literal> was not intended to be writable. As we
      will see in <xref linkend="FunctionalProgramming"/>, read-only values
      have important benefits. We would prefer for
      <literal moreinfo="none">maxAllowed</literal> to be read-only, at least after the
      construction process completes.</para><para id="para_we_can_see_that_the_simple_act">We can see that the
      simple act of changing the <literal moreinfo="none">val</literal> to a
      <literal moreinfo="none">var</literal> causes potential problems for the maintainer of
      <literal moreinfo="none">VetoableClicks</literal>. Control over that field is now lost.
      The maintainer must carefully consider whether or not the value will
      change and if a change will invalidate the state of the instance. This
      issue is especially pernicious in multithreaded systems (see <xref linkend="ProblemsOfSharedSynchronizedState"/>).<indexterm class="endofrange" startref="ch06_traitsoverridefields" significance="normal"/><indexterm class="endofrange" startref="ch06_overridingfieldstrait" significance="normal"/><indexterm class="endofrange" startref="ch06_fieldstrait" significance="normal"/></para><tip id="para_tip_avoid_var_fields_when_p"><para>Avoid <literal moreinfo="none">var</literal> fields when possible (in classes as
        well as traits). Consider public <literal moreinfo="none">var</literal> fields
        especially risky.</para></tip></sect2><sect2 id="OverridingFieldsInClasses"><title>Overriding Abstract and Concrete Fields in Classes</title><para id="para_in_contrast_to_traits_overrid">In contrast to traits,
      overriding a <literal moreinfo="none">val</literal> declared in a class works as
      expected. Here is an example with both a <literal moreinfo="none">val</literal> override
      and a <literal moreinfo="none">var</literal> reassignment in a derived class:<indexterm significance="normal"><primary>overriding class and trait members</primary><secondary>abstract and concrete fields</secondary><tertiary>in classes</tertiary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>overriding abstract and concrete fields in</secondary></indexterm><indexterm significance="normal"><primary>fields</primary><secondary>overriding abstract and concrete fields in
          classes</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/class-field-script.scala</code>

<code role="statement">class</code> <code role="special">C1</code> {
  <code role="statement">val</code> name = <code role="constant">"C1"</code>
  <code role="statement">var</code> count = <code role="constant">0</code>
}

<code role="statement">class</code> <code role="special">ClassWithC1</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">val</code> name = <code role="constant">"ClassWithC1"</code>
  count = <code role="constant">1</code>
}

<code role="statement">val</code> c = <code role="statement">new</code> <code role="special">ClassWithC1</code>()
println(c.name)
println(c.count)
</programlisting><para id="para_the_override_keyword_is_requ">The
      <literal moreinfo="none">override</literal> keyword is required for the
      <emphasis>concrete</emphasis> <literal moreinfo="none">val</literal> field
      <literal moreinfo="none">name</literal>, but not for the <literal moreinfo="none">var</literal> field
      <literal moreinfo="none">count</literal>. This is because we are changing the
      initialization of a constant (<literal moreinfo="none">val</literal>), which is a
      “special” operation.</para><para id="para_if_you_run_this_script_oo1b">If you run this script, the
      output is the following:</para><screen format="linespecific">ClassWithC1
1</screen><para id="para_both_fields_are_overridden_in_">Both fields are
      overridden in the derived class, as expected. Here is the same example
      modified so that both the <literal moreinfo="none">val</literal> and the
      <literal moreinfo="none">var</literal> are abstract in the base class:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/class-abs-field-script.scala</code>

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">AbstractC1</code> {
  <code role="statement">val</code> name:<code role="type"> String</code>
  <code role="statement">var</code> count:<code role="type"> Int</code>
}

<code role="statement">class</code> <code role="special">ClassWithAbstractC1</code> <code role="statement">extends</code> <code role="special">AbstractC1</code> {
  <code role="statement">val</code> name = <code role="constant">"ClassWithAbstractC1"</code>
  <code role="statement">var</code> count = <code role="constant">1</code>
}

<code role="statement">val</code> c = <code role="statement">new</code> <code role="special">ClassWithAbstractC1</code>()
println(c.name)
println(c.count)
</programlisting><para id="para_the_override_keyword_is_not_">The
      <literal moreinfo="none">override</literal> keyword is not required for
      <literal moreinfo="none">name</literal> in <literal moreinfo="none">ClassWithAbstractC1</literal>, since
      the original declaration is abstract. The output of this script is the
      following:</para><screen format="linespecific">ClassWithAbstractC1
1</screen><para id="para_it_s_important_to_emphasize_th">It’s important to
      emphasize that <literal moreinfo="none">name</literal> and <literal moreinfo="none">count</literal> are
      <emphasis>abstract</emphasis> fields, not concrete fields with default
      values. A similar-looking declaration of <literal moreinfo="none">name</literal> in a
      Java class, <literal role="keep-together" moreinfo="none">String name;</literal>, would
      declare a concrete field with the default value (<literal moreinfo="none">null</literal>
      in this case). Java doesn’t support abstract fields or types (as we’ll
      discuss next), only methods.<indexterm class="startofrange" id="ch06_overrideabstracttypes" significance="normal"><primary>overriding class and trait members</primary><secondary>abstract types</secondary></indexterm></para></sect2><sect2 id="OverridingAbstractTypes"><title>Overriding Abstract Types</title><para id="para_we_introduced_abstract_type_de">We introduced abstract
      type declarations in <xref linkend="AbstractTypesAndParameterizedTypes"/>. Recall the
      <literal moreinfo="none">BulkReader</literal> example from that section:<indexterm class="startofrange" id="ch06_abstracttypeoverride" significance="normal"><primary>abstract types</primary><secondary>overriding</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/abstract-types-script.scala</code>

<code role="preproc">import</code> java.io._

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code>
  <code role="statement">val</code> source:<code role="type"> In</code>
  <code role="statement">def</code> <code role="identifier">read</code>:<code role="type"> String</code>
}

<code role="statement">class</code> <code role="special">StringBulkReader</code>(<code role="statement">val</code> source:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code> = <code role="special">String</code>
  <code role="statement">def</code> <code role="identifier">read</code> = source
}

<code role="statement">class</code> <code role="special">FileBulkReader</code>(<code role="statement">val</code> source:<code role="type"> File</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code> = <code role="special">File</code>
  <code role="statement">def</code> <code role="identifier">read</code> = {
    <code role="statement">val</code> in = <code role="statement">new</code> <code role="special">BufferedInputStream</code>(<code role="statement">new</code> <code role="special">FileInputStream</code>(source))
    <code role="statement">val</code> numBytes = in.available()
    <code role="statement">val</code> bytes = <code role="statement">new</code> <code role="special">Array</code><code role="special">[Byte]</code>(numBytes)
    in.read(bytes, <code role="constant">0</code>, numBytes)
    <code role="statement">new</code> <code role="special">String</code>(bytes)
  }
}

println( <code role="statement">new</code> <code role="special">StringBulkReader</code>(<code role="constant">"Hello Scala!"</code>).read )
println( <code role="statement">new</code> <code role="special">FileBulkReader</code>(<code role="statement">new</code> <code role="special">File</code>(<code role="constant">"abstract-types-script.scala"</code>)).read )
</programlisting><para id="para_abstract_types_are_an_alternat">Abstract types are an
      alternative to parameterized types, which we’ll explore in <xref linkend="ParameterizedTypes"/>. Like parameterized types, they provide
      an abstraction mechanism at the type level.</para><para id="para_the_example_shows_how_to_decla">The example shows how to
      declare an abstract type and how to define a concrete value in derived
      classes. <literal moreinfo="none">BulkReader</literal> declares <literal moreinfo="none">type
      In</literal> without initializing it. The concrete derived class
      <literal moreinfo="none">StringBulkReader</literal> provides a concrete value using
      <literal moreinfo="none">type In = String</literal>.</para><para id="para_unlike_fields_and_methods_it_">Unlike fields and methods,
      it is not possible to override a concrete <literal moreinfo="none">type</literal>
      definition. However, the abstract declaration can constrain the allowed
      concrete type values. We’ll learn how in <xref linkend="ScalasTypeSystem"/>.</para><para id="para_finally_you_probably_noticed_">Finally, you probably
      noticed that this example also demonstrates defining an abstract field,
      using a constructor parameter, and an abstract method.</para><para id="para_for_another_example_let_s_rev">For another example, let’s
      revisit our <literal moreinfo="none">Subject</literal> trait from <xref linkend="TraitsAsMixins"/>. The definition of the
      <literal moreinfo="none">Observer</literal> type is a <emphasis>structural
      type</emphasis> with a method named <literal moreinfo="none">receiveUpdate</literal>.
      Observers must have this “structure.” Let’s generalize the
      implementation now, using an abstract type:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/observer/observer2.scala</code>

<code role="preproc">package</code> observer

<code role="statement">trait</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code>

  <code role="statement">private</code> <code role="statement">var</code> observers = <code role="special">List</code><code role="special">[Observer]</code>()
  <code role="statement">def</code> <code role="identifier">addObserver</code>(observer:<code role="type">Observer</code>) = observers ::= observer
  <code role="statement">def</code> <code role="identifier">notifyObservers</code> = observers foreach (notify(<code role="statement">_</code>))

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code>
}

<code role="statement">trait</code> <code role="special">SubjectForReceiveUpdateObservers</code> <code role="statement">extends</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = { <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> Any</code>) }

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code> = observer.receiveUpdate(<code role="statement">this</code>)
}

<code role="statement">trait</code> <code role="special">SubjectForFunctionalObservers</code> <code role="statement">extends</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = (<code role="special">AbstractSubject</code>) <code role="statement">=&gt;</code> <code role="special">Unit</code>

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code> = observer(<code role="statement">this</code>)
}
</programlisting><para id="para_now_abstractsubject_declare">Now,
      <literal moreinfo="none">AbstractSubject</literal> declares <literal moreinfo="none">type
      Observer</literal> as abstract (implicitly, because there is no
      definition). Since the original structural type is gone, we don’t know
      exactly how to notify an observer. So, we also added an abstract method
      <literal moreinfo="none">notify</literal>, which a concrete class or trait will define
      as appropriate.</para><para id="para_the_subjectforreceiveupdateob">The
      <literal moreinfo="none">SubjectForReceiveUpdateObservers</literal> derived trait
      defines <literal moreinfo="none">Observer</literal> with the same structural type we
      used in the original example, and <literal moreinfo="none">notify</literal> simply calls
      <literal role="keep-together" moreinfo="none">receiveUpdate</literal>, as before.</para><para id="para_the_subjectforfunctionalobser">The
      <literal moreinfo="none">SubjectForFunctionalObservers</literal> derived trait defines
      <literal moreinfo="none">Observer</literal> to be a function taking an instance of
      <literal moreinfo="none">AbstractSubject</literal> and returning
      <literal moreinfo="none">Unit</literal>. All <literal moreinfo="none">notify</literal> has to do is call
      the observer function, passing the subject as the sole argument. Note
      that this implementation is similar to the approach we used in our
      original button implementation, <literal moreinfo="none">ButtonWithCallbacks</literal>,
      where the “callbacks” were user-supplied functions. (See <xref linkend="IntroducingTraits"/> and a revisited version in <xref linkend="Constructors"/>.)</para><para id="para_here_is_a_specification_that_e">Here is a specification
      that exercises these two variations, observing button clicks as
      before:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/observer/button-observer2-spec.scala</code>

<code role="preproc">package</code> ui
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._

<code role="statement">object</code> <code role="special">ButtonObserver2Spec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"An Observer watching a SubjectForReceiveUpdateObservers button"</code> should {
    <code role="constant">"observe button clicks"</code> in {
      <code role="statement">val</code> observableButton =
        <code role="statement">new</code> <code role="special">Button</code>(name) <code role="statement">with</code> <code role="special">SubjectForReceiveUpdateObservers</code> {
        <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
          <code role="statement">super</code>.click()
          notifyObservers
        }
      }
      <code role="statement">val</code> buttonObserver = <code role="statement">new</code> <code role="special">ButtonCountObserver</code>
      observableButton.addObserver(buttonObserver)
      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      buttonObserver.count mustEqual <code role="constant">3</code>
    }
  }
  <code role="constant">"An Observer watching a SubjectForFunctionalObservers button"</code> should {
    <code role="constant">"observe button clicks"</code> in {
      <code role="statement">val</code> observableButton =
        <code role="statement">new</code> <code role="special">Button</code>(name) <code role="statement">with</code> <code role="special">SubjectForFunctionalObservers</code> {
        <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
          <code role="statement">super</code>.click()
          notifyObservers
        }
      }
      <code role="statement">var</code> count = <code role="constant">0</code>
      observableButton.addObserver((button) <code role="statement">=&gt;</code> count += <code role="constant">1</code>)
      <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) observableButton.click()
      count mustEqual <code role="constant">3</code>
    }
  }
}
</programlisting><para id="para_first_we_exercise_subjectforr">First we exercise
      <literal moreinfo="none">SubjectForReceiveUpdateObservers</literal>, which looks very
      similar to our earlier examples. Next we exercise
      <literal moreinfo="none">SubjectForFunctionalObservers</literal>. In this case, we don’t
      need another “observer” instance at all. We just maintain a
      <literal moreinfo="none">count</literal> variable and pass a <emphasis>function
      literal</emphasis> to <literal moreinfo="none">addObserver</literal> to increment the
      count (and ignore the button).</para><para id="para_the_main_virtue_of_subjectfor">The main virtue of
      <literal moreinfo="none">SubjectForFunctionalObservers</literal> is its minimalism. It
      requires no special instances, no traits defining abstractions, etc. For
      many cases, it is an ideal approach.</para><para id="para__abstractsubject_is_more_reus"><literal moreinfo="none">AbstractSubject</literal>
      is more reusable than the original definition of
      <literal moreinfo="none">Subject</literal>, because it imposes fewer constraints on
      potential observers.</para><note id="para_note_abstractsubject_illust"><para><literal moreinfo="none">AbstractSubject</literal> illustrates that an
        abstraction with fewer concrete details is usually more
        reusable.</para></note><para id="para_but_wait_there_s_more_we_ll_">But wait, there’s more!
      We’ll revisit the use of abstract types and the Observer Pattern in
      <xref linkend="ScalableAbstractions"/>.<indexterm class="endofrange" startref="ch06_overrideabstracttypes" significance="normal"/><indexterm class="endofrange" startref="ch06_abstracttypeoverride" significance="normal"/></para></sect2><sect2 id="UniformAccessPrinciple"><title>When Accessor Methods and Fields Are Indistinguishable: The
      Uniform Access Principle</title><para id="para_suppose_a_user_of_buttoncount">Suppose a user of
      <literal moreinfo="none">ButtonCountObserver</literal> from <xref linkend="TraitsAsMixins"/> accesses the <literal moreinfo="none">count</literal>
      member:<indexterm class="startofrange" id="ch06_overridemethodsfields" significance="normal"><primary>overriding class and trait members</primary><secondary>accessor methods indistinguishable from
          fields</secondary></indexterm><indexterm class="startofrange" id="ch06_methodsaccessor" significance="normal"><primary>methods</primary><secondary>overriding accessor methods indistinguishable from
          fields</secondary></indexterm><indexterm class="startofrange" id="ch06_fieldsaccessor" significance="normal"><primary>fields</primary><secondary>indistinguishable from accessor methods,
          overriding</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/ui/button-count-observer-script.scala</code>

<code role="statement">val</code> bco = <code role="statement">new</code> ui.<code role="special">ButtonCountObserver</code>
<code role="statement">val</code> oldCount = bco.count
bco.count = <code role="constant">5</code>
<code role="statement">val</code> newCount = bco.count
println(newCount + <code role="constant">" == 5 and "</code> + oldCount + <code role="constant">" == 0?"</code>)
</programlisting><para id="para_when_the_count_field_is_read">When the
      <literal moreinfo="none">count</literal> field is read or written, as in this example,
      are methods called or is the field accessed directly? As originally
      declared in <literal moreinfo="none">ButtonCountObserver</literal>, the field is
      accessed directly. However, the user doesn’t really care. In fact, the
      following two definitions are functionally equivalent, from the
      perspective of the user:</para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">ButtonCountObserver</code> {
  <code role="statement">var</code> count = <code role="constant">0</code>  <code role="comment">// public field access (original definition)</code>
  <code role="comment">// ...</code>
}
</programlisting><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">ButtonCountObserver</code> {
  <code role="statement">private</code> <code role="statement">var</code> cnt = <code role="constant">0</code>  <code role="comment">// private field</code>
  <code role="statement">def</code> <code role="identifier">count</code> = cnt      <code role="comment">// reader method</code>
  <code role="statement">def</code> <code role="identifier">count_</code>=(newCount:<code role="type"> Int</code>) = cnt = newCount  <code role="comment">// writer method</code>
  <code role="comment">// ...</code>
}
</programlisting><para id="para_this_equivalence_in_scala_is_c">This equivalence is an
      example of the <emphasis>Uniform Access Principle</emphasis>. Clients
      read and write field values as if they are publicly accessible, even
      though in some cases they are actually calling methods. The maintainer
      of <literal moreinfo="none">ButtonCountObserver</literal> has the freedom to change the
      implementation without forcing users to make code changes.<indexterm significance="normal"><primary>Uniform Access Principle</primary></indexterm></para><para id="para_the_reader_method_in_the_secon">The reader method in the
      second version does not have parentheses. Recall that consistency in the
      use of parentheses is required if a method definition omits parentheses.
      This is only possible if the method takes no arguments. For the Uniform
      Access Principle to work, we want to define field reader methods without
      parentheses. (Contrast that with Ruby, where method parentheses are
      always optional as long as the parse is <phrase role="keep-together">unambiguous</phrase>.)<indexterm significance="normal"><primary>( ) (parentheses)</primary><secondary>omitting in method definitions</secondary></indexterm></para><para id="para_the_writer_method_has_the_form">The writer method has the
      format <literal moreinfo="none">count_=(...)</literal>. As a bit of syntactic sugar, the
      compiler allows invocations of methods with this format to be written in
      either of the following ways:</para><programlisting language="scala" format="linespecific">obj.field_=(newValue)
<code role="comment">// or</code>
obj.field = newValue
</programlisting><para id="para_we_named_the_private_variable_">We named the private
      variable <literal moreinfo="none">cnt</literal> in the alternative definition. Scala
      keeps field and method names in the <emphasis>same</emphasis> namespace,
      which means we can’t name the field <literal moreinfo="none">count</literal> if a method
      is named <literal moreinfo="none">count</literal>. Many languages, like Java, don’t have
      this restriction because they keep field and method names in separate
      namespaces. However, these languages can’t support the Uniform Access
      Principle as a result, unless they build in ad hoc support in their
      grammars or compilers.</para><para id="para_object_in_member_namespace">Since member
      <literal moreinfo="none">object</literal> definitions behave similar to fields from the
      caller’s perspective, they are also in the same namespace as methods and
      fields. Hence, the following class would not compile:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/member-namespace-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="statement">class</code> <code role="special">IllegalMemberNameUse</code> {
  <code role="statement">def</code> <code role="identifier">member</code>(i:<code role="type"> Int</code>) = <code role="constant">2</code> * i
  <code role="statement">val</code> member = <code role="constant">2</code>         <code role="comment">// ERROR</code>
  <code role="statement">object</code> <code role="special">member</code> {        <code role="comment">// ERROR</code>
    <code role="statement">def</code> <code role="identifier">apply</code>() = <code role="constant">2</code>
  }
}
</programlisting><para id="para_there_is_one_other_benefit_of_">There is one other
      benefit of this namespace “unification.” If a parent class declares a
      parameterless method, then a subclass can override that method with a
      <literal moreinfo="none">val</literal>. If the parent’s method is concrete, then the
      <literal moreinfo="none">override</literal> keyword is required:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/method-field-class-script.scala</code>

<code role="statement">class</code> <code role="special">Parent</code> {
  <code role="statement">def</code> <code role="identifier">name</code> = <code role="constant">"Parent"</code>
}

<code role="statement">class</code> <code role="special">Child</code> <code role="statement">extends</code> <code role="special">Parent</code> {
  <code role="statement">override</code> <code role="statement">val</code> name = <code role="constant">"Child"</code>
}

println(<code role="statement">new</code> <code role="special">Child</code>().name)   <code role="comment">// =&gt; "Child"</code>
</programlisting><para id="para_if_the_parent_s_method_is_abst">If the parent’s method is
      abstract, then the <literal moreinfo="none">override</literal> keyword is
      optional:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/abs-method-field-class-script.scala</code>

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">AbstractParent</code> {
  <code role="statement">def</code> <code role="identifier">name</code>:<code role="type"> String</code>
}

<code role="statement">class</code> <code role="special">ConcreteChild</code> <code role="statement">extends</code> <code role="special">AbstractParent</code> {
  <code role="statement">val</code> name = <code role="constant">"Child"</code>
}

println(<code role="statement">new</code> <code role="special">ConcreteChild</code>().name)   <code role="comment">// =&gt; "Child"</code>
</programlisting><para id="para_this_also_works_for_traits_if">This also works for
      traits. If the trait’s method is concrete, we have the
      following:<indexterm significance="normal"><primary>traits</primary><secondary>overriding accessor methods indistinguishable from
          fields</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/method-field-trait-script.scala</code>

<code role="statement">trait</code> <code role="special">NameTrait</code> {
  <code role="statement">def</code> <code role="identifier">name</code> = <code role="constant">"NameTrait"</code>
}

<code role="statement">class</code> <code role="special">ConcreteNameClass</code> <code role="statement">extends</code> <code role="special">NameTrait</code> {
  <code role="statement">override</code> <code role="statement">val</code> name = <code role="constant">"ConcreteNameClass"</code>
}

println(<code role="statement">new</code> <code role="special">ConcreteNameClass</code>().name)   <code role="comment">// =&gt; "ConcreteNameClass"</code>
</programlisting><para id="para_if_the_trait_s_method_is_abstr">If the trait’s method is
      abstract, we have the following:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/overrides/abs-method-field-trait-script.scala</code>

<code role="statement">trait</code> <code role="special">AbstractNameTrait</code> {
  <code role="statement">def</code> <code role="identifier">name</code>:<code role="type"> String</code>
}

<code role="statement">class</code> <code role="special">ConcreteNameClass</code> <code role="statement">extends</code> <code role="special">AbstractNameTrait</code> {
  <code role="statement">val</code> name = <code role="constant">"ConcreteNameClass"</code>
}

println(<code role="statement">new</code> <code role="special">ConcreteNameClass</code>().name)   <code role="comment">// =&gt; "ConcreteNameClass"</code>
</programlisting><para id="para_why_is_this_feature_useful_it">Why is this feature
      useful? It allows derived classes and traits to use a simple field
      access when that is sufficient, or a method call when more processing is
      required, such as lazy initialization. The same argument holds for the
      Uniform Access Principle, in general.</para><para id="para_overriding_a_def_with_a_val">Overriding a
      <literal moreinfo="none">def</literal> with a <literal moreinfo="none">val</literal> in a subclass can
      also be handy when interoperating with Java code. Turn a getter into a
      <literal moreinfo="none">val</literal> by placing it in the constructor. You’ll see this
      in action in the following example, in which our Scala class
      <literal moreinfo="none">Person</literal> implements a hypothetical
      <literal moreinfo="none">PersonInterface</literal> from some legacy Java code:</para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">Person</code>(<code role="statement">val</code> getName:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">PersonInterface</code>
</programlisting><para id="para_if_you_only_have_a_few_accesso">If you only have a few
      accessors in the Java code you’re integrating with, this technique makes
      quick work of them.</para><para id="para_what_about_overriding_a_parame">What about overriding a
      parameterless method with a <literal moreinfo="none">var</literal>, or overriding a
      <literal moreinfo="none">val</literal> or <literal moreinfo="none">var</literal> with a method? These
      are not permitted because they can’t match the behaviors of the things
      they are overriding.</para><para id="para_if_you_attempt_to_use_a_var_">If you attempt to use a
      <literal moreinfo="none">var</literal> to override a parameterless method, you get an
      error that the writer method, <literal moreinfo="none">override name_=</literal>, is not
      overriding anything. This would also be inconsistent with a
      philosophical goal of functional programming, that a method that takes
      no parameters should always return the same result. To do otherwise
      would require side effects in the implementation, which functional
      programming tries to avoid, for reasons we will examine in <xref linkend="FunctionalProgramming"/>. Because a <literal moreinfo="none">var</literal> is
      changeable, the no-parameter “method” defined in the parent type would
      no longer return the same result consistently.</para><para id="para_if_you_could_override_a_val_">If you could override a
      <literal moreinfo="none">val</literal> with a method, there would be no way for Scala to
      guarantee that the method would always return the same value, consistent
      with <literal moreinfo="none">val</literal> semantics. That issue doesn’t exist with a
      <literal moreinfo="none">var</literal>, of course, but you would have to override the
      <literal moreinfo="none">var</literal> with two methods, a reader and a writer. The
      Scala compiler doesn’t support that substitution.<indexterm class="endofrange" startref="ch06_fieldsaccessor" significance="normal"/><indexterm class="endofrange" startref="ch06_methodsaccessor" significance="normal"/><indexterm class="endofrange" startref="ch06_overridemethodsfields" significance="normal"/><indexterm class="endofrange" startref="ch06_overriding" significance="normal"/><indexterm class="endofrange" startref="ch06_OOPoverriding" significance="normal"/></para></sect2></sect1><sect1 id="CompanionObjects"><title>Companion Objects</title><para id="para_recall_that_fields_and_methods">Recall that fields and
    methods defined in <literal moreinfo="none">objects</literal> serve the role that class
    “static” fields and methods serve in languages like Java. When
    <literal moreinfo="none">object</literal>-based fields and methods are closely associated
    with a particular <literal moreinfo="none">class</literal>, they are normally defined in a
    <emphasis>companion object</emphasis>.<indexterm class="startofrange" id="ch06_companionobj" significance="normal"><primary>companion objects</primary></indexterm><indexterm class="startofrange" id="ch06_OOPcompanionobjs" significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>companion objects</secondary></indexterm></para><para id="para_we_mentioned_companion_objects">We mentioned companion
    objects briefly in <xref linkend="IntroducingScala"/>, and we discussed
    the <literal moreinfo="none">Pair</literal> example from the Scala library in <xref linkend="TypeLessDoMore"/>. Let’s fill in the remaining details
    now.</para><para id="para_first_recall_that_if_a_class">First, recall that if a
    <literal moreinfo="none">class</literal> (or a <literal moreinfo="none">type</literal> referring to a
    class) and an <literal moreinfo="none">object</literal> are declared in the same file, in
    the same package, and with the same name, they are called a
    <emphasis>companion class</emphasis> (or <emphasis>companion
    type</emphasis>) and a <emphasis>companion object</emphasis>,
    respectively.<indexterm significance="normal"><primary>companion classes</primary></indexterm></para><para id="para_there_is_no_namespace_collisio">There is no namespace
    collision when the name is reused in this way, because Scala stores the
    class name in the type namespace, while it stores the object name in the
    term namespace (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>).</para><para id="para_the_two_most_interesting_metho">The two most interesting
    methods frequently defined in a companion object are
    <literal moreinfo="none">apply</literal> and <literal moreinfo="none">unapply</literal>.</para><sect2 id="ApplyMethod"><title>Apply</title><para id="para_scala_defines_a_form_of_syntac">Scala provides some
      syntactic sugar in the form of the <literal moreinfo="none">apply</literal> method. When
      an instance of a class is followed by parentheses with a list of zero or
      more parameters, the compiler invokes the <literal moreinfo="none">apply</literal>
      method for that instance. This is true for an <literal moreinfo="none">object</literal>
      with a defined <literal moreinfo="none">apply</literal> method (such as a companion
      object), as well as an instance of a <literal moreinfo="none">class</literal> that
      defines an <literal moreinfo="none">apply</literal> method.<indexterm significance="normal"><primary>Pair class</primary><secondary>apply method</secondary></indexterm><indexterm class="startofrange" id="ch06_applymethod" significance="normal"><primary>apply method</primary></indexterm><indexterm class="startofrange" id="ch06_companionapply" significance="normal"><primary>companion objects</primary><secondary>apply method</secondary></indexterm></para><para id="para_in_the_case_of_an_object_a">In the case of an
      <literal moreinfo="none">object</literal>, <literal moreinfo="none">apply</literal> is conventionally
      used as a <emphasis>factory</emphasis> method, returning a new instance.
      This is what <literal moreinfo="none">Pair.apply</literal> does in the Scala library.
      Here is <literal moreinfo="none">Pair</literal> from the standard library:<indexterm significance="normal"><primary>factory methods, apply method as</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">type</code> <code role="special">Pair</code><code role="special">[+A, +B]</code> = <code role="special">Tuple2</code><code role="special">[A, B]</code>
<code role="statement">object</code> <code role="special">Pair</code> {
  <code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[A, B]</code>(x:<code role="type"> A</code>, y:<code role="type"> B</code>) = <code role="special">Tuple2</code>(x, y)
  <code role="statement">def</code> <code role="identifier">unapply</code><code role="identifier">[A, B]</code>(x:<code role="type"> Tuple2[A, B]</code>):<code role="type"> Option[Tuple2[A, B]]</code> = <code role="special">Some</code>(x)
}
</programlisting><para id="para_so_you_can_create_a_new_pair_">So, you can create a new
      <literal moreinfo="none">Pair</literal> as follows:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> p = <code role="special">Pair</code>(<code role="constant">1</code>, <code role="constant">"one"</code>)
</programlisting><para id="para_it_looks_like_we_are_some_how_">It looks like we are
      somehow creating a <literal moreinfo="none">Pair</literal> instance without a
      <literal moreinfo="none">new</literal>. Rather than calling a <literal moreinfo="none">Pair</literal>
      constructor directly, we are actually calling
      <literal moreinfo="none">Pair.apply</literal> (i.e., the companion object
      <literal moreinfo="none">Pair</literal>), which then calls
      <literal moreinfo="none">Tuple2.apply</literal> on the <literal moreinfo="none">Tuple2</literal>
      companion object!</para><tip id="para_tip_if_there_are_several_alte"><para>If there are several alternative constructors for a class and it
        also has a companion object, consider defining fewer constructors on
        the class and defining several overloaded <literal moreinfo="none">apply</literal>
        methods on the companion object to handle the variations.</para></tip><para id="para_however_apply_is_not_limite">However,
      <literal moreinfo="none">apply</literal> is not limited to instantiating the companion
      class. It could instead return an instance of a subclass of the
      companion class. Here is an example where we define a companion object
      <literal moreinfo="none">Widget</literal> that uses regular expressions to parse a
      string representing a <literal moreinfo="none">Widget</literal> subclass. When a match
      occurs, the subclass is instantiated and the new instance is
      returned:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/widget.scala</code>

<code role="preproc">package</code> objects

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Widget</code> {
  <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"(widget)"</code>
}

<code role="statement">object</code> <code role="special">Widget</code> {
  <code role="statement">val</code> ButtonExtractorRE = <code role="constant">"""\(button: label=([^,]+),\s+\(Widget\)\)"""</code>.r
  <code role="statement">val</code> TextFieldExtractorRE = <code role="constant">"""\(textfield: text=([^,]+),\s+\(Widget\)\)"""</code>.r

  <code role="statement">def</code> <code role="identifier">apply</code>(specification:<code role="type"> String</code>):<code role="type"> Option[Widget]</code> = specification <code role="statement">match</code> {
    <code role="statement">case</code> <code role="special">ButtonExtractorRE</code>(label)   <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">Some</code>(<code role="statement">new</code> <code role="special">Button</code>(label))
    <code role="statement">case</code> <code role="special">TextFieldExtractorRE</code>(text) <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">Some</code>(<code role="statement">new</code> <code role="special">TextField</code>(text))
    <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> <code role="special">None</code>
  }
}
</programlisting><para id="para__widget_apply_receives_a_stri"><literal moreinfo="none">Widget.apply</literal>
      receives a string “specification” that defines which class to
      instantiate. The string might come from a configuration file with
      widgets to create at startup, for example. The string format is the same
      format used by <literal moreinfo="none">toString()</literal>. Regular expressions are
      defined for each type. (<emphasis>Parser combinators</emphasis> are an
      alternative. They are discussed in <xref linkend="ExternalDSLsWithCombinatorParsers"/>.)</para><para id="para_the_match_expression_applies">The
      <literal moreinfo="none">match</literal> expression applies each regular expression to
      the string. A case expression like:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="special">ButtonExtractorRE</code>(label) <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">Some</code>(<code role="statement">new</code> <code role="special">Button</code>(label))
</programlisting><para id="para_means_that_the_string_is_match">means that the string is
      matched against the <literal moreinfo="none">ButtonExtractorRE</literal> regular
      expression. If successful, it extracts the substring in the first
      capture group in the regular expression and assigns it to the variable
      <literal moreinfo="none">label</literal>. Finally, a new <literal moreinfo="none">Button</literal> with
      this label is created, wrapped in a <literal moreinfo="none">Some</literal>. We’ll learn
      how this extraction process works in the next section, <xref linkend="UnapplyMethod"/>.</para><para id="para_a_similar_case_handles_textfi">A similar case handles
      <literal moreinfo="none">TextField</literal> creation. (<literal moreinfo="none">TextField</literal> is
      not shown. See the online code examples.) Finally, if
      <literal moreinfo="none">apply</literal> can’t match the string, it returns
      <literal moreinfo="none">None</literal>.</para><para id="para_specs_exercise">Here is a <literal moreinfo="none">specs</literal>
      <literal moreinfo="none">object</literal> that exercises
      <literal moreinfo="none">Widget.apply</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/widget-apply-spec.scala</code>

<code role="preproc">package</code> objects
<code role="preproc">import</code> org.specs._

<code role="statement">object</code> <code role="special">WidgetApplySpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"Widget.apply with a valid widget specification string"</code> should {
    <code role="constant">"return a widget instance with the correct fields set"</code> in {
      <code role="special">Widget</code>(<code role="constant">"(button: label=click me, (Widget))"</code>) <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">Some</code>(w) <code role="statement">=&gt;</code> w <code role="statement">match</code> {
          <code role="statement">case</code> b:<code role="type">Button =&gt; b.label</code> mustEqual <code role="constant">"click me"</code>
          <code role="statement">case</code> x <code role="statement">=&gt;</code> fail(x.toString())
        }
        <code role="statement">case</code> <code role="special">None</code> <code role="statement">=&gt;</code> fail(<code role="constant">"None returned."</code>)
      }
      <code role="special">Widget</code>(<code role="constant">"(textfield: text=This is text, (Widget))"</code>) <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">Some</code>(w) <code role="statement">=&gt;</code> w <code role="statement">match</code> {
          <code role="statement">case</code> tf:<code role="type">TextField =&gt; tf.text</code> mustEqual <code role="constant">"This is text"</code>
          <code role="statement">case</code> x <code role="statement">=&gt;</code> fail(x.toString())
        }
        <code role="statement">case</code> <code role="special">None</code> <code role="statement">=&gt;</code> fail(<code role="constant">"None returned."</code>)
      }
    }
  }
  <code role="constant">"Widget.apply with an invalid specification string"</code> should {
    <code role="constant">"return None"</code> in {
      <code role="special">Widget</code>(<code role="constant">"(button: , (Widget)"</code>) mustEqual <code role="special">None</code>
    }
  }
}
</programlisting><para id="para_the_first_match_statement_impl">The first match statement
      implicitly invokes <literal moreinfo="none">Widget.apply</literal> with the string
      <literal moreinfo="none">"(button: label=click me, (Widget))"</literal>. If a button
      wrapped in a <literal moreinfo="none">Some</literal> is not returned with the label
      <literal moreinfo="none">"click me"</literal>, this test will fail. Next, a similar test
      for a <literal moreinfo="none">TextField</literal> widget is done. The final test uses
      an invalid string and confirms that <literal moreinfo="none">None</literal> is
      returned.</para><para id="para_a_drawback_of_this_particular_">A drawback of this
      particular implementation is that we have hardcoded a dependency on each
      derived class of <literal moreinfo="none">Widget</literal> in <literal moreinfo="none">Widget</literal>
      itself, which breaks the <emphasis>Open-Closed Principle</emphasis> (see
      <link linkend="Meyer1997" xrefstyle="select:nopage">[Meyer1997]</link>
      and <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>). A better implementation
      would use a factory design pattern from <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>. Nevertheless, the example
      illustrates how an <literal role="keep-together" moreinfo="none">apply</literal> method
      can be used as a real factory.</para><para id="para_there_is_no_requirement_for_a">There is no requirement
      for <literal moreinfo="none">apply</literal> in an <literal moreinfo="none">object</literal> to be used
      as a factory. Neither is there any restriction on the argument list or
      what <literal moreinfo="none">apply</literal> returns. However, because it is so common
      to use <literal moreinfo="none">apply</literal> in an <literal moreinfo="none">object</literal> as a
      factory, use caution when using <literal moreinfo="none">apply</literal> for other
      purposes, as it could confuse users. However, there are good
      counterexamples, such as the use of <literal moreinfo="none">apply</literal> in
      Domain-Specific Languages (see <xref linkend="DomainSpecificLanguages"/>).</para><para id="para_the_factory_convention_is_less">The factory convention is
      less commonly used for <literal moreinfo="none">apply</literal> defined in classes. For
      example, in the Scala standard library, <literal moreinfo="none">Array.apply(i:
      int)</literal> returns the element at index <literal moreinfo="none">i</literal> in the
      array. Many of the other collections use <literal moreinfo="none">apply</literal> in a
      similar way. So, users can write code like the following:<indexterm significance="normal"><primary>Array class</primary><secondary>apply method</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">val</code> a = <code role="special">Array</code>(<code role="constant">1</code>,<code role="constant">2</code>,<code role="constant">3</code>,<code role="constant">4</code>)
println(a(<code role="constant">2</code>))  <code role="comment">// =&gt; 3</code>
</programlisting><para id="para_finally_as_a_reminder_althou">Finally, as a reminder,
      although <literal moreinfo="none">apply</literal> is handled specially by the compiler,
      it is otherwise no different from any other method. You can overload it,
      you can invoke it directly, etc.<indexterm class="endofrange" startref="ch06_companionapply" significance="normal"/><indexterm class="endofrange" startref="ch06_applymethod" significance="normal"/></para></sect2><sect2 id="UnapplyMethod"><title>Unapply</title><para id="para_the_name_unapply_suggests_th">The name
      <literal moreinfo="none">unapply</literal> suggests that it does the “opposite”
      operation of <literal moreinfo="none">apply</literal>. Indeed, it is used to extract the
      constituent parts of an instance. Pattern matching uses this feature
      extensively. Hence, <literal moreinfo="none">unapply</literal> is often defined in
      companion objects and is used to extract the field values from instances
      of the corresponding companion types. For this reason,
      <literal moreinfo="none">unapply</literal> methods are called
      <emphasis>extractors</emphasis>.<indexterm significance="normal"><primary>extractors</primary><secondary>unapply methods</secondary></indexterm><indexterm class="startofrange" id="ch06_companionunapply" significance="normal"><primary>companion objects</primary><secondary>unapply method</secondary></indexterm><indexterm class="startofrange" id="ch06_unapply" significance="normal"><primary>unapply method</primary></indexterm></para><para id="para_here_is_an_expanded_button_sc">Here is an expanded
      <literal moreinfo="none">button.scala</literal> with a <literal moreinfo="none">Button</literal>
      <literal moreinfo="none">object</literal> that defines an <literal moreinfo="none">unapply</literal>
      extractor method:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/button.scala</code>

<code role="preproc">package</code> objects
<code role="preproc">import</code> ui3.Clickable

<code role="statement">class</code> <code role="special">Button</code>(<code role="statement">val</code> label:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Widget</code> <code role="statement">with</code> <code role="special">Clickable</code> {

  <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="comment">// Logic to give the appearance of clicking a button...</code>
  }

  <code role="statement">def</code> <code role="identifier">draw</code>() = {
    <code role="comment">// Logic to draw the button on the display, web page, etc.</code>
  }

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"(button: label="</code>+label+<code role="constant">", "</code>+<code role="statement">super</code>.toString()+<code role="constant">")"</code>
}

<code role="statement">object</code> <code role="special">Button</code> {
  <code role="statement">def</code> <code role="identifier">unapply</code>(button:<code role="type"> Button</code>) = <code role="special">Some</code>(button.label)
}
</programlisting><para id="para__button_unapply_takes_a_singl"><literal moreinfo="none">Button.unapply</literal>
      takes a single <literal moreinfo="none">Button</literal> argument and returns a
      <literal moreinfo="none">Some</literal> wrapping the <literal moreinfo="none">label</literal> value.
      This demonstrates the protocol for <literal moreinfo="none">unapply</literal> methods.
      They return a <literal moreinfo="none">Some</literal> wrapping the extracted fields.
      (We’ll see how to handle more than one field in a moment.)</para><para id="para_specs_button_unapply">Here is a <literal moreinfo="none">specs</literal>
      <literal moreinfo="none">object</literal> that exercises
      <literal moreinfo="none">Button.unapply</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/button-unapply-spec.scala</code>

<code role="preproc">package</code> objects
<code role="preproc">import</code> org.specs._

<code role="statement">object</code> <code role="special">ButtonUnapplySpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"Button.unapply"</code> should {
    <code role="constant">"match a Button object"</code> in {
      <code role="statement">val</code> b = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"click me"</code>)
      b <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">Button</code>(label) <code role="statement">=&gt;</code>
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fail()
      }
    }
    <code role="constant">"match a RadioButton object"</code> in {
      <code role="statement">val</code> b = <code role="statement">new</code> <code role="special">RadioButton</code>(<code role="constant">false</code>, <code role="constant">"click me"</code>)
      b <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">Button</code>(label) <code role="statement">=&gt;</code>
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fail()
      }
    }
    <code role="constant">"not match a non-Button object"</code> in {
      <code role="statement">val</code> tf = <code role="statement">new</code> <code role="special">TextField</code>(<code role="constant">"hello world!"</code>)
      tf <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">Button</code>(label) <code role="statement">=&gt;</code> fail()
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code>
      }
    }
    <code role="constant">"extract the Button's label"</code> in {
      <code role="statement">val</code> b = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"click me"</code>)
      b <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">Button</code>(label) <code role="statement">=&gt;</code> label mustEqual <code role="constant">"click me"</code>
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fail()
      }
    }
    <code role="constant">"extract the RadioButton's label"</code> in {
      <code role="statement">val</code> rb = <code role="statement">new</code> <code role="special">RadioButton</code>(<code role="constant">false</code>, <code role="constant">"click me, too"</code>)
      rb <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">Button</code>(label) <code role="statement">=&gt;</code> label mustEqual <code role="constant">"click me, too"</code>
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fail()
      }
    }
  }
}
</programlisting><para id="para_the_first_three_examples_in_">The first three examples
      (<literal moreinfo="none">in</literal> clauses) confirm that
      <literal moreinfo="none">Button.unapply</literal> is only called for actual
      <literal moreinfo="none">Button</literal> instances or instances of derived classes,
      like <literal moreinfo="none">RadioButton</literal>.</para><para id="para_since_unapply_takes_a_butto">Since
      <literal moreinfo="none">unapply</literal> takes a <literal moreinfo="none">Button</literal> argument
      (in this case), the Scala runtime type checks the instance being
      matched. It then looks for a companion object with an
      <literal moreinfo="none">unapply</literal> method and invokes that method, passing the
      instance. The default case clause <literal moreinfo="none">case _</literal> is invoked
      for the instances that don’t type check as compatible. The pattern
      matching process is fully type-safe.</para><para id="para_the_remaining_examples_in_c">The remaining examples
      (<literal moreinfo="none">in</literal> clauses) confirm that the correct values for the
      <literal moreinfo="none">label</literal> are extracted. The Scala runtime automatically
      extracts the item in the <literal moreinfo="none">Some</literal>.</para><para id="para_what_about_extracting_multiple">What about extracting
      multiple fields? For a fixed set of known fields, a
      <literal moreinfo="none">Some</literal> wrapping a <literal moreinfo="none">Tuple</literal> is returned,
      as shown in this updated version of
      <literal moreinfo="none">RadioButton</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/radio-button.scala</code>

<code role="preproc">package</code> objects

<code role="comment">/**</code>
<code role="comment"> * Button with two states, on or off, like an old-style,</code>
<code role="comment"> * channel-selection botton on a radio.</code>
<code role="comment"> */</code>
<code role="statement">class</code> <code role="special">RadioButton</code>(<code role="statement">val</code> on:<code role="type"> Boolean</code>, label:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Button</code>(label)

<code role="statement">object</code> <code role="special">RadioButton</code> {
  <code role="statement">def</code> <code role="identifier">unapply</code>(button:<code role="type"> RadioButton</code>) = <code role="special">Some</code>((button.on, button.label))
                 <code role="comment">// equivalent to: = Some(Pair(button.on, button.label))</code>
}
</programlisting><para id="para_a_some_wrapping_a_pair_butt">A <literal moreinfo="none">Some</literal>
      wrapping a <literal moreinfo="none">Pair(button.on, button.label)</literal> is returned.
      As we discuss in <xref linkend="PredefObject"/>,
      <literal moreinfo="none">Pair</literal> is a <emphasis>type</emphasis> defined to be
      equal to <literal moreinfo="none">Tuple2</literal>. Here is the corresponding
      <literal moreinfo="none">specs</literal> <literal moreinfo="none">object</literal> that tests
      it<indexterm class="endofrange" startref="ch06_unapply" significance="normal"/><indexterm class="endofrange" startref="ch06_companionunapply" significance="normal"/>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/radio-button-unapply-spec.scala</code>

<code role="preproc">package</code> objects
<code role="preproc">import</code> org.specs._

<code role="statement">object</code> <code role="special">RadioButtonUnapplySpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"RadioButton.unapply"</code> should {
    <code role="constant">"should match a RadioButton object"</code> in {
      <code role="statement">val</code> b = <code role="statement">new</code> <code role="special">RadioButton</code>(<code role="constant">true</code>, <code role="constant">"click me"</code>)
      b <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">RadioButton</code>(on, label) <code role="statement">=&gt;</code>
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fail()
      }
    }
    <code role="constant">"not match a Button (parent class) object"</code> in {
      <code role="statement">val</code> b = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"click me"</code>)
      b <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">RadioButton</code>(on, label) <code role="statement">=&gt;</code> fail()
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code>
      }
    }
    <code role="constant">"not match a non-RadioButton object"</code> in {
      <code role="statement">val</code> tf = <code role="statement">new</code> <code role="special">TextField</code>(<code role="constant">"hello world!"</code>)
      tf <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">RadioButton</code>(on, label) <code role="statement">=&gt;</code> fail()
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code>
      }
    }
    <code role="constant">"extract the RadioButton's on/off state and label"</code> in {
      <code role="statement">val</code> b = <code role="statement">new</code> <code role="special">RadioButton</code>(<code role="constant">true</code>, <code role="constant">"click me"</code>)
      b <code role="statement">match</code> {
        <code role="statement">case</code> <code role="special">RadioButton</code>(on, label) <code role="statement">=&gt;</code> {
          label mustEqual <code role="constant">"click me"</code>
          on    mustEqual <code role="constant">true</code>
        }
        <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fail()
      }
    }
  }
}
</programlisting></sect2><sect2 id="UnapplySeqMethod"><title>Apply and UnapplySeq for Collections</title><para id="para_what_if_you_want_to_build_a_co">What if you want to build
      a collection from a variable argument list passed to
      <literal moreinfo="none">apply</literal>? What if you want to extract the first few
      elements from a collection and you don’t care about the rest of
      it?<indexterm significance="normal"><primary>apply method</primary><secondary>for collections</secondary></indexterm><indexterm significance="normal"><primary>companion objects</primary><secondary>apply and unapplySeq methods for collections</secondary></indexterm><indexterm significance="normal"><primary>collections</primary><secondary>apply and unapplySeq methods</secondary></indexterm></para><para id="para_in_this_case_you_define_appl">In this case, you define
      <literal moreinfo="none">apply</literal> and <literal moreinfo="none">unapplySeq</literal> (“unapply
      sequence”) methods. Here are those methods from Scala’s own
      <literal moreinfo="none">List</literal> class:<indexterm significance="normal"><primary>List class</primary><secondary>apply and unapplySeq methods</secondary></indexterm><indexterm significance="normal"><primary>unapplySeq method for collections</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[A]</code>(xs:<code role="type"> A</code>*):<code role="type"> List[A]</code> = xs.toList

<code role="statement">def</code> <code role="identifier">unapplySeq</code><code role="identifier">[A]</code>(x:<code role="type"> List[A]</code>):<code role="type"> Some[List[A]]</code> = <code role="special">Some</code>(x)
</programlisting><para id="para_the_a_type_parameterizatio">The <literal moreinfo="none">[A]</literal>
      type parameterization on these methods allows the
      <literal moreinfo="none">List</literal> <literal moreinfo="none">object</literal>, which is not
      parameterized, to construct a new <literal moreinfo="none">List[A]</literal>. (See <xref linkend="ParameterizedTypes"/> for more details.) Most of the time, the
      type parameter will be inferred based on the context.</para><para id="para_the_parameter_list_xs_a_is">The parameter list
      <literal moreinfo="none">xs: A*</literal> is a variable argument list. Callers of
      <literal moreinfo="none">apply</literal> can pass as many <literal moreinfo="none">A</literal> instances
      as they want, including none. Internally, variable argument lists are
      stored in an <literal moreinfo="none">Array[A]</literal>, which inherits the
      <literal moreinfo="none">toList</literal> method from <literal moreinfo="none">Iterable</literal> that
      we used here.</para><tip id="para_tip_this_is_a_handy_idiom_for"><para>This is a handy idiom for API writers. Accepting variable
        arguments to a function can be convenient for users, and converting
        the arguments to a <literal moreinfo="none">List</literal> is often ideal for internal
        management.</para></tip><para id="para_here_is_an_example_script_that">Here is an example script
      that uses <literal moreinfo="none">List.apply</literal> implicitly:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/list-apply-example-script.scala</code>

<code role="statement">val</code> list1 = <code role="special">List</code>()
<code role="statement">val</code> list2 = <code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2.2</code>, <code role="constant">"three"</code>, <code role="special">'four</code>)
<code role="statement">val</code> list3 = <code role="special">List</code>(<code role="constant">"1"</code>, <code role="constant">"2.2"</code>, <code role="constant">"three"</code>, <code role="constant">"four"</code>)
println(<code role="constant">"1: "</code>+list1)
println(<code role="constant">"2: "</code>+list2)
println(<code role="constant">"3: "</code>+list3)
</programlisting><para id="para_the_four_is_a__symbol__ess">The <literal moreinfo="none">'four</literal>
      is a <emphasis>symbol</emphasis>, essentially an interned string.
      Symbols are more commonly used in Ruby, for example, where the same
      symbol would be written as <literal moreinfo="none">:four</literal>. Symbols are useful
      for representing identities consistently.<indexterm significance="normal"><primary>symbols</primary></indexterm></para><para id="para_this_script_yields_the_followi">This script yields the
      following output:</para><screen format="linespecific">1: List()
2: List(1, 2.2, three, 'four)
3: List(1, 2.2, three, four)</screen><para id="para_the_unapplyseq_method_is_tri">The
      <literal moreinfo="none">unapplySeq</literal> method is trivial; it returns the input
      list wrapped in a <literal moreinfo="none">Some</literal>. However, this is sufficient
      for pattern matching, as shown in this example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/list-unapply-example-script.scala</code>

<code role="statement">val</code> list = <code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2.2</code>, <code role="constant">"three"</code>, <code role="special">'four</code>)
list <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">List</code>(x, y, <code role="statement">_</code>*) <code role="statement">=&gt;</code> println(<code role="constant">"x = "</code>+x+<code role="constant">", y = "</code>+y)
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> <code role="statement">throw</code> <code role="statement">new</code> <code role="special">Exception</code>(<code role="constant">"No match! "</code>+list)
}
</programlisting><para id="para_the_list_x_y___syntax_m">The <literal moreinfo="none">List(x, y,
      _*)</literal> syntax means we will only match on a list with at least
      two elements, and the first two elements will be assigned to
      <literal moreinfo="none">x</literal> and <literal moreinfo="none">y</literal>. We don’t care about the
      rest of the list. The <literal moreinfo="none">_*</literal> matches zero or more
      remaining elements.</para><para id="para_out2">The output is the following:</para><screen format="linespecific">x = 1, y = 2.2</screen><para id="para_we_ll_have_much_more_to_say_ab">We’ll have much more to
      say about <literal moreinfo="none">List</literal> and pattern matching in <xref linkend="ListsInFunctionalProgramming"/>.</para></sect2><sect2 id="CompanionObjectsAndJavaStaticMethods"><title>Companion Objects and Java Static Methods</title><para id="para_there_is_one_more_thing_to_kno">There is one more thing
      to know about companion objects. Whenever you define a
      <literal moreinfo="none">main</literal> method to use as the entry point for an
      application, Scala requires you to put it in an object. However, at the
      time of this writing, <literal moreinfo="none">main</literal> methods cannot be defined
      in a companion object. Because of implementation details in the
      generated code, the JVM won’t find the <literal moreinfo="none">main</literal> method.
      This issue may be resolved in a future release. For now, you must define
      any <literal moreinfo="none">main</literal> method in a <emphasis>singleton</emphasis>
      object (i.e., a “non-companion” object; see <link linkend="ScalaTips" xrefstyle="select:nopage">[ScalaTips]</link>). Consider the following
      example of a simple <literal moreinfo="none">Person</literal> class and companion object
      that attempts to define <literal moreinfo="none">main</literal>:<indexterm class="startofrange" id="ch06_Javamethods" significance="normal"><primary>Java</primary><secondary>static methods, companion objects and</secondary></indexterm><indexterm significance="normal"><primary>singleton objects</primary></indexterm><indexterm class="startofrange" id="ch06_methodsJavastatic" significance="normal"><primary>methods</primary><secondary>Java static methods and companion objects</secondary></indexterm><indexterm class="startofrange" id="ch06_companionobjsJava" significance="normal"><primary>companion objects</primary><secondary>Java static methods and</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/person.scala</code>

<code role="preproc">package</code> objects

<code role="statement">class</code> <code role="special">Person</code>(<code role="statement">val</code> name:<code role="type"> String</code>, <code role="statement">val</code> age:<code role="type"> Int</code>) {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = <code role="constant">"name: "</code> + name + <code role="constant">", age: "</code> + age
}

<code role="statement">object</code> <code role="special">Person</code> {
  <code role="statement">def</code> <code role="identifier">apply</code>(name:<code role="type"> String</code>, age:<code role="type"> Int</code>) = <code role="statement">new</code> <code role="special">Person</code>(name, age)
  <code role="statement">def</code> <code role="identifier">unapply</code>(person:<code role="type"> Person</code>) = <code role="special">Some</code>((person.name, person.age))

  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) = {
    <code role="comment">// Test the constructor...</code>
    <code role="statement">val</code> person = <code role="statement">new</code> <code role="special">Person</code>(<code role="constant">"Buck Trends"</code>, <code role="constant">18</code>)
    assert(person.name == <code role="constant">"Buck Trends"</code>)
    assert(person.age  == <code role="constant">21</code>)
  }
}

<code role="statement">object</code> <code role="special">PersonTest</code> {
  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) = Person.main(args)
}
</programlisting><para id="para_this_code_compiles_fine_but_i">This code compiles fine,
      but if you attempt to invoke <literal moreinfo="none">Person.main</literal>, using
      <literal moreinfo="none">scala -cp ... objects.Person</literal>, you get the following
      error:</para><screen format="linespecific">java.lang.NoSuchMethodException: objects.Person.main([Ljava.lang.String;)</screen><para id="para_the_objects_person_class_fil">The
      <literal moreinfo="none">objects/Person.class</literal> file exists. If you decompile it
      with <literal moreinfo="none">javap -classpath ... objects.Person</literal> (refer to
      <xref linkend="CommandLineToolDecompilers"/>), you can see that it
      doesn’t contain a <literal moreinfo="none">main</literal> method. If you decompile
      <literal moreinfo="none">objects/Person$.class</literal>, the file for the companion
      object’s byte code, it has a <literal moreinfo="none">main</literal> method, but notice
      that it isn’t declared <literal moreinfo="none">static</literal>. So, attempting to
      invoke <literal moreinfo="none">scala -⁠cp ... objects.Person$</literal> also fails to
      find the “static” <literal moreinfo="none">main</literal>:</para><screen format="linespecific">java.lang.NoSuchMethodException: objects.Person$.main is not static</screen><para id="para_the_separate__singleton__objec">The separate
      <emphasis>singleton</emphasis> object <literal moreinfo="none">PersonTest</literal>
      defined in this example has to be used. Decompiling it with
      <literal moreinfo="none">javap -classpath ... objects.PersonTest</literal> shows that it
      has a <literal moreinfo="none">static main</literal> method. If you invoke it using
      <literal moreinfo="none">scala -cp ... objects.PersonTest</literal>, the
      <literal moreinfo="none">PersonTest.main</literal> method is invoked, which in turn
      invokes <literal moreinfo="none">Person.main</literal>. You get an assertion error from
      the second call to <literal moreinfo="none">assert</literal>, which is
      intentional:</para><screen format="linespecific">java.lang.AssertionError: assertion failed
    at scala.Predef$.assert(Predef.scala:87)
    at objects.Person$.test(person.scala:15)
    at objects.PersonTest$.main(person.scala:20)
    at objects.PersonTest.main(person.scala)
    ...</screen><para id="para_general_problem_with_statics_and_companions">In fact,
      this is a general issue with methods defined in companion objects that
      need to be visible to Java code as static methods. They aren’t static in
      the byte code. You have to put these methods in singleton objects
      instead. Consider the following Java class that attempts to create a
      user with <literal moreinfo="none">Person.apply</literal>:</para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/PersonUserWontCompile.java</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> objects;

<code role="type">public</code> <code role="type">class</code> PersonUserWontCompile {
  <code role="type">public</code> <code role="type">static</code> <code role="type">void</code> main(String[] args) {
    Person buck = Person.apply(<code role="constant">"Buck Trends"</code>, <code role="constant">100</code>);  <code role="comment">// ERROR</code>
    System.out.println(buck);
  }
}
</programlisting><para id="para_if_we_compile_it_after_compil">If we compile it (after
      compiling <literal moreinfo="none">Person.scala</literal>), we get the following
      error:</para><screen format="linespecific">$ javac -classpath ... objects/PersonUserWontCompile.java
objects/PersonUserWontCompile.java:5: cannot find symbol
symbol  : method apply(java.lang.String,int)
location: class objects.Person
        Person buck = Person.apply("Buck Trends", 100);
                            ^
1 error</screen><para id="para_however_we_can_use_the_follow">However, we can use the
      following singleton object:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/person-factory.scala</code>

<code role="preproc">package</code> objects

<code role="statement">object</code> <code role="special">PersonFactory</code> {
  <code role="statement">def</code> <code role="identifier">make</code>(name:<code role="type"> String</code>, age:<code role="type"> Int</code>) = <code role="statement">new</code> <code role="special">Person</code>(name, age)
}
</programlisting><para id="para_now_the_following_java_class_w">Now the following Java
      class will compile:</para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/AdvOOP/objects/PersonUser.java</code>

<code role="preproc">package</code> objects;

<code role="type">public</code> <code role="type">class</code> PersonUser {
  <code role="type">public</code> <code role="type">static</code> <code role="type">void</code> main(String[] args) {
    <code role="comment">// The following line won't compile.</code>
    <code role="comment">// Person buck = Person.apply("Buck Trends", 100);</code>
    Person buck = PersonFactory.make(<code role="constant">"Buck Trends"</code>, <code role="constant">100</code>);
    System.out.println(buck);
  }
}
</programlisting><warning id="para_warning_do_not_main_methods"><para>Do not define <literal moreinfo="none">main</literal> or any other method in a
        <emphasis>companion</emphasis> object that needs to be visible to Java
        code as a <literal moreinfo="none">static</literal> method. Define it in a
        <emphasis>singleton</emphasis> object, instead.</para></warning><para id="para_calling_companion_object_methods_from_java">If you have
      no other choice but to call a method in a companion object from Java,
      you can explicitly create an instance of the object with
      <literal moreinfo="none">new</literal>, since the object is a “regular” Java class in
      the byte code, and call the method on the instance.<indexterm class="endofrange" startref="ch06_Javamethods" significance="normal"/><indexterm class="startofrange" startref="ch06_companionobjsJava" significance="normal"/><indexterm class="endofrange" startref="ch06_methodsJavastatic" significance="normal"/><indexterm class="endofrange" startref="ch06_companionobj" significance="normal"/><indexterm class="endofrange" startref="ch06_OOPcompanionobjs" significance="normal"/></para></sect2></sect1><sect1 id="CaseClasses"><title>Case Classes</title><para id="para_in_matchingoncaseclasses_i">In <xref linkend="MatchingOnCaseClasses"/>, we briefly introduced you to
    <emphasis>case classes</emphasis>. Case classes have several useful
    features, but also some drawbacks.<indexterm class="startofrange" id="ch06_caseclasses" significance="normal"><primary>case classes</primary></indexterm><indexterm class="startofrange" id="ch06_OOPcaseclasses" significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>case classes</secondary></indexterm></para><para id="para_let_s_rewrite_the_shape_exam">Let’s rewrite the
    <literal moreinfo="none">Shape</literal> example we used in <xref linkend="ATasteOfConcurrency"/> to use case classes. Here is the original
    implementation:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/IntroducingScala/shapes.scala</code>

<code role="preproc">package</code> shapes {
  <code role="statement">class</code> <code role="special">Point</code>(<code role="statement">val</code> x:<code role="type"> Double</code>, <code role="statement">val</code> y:<code role="type"> Double</code>) {
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"Point("</code> + x + <code role="constant">","</code> + y + <code role="constant">")"</code>
  }

  <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  }

  <code role="statement">class</code> <code role="special">Circle</code>(<code role="statement">val</code> center:<code role="type"> Point</code>, <code role="statement">val</code> radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Circle.draw: "</code> + <code role="statement">this</code>)
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"Circle("</code> + center + <code role="constant">","</code> + radius + <code role="constant">")"</code>
  }

  <code role="statement">class</code> <code role="special">Rectangle</code>(<code role="statement">val</code> lowerLeft:<code role="type"> Point</code>, <code role="statement">val</code> height:<code role="type"> Double</code>, <code role="statement">val</code> width:<code role="type"> Double</code>)
        <code role="statement">extends</code> <code role="special">Shape</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Rectangle.draw: "</code> + <code role="statement">this</code>)
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() =
      <code role="constant">"Rectangle("</code> + lowerLeft + <code role="constant">","</code> + height + <code role="constant">","</code> + width + <code role="constant">")"</code>
  }

  <code role="statement">class</code> <code role="special">Triangle</code>(<code role="statement">val</code> point1:<code role="type"> Point</code>, <code role="statement">val</code> point2:<code role="type"> Point</code>, <code role="statement">val</code> point3:<code role="type"> Point</code>)
        <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Triangle.draw: "</code> + <code role="statement">this</code>)
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() =
      <code role="constant">"Triangle("</code> + point1 + <code role="constant">","</code> + point2 + <code role="constant">","</code> + point3 + <code role="constant">")"</code>
  }
}
</programlisting><para id="para_here_is_the_example_rewritten_">Here is the example
    rewritten using the <literal moreinfo="none">case</literal> keyword:<indexterm significance="normal"><primary>case keyword</primary><secondary>case class example</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/shapes/shapes-case.scala</code>

<code role="preproc">package</code> shapes {
  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Point</code>(x:<code role="type"> Double</code>, y:<code role="type"> Double</code>)

  <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Circle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Rectangle</code>(lowerLeft:<code role="type"> Point</code>, height:<code role="type"> Double</code>, width:<code role="type"> Double</code>)
      <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Rectangle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Triangle</code>(point1:<code role="type"> Point</code>, point2:<code role="type"> Point</code>, point3:<code role="type"> Point</code>)
      <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Triangle.draw: "</code> + <code role="statement">this</code>)
  }
}
</programlisting><para id="para_adding_the_case_keyword_caus">Adding the
    <literal moreinfo="none">case</literal> keyword causes the compiler to add a number of
    useful features automatically. The keyword suggests an association with
    <literal moreinfo="none">case</literal> expressions in pattern matching. Indeed, they are
    particularly well suited for that application, as we will see.</para><para id="para_first_the_parser_automaticall">First, the compiler
    automatically converts the constructor arguments into immutable fields
    (<literal moreinfo="none">val</literal>s). The <literal moreinfo="none">val</literal> keyword is optional.
    If you want mutable fields, use the <literal moreinfo="none">var</literal> keyword. So,
    our constructor argument lists are now shorter.</para><para id="para_second_the_parser_automatical">Second, the compiler
    automatically implements <literal moreinfo="none">equals</literal>,
    <literal moreinfo="none">hashCode</literal>, and <literal moreinfo="none">toString</literal> methods to
    the class, which use the fields specified as constructor arguments. So, we
    no longer need our own <literal moreinfo="none">toString</literal> methods. In fact, the
    generated <literal moreinfo="none">toString</literal> methods produce the same outputs as
    the ones we implemented ourselves. Also, the body of
    <literal moreinfo="none">Point</literal> is gone because there are no methods that we need
    to define!</para><para id="para_the_following_script_uses_thes">The following script uses
    these methods that are now in the shapes:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/shapes/shapes-usage-example1-script.scala</code>

<code role="preproc">import</code> shapes._

<code role="statement">val</code> shapesList = <code role="special">List</code>(
  <code role="special">Circle</code>(<code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>), <code role="constant">1.0</code>),
  <code role="special">Circle</code>(<code role="special">Point</code>(<code role="constant">5.0</code>, <code role="constant">2.0</code>), <code role="constant">3.0</code>),
  <code role="special">Rectangle</code>(<code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>), <code role="constant">2</code>, <code role="constant">5</code>),
  <code role="special">Rectangle</code>(<code role="special">Point</code>(-<code role="constant">2.0</code>, -<code role="constant">1.0</code>), <code role="constant">4</code>, <code role="constant">3</code>),
  <code role="special">Triangle</code>(<code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>), <code role="special">Point</code>(<code role="constant">1.0</code>, <code role="constant">0.0</code>), <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">1.0</code>)))

<code role="statement">val</code> shape1 = shapesList.head  <code role="comment">// grab the first one.</code>
println(<code role="constant">"shape1: "</code>+shape1+<code role="constant">". hash = "</code>+shape1.hashCode)
<code role="statement">for</code> (shape2 <code role="statement">&lt;-</code> shapesList) {
  println(<code role="constant">"shape2: "</code>+shape2+<code role="constant">". 1 == 2 ? "</code>+(shape1 == shape2))
}
</programlisting><para id="para_output1">This script outputs the following:</para><screen format="linespecific">shape1: Circle(Point(0.0,0.0),1.0). hash = 2061963534
shape2: Circle(Point(0.0,0.0),1.0). 1 == 2 ? true
shape2: Circle(Point(5.0,2.0),3.0). 1 == 2 ? false
shape2: Rectangle(Point(0.0,0.0),2.0,5.0). 1 == 2 ? false
shape2: Rectangle(Point(-2.0,-1.0),4.0,3.0). 1 == 2 ? false
shape2: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0)). 1 == 2 ? false</screen><para id="para_as_we_ll_see_in_equalityofob">As we’ll see in <xref linkend="EqualityOfObjects"/>, the <literal moreinfo="none">==</literal> method actually
    invokes the <literal moreinfo="none">equals</literal> method.<indexterm significance="normal"><primary>= (equals sign)</primary><secondary>== (equals) operator</secondary></indexterm></para><para id="para_even_outside_of_case_express">Even outside of
    <literal moreinfo="none">case</literal> expressions, automatic generation of these three
    methods is very convenient for simple, “structural” classes, i.e., classes
    that contain relatively simple fields and behaviors.</para><para id="para_third_when_the_case_keyword">Third, when the
    <literal moreinfo="none">case</literal> keyword is used, the compiler automatically
    creates a <emphasis>companion object</emphasis> with an
    <literal moreinfo="none">apply</literal> factory method that takes the same arguments as
    the <emphasis>primary</emphasis> constructor. The previous example used
    the appropriate <literal moreinfo="none">apply</literal> methods to create the
    <literal moreinfo="none">Points</literal>, the different <literal moreinfo="none">Shapes</literal>, and
    also the <literal moreinfo="none">List</literal> itself. That’s why we don’t need
    <literal moreinfo="none">new</literal>; we’re actually calling
    <literal moreinfo="none">apply(x,y)</literal> in the <literal moreinfo="none">Point</literal> companion
    object, for example.<indexterm significance="normal"><primary>companion objects</primary><secondary>creation for case classes</secondary></indexterm><indexterm significance="normal"><primary>constructors</primary><secondary>case class</secondary></indexterm></para><note id="para_note_you_can_have__secondary_"><para>You can have <emphasis>secondary</emphasis> constructors in case
      classes, but there will be no overloaded <literal moreinfo="none">apply</literal> method
      generated that has the same argument list. You’ll have to use
      <literal moreinfo="none">new</literal> to create instances with those
      constructors.</para></note><para id="para_the_companion_object_also_gets">The companion object also
    gets an <literal moreinfo="none">unapply</literal> extractor method, which extracts all
    the fields of an instance in an elegant fashion. The following script
    demonstrates the extractors in pattern matching <literal moreinfo="none">case</literal>
    statements:<indexterm significance="normal"><primary>pattern matching</primary><secondary>extractors in case statements</secondary></indexterm><indexterm significance="normal"><primary>extractors</primary><secondary>use in pattern matching case statements</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/shapes/shapes-usage-example2-script.scala</code>

<code role="preproc">import</code> shapes._

<code role="statement">val</code> shapesList = <code role="special">List</code>(
  <code role="special">Circle</code>(<code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>), <code role="constant">1.0</code>),
  <code role="special">Circle</code>(<code role="special">Point</code>(<code role="constant">5.0</code>, <code role="constant">2.0</code>), <code role="constant">3.0</code>),
  <code role="special">Rectangle</code>(<code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>), <code role="constant">2</code>, <code role="constant">5</code>),
  <code role="special">Rectangle</code>(<code role="special">Point</code>(-<code role="constant">2.0</code>, -<code role="constant">1.0</code>), <code role="constant">4</code>, <code role="constant">3</code>),
  <code role="special">Triangle</code>(<code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>), <code role="special">Point</code>(<code role="constant">1.0</code>, <code role="constant">0.0</code>), <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">1.0</code>)))

<code role="statement">def</code> <code role="identifier">matchOn</code>(shape:<code role="type"> Shape</code>) = shape <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Circle</code>(center, radius) <code role="statement">=&gt;</code>
    println(<code role="constant">"Circle: center = "</code>+center+<code role="constant">", radius = "</code>+radius)
  <code role="statement">case</code> <code role="special">Rectangle</code>(ll, h, w) <code role="statement">=&gt;</code>
    println(<code role="constant">"Rectangle: lower-left = "</code>+ll+<code role="constant">", height = "</code>+h+<code role="constant">", width = "</code>+w)
  <code role="statement">case</code> <code role="special">Triangle</code>(p1, p2, p3) <code role="statement">=&gt;</code>
    println(<code role="constant">"Triangle: point1 = "</code>+p1+<code role="constant">", point2 = "</code>+p2+<code role="constant">", point3 = "</code>+p3)
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code>
    println(<code role="constant">"Unknown shape!"</code>+shape)
}

shapesList.foreach { shape <code role="statement">=&gt;</code> matchOn(shape) }
</programlisting><para id="para_output2">This script outputs the following:</para><screen format="linespecific">Circle: center = Point(0.0,0.0), radius = 1.0
Circle: center = Point(5.0,2.0), radius = 3.0
Rectangle: lower-left = Point(0.0,0.0), height = 2.0, width = 5.0
Rectangle: lower-left = Point(-2.0,-1.0), height = 4.0, width = 3.0
Triangle: point1 = Point(0.0,0.0), point2 = Point(1.0,0.0), point3 = Point(0.0,1.0)</screen><sect2 id="SyntacticSugarForBinaryOperations"><title>Syntactic Sugar for Binary Operations</title><para id="para_by_the_way_remember_in_matc">By the way, remember in
      <xref linkend="MatchingOnSequences"/> when we discussed matching on
      lists? We wrote this <literal moreinfo="none">case</literal> expression:<indexterm significance="normal"><primary>case classes</primary><secondary>binary operations</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">processList</code>(l:<code role="type"> List[Any]</code>):<code role="type"> Unit</code> = l <code role="statement">match</code> {
  <code role="statement">case</code> head :: tail <code role="statement">=&gt;</code> ...
  ...
}
</programlisting><para id="para_it_turns_out_that_the_followin">It turns out that the
      following expressions are identical:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> head :: tail <code role="statement">=&gt;</code> ...
  <code role="statement">case</code> ::(head, tail) <code role="statement">=&gt;</code> ...
</programlisting><para id="para_we_are_using_the_companion_obj">We are using the
      companion object for the case class named <literal moreinfo="none">::</literal>, which
      is used for non-empty lists. When used in <literal moreinfo="none">case</literal>
      expressions, the compiler supports this special infix operator notation
      for invocations of <literal moreinfo="none">unapply</literal>.</para><para id="para_it_works_not_only_for_unapply">It works not only for
      <literal moreinfo="none">unapply</literal> methods with two arguments, but also with one
      or more arguments. We could rewrite our <literal moreinfo="none">matchOn</literal>
      method this way:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">matchOn</code>(shape:<code role="type"> Shape</code>) = shape <code role="statement">match</code> {
  <code role="statement">case</code> center <code role="special">Circle</code> radius <code role="statement">=&gt;</code> ...
  <code role="statement">case</code> ll <code role="special">Rectangle</code> (h, w) <code role="statement">=&gt;</code> ...
  <code role="statement">case</code> p1 <code role="special">Triangle</code> (p2, p3) <code role="statement">=&gt;</code> ...
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> ...
}
</programlisting><para id="para_for_an_unapply_that_takes_on">For an
      <literal moreinfo="none">unapply</literal> that takes one argument, you would have to
      insert an empty set of parentheses to avoid a parsing ambiguity:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> arg <code role="special">Foo</code> () <code role="statement">=&gt;</code> ...
</programlisting><para id="para_from_the_point_of_view_of_clar">From the point of view of
      clarity, this syntax is elegant for some cases when there are two
      arguments. For lists, <literal moreinfo="none">head :: tail</literal> matches the
      expressions for building up lists, so there is a beautiful symmetry when
      the extraction process uses the same syntax. However, the merits of this
      syntax are less clear for other examples, especially when there are N !=
      2 arguments.</para></sect2><sect2 id="TheCopyMethodInScalaVersion28"><title>The copy Method in Scala Version 2.8</title><para id="para_in_scala_version_2_8_another_">In Scala version 2.8,
      another instance method is automatically generated, called
      <literal moreinfo="none">copy</literal>. This method is useful when you want to make a
      new instance of a case class that is identical to another instance with
      a few fields changed. Consider the following example script:<indexterm significance="normal"><primary>case classes</primary><secondary>copy method in Scala 2.8</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/shapes/shapes-usage-example3-v28-script.scala</code>
<code role="comment">// Scala version 2.8 only.</code>

<code role="preproc">import</code> shapes._

<code role="statement">val</code> circle1 = <code role="special">Circle</code>(<code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>), <code role="constant">2.0</code>)
<code role="statement">val</code> circle2 = circle1 copy (radius = <code role="constant">4.0</code>)

println(circle1)
println(circle2)
</programlisting><para id="para_the_second_circle_is_created_b">The second circle is
      created by copying the first and specifying a new radius. The
      <literal moreinfo="none">copy</literal> method implementation that is generated by the
      compiler exploits the new named and default parameters in Scala version
      2.8, which we discussed in <xref linkend="MethodDefaultAndNamedArguments"/>. The generated
      implementation of <literal moreinfo="none">Circle.copy</literal> looks roughly like the
      following:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code>() {
  ...
  <code role="statement">def</code> <code role="identifier">copy</code>(center:<code role="type"> Point</code> = <code role="statement">this</code>.center, radius:<code role="type"> Double</code> = <code role="statement">this</code>.radius) =
    <code role="statement">new</code> <code role="special">Circle</code>(center, radius)
}
</programlisting><para id="para_so_default_values_are_provide">So, default values are
      provided for all the arguments to the method (only two in this case).
      When using the <literal moreinfo="none">copy</literal> method, the user specifies by
      name only the fields that are changing. The values for the rest of the
      fields are used without having to reference them explicitly.</para></sect2><sect2 id="CaseClassInheritance"><title>Case Class Inheritance</title><para id="para_did_you_notice_that_shapes_c">Did you notice that the new
      <literal moreinfo="none">Shapes</literal> code in <xref linkend="CaseClasses"/> did not
      put the <literal moreinfo="none">case</literal> keyword on the abstract
      <literal moreinfo="none">Shape</literal> class? This is allowed by the compiler, but
      there are reasons for not having one case class inherit another. First,
      it can complicate field initialization. Suppose we make
      <literal moreinfo="none">Shape</literal> a case class. Suppose we want to add a string
      field to all shapes representing an <literal moreinfo="none">id</literal> that the user
      wants to set. It makes sense to define this field in
      <literal moreinfo="none">Shape</literal>. Let’s make these two changes to
      <literal moreinfo="none">Shape</literal>:<indexterm significance="normal"><primary>inheritance</primary><secondary>case class</secondary></indexterm><indexterm significance="normal"><primary>case classes</primary><secondary>inheritance</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">abstract</code> <code role="statement">case</code> <code role="statement">class</code> <code role="special">Shape</code>(id:<code role="type"> String</code>) {
  <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
}
</programlisting><para id="para_now_the_derived_shapes_need_to">Now the derived shapes
      need to pass the <literal moreinfo="none">id</literal> to the <literal moreinfo="none">Shape</literal>
      constructor. For example, <literal moreinfo="none">Circle</literal> would become the
      following:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(id:<code role="type"> String</code>, center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code>(id){
  <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
}
</programlisting><para id="para_however_if_you_compile_this_c">However, if you compile
      this code, you’ll get errors like the following:</para><screen format="linespecific">... error: error overriding value id in class Shape of type String;
 value id needs `override' modifier
  case class Circle(id: String, center: Point, radius: Double) extends Shape(id){
                    ^</screen><para id="para_remember_that_both_definitions">Remember that both
      definitions of <literal moreinfo="none">id</literal>, the one in
      <literal moreinfo="none">Shape</literal> and the one in <literal moreinfo="none">Circle</literal>, are
      considered <literal moreinfo="none">val</literal> field definitions! The error message
      tells us the answer; use the <literal role="keep-together" moreinfo="none">override</literal> keyword, as we discussed in
      <xref linkend="OverridingMembers"/>. So, the complete set of required
      modifications are as follows:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/shapes/shapes-case-id.scala</code>

<code role="preproc">package</code> shapesid {
  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Point</code>(x:<code role="type"> Double</code>, y:<code role="type"> Double</code>)

  <code role="statement">abstract</code> <code role="statement">case</code> <code role="statement">class</code> <code role="special">Shape</code>(id:<code role="type"> String</code>) {
    <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(<code role="statement">override</code> <code role="statement">val</code> id:<code role="type"> String</code>, center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>)
        <code role="statement">extends</code> <code role="special">Shape</code>(id) {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Circle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Rectangle</code>(<code role="statement">override</code> <code role="statement">val</code> id:<code role="type"> String</code>, lowerLeft:<code role="type"> Point</code>,
        height:<code role="type"> Double</code>, width:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code>(id) {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Rectangle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Triangle</code>(<code role="statement">override</code> <code role="statement">val</code> id:<code role="type"> String</code>, point1:<code role="type"> Point</code>,
        point2:<code role="type"> Point</code>, point3:<code role="type"> Point</code>) <code role="statement">extends</code> <code role="special">Shape</code>(id) {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Triangle.draw: "</code> + <code role="statement">this</code>)
  }
}
</programlisting><para id="para_note_that_we_also_have_to_add_">Note that we also have to
      add the <literal moreinfo="none">val</literal> keywords. This works, but it is somewhat
      ugly.</para><para id="para_a_more_ominous_problem_involve">A more ominous problem
      involves the generated <literal moreinfo="none">equals</literal> methods. Under
      inheritance, the <literal moreinfo="none">equals</literal> methods don’t obey all the
      standard rules for robust object equality. We’ll discuss those rules in
      <xref linkend="EqualityOfObjects"/>. For now, consider the following
      example:<indexterm significance="normal"><primary>equals method</primary><secondary>case class comparisons</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/shapes/shapes-case-equals-ambiguity-script.scala</code>

<code role="preproc">import</code> shapesid._

<code role="statement">case</code> <code role="statement">class</code> <code role="special">FancyCircle</code>(name:<code role="type"> String</code>, <code role="statement">override</code> <code role="statement">val</code> id:<code role="type"> String</code>,
    <code role="statement">override</code> <code role="statement">val</code> center:<code role="type"> Point</code>, <code role="statement">override</code> <code role="statement">val</code> radius:<code role="type"> Double</code>)
      <code role="statement">extends</code> <code role="special">Circle</code>(id, center, radius) {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"FancyCircle.draw: "</code> + <code role="statement">this</code>)
}

<code role="statement">val</code> fc = <code role="special">FancyCircle</code>(<code role="constant">"me"</code>, <code role="constant">"circle"</code>, <code role="special">Point</code>(<code role="constant">0.0</code>,<code role="constant">0.0</code>), <code role="constant">10.0</code>)
<code role="statement">val</code> c  = <code role="special">Circle</code>(<code role="constant">"circle"</code>, <code role="special">Point</code>(<code role="constant">0.0</code>,<code role="constant">0.0</code>), <code role="constant">10.0</code>)
format(<code role="constant">"FancyCircle == Circle? %b</code><code role="special">\n</code><code role="constant">"</code>, (fc == c))
format(<code role="constant">"Circle == FancyCircle? %b</code><code role="special">\n</code><code role="constant">"</code>, (c  == fc))
</programlisting><para id="para_if_you_run_this_script_you_ge">If you run this script,
      you get the following output:</para><screen format="linespecific">FancyCircle == Circle? false
Circle == FancyCircle? true</screen><para id="para_so_circle_equals_evaluates_">So,
      <literal moreinfo="none">Circle.equals</literal> evaluates to <literal moreinfo="none">true</literal>
      when given a <literal moreinfo="none">FancyCircle</literal> with the same values for the
      <literal moreinfo="none">Circle</literal> fields. The reverse case isn’t true. While you
      might argue that, as far as <literal moreinfo="none">Circle</literal> is concerned, they
      really <emphasis>are</emphasis> equal, most people would argue that this
      is a risky, “relaxed” interpretation of equality. It’s true that a
      future version of Scala could generate <literal moreinfo="none">equals</literal> methods
      for <literal moreinfo="none">case</literal> classes that do exact type-equality
      checking.</para><para id="para_so_the_conveniences_provided_">So, the conveniences
      provided by case classes sometimes lead to problems. It is best to avoid
      inheritance of one case class by another. Note that it’s fine for a case
      class to inherit from a non-case class or trait. It’s also fine for a
      non-case class or trait to inherit from a case class.</para><para id="para_because_of_these_issues_it_is">Because of these issues,
      it is possible that case class inheritance will be deprecated and
      removed in future versions of Scala.<indexterm class="endofrange" startref="ch06_caseclasses" significance="normal"/><indexterm class="endofrange" startref="ch06_OOPcaseclasses" significance="normal"/></para><warning id="para_warning_avoid_inheriting_a_ca"><para>Avoid inheriting a case class from another case class.</para></warning></sect2></sect1><sect1 id="EqualityOfObjects"><title>Equality of Objects</title><para id="para_implementing_a_reliable_equali">Implementing a reliable
    equality test for instances is difficult to do correctly.
    <emphasis>Effective Java</emphasis> (<link linkend="Bloch2008" xrefstyle="select:nopage">[Bloch2008]</link>) and the Scaladoc page for
    <literal moreinfo="none">AnyRef.equals</literal> describe the requirements for a good
    equality test. A very good description of the techniques for writing
    correct <literal moreinfo="none">equals</literal> and <literal moreinfo="none">hashCode</literal> methods
    can be found in <link linkend="Odersky2009" xrefstyle="select:nopage">[Odersky2009]</link>, which uses Java syntax,
    but is adapted from Chapter 28 of <emphasis>Programming in
    Scala</emphasis> (<link linkend="Odersky2008" xrefstyle="select:nopage">[Odersky2008]</link>). Consult these references
    when you need to implement your own <literal moreinfo="none">equals</literal> and
    <literal moreinfo="none">hashCode</literal> methods. Recall that these methods are created
    automatically for <literal moreinfo="none">case</literal> classes.<indexterm significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>equality of objects</secondary></indexterm><indexterm significance="normal"><primary>equality of objects</primary></indexterm></para><para id="para_here_we_focus_on_the_different">Here we focus on the
    different equality methods available in Scala and their meanings. There
    are some slight inconsistencies between the Scala specification (see <link linkend="ScalaSpec2009" role="keep-together" xrefstyle="select:nopage">[ScalaSpec2009]</link>) and the Scaladoc pages
    for the equality-related methods for <literal moreinfo="none">Any</literal> and <literal role="keep-together" moreinfo="none">AnyRef</literal>, but the general behavior is
    clear.</para><caution id="para_caution_some_of_the_equality_"><para>Some of the equality methods have the same names as equality
      methods in other languages, but the semantics are sometimes
      different!</para></caution><sect2 id="_the_equals_method"><title>The equals Method</title><para id="para_the_equals_method_tests_for_">The
      <literal moreinfo="none">equals</literal> method tests for <emphasis>value</emphasis>
      equality. That is, <literal moreinfo="none">obj1 equals obj2</literal> is true if both
      <literal moreinfo="none">obj1</literal> and <literal moreinfo="none">obj2</literal> have the same value.
      They do not need to refer to the same instance.<indexterm significance="normal"><primary>equals method</primary></indexterm></para><para id="para_hence_equals_behaves_like_t">Hence,
      <literal moreinfo="none">equals</literal> behaves like the <literal moreinfo="none">equals</literal>
      method in Java and the <literal moreinfo="none">eql?</literal> method in Ruby.</para></sect2><sect2 id="_the_and_methods"><title>The == and != Methods</title><para id="para_while_is_an_operator_in_m">While <literal moreinfo="none">==</literal> is
      an operator in many languages, it is a method in Scala, defined as
      <literal moreinfo="none">final</literal> in <literal moreinfo="none">Any</literal>. It tests for
      <emphasis>value</emphasis> equality, like <literal moreinfo="none">equals</literal>.
      That is, <literal moreinfo="none">obj1 == obj2</literal> is true if both
      <literal moreinfo="none">obj1</literal> and <literal moreinfo="none">obj2</literal> have the same value.
      In fact, <literal moreinfo="none">==</literal> delegates to <literal moreinfo="none">equals</literal>.
      Here is part of the Scaladoc entry for
      <literal moreinfo="none">Any.==</literal>:<indexterm significance="normal"><primary>= (equals sign)</primary><secondary>== (equals) method</secondary></indexterm><indexterm significance="normal"><primary>Any class</primary><secondary>== (equals) method</secondary></indexterm></para><screen format="linespecific">o == arg0 is the same as o.equals(arg0).</screen><para id="para_here_is_the_corresponding_part">Here is the corresponding
      part of the Scaladoc entry for <literal moreinfo="none">AnyRef.==</literal>:<indexterm significance="normal"><primary>AnyRef class</primary><secondary>== (equals) method</secondary></indexterm></para><screen format="linespecific">o == arg0 is the same as if (o eq null) arg0 eq null else o.equals(arg0).</screen><para id="para_as_you_would_expect_is_th">As you would expect,
      <literal moreinfo="none">!=</literal> is the negation, i.e., it is equivalent to
      <literal moreinfo="none">!(obj1 == obj2)</literal>.<indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>!= (not equal) method</secondary></indexterm></para><para id="para_since_and_are_declar">Since <literal moreinfo="none">==</literal> and
      <literal moreinfo="none">!=</literal> are declared <literal moreinfo="none">final</literal> in
      <literal moreinfo="none">Any</literal>, you can’t override them, but you don’t need to,
      since they delegate to <literal moreinfo="none">equals</literal>.<indexterm significance="normal"><primary>Any class</primary><secondary>!= (not equal) method</secondary></indexterm></para><note id="para_note_that_in_java_c_043"><para>In Java, C++, and C#, the <literal moreinfo="none">==</literal> operator tests
        for <emphasis>reference</emphasis>, not <emphasis>value</emphasis>
        equality. In contrast, Ruby’s <literal moreinfo="none">==</literal> operator tests for
        <emphasis>value</emphasis> equality. Whatever language you’re used to,
        make sure to remember that in Scala, <literal moreinfo="none">==</literal> is testing
        for value equality.</para></note></sect2><sect2 id="_the_ne_and_eq_methods"><title>The ne and eq Methods</title><para id="para_the_eq_method_tests_for__ref">The <literal moreinfo="none">eq</literal>
      method tests for <emphasis>reference</emphasis> equality. That is,
      <literal moreinfo="none">obj1 eq obj2</literal> is true if both <literal moreinfo="none">obj1</literal>
      and <literal moreinfo="none">obj2</literal> point to the same location in memory. These
      methods are only defined for <literal moreinfo="none">AnyRef</literal>.<indexterm significance="normal"><primary>AnyRef class</primary><secondary>eq and ne methods</secondary></indexterm><indexterm significance="normal"><primary>eq method (AnyRef)</primary></indexterm><indexterm significance="normal"><primary>reference types</primary><secondary>testing equality</secondary></indexterm></para><para id="para_hence_eq_behave_like_the_">Hence, <literal moreinfo="none">eq</literal>
      behaves like the <literal moreinfo="none">==</literal> operator in Java, C++, and C#,
      but not <literal moreinfo="none">==</literal> in Ruby.</para><para id="para_the_ne_method_is_the_negatio">The <literal moreinfo="none">ne</literal>
      method is the negation of <literal moreinfo="none">eq</literal>, i.e., it is equivalent
      to <literal moreinfo="none">!(obj1 eq obj2)</literal>.<indexterm significance="normal"><primary>ne method (AnyRef)</primary></indexterm></para></sect2><sect2 id="_array_equality_and_the_sameelements_method"><title>Array Equality and the sameElements Method</title><para id="para_comparing_the_contents_of_two_">Comparing the contents of
      two <literal moreinfo="none">Array</literal>s doesn’t have an obvious result in
      Scala:<indexterm significance="normal"><primary>arrays, comparing for equality</primary></indexterm></para><screen format="linespecific">scala&gt; Array(1, 2) == Array(1, 2)
res0: Boolean = false</screen><para id="para_that_s_a_surprise_thankfully_">That’s a surprise!
      Thankfully, there’s a simple solution in the form of the <literal role="keep-together" moreinfo="none">sameElements</literal> method:<indexterm significance="normal"><primary>Array class</primary><secondary>sameElements method</secondary></indexterm></para><screen format="linespecific">scala&gt; Array(1, 2).sameElements(Array(1, 2))
res1: Boolean = true</screen><para id="para_much_better_remember_to_use_">Much better. Remember to
      use <literal moreinfo="none">sameElements</literal> when you want to test if two
      <literal moreinfo="none">Array</literal>s contain the same elements.</para><para id="para_while_this_may_seem_like_an_in">While this may seem like
      an inconsistency, encouraging an explicit test of the equality of two
      mutable data structures is a conservative approach on the part of the
      language designers. In the long run, it should save you from unexpected
      results in your <phrase role="keep-together">conditionals</phrase>.</para></sect2></sect1><sect1 id="AdvOOPRecapAndWhatsNext"><title>Recap and What’s Next</title><para id="para_we_explored_the_fine_points_of">We explored the fine points
    of overriding members in derived classes. We learned about object
    equality, case classes, and companion classes and objects.</para><para id="para_in_the_next_chapter_on_scalas_object_system">In the next
    chapter, we’ll learn about the Scala type hierarchy—in particular, the
    <literal role="keep-together" moreinfo="none">Predef</literal> object that includes many
    useful definitions. We’ll also learn about Scala’s alternative to Java’s
    <literal moreinfo="none">static</literal> class members and the
    <emphasis>linearization</emphasis> rules for method lookup.</para></sect1></chapter><chapter id="ScalaObjectSystem"><title>The Scala Object System</title><sect1 id="PredefObject"><title>The Predef Object</title><para id="para_for_your_convenience_whenever">For your convenience,
    whenever you compile code, the Scala compiler automatically imports the
    definitions in the <literal moreinfo="none">java.lang</literal> package
    (<literal moreinfo="none">javac</literal> does this, too). On the .NET platform, it
    imports the <literal moreinfo="none">system</literal> package. The compiler also imports
    the definitions in the analogous Scala package, <literal moreinfo="none">scala</literal>.
    Hence, common Java or .NET types can be used without explicitly importing
    them or fully qualifying them with the <literal moreinfo="none">java.lang.</literal>
    prefix, in the Java case. Similarly, a number of common, Scala-specific
    types are made available without qualification, such as
    <literal moreinfo="none">List</literal>. Where there are Java and Scala type names that
    overlap, like <literal moreinfo="none">String</literal>, the Scala version is imported
    last, so it “wins.”<indexterm significance="normal"><primary>object system (Scala)</primary><secondary>Predef object</secondary></indexterm><indexterm significance="normal"><primary>Predef object</primary></indexterm><indexterm class="startofrange" id="ch07_objectsys" significance="normal"><primary>object system (Scala)</primary></indexterm></para><para id="para_the_parser_also_automatically_">The compiler also
    automatically imports the <literal moreinfo="none">Predef</literal> object, which defines
    or imports several useful types, objects, and functions.</para><tip id="para_tip_you_can_learn_a_lot_of_sc"><para>You can learn a lot of Scala by viewing the source for
      <literal moreinfo="none">Predef</literal>. It is available by clicking the “source” link
      in the <literal moreinfo="none">Predef</literal> Scaladoc page, or you can download the
      full source code for Scala at <ulink url="http://www.scala-lang.org/"/>.</para></tip><para id="para_here_is_a_partial_list_of_the_"><xref linkend="table_7-1"/> shows a partial list of the items imported or
    defined by <literal moreinfo="none">Predef</literal> on the Java platform.<indexterm significance="normal"><primary>Predef object</primary><secondary>items imported or defined by</secondary></indexterm></para><table colsep="1" frame="all" id="table_7-1" rowsep="1"><title>Items imported or defined by Predef</title><tgroup cols="2"><tbody valign="top"><row><entry><para><emphasis role="strong">Types</emphasis></para></entry><entry><para><literal moreinfo="none">Character</literal>,
            <literal moreinfo="none">Class</literal>, <literal moreinfo="none">Error</literal>,
            <literal moreinfo="none">Function</literal>, <literal moreinfo="none">Integer</literal>,
            <literal moreinfo="none">Map</literal>, <literal moreinfo="none">Pair</literal>,
            <literal moreinfo="none">Runnable</literal>, <literal moreinfo="none">Set</literal>,
            <literal moreinfo="none">String</literal>, <literal moreinfo="none">Throwable</literal>,
            <literal moreinfo="none">Triple</literal>.</para></entry></row><row><entry><para><emphasis role="strong">Exceptions</emphasis></para></entry><entry><para><literal moreinfo="none">Exception</literal>,
            <literal moreinfo="none">ArrayIndexOutOfBoundsException</literal>,
            <literal moreinfo="none">ClassCastException</literal>,
            <literal moreinfo="none">IllegalArgumentException</literal>,
            <literal moreinfo="none">IndexOutOfBoundsException</literal>,
            <literal moreinfo="none">NoSuchElementException</literal>,
            <literal moreinfo="none">NullPointerException</literal>,
            <literal moreinfo="none">NumberFormatException</literal>,
            <literal moreinfo="none">RuntimeException</literal>,
            <literal moreinfo="none">StringIndexOutOfBoundsException</literal>,
            <literal moreinfo="none">UnsupportedOperationException</literal>.</para></entry></row><row><entry><para><emphasis role="strong">Values</emphasis></para></entry><entry><para><literal moreinfo="none">Map</literal>,
            <literal moreinfo="none">Set</literal>.</para></entry></row><row><entry><para><emphasis role="strong">Objects</emphasis></para></entry><entry><para><literal moreinfo="none">Pair</literal>,
            <literal moreinfo="none">Triple</literal>.</para></entry></row><row><entry><para><emphasis role="strong">Classes</emphasis></para></entry><entry><para><literal moreinfo="none">Ensuring</literal>,
            <literal moreinfo="none">ArrowAssoc</literal>.</para></entry></row><row><entry><para><emphasis role="strong">Methods</emphasis></para></entry><entry><para>Factory methods to create
            <emphasis>tuples</emphasis>; overloaded versions of
            <literal moreinfo="none">exit</literal>, <literal moreinfo="none">error</literal>,
            <literal moreinfo="none">assert</literal>, <literal moreinfo="none">assume</literal>, and
            <literal moreinfo="none">require</literal>; <emphasis>implicit</emphasis> type
            conversion methods; I/O methods like <literal moreinfo="none">readLine</literal>,
            <literal moreinfo="none">println</literal>, and <literal moreinfo="none">format</literal>; and a
            method <literal moreinfo="none">currentThread</literal>, which calls
            <literal moreinfo="none">java.lang.Thread.currentThread</literal>.</para></entry></row></tbody></tgroup></table><para id="para__predef_declares_the_types_an"><literal moreinfo="none">Predef</literal>
    declares the types and exceptions listed in the table using the
    <literal moreinfo="none">type</literal> keyword. They are definitions that equal the
    corresponding <literal moreinfo="none">scala.&lt;Type&gt;</literal> or
    <literal moreinfo="none">java.lang.&lt;Type&gt;</literal> classes, so they behave like
    “aliases” or imports for the corresponding classes. For example,
    <literal moreinfo="none">String</literal> is declared as follows:<indexterm significance="normal"><primary>Predef object</primary><secondary>declaring types and exceptions</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">type</code> <code role="special">String</code> = java.lang.<code role="special">String</code>
</programlisting><para id="para_in_this_case_the_declaration_">In this case, the
    declaration has the same net effect as an <literal moreinfo="none">import
    java.lang.String</literal> statement would have.</para><para id="para_but_didn_t_we_just_say_that_de">But didn’t we just say that
    definitions in <literal moreinfo="none">java.lang</literal> are imported automatically,
    like <literal moreinfo="none">String</literal>? The reason there is a type definition is
    to enable support for a uniform string type across all runtime
    environments. The definition is only redundant on the JVM.</para><para id="para_the_type_pair_is_an_alias_">The type
    <literal moreinfo="none">Pair</literal> is an “alias” for
    <literal moreinfo="none">Tuple2</literal>:<indexterm significance="normal"><primary>Pair class</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">type</code> <code role="special">Pair</code><code role="special">[+A, +B]</code> = <code role="special">Tuple2</code><code role="special">[A, B]</code>
</programlisting><para id="para_as_you_would_expect_there_are">There are two type
    parameters, <literal moreinfo="none">A</literal> and <literal moreinfo="none">B</literal>, one for each
    item in the pair. Recall from <xref linkend="AbstractTypesAndParameterizedTypes"/> that we explained the
    meaning of the <literal moreinfo="none">+</literal> in front of each type
    parameter.</para><para id="para_suppose_we_declare_a_var_of_">Briefly, a
    <literal moreinfo="none">Pair[A2,B2]</literal>, for some <literal moreinfo="none">A2</literal> and
    <literal moreinfo="none">B2</literal>, is a <emphasis>subclass</emphasis> of
    <literal moreinfo="none">Pair[A1,B1]</literal>, for some <literal moreinfo="none">A1</literal> and
    <literal moreinfo="none">B1</literal>, if <literal moreinfo="none">A2</literal> is a subtype of
    <literal moreinfo="none">A1</literal> and <literal moreinfo="none">B2</literal> is a subtype of
    <literal moreinfo="none">B1</literal>. In <xref linkend="ParameterizedTypes"/>, we’ll
    discuss <literal moreinfo="none">+</literal> and other type qualifiers in more
    detail.<indexterm significance="normal"><primary>Pair object</primary></indexterm><indexterm significance="normal"><primary>companion objects</primary><secondary>Pair object for Pair class</secondary></indexterm></para><para id="para_the_pair_class_also_has_a__c">The <literal moreinfo="none">Pair</literal>
    class also has a <emphasis>companion object</emphasis>
    <literal moreinfo="none">Pair</literal> with an <literal moreinfo="none">apply</literal> factory method,
    as discussed in <xref linkend="CompanionObjects"/>. Hence, we can create
    <literal moreinfo="none">Pair</literal> instances as in this example:</para><screen format="linespecific">val p = Pair(1, "one")</screen><para id="para__pair_apply_is_called_with_th"><literal moreinfo="none">Pair.apply</literal> is
    called with the two arguments. The types <literal moreinfo="none">A</literal> and
    <literal moreinfo="none">B</literal>, shown in the definition of <literal moreinfo="none">Pair</literal>,
    are inferred. A new <literal moreinfo="none">Tuple2</literal> instance is returned.</para><para id="para__map_and_set_appear_in_both"><literal moreinfo="none">Map</literal> and
    <literal moreinfo="none">Set</literal> appear in both the types and values lists. In the
    values list, they are <phrase role="keep-together">assigned the</phrase>
    <emphasis>companion objects</emphasis>
    <literal moreinfo="none">scala.collection.immutable.Map</literal> and
    <literal moreinfo="none">scala.collection.immuta⁠ble.Set</literal>, respectively. Hence,
    <literal moreinfo="none">Map</literal> and <literal moreinfo="none">Set</literal> in
    <literal moreinfo="none">Predef</literal> are <emphasis>values</emphasis>, not object
    definitions, because they refer to objects defined elsewhere, whereas
    <literal moreinfo="none">Pair</literal> and <literal moreinfo="none">Triple</literal> are defined in
    <literal moreinfo="none">Predef</literal> itself. The types <literal moreinfo="none">Map</literal> and
    <literal moreinfo="none">Set</literal> are assigned the corresponding <phrase role="keep-together">immutable</phrase> classes.<indexterm significance="normal"><primary>companion objects</primary><secondary>Map and Set</secondary></indexterm><indexterm significance="normal"><primary>Set values</primary></indexterm><indexterm significance="normal"><primary>Map values</primary></indexterm><indexterm significance="normal"><primary>ArrowAssoc class</primary></indexterm></para><para id="para_the_arrowassoc_class_defines">The
    <literal moreinfo="none">ArrowAssoc</literal> class defines two methods:
    <literal moreinfo="none">-&gt;</literal>, and the Unicode equivalent <literal moreinfo="none">→</literal>.
    The utility of these methods was demonstrated previously in <xref linkend="OptionSomeNone"/>, where we created a map of U.S. state
    capitals:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> stateCapitals = <code role="special">Map</code>(
  <code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>,
  <code role="constant">"Alaska"</code>  -&gt; <code role="constant">"Juneau"</code>,
  <code role="comment">// ...</code>
  <code role="constant">"Wyoming"</code> -&gt; <code role="constant">"Cheyenne"</code>)
<code role="comment">// ...</code>
</programlisting><para id="para_the_definition_of_the_arrowas">The definition of the
    <literal moreinfo="none">ArrowAssoc</literal> class and the <literal moreinfo="none">Map</literal> and
    <literal moreinfo="none">Set</literal> values in <literal moreinfo="none">Predef</literal> make the
    convenient <literal moreinfo="none">Map</literal> initialization syntax possible. First,
    when Scala sees <literal moreinfo="none">Map(...)</literal> it calls the
    <literal moreinfo="none">apply</literal> method on the <literal moreinfo="none">Map</literal> companion
    object, just as we discussed for <literal moreinfo="none">Pair</literal>.<indexterm significance="normal"><primary>Set companion object</primary></indexterm><indexterm significance="normal"><primary>Map companion object</primary></indexterm></para><para id="para__map_apply_expects_zero_or_mo"><literal moreinfo="none">Map.apply</literal>
    expects zero or more <literal moreinfo="none">Pairs</literal> (e.g., <literal moreinfo="none">(a1, b2),
    (a2, b2), ...</literal>), where each tuple holds a name and value. In the
    example, the tuple types are all inferred to be of type
    <literal moreinfo="none">Pair[String,String]</literal>. The declaration of
    <literal moreinfo="none">Map.apply</literal> is as follows:<indexterm significance="normal"><primary>Map.apply method</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">object</code> <code role="special">Map</code> {
  ...
  <code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[A, B]</code>(elems : (<code role="special">A</code>, <code role="special">B</code>)*) :<code role="type"> Map[A, B]</code> = ...
}
</programlisting><para id="para_there_are_no_type_parameters_o">Recall that there can be no
    type parameters on the <literal moreinfo="none">Map</literal> companion object because
    there can be only one instance. However, <literal moreinfo="none">apply</literal> can have
    type parameters.</para><para id="para_notice_the_argument_list_signa">The apply method takes a
    <emphasis>variable-length argument list</emphasis>. Internally,
    <literal moreinfo="none">x</literal> will be a subtype of <literal moreinfo="none">Array[X]</literal>. So,
    for <literal moreinfo="none">Map.apply</literal>, <literal moreinfo="none">elems</literal> is of type
    <literal moreinfo="none">Array[(A,B)]</literal> or <literal moreinfo="none">Array[Tuple2[A,B]]</literal>,
    if you prefer.<indexterm significance="normal"><primary>variable-length argument lists</primary></indexterm></para><para id="para_so_now_that_we_know_what_map">So, now that we know what
    <literal moreinfo="none">Map.apply</literal> expects, how do we get from <literal moreinfo="none">a -&gt;
    b</literal> to <literal moreinfo="none">(a, b)</literal>?<indexterm significance="normal"><primary>implicit conversions</primary><secondary>Predef.any2ArrowAssoc method</secondary></indexterm></para><para id="para__predef_also_defines_an__impl"><literal moreinfo="none">Predef</literal>
    also defines an <emphasis>implicit</emphasis> type conversion method
    called <literal moreinfo="none">any2ArrowAssoc</literal>. The compiler knows that
    <literal moreinfo="none">String</literal> does not define a <literal moreinfo="none">-&gt;</literal>
    method, so it looks for an <emphasis>implicit</emphasis> conversion
    <emphasis>in scope</emphasis> to a type that defines such a method, such
    as <literal moreinfo="none">ArrowAssoc</literal>. The <literal moreinfo="none">any2ArrowAssoc</literal>
    method performs that conversion. It has the following
    implementation:<indexterm significance="normal"><primary>Predef object</primary><secondary>any2ArrowAssoc method</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">any2ArrowAssoc</code><code role="identifier">[A]</code>(x:<code role="type"> A</code>):<code role="type"> ArrowAssoc[A]</code> = <code role="statement">new</code> <code role="special">ArrowAssoc</code>(x)
</programlisting><para id="para_it_is_applied_to_each_item_to_">It is applied to each item
    to the left of an arrow <literal moreinfo="none">-&gt;</literal>, e.g., the
    <literal moreinfo="none">"Alabama"</literal> string. These strings are wrapped in
    <literal moreinfo="none">ArrowAssoc</literal> instances, upon which the
    <literal moreinfo="none">-&gt;</literal> method is then invoked. This method has the
    following implementation:</para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">ArrowAssoc</code><code role="special">[A]</code>(x:<code role="type"> A</code>) {
    ...
    <code role="statement">def</code> <code role="identifier">-&gt;</code> <code role="identifier">[B]</code>(y:<code role="type"> B</code>):<code role="type"> Tuple2[A, B]</code> = <code role="special">Tuple2</code>(x, y)
}
</programlisting><para id="para_when_it_is_invoked_it_is_pass">When it is invoked, it is
    passed the string on the righthand side of the <literal moreinfo="none">-&gt;</literal>.
    The method returns a tuple with the value, <literal moreinfo="none">("Alabama",
    "Montgomery")</literal>, for example. In this way, each <literal moreinfo="none">key -&gt;
    value</literal> is converted into a tuple and the resulting
    comma-separated list of tuples is passed to the
    <literal moreinfo="none">Map.apply</literal> factory method.</para><para id="para_the_description_may_sound_comp">The description may sound
    complicated at first, but the beauty of Scala is that this map
    initialization syntax is not an ad hoc language feature, such as a
    special-purpose operator <literal moreinfo="none">-&gt;</literal> defined in the language
    grammar. Instead, this syntax is defined with normal definitions of types
    and methods, combined with a few general-purpose parsing conventions, such
    as support for <emphasis>implicits</emphasis>. Furthermore, it is all
    <emphasis>type-safe</emphasis>. You can use the same techniques to write
    your own convenient “operators” for mini <emphasis>Domain-Specific
    Languages</emphasis> (see <xref linkend="DomainSpecificLanguages"/>).</para><para id="para__implicit__type_conversions_ar"><emphasis>Implicit</emphasis>
    type conversions are discussed in more detail in <xref linkend="ImplicitConversions"/>.</para><para id="para_next_recall_from_chapter_1_th">Next, recall from <xref linkend="IntroducingScala"/> that we were able to replace calls to
    <literal role="keep-together" moreinfo="none">Console.println(...)</literal> with
    <literal moreinfo="none">println(...)</literal>. This “bare” <literal moreinfo="none">println</literal>
    method is defined in <literal role="keep-together" moreinfo="none">Predef</literal>, then
    imported <phrase role="keep-together">automatically</phrase> by the
    compiler. The definition calls the corresponding method in <literal role="keep-together" moreinfo="none">Console</literal>. Similarly, all the other I/O
    methods defined by <literal moreinfo="none">Predef</literal>, e.g.,
    <literal moreinfo="none">readLine</literal> and <literal role="keep-together" moreinfo="none">format</literal>, call the corresponding
    <literal moreinfo="none">Console</literal> methods.</para><para id="para_finally_the_assert_assume">Finally, the
    <literal moreinfo="none">assert</literal>, <literal moreinfo="none">assume</literal>, and
    <literal moreinfo="none">require</literal> methods are each overloaded with various
    argument list options. They are used for runtime testing of boolean
    conditions. If a condition is false, an exception is thrown. The
    <literal moreinfo="none">Ensuring</literal> class serves a similar purpose. You can use
    these features for <emphasis>Design by Contract</emphasis> programming, as
    discussed in <xref linkend="DesignByContractExample"/>.</para><para id="para_for_the_full_list_of_features_">For the full list of
    features defined by <literal moreinfo="none">Predef</literal>, see the corresponding
    Scaladoc entry in <link linkend="ScalaAPI2008" xrefstyle="select:nopage">[ScalaAPI2008]</link>.<indexterm significance="normal"><primary>tuples</primary><secondary>ways to create two-item tuple</secondary></indexterm><indexterm significance="normal"><primary>Predef object</primary><secondary>documentation</secondary></indexterm></para><sidebar><title>Four Ways to Create a Two-Item Tuple</title><para id="para_we_now_know_four_ways_to_creat">We now know four ways to
      create a two-item tuple (<emphasis>twople</emphasis>?):</para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>(“Hello”, 3.14)</para></listitem><listitem><para>Pair(“Hello”, 3.14)</para></listitem><listitem><para>Tuple2(“Hello”, 3.14)</para></listitem><listitem><para>“Hello” → 3.14</para></listitem></orderedlist></sidebar></sect1><sect1 id="ClassesAndObjects"><title>Classes and Objects: Where Are the Statics?</title><para id="para_many_object_oriented_languages">Many object-oriented
    languages allow classes to have class-level constants, fields, and
    methods, called “static” members in Java, C#, and C++. These constants,
    fields, and methods are not associated with any
    <emphasis>instances</emphasis> of the class.<indexterm significance="normal"><primary>static members, Scala and</primary></indexterm><indexterm significance="normal"><primary>object system (Scala)</primary><secondary>classes and objects</secondary></indexterm></para><para id="para_an_example_of_a_class_level_fi">An example of a class-level
    field is a shared logging instance used by all instances of a class for
    logging messages. An example of a class-level constant is the default
    logging “threshold” level.<indexterm significance="normal"><primary>fields</primary><secondary>comparison to Java class-level</secondary></indexterm></para><para id="para_an_example_of_a_class_level_me">An example of a class-level
    method is a “finder” method that locates all instances of the class in
    some repository that match some user-specified criteria. Another example
    is a <emphasis>factory</emphasis> method, as used in one of the
    factory-related design patterns (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>).<indexterm significance="normal"><primary>methods</primary><secondary>class-level</secondary></indexterm></para><para id="para_in_order_to_remain_consistent_">To remain consistent with
    the goal that “everything is an object” in Scala, class-level fields and
    methods are not supported. Instead, Scala supports declarations of classes
    that are <emphasis>singletons</emphasis>, using the
    <literal moreinfo="none">object</literal> keyword instead of the <literal moreinfo="none">class</literal>
    keyword. The <literal moreinfo="none">objects</literal> provide an object-oriented
    approach to “static” data and methods. Hence, Scala does not even have a
    <literal moreinfo="none">static</literal> keyword.<indexterm significance="normal"><primary>singletons</primary><secondary>Scala classes declared as</secondary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>declaration of classes as singletons</secondary></indexterm></para><para id="para__objects_are_instantiated_aut"><literal moreinfo="none">Objects</literal>
    are instantiated automatically and lazily by the runtime system (see
    Section 5.4 of <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). Just as for classes and
    traits, the body of the <literal moreinfo="none">object</literal> is the constructor, but
    since the system instantiates the object, there is no way for the user to
    specify a parameter list for the constructor, so they aren’t supported.
    Any data defined in the object has to be initialized with default values.
    For the same reasons, auxiliary constructors can’t be used and are not
    supported.<indexterm significance="normal"><primary>objects</primary><secondary>instantiation in Scala</secondary></indexterm></para><para id="para_we_ve_already_seen_some_exampl">We’ve already seen some
    examples of objects, such as the <literal moreinfo="none">specs</literal> objects used
    previously for tests, and the <literal moreinfo="none">Pair</literal> type and its
    <emphasis>companion object</emphasis>, which we explored in <xref linkend="PredefObject"/>:</para><programlisting language="scala" format="linespecific"><code role="statement">type</code> <code role="special">Pair</code><code role="special">[+A, +B]</code> = <code role="special">Tuple2</code><code role="special">[A, B]</code>
<code role="statement">object</code> <code role="special">Pair</code> {
  <code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[A, B]</code>(x:<code role="type"> A</code>, y:<code role="type"> B</code>) = <code role="special">Tuple2</code>(x, y)
  <code role="statement">def</code> <code role="identifier">unapply</code><code role="identifier">[A, B]</code>(x:<code role="type"> Tuple2[A, B]</code>):<code role="type"> Option[Tuple2[A, B]]</code> = <code role="special">Some</code>(x)
}
</programlisting><para id="para_to_reference_an_object_field">To reference an object field
    or method, you use the syntax <literal moreinfo="none">object_name.field</literal> or
    <literal moreinfo="none">object_name.method(...)</literal>, respectively. For example,
    <literal moreinfo="none">Pair.apply(...)</literal>. Note that this is the same syntax that
    is commonly used in languages with static fields and methods.<indexterm significance="normal"><primary>fields</primary><secondary>referencing object field</secondary></indexterm><indexterm significance="normal"><primary>methods</primary><secondary>referencing object method</secondary></indexterm></para><tip id="para_tip_when_an_object_named_m"><para>When an object named <literal moreinfo="none">MyObject</literal> is compiled to a
      class file, the class file name will be
      <literal moreinfo="none">MyObject$.class</literal>.</para></tip><para id="para_the_convention_for_defining_constants">In Java and C#, the
    convention for defining constants is to use <literal moreinfo="none">final
    static</literal> fields. (C# also has a <literal moreinfo="none">constant</literal>
    keyword for simple fields, like <literal moreinfo="none">ints</literal> and
    <literal moreinfo="none">strings</literal>.) In Scala, the convention is to use
    <literal moreinfo="none">val</literal> fields in objects.<indexterm significance="normal"><primary>constants</primary><secondary>defining</secondary></indexterm></para><para id="para_finally_the_convention_for_de">Finally, recall from <xref linkend="NestedClasses"/> that class definitions can be nested within
    other class definitions. This property generalizes for objects. You can
    define nested objects, traits, and classes inside other objects, traits,
    and classes.</para><sect2 id="PackageObjects"><title>Package Objects</title><para id="para_scala_version_2_8_introduces_a">Scala version 2.8
      introduces a new scoping construct called <emphasis>package
      objects</emphasis>. They are used to define types, variables, and
      methods that are visible at the level of the corresponding package. To
      understand their usefulness, let’s see an example from Scala version 2.8
      itself. The collection library is being reorganized to refine the
      package structure and to use it more consistently (among other changes).
      The Scala team faced a dilemma. They wanted to move types to new
      packages, but avoid breaking backward compatibility. The
      <literal moreinfo="none">package object</literal> construct provided a solution, along
      with other benefits.<indexterm significance="normal"><primary>scope</primary><secondary>package objects</secondary></indexterm><indexterm significance="normal"><primary>package objects</primary></indexterm><indexterm significance="normal"><primary>object system (Scala)</primary><secondary>classes and objects</secondary><tertiary>package objects</tertiary></indexterm></para><para id="para_for_example_the_immutable_li">For example, the immutable
      <literal moreinfo="none">List</literal> is defined in the <literal moreinfo="none">scala</literal>
      package in version 2.7, but it is moved to the
      <literal moreinfo="none">scala.collection.immutable</literal> package in version 2.8.
      Despite the change, <literal moreinfo="none">List</literal> is made visible in the
      <literal moreinfo="none">scala</literal> package using <literal moreinfo="none">package object
      scala</literal>, found in the
      <filename moreinfo="none">src/library/scala/package.scala</filename> file in the version
      2.8 source code distribution. Note the file name. It’s not required, but
      it’s a useful convention for package objects. Here is the full package
      object definition (at the time of this writing; it could change before
      the 2.8.0 final version is released):</para><programlisting language="scala" format="linespecific"><code role="preproc">package</code> object scala {
  <code role="statement">type</code> <code role="special">Iterable</code><code role="special">[+A]</code> = scala.collection.<code role="special">Iterable</code><code role="special">[A]</code>
  <code role="statement">val</code> Iterable = scala.collection.<code role="special">Iterable</code>

  @deprecated(<code role="constant">"use Iterable instead"</code>) <code role="statement">type</code> <code role="special">Collection</code><code role="special">[+A]</code> = <code role="special">Iterable</code><code role="special">[A]</code>
  @deprecated(<code role="constant">"use Iterable instead"</code>) <code role="statement">val</code> Collection = <code role="special">Iterable</code>

  <code role="statement">type</code> <code role="special">Seq</code><code role="special">[+A]</code> = scala.collection.<code role="special">Sequence</code><code role="special">[A]</code>
  <code role="statement">val</code> Seq = scala.collection.<code role="special">Sequence</code>

  <code role="statement">type</code> <code role="special">RandomAccessSeq</code><code role="special">[+A]</code> = scala.collection.<code role="special">Vector</code><code role="special">[A]</code>
  <code role="statement">val</code> RandomAccessSeq = scala.collection.<code role="special">Vector</code>

  <code role="statement">type</code> <code role="special">Iterator</code><code role="special">[+A]</code> = scala.collection.<code role="special">Iterator</code><code role="special">[A]</code>
  <code role="statement">val</code> Iterator = scala.collection.<code role="special">Iterator</code>

  <code role="statement">type</code> <code role="special">BufferedIterator</code><code role="special">[+A]</code> = scala.collection.<code role="special">BufferedIterator</code><code role="special">[A]</code>

  <code role="statement">type</code> <code role="special">List</code><code role="special">[+A]</code> = scala.collection.immutable.<code role="special">List</code><code role="special">[A]</code>
  <code role="statement">val</code> List = scala.collection.immutable.<code role="special">List</code>

  <code role="statement">val</code> Nil = scala.collection.immutable.<code role="special">Nil</code>

  <code role="statement">type</code> ::[<code role="special">A</code>] = scala.collection.immutable.::[<code role="special">A</code>]
  <code role="statement">val</code> :: = scala.collection.immutable.::

  <code role="statement">type</code> <code role="special">Stream</code><code role="special">[+A]</code> = scala.collection.immutable.<code role="special">Stream</code><code role="special">[A]</code>
  <code role="statement">val</code> Stream = scala.collection.immutable.<code role="special">Stream</code>

  <code role="statement">type</code> <code role="special">StringBuilder</code> = scala.collection.mutable.<code role="special">StringBuilder</code>
  <code role="statement">val</code> StringBuilder = scala.collection.mutable.<code role="special">StringBuilder</code>
}
</programlisting><para id="para_note_that_pairs_of_declaration">Note that pairs of
      declarations like <literal moreinfo="none">type List[+] = ...</literal> and <literal moreinfo="none">val
      List = ...</literal> are effectively “aliases” for the companion class
      and object, respectively. Because the contents of the
      <literal moreinfo="none">scala</literal> package are automatically imported by the
      compiler, you can still reference all the definitions in this object in
      any scope without an explicit import statement for fully qualified
      names.</para><para id="para_other_than_the_way_the_members">Other than the way the
      members in package objects are scoped, they behave just like other
      object declarations. While this example contains only
      <literal moreinfo="none">val</literal>s and <literal moreinfo="none">type</literal>s, you can also
      define methods, and you can subclass another class or trait and mix in
      other traits.</para><para id="para_another_benefit_of_package_obj">Another benefit of
      package objects is that it provides a more succinct implementation of
      what was an awkward idiom before. Without package objects, you would
      have to put definitions in an ad hoc object inside the desired package,
      then import from the object. For example, here is how
      <literal moreinfo="none">List</literal> would have to be handled without a package
      object:</para><programlisting language="scala" format="linespecific"><code role="preproc">package</code> scala {
  <code role="statement">object</code> <code role="special">toplevel</code> {
    ...
    <code role="statement">type</code> <code role="special">List</code><code role="special">[+A]</code> = scala.collection.immutable.<code role="special">List</code><code role="special">[A]</code>
    <code role="statement">val</code> List = scala.collection.immutable.<code role="special">List</code>
    ...
  }
}

...
<code role="preproc">import</code> scala.toplevel._
...
</programlisting><para id="para_finally_another_benefit_of_pa">Finally, another benefit
      of package objects is the way they provide a clear separation between
      the abstractions exposed by a package and the implementations that
      should be hidden inside it. In a larger application, a package object
      could be used to expose all the public types, values, and operations
      (methods) for a “component,” while everything else in the package and
      nested packages could be treated as internal implementation
      details.</para></sect2></sect1><sect1 id="SealedClassHierarchies"><title>Sealed Class Hierarchies</title><para id="para_recall_shapes_usage_example2">Recall from <xref linkend="CaseClasses"/> that we demonstrated pattern matching with our
    <literal moreinfo="none">Shapes</literal> hierarchy, which use case classes. We had a
    default <literal role="keep-together" moreinfo="none">case _ =&gt; ...</literal>
    expression. It’s usually wise to have one. Otherwise, if someone defines a
    new subtype of <literal moreinfo="none">Shape</literal> and passes it to this
    <literal moreinfo="none">match</literal> statement, a runtime
    <literal moreinfo="none">scala.MatchError</literal> will be thrown, because the new shape
    won’t match the shapes covered in the match statement. However, it’s not
    always possible to define reasonable behavior for the default
    case.<indexterm class="startofrange" id="ch07_sealedclass" significance="normal"><primary>sealed class hierarchies</primary></indexterm><indexterm class="startofrange" id="ch07_classessealed" significance="normal"><primary>classes</primary><secondary>sealed class hierarchies</secondary></indexterm><indexterm significance="normal"><primary>MatchError object</primary></indexterm><indexterm class="startofrange" id="ch07_objectsyssealedclass" significance="normal"><primary>object system (Scala)</primary><secondary>sealed class hierarchies</secondary></indexterm></para><para id="para_there_is_an_alternative_soluti">There is an alternative
    solution if you know that the case class hierarchy is unlikely to change
    and you can define the whole hierarchy in <emphasis>one file</emphasis>.
    In this situation, you can add the <literal moreinfo="none">sealed</literal> keyword to
    the declaration of the common base class. When sealed, the compiler knows
    all the possible classes that could appear in the <literal moreinfo="none">match</literal>
    expression, because all of them must be defined in the same source file.
    So, if you cover all those classes in the <literal moreinfo="none">case</literal>
    expressions (either explicitly or through shared parent classes), then you
    can safely eliminate the default <literal moreinfo="none">case</literal>
    expression.</para><para id="para_here_is_an_example_using_the_h">Here is an example using
    the HTTP 1.1 methods (see <link linkend="HTTP11" xrefstyle="select:nopage">[HTTP1.1]</link>), which are not likely to
    change very often, so we declare a “sealed” set of case classes for
    them:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/sealed/http-script.scala</code>

<code role="statement">sealed</code> <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">HttpMethod</code>()
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Connect</code>(body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Delete</code> (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Get</code>    (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Head</code>   (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Options</code>(body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Post</code>   (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Put</code>    (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Trace</code>  (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>

<code role="statement">def</code> <code role="identifier">handle</code> (method:<code role="type"> HttpMethod</code>) = method <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Connect</code> (body) <code role="statement">=&gt;</code> println(<code role="constant">"connect: "</code> + body)
  <code role="statement">case</code> <code role="special">Delete</code>  (body) <code role="statement">=&gt;</code> println(<code role="constant">"delete: "</code>  + body)
  <code role="statement">case</code> <code role="special">Get</code>     (body) <code role="statement">=&gt;</code> println(<code role="constant">"get: "</code>     + body)
  <code role="statement">case</code> <code role="special">Head</code>    (body) <code role="statement">=&gt;</code> println(<code role="constant">"head: "</code>    + body)
  <code role="statement">case</code> <code role="special">Options</code> (body) <code role="statement">=&gt;</code> println(<code role="constant">"options: "</code> + body)
  <code role="statement">case</code> <code role="special">Post</code>    (body) <code role="statement">=&gt;</code> println(<code role="constant">"post: "</code>    + body)
  <code role="statement">case</code> <code role="special">Put</code>     (body) <code role="statement">=&gt;</code> println(<code role="constant">"put: "</code>     + body)
  <code role="statement">case</code> <code role="special">Trace</code>   (body) <code role="statement">=&gt;</code> println(<code role="constant">"trace: "</code>   + body)
}

<code role="statement">val</code> methods = <code role="special">List</code>(
  <code role="special">Connect</code>(<code role="constant">"connect body..."</code>),
  <code role="special">Delete</code> (<code role="constant">"delete body..."</code>),
  <code role="special">Get</code>    (<code role="constant">"get body..."</code>),
  <code role="special">Head</code>   (<code role="constant">"head body..."</code>),
  <code role="special">Options</code>(<code role="constant">"options body..."</code>),
  <code role="special">Post</code>   (<code role="constant">"post body..."</code>),
  <code role="special">Put</code>    (<code role="constant">"put body..."</code>),
  <code role="special">Trace</code>  (<code role="constant">"trace body..."</code>))

methods.foreach { method <code role="statement">=&gt;</code> handle(method) }
</programlisting><para id="para_output3">This script outputs the following:</para><screen format="linespecific">connect: connect body...
delete: delete body...
get: get body...
head: head body...
options: options body...
post: post body...
put: put body...
trace: trace body...</screen><para id="para_no_default_case_is_necessary_">No default case is
    necessary, since we cover all the possibilities. Conversely, if you omit
    one of the classes and you don’t provide a default case or a case for a
    shared parent class, the compiler warns you that the “match is not
    exhaustive.” For example, if you comment out the case for
    <literal moreinfo="none">Put</literal>, you get this warning:</para><screen format="linespecific">warning: match is not exhaustive!
missing combination            Put

def handle (method: HttpMethod) = method match {
...</screen><para id="para_you_also_get_a_matcherror_ex">You also get a
    <literal moreinfo="none">MatchError</literal> exception if a <literal moreinfo="none">Put</literal>
    instance is passed to the match.</para><para id="para_using_sealed_has_one_drawbac">Using
    <literal moreinfo="none">sealed</literal> has one drawback. Every time you add or remove a
    class from the hierarchy, you have to modify the file, since the entire
    hierarchy has to be declared in the same file. This breaks the
    <emphasis>Open-Closed Principle</emphasis> (see <link linkend="Meyer1997" xrefstyle="select:nopage">[Meyer1997]</link> and <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>), which
    is a solution to the practical problem that it can be costly to modify
    existing code, retest it (and other code that uses it), and redeploy it.
    It’s much less “costly” if you can extend the system by adding new derived
    types in <emphasis>separate</emphasis> source files. This is why we picked
    the HTTP method hierarchy for the example. The list of methods is very
    stable.<indexterm significance="normal"><primary>Open-Closed Principle (OCP)</primary></indexterm></para><tip id="para_tip_avoid_sealed_case_class"><para>Avoid <literal moreinfo="none">sealed</literal> case class hierarchies if the
      hierarchy changes frequently (for an appropriate definition of
      “frequently”).</para></tip><para id="para_finally_you_may_have_noticed_">Finally, you may have
    noticed some duplication in the example. All the concrete classes have a
    <literal moreinfo="none">body</literal> field. Why didn’t we put that field in the parent
    <literal moreinfo="none">HttpMethod</literal> class? Because we decided to use case
    classes for the concrete classes, we’ll run into the same problem with
    case class inheritance that we discussed in <xref linkend="CaseClassInheritance"/>, where we added a shared
    <literal moreinfo="none">id</literal> field in the <literal moreinfo="none">Shape</literal> hierarchy. We
    need the <literal moreinfo="none">body</literal> argument for each HTTP method’s
    constructor, yet it will be made a field of each method type
    automatically. So, we would have to use the <literal moreinfo="none">override
    val</literal> technique we demonstrated previously.</para><para id="para_we_could_remove_the_case_keywo">We could remove the case
    keywords and implement the methods and companion objects that we need.
    However, in this case, the duplication is minimal and tolerable.</para><para id="para_what_if_we_want_to_use_case_cl">What if we want to use case
    classes, yet also reference the <literal moreinfo="none">body</literal> field in
    <literal moreinfo="none">HttpMethod</literal>? Fortunately, we know that Scala will
    generate a <literal moreinfo="none">body</literal> reader method in every concrete
    subclass (as long as we use the name <literal moreinfo="none">body</literal>
    consistently!). So, we can declare that method abstract in
    <literal moreinfo="none">HttpMethod</literal>, then use it as we see fit. The following
    example demonstrates this technique:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/sealed/http-body-script.scala</code>

<code role="statement">sealed</code> <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">HttpMethod</code>() {
    <code role="statement">def</code> <code role="identifier">body</code>:<code role="type"> String</code>
    <code role="statement">def</code> <code role="identifier">bodyLength</code> = body.length
}

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Connect</code>(body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Delete</code> (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Get</code>    (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Head</code>   (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Options</code>(body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Post</code>   (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Put</code>    (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Trace</code>  (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>

<code role="statement">def</code> <code role="identifier">handle</code> (method:<code role="type"> HttpMethod</code>) = method <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Connect</code> (body) <code role="statement">=&gt;</code> println(<code role="constant">"connect: "</code> + body)
  <code role="statement">case</code> <code role="special">Delete</code>  (body) <code role="statement">=&gt;</code> println(<code role="constant">"delete: "</code>  + body)
  <code role="statement">case</code> <code role="special">Get</code>     (body) <code role="statement">=&gt;</code> println(<code role="constant">"get: "</code>     + body)
  <code role="statement">case</code> <code role="special">Head</code>    (body) <code role="statement">=&gt;</code> println(<code role="constant">"head: "</code>    + body)
  <code role="statement">case</code> <code role="special">Options</code> (body) <code role="statement">=&gt;</code> println(<code role="constant">"options: "</code> + body)
  <code role="statement">case</code> <code role="special">Post</code>    (body) <code role="statement">=&gt;</code> println(<code role="constant">"post: "</code>    + body)
  <code role="statement">case</code> <code role="special">Put</code>     (body) <code role="statement">=&gt;</code> println(<code role="constant">"put: "</code>     + body)
  <code role="statement">case</code> <code role="special">Trace</code>   (body) <code role="statement">=&gt;</code> println(<code role="constant">"trace: "</code>   + body)
}

<code role="statement">val</code> methods = <code role="special">List</code>(
  <code role="special">Connect</code>(<code role="constant">"connect body..."</code>),
  <code role="special">Delete</code> (<code role="constant">"delete body..."</code>),
  <code role="special">Get</code>    (<code role="constant">"get body..."</code>),
  <code role="special">Head</code>   (<code role="constant">"head body..."</code>),
  <code role="special">Options</code>(<code role="constant">"options body..."</code>),
  <code role="special">Post</code>   (<code role="constant">"post body..."</code>),
  <code role="special">Put</code>    (<code role="constant">"put body..."</code>),
  <code role="special">Trace</code>  (<code role="constant">"trace body..."</code>))

methods.foreach { method <code role="statement">=&gt;</code>
  handle(method)
  println(<code role="constant">"body length? "</code> + method.bodyLength)
}
</programlisting><para id="para_we_declared_body_abstract_in">We declared
    <literal moreinfo="none">body</literal> abstract in <literal moreinfo="none">HttpMethod</literal>. We
    added a simple <literal moreinfo="none">bodyLength</literal> method that calls
    <literal moreinfo="none">body</literal>. The loop at the end of the script calls
    <literal moreinfo="none">bodyLength</literal>. Running this script produces the following
    output:</para><screen format="linespecific">connect: connect body...
body length? 15
delete: delete body...
body length? 14
get: get body...
body length? 11
head: head body...
body length? 12
options: options body...
body length? 15
post: post body...
body length? 12
put: put body...
body length? 11
trace: trace body...
body length? 13</screen><para id="para_as_always_every_feature_has_p">As always, every feature has
    pluses and minuses. Case classes and sealed class hierarchies have very
    useful properties, but they aren’t suitable for all situations.<indexterm class="endofrange" startref="ch07_sealedclass" significance="normal"/><indexterm class="endofrange" startref="ch07_objectsyssealedclass" significance="normal"/><indexterm class="endofrange" startref="ch07_classessealed" significance="normal"/></para></sect1><sect1 id="ScalaTypeHierarchy"><title>The Scala Type Hierarchy</title><para id="para_we_have_mentioned_a_number_of_">We have mentioned a number
    of types in Scala’s type hierarchy already. Let’s look at the general
    structure of the hierarchy, as illustrated in <xref linkend="scalas-type-hierarchy"/>.<indexterm significance="normal"><primary>data types</primary><secondary>type hierarchy in Scala</secondary></indexterm><indexterm significance="normal"><primary>object system (Scala)</primary><secondary>type hierarchy</secondary></indexterm></para><figure float="none" id="scalas-type-hierarchy"><title>Scala’s type hierarchy</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_0701.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_0701.png" format="PNG"/></imageobject></mediaobject></figure><para id="para_the_following_tables_discuss_t">Tables <xref linkend="any-anyval-anyref" xrefstyle="select: labelnumber"/> and <xref linkend="AnyVal-value-types" xrefstyle="select: labelnumber"/> discuss
    the types shown in <xref linkend="scalas-type-hierarchy"/>, as well as
    some other important types that aren’t shown. Some details are omitted for
    clarity. When the underlying “runtime” is discussed, the points made apply
    equally to the JVM and the .NET CLR, except where noted.<indexterm significance="normal"><primary>reference types</primary><secondary>parent of, AnyRef</secondary></indexterm><indexterm significance="normal"><primary>AnyRef object</primary></indexterm><indexterm significance="normal"><primary>AnyVal object</primary></indexterm><indexterm significance="normal"><primary>Any object</primary></indexterm></para><table id="any-anyval-anyref"><title>Any, AnyVal, and AnyRef</title><tgroup cols="3"><colspec colnum="1" colwidth=".5in"/><colspec colnum="2" colwidth=".5in"/><colspec colnum="3"/><thead valign="top"><row><entry>Name</entry><entry><phrase role="keep-together">Parent</phrase></entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">Any</literal></para></entry><entry><para><emphasis>none</emphasis></para></entry><entry><para>The root of the hierarchy. Defines a few
            <emphasis>final</emphasis> methods like <literal moreinfo="none">==</literal>,
            <literal moreinfo="none">!=</literal>, <literal moreinfo="none">isInstanceOf[T]</literal> (for
            type checking), and <literal moreinfo="none">asInstanceOf[T]</literal> (for type
            casting), as well as default versions of
            <literal moreinfo="none">equals</literal>, <literal role="keep-together" moreinfo="none">hashCode</literal>, and
            <literal moreinfo="none">toString</literal>, which are designed to be overridden
            by subclasses.</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">AnyVal</literal></para></entry><entry><para><literal moreinfo="none">Any</literal></para></entry><entry><para>The parent of all <emphasis>value</emphasis> types,
            which correspond to the <emphasis>primitive</emphasis> types on
            the runtime platform, plus <literal moreinfo="none">Unit</literal>. All the
            <literal moreinfo="none">AnyVal</literal> instances are immutable <emphasis>value
            instances</emphasis>, and all the <literal moreinfo="none">AnyVal</literal> types
            are <literal moreinfo="none">abstract final</literal>. Hence, none of them can be
            instantiated with <literal moreinfo="none">new</literal>. Rather, new instances
            are created with <emphasis>literal</emphasis> values (e.g.,
            <literal moreinfo="none">3.14</literal> for a <literal moreinfo="none">Double</literal>) or by
            calling methods on instances that return new
            values.</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">AnyRef</literal></para></entry><entry><para><literal moreinfo="none">Any</literal></para></entry><entry><para>The parent of all <emphasis>reference</emphasis>
            types, including all <literal moreinfo="none">java.*</literal> and
            <literal moreinfo="none">scala.*</literal> types. It is equivalent to
            <literal moreinfo="none">java.lang.Object</literal> for the JVM and
            <literal moreinfo="none">object</literal> (<literal moreinfo="none">System.Object</literal>) for
            the .NET runtime. Instances of reference types are created with
            <literal moreinfo="none">new</literal>.</para></entry></row></tbody></tgroup></table><para id="para_the__value_types__are_children">The <emphasis>value
    types</emphasis> are children of <literal moreinfo="none">AnyVal</literal>.<indexterm significance="normal"><primary>value types</primary><secondary>listed</secondary></indexterm><indexterm significance="normal"><primary>AnyVal object</primary><secondary>direct subtypes</secondary></indexterm></para><table id="AnyVal-value-types"><title>Direct subtypes of AnyVal, the value types</title><tgroup cols="2"><colspec colnum="1" colwidth="1in"/><colspec colnum="2"/><thead valign="top"><row><entry>Name</entry><entry>Runtime primitive type</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">Boolean</literal></para></entry><entry><para>Boolean (<literal moreinfo="none">true</literal> and
            <literal moreinfo="none">false</literal>).</para></entry></row><row><entry><para><literal moreinfo="none">Byte</literal></para></entry><entry><para>Byte.</para></entry></row><row><entry><para><literal moreinfo="none">Char</literal></para></entry><entry><para>Char.</para></entry></row><row><entry><para><literal moreinfo="none">Short</literal></para></entry><entry><para>Short.</para></entry></row><row><entry><para><literal moreinfo="none">Int</literal></para></entry><entry><para>Int.</para></entry></row><row><entry><para><literal moreinfo="none">Long</literal></para></entry><entry><para>Long.</para></entry></row><row><entry><para><literal moreinfo="none">Float</literal></para></entry><entry><para>Float.</para></entry></row><row><entry><para><literal moreinfo="none">Double</literal></para></entry><entry><para>Double.</para></entry></row><row><entry><para><literal moreinfo="none">Unit</literal></para></entry><entry><para>Serves the same role as <literal moreinfo="none">void</literal> in
            most imperative languages. Used primarily as a function return
            value. There is only one instance of <literal moreinfo="none">Unit</literal>,
            named <literal moreinfo="none">()</literal>. Think of it as a tuple with zero
            items.</para></entry></row></tbody></tgroup></table><para id="para_all_other_types_the__referenc">All other types, the
    <emphasis>reference types</emphasis>, are children of
    <literal moreinfo="none">AnyRef</literal>. <xref linkend="AnyRef-reference-types"/> lists
    some of the more commonly used reference types. Note that there are some
    significant differences between the version 2.7.X and 2.8
    collections.<indexterm significance="normal"><primary>AnyRef object</primary><secondary>direct and indirect subtypes</secondary></indexterm><indexterm significance="normal"><primary>reference types</primary><secondary>listed</secondary></indexterm></para><table id="AnyRef-reference-types"><title>Direct and indirect subtypes of AnyRef, the reference
      types</title><tgroup cols="3"><thead valign="top"><row><entry>Name</entry><entry><phrase role="keep-together">Parent</phrase></entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para><literal role="keep-together" moreinfo="none">Collection[+T]</literal></para></entry><entry><para><literal role="keep-together" moreinfo="none">Iterable[T]</literal></para></entry><entry><para>Trait for collections of known size.</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">Either[+T1,
            +T2]</literal></para></entry><entry><para><literal moreinfo="none">AnyRef</literal></para></entry><entry><para>Used most often as a return type when a method could
            return an instance of one of two unrelated types. For example, an
            exception or a “successful” result. The <literal moreinfo="none">Either</literal>
            can be pattern matched for its <literal moreinfo="none">Left</literal> or
            <literal moreinfo="none">Right</literal> subtypes. (It is analogous to
            <literal moreinfo="none">Option</literal>, with <literal moreinfo="none">Some</literal> and
            <literal moreinfo="none">None</literal>.) For the exception-handling idiom, it is
            conventional to use <literal moreinfo="none">Left</literal> for the <phrase role="keep-together">exception</phrase>.</para></entry></row><row><entry><para><phrase role="keep-together"><literal moreinfo="none">FunctionN[-T</literal><subscript>1</subscript><literal moreinfo="none">,
            -T</literal><subscript>2</subscript><literal moreinfo="none">,</literal></phrase><literal moreinfo="none"><?lb?>
            ..., -T</literal><subscript>N</subscript><literal moreinfo="none">,
            +R]</literal></para></entry><entry><para><literal moreinfo="none">AnyRef</literal></para></entry><entry><para>Trait representing a function that takes
            <literal moreinfo="none">N</literal> arguments, each of which can have its own
            type, and returns a value of type <literal moreinfo="none">R</literal>. (Traits
            are defined for <literal moreinfo="none">N</literal> = 0 to 22.) The
            <emphasis>variance annotations</emphasis> (<literal moreinfo="none">+</literal>
            and <literal moreinfo="none">-</literal>) in front of the types will be explained
            in <xref linkend="VarianceUnderInheritance"/>.</para></entry></row><row><entry><para><literal moreinfo="none">Iterable[+T]</literal></para></entry><entry><para><literal moreinfo="none">AnyRef</literal></para></entry><entry><para>Trait with methods for operating on collections of
            instances. Users <phrase role="keep-together">implement</phrase>
            the abstract <literal moreinfo="none">elements</literal> method to return an
            <literal moreinfo="none">Iterable</literal> <phrase role="keep-together">instance</phrase>.</para></entry></row><row><entry><para><literal moreinfo="none">List[+T]</literal></para></entry><entry><para><literal moreinfo="none">Seq[T]</literal></para></entry><entry><para><literal moreinfo="none">sealed abstract class</literal> for ordered
            collections with functional-style list semantics. It is the most
            widely used collection in Scala, so it is defined in the
            <literal moreinfo="none">scala</literal> package, rather than one of the
            collection packages. (In Scala version2.8, it is actually defined
            in <literal moreinfo="none">scala.col⁠lection.immutable</literal> and “aliased” in
            <literal moreinfo="none">package object scala</literal>). It has two subclasses,
            <literal moreinfo="none">case object Nil</literal>, which extends
            <literal moreinfo="none">List[Nothing]</literal> and represents an empty list, and
            <literal moreinfo="none">case final class ::[T]</literal>, which represents a
            non-empty list, characterized by a head element and a tail list,
            which would be <literal moreinfo="none">Nil</literal> for a one-element
            list.</para></entry></row><row><entry><para><literal moreinfo="none">Nothing</literal></para></entry><entry><para><emphasis>All other types</emphasis></para></entry><entry><para><literal moreinfo="none">Nothing</literal> is the subtype of
            <emphasis>all</emphasis> other types. It has no instances. It is
            used primarily for defining other types in a type-safe way, such
            as the special <literal moreinfo="none">List</literal> subtype
            <literal moreinfo="none">Nil</literal>. See also <xref linkend="NothingAndNull"/>.</para></entry></row><row><entry><para><literal moreinfo="none">Null</literal></para></entry><entry><para><emphasis>All reference
            types</emphasis></para></entry><entry><para><literal moreinfo="none">Null</literal> has one instance,
            <literal moreinfo="none">null</literal>, corresponding to the runtime’s concept of
            <literal moreinfo="none">null</literal>.</para></entry></row><row><entry><para><literal moreinfo="none">Option[T]</literal></para></entry><entry><para><literal moreinfo="none">Product</literal></para></entry><entry><para>Wraps an optional item. It is a <literal moreinfo="none">sealed
            abstract</literal> type and the only allowed instances are an
            instance of its derived <literal moreinfo="none">case class Some[T]</literal>,
            wrapping an instance of <literal moreinfo="none">T</literal>, or its derived
            <literal moreinfo="none">case object None</literal>, which extends
            <literal moreinfo="none">Option[Nothing]</literal>.</para></entry></row><row><entry><para><literal moreinfo="none">Predef</literal></para></entry><entry><para><literal moreinfo="none">AnyRef</literal></para></entry><entry><para>An <literal moreinfo="none">object</literal> that defines and imports
            many commonly used types and methods. See <xref linkend="PredefObject"/> for details.</para></entry></row><row><entry><para><literal moreinfo="none">Product</literal></para></entry><entry><para><literal moreinfo="none">AnyRef</literal></para></entry><entry><para>Trait with methods for determining arity and getting
            the n<superscript>th</superscript> item in a “Cartesian product.”
            Subtraits are defined for <literal moreinfo="none">Product</literal>, called
            <literal role="keep-together" moreinfo="none">ProductN</literal>, for dimension
            <literal moreinfo="none">N</literal> from 1 through 22.</para></entry></row><row><entry><para><literal moreinfo="none">ScalaObject</literal><indexterm significance="normal"><primary>ScalaObject class</primary></indexterm></para></entry><entry><para><literal moreinfo="none">AnyRef</literal></para></entry><entry><para><emphasis>Mixin</emphasis> trait added to all Scala
            reference type instances.</para></entry></row><row><entry><para><literal moreinfo="none">Seq[+T]</literal></para></entry><entry><para><literal role="keep-together" moreinfo="none">Collection[T]</literal></para></entry><entry><para>Trait for ordered collections.</para></entry></row><row><entry><para><literal moreinfo="none">TupleN</literal></para></entry><entry><para><literal moreinfo="none">ProductN</literal></para></entry><entry><para>Separate case classes for arity <literal moreinfo="none">N</literal>
            = 1 through 22. Tuples support the <emphasis>literal</emphasis>
            syntax <literal moreinfo="none">(x1, x2, ..., xN)</literal>.</para></entry></row></tbody></tgroup></table><para id="para_besides_list_defined_in_th">Besides
    <literal moreinfo="none">List</literal>, some of the other library collections include
    <literal moreinfo="none">Map</literal>, <literal moreinfo="none">Set</literal>, <literal moreinfo="none">Queue</literal>,
    and <literal moreinfo="none">Stack</literal>. These other collections come in two
    varieties: mutable and immutable. The immutable collections are in the
    package <literal moreinfo="none">scala.collection.immutable</literal>, while the mutable
    collections are in <literal moreinfo="none">scala.collection.mutable</literal>. Only an
    immutable version of <literal moreinfo="none">List</literal> is provided; for a mutable
    list, use a <literal moreinfo="none">ListBuffer</literal>, which can return a
    <literal moreinfo="none">List</literal> via the <literal moreinfo="none">toList</literal> method. <phrase role="keep-together">For Scala version</phrase> 2.8, the collections
    implementations reuse code from
    <literal moreinfo="none">scala.col⁠lec⁠tion.generic</literal>. Users of the collections
    would normally not use any types defined in this package. We’ll explore
    some of these collections in greater detail in <xref linkend="FunctionalDataStructures"/>.<indexterm significance="normal"><primary>collections</primary><secondary>mutable and immutable</secondary></indexterm></para><para id="para_consistent_with_its_emphasis_o">Consistent with its
    emphasis on <emphasis>functional programming</emphasis> (see <xref linkend="FunctionalProgramming"/>), Scala encourages you to use the
    immutable collections, since <literal moreinfo="none">List</literal> is automatically
    imported and <literal moreinfo="none">Predef</literal> defines types
    <literal moreinfo="none">Map</literal> and <literal moreinfo="none">Set</literal> that refer to the
    immutable versions of these collections. All other collections have to be
    imported explicitly.</para><para id="para__predef_defines_a_number_of_i"><literal moreinfo="none">Predef</literal>
    defines a number of implicit conversion methods for the value types
    (excluding <literal moreinfo="none">Unit</literal>). There are implicit conversions to the
    corresponding <literal moreinfo="none">scala.runtime.RichX</literal> types. For example,
    the <literal moreinfo="none">byteWrapper</literal> method converts a
    <literal moreinfo="none">Byte</literal> to a <literal moreinfo="none">scala.runtime.RichByte</literal>.
    There are implicit conversions between the “numeric”
    types—<literal moreinfo="none">Byte</literal>, <literal moreinfo="none">Short</literal>,
    <literal moreinfo="none">Int</literal>, <literal moreinfo="none">Long</literal>, and
    <literal moreinfo="none">Float</literal>—to the other types that are “wider” than the
    original. For example, <literal moreinfo="none">Byte</literal> to <literal moreinfo="none">Int</literal>,
    <literal moreinfo="none">Int</literal> to <literal moreinfo="none">Long</literal>, <literal moreinfo="none">Int</literal>
    to <literal moreinfo="none">Double</literal>, etc. Finally, there are conversions to the
    corresponding Java wrapper types, e.g., <literal moreinfo="none">Int</literal> to
    <literal moreinfo="none">java.lang.Integer</literal>. We discuss implicit conversions in
    more detail in <xref linkend="ImplicitConversions"/>.<indexterm significance="normal"><primary>value types</primary><secondary>implicit conversions by Predef object methods</secondary></indexterm><indexterm significance="normal"><primary>Predef object</primary><secondary>implicit conversion methods for value types</secondary></indexterm></para><para id="para_either_example">There are several examples of
    <literal moreinfo="none">Option</literal> elsewhere, e.g., <xref linkend="OptionSomeNone"/>. Here is a script that illustrates using an
    <literal moreinfo="none">Either</literal> return value to handle a thrown exception or
    successful result (adapted from <ulink url="http://dcsobral.blogspot.com/2009/06/catching-exceptions.html"/>):<indexterm significance="normal"><primary>Either object</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/typehierarchy/either-script.scala</code>

<code role="statement">def</code> <code role="identifier">exceptionToLeft</code><code role="identifier">[T]</code>(f:<code role="type"> =&gt; T</code>):<code role="type"> Either[java.lang.Throwable, T]</code> = <code role="statement">try</code> {
  <code role="special">Right</code>(f)
} <code role="statement">catch</code> {
  <code role="statement">case</code> ex <code role="statement">=&gt;</code> <code role="special">Left</code>(ex)
}

<code role="statement">def</code> <code role="identifier">throwsOnOddInt</code>(i:<code role="type"> Int</code>) = i % <code role="constant">2</code> <code role="statement">match</code> {
  <code role="statement">case</code> <code role="constant">0</code> <code role="statement">=&gt;</code> i
  <code role="statement">case</code> <code role="constant">1</code> <code role="statement">=&gt;</code> <code role="statement">throw</code> <code role="statement">new</code> <code role="special">RuntimeException</code>(i + <code role="constant">" is odd!"</code>)
}

<code role="statement">for</code>(i <code role="statement">&lt;-</code> <code role="constant">0</code> to <code role="constant">3</code>)
  exceptionToLeft(throwsOnOddInt(i)) <code role="statement">match</code> {
    <code role="statement">case</code> <code role="special">Left</code>(ex) <code role="statement">=&gt;</code> println(<code role="constant">"Oops, got exception "</code> + ex.toString)
    <code role="statement">case</code> <code role="special">Right</code>(x) <code role="statement">=&gt;</code> println(x)
  }
</programlisting><para id="para_the_exceptiontoleft_method_e">The
    <literal moreinfo="none">exceptionToLeft</literal> method evaluates <literal moreinfo="none">f</literal>.
    It catches a <literal moreinfo="none">Throwable</literal> and returns it as the
    <literal moreinfo="none">Left</literal> value or returns the normal result as the
    <literal moreinfo="none">Right</literal> value. The <literal moreinfo="none">for</literal> loop uses this
    method to invoke <literal moreinfo="none">throwsOnOddInt</literal>. It pattern matches on
    the result and prints an appropriate message. The output of the script is
    the following:</para><screen format="linespecific">0
Oops, got exception java.lang.RuntimeException: 1 is odd!
2
Oops, got exception java.lang.RuntimeException: 3 is odd!</screen><para id="para_a_function__n__trait_where__">A
    <literal moreinfo="none">FunctionN</literal> trait, where <literal moreinfo="none">N</literal> is 0 to 22,
    is instantiated for an anonymous function with <literal moreinfo="none">N</literal>
    arguments. So, consider the following anonymous function:<indexterm significance="normal"><primary>FunctionN object</primary></indexterm></para><programlisting language="scala" format="linespecific">(t1:<code role="type"> T1</code>, ..., tN:<code role="type"> TN</code>) <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">R</code>(...)
</programlisting><para id="para_it_is_syntactic_sugar_for_the_">It is syntactic sugar for
    the following creation of an anonymous class:</para><programlisting language="scala" format="linespecific"><code role="statement">new</code> <code role="special">FunctionN</code> {
  <code role="statement">def</code> <code role="identifier">apply</code>(t1:<code role="type"> T1</code>, ..., tN:<code role="type"> TN</code>):<code role="type"> R</code> = <code role="statement">new</code> <code role="special">R</code>(...)

  <code role="comment">// other methods</code>
}
</programlisting><para id="para_we_ll_revisit_function__n__in">We’ll revisit
    <literal moreinfo="none">FunctionN</literal> in <xref linkend="VarianceUnderInheritance"/> and <xref linkend="FunctionTypes"/>.</para></sect1><sect1 id="Linearization"><title>Linearization of an Object’s Hierarchy</title><para id="para_because_of_single_inheritance_">Because of single
    inheritance, the inheritance hierarchy would be linear, if we ignored
    mixed-in traits. When traits are considered, each of which may be derived
    from other traits and classes, the inheritance hierarchy forms a directed,
    acyclic graph (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). The term
    <emphasis>linearization</emphasis> refers to the algorithm used to
    “flatten” this graph for the purposes of resolving method lookup
    priorities, constructor invocation order, binding of
    <literal moreinfo="none">super</literal>, etc.<indexterm class="startofrange" id="ch07_inheritlinearization" significance="normal"><primary>inheritance</primary><secondary>linearization of object hierarchy</secondary></indexterm><indexterm class="startofrange" id="ch07_linearization" significance="normal"><primary>linearization of object hierarchy</primary></indexterm><indexterm class="startofrange" id="ch07_ojectsyslinearization" significance="normal"><primary>object system (Scala)</primary><secondary>linearization of object hierarchy</secondary></indexterm></para><para id="para_informally_we_saw_in_stacka">Informally, we saw in <xref linkend="StackableTraits"/> that when an instance has more than one
    trait, they bind right to left, as declared. Consider the following
    example of linearization:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/linearization/linearization1-script.scala</code>

<code role="statement">class</code> <code role="special">C1</code> {
  <code role="statement">def</code> <code role="identifier">m</code> = <code role="special">List</code>(<code role="constant">"C1"</code>)
}

<code role="statement">trait</code> <code role="special">T1</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"T1"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">trait</code> <code role="special">T2</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"T2"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">trait</code> <code role="special">T3</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"T3"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">class</code> <code role="special">C2</code> <code role="statement">extends</code> <code role="special">T1</code> <code role="statement">with</code> <code role="special">T2</code> <code role="statement">with</code> <code role="special">T3</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"C2"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">val</code> c2 = <code role="statement">new</code> <code role="special">C2</code>
println(c2.m)
</programlisting><para id="para_running_oop2a">Running this script yields the following
    output:</para><screen format="linespecific">List(C2, T3, T2, T1, C1)</screen><para id="para_this_list_of_strings_built_up_">This list of strings built
    up by the <literal moreinfo="none">m</literal> methods reflects the
    <emphasis>linearization</emphasis> of the inheritance hierarchy, with a
    few missing pieces we’ll discuss shortly. We’ll also see why C1 is at the
    end of the list. First, let’s see what the invocation sequence of the
    constructors looks like:<indexterm significance="normal"><primary>reference types</primary><secondary>linearization algorithm for</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/linearization/linearization2-script.scala</code>

<code role="statement">var</code> clist = <code role="special">List</code><code role="special">[String]</code>()

<code role="statement">class</code> <code role="special">C1</code> {
  clist ::= <code role="constant">"C1"</code>
}

<code role="statement">trait</code> <code role="special">T1</code> <code role="statement">extends</code> <code role="special">C1</code> {
  clist ::= <code role="constant">"T1"</code>
}

<code role="statement">trait</code> <code role="special">T2</code> <code role="statement">extends</code> <code role="special">C1</code> {
  clist ::= <code role="constant">"T2"</code>
}

<code role="statement">trait</code> <code role="special">T3</code> <code role="statement">extends</code> <code role="special">C1</code> {
  clist ::= <code role="constant">"T3"</code>
}

<code role="statement">class</code> <code role="special">C2</code> <code role="statement">extends</code> <code role="special">T1</code> <code role="statement">with</code> <code role="special">T2</code> <code role="statement">with</code> <code role="special">T3</code> {
  clist ::= <code role="constant">"C2"</code>
}

<code role="statement">val</code> c2 = <code role="statement">new</code> <code role="special">C2</code>
println(clist.reverse)
</programlisting><para id="para_running_oop2b">Running this script yields the following
    output:</para><screen format="linespecific">List(C1, T1, T2, T3, C2)</screen><para id="para_so_the_construction_sequence_">So, the construction
    sequence is the reverse. (We had to reverse the list on the last line,
    because the way it was constructed put the elements in the reverse order.)
    This invocation order makes sense. For proper construction to occur, the
    parent types need to be constructed before the derived types, since a
    derived type often uses fields and methods in the parent types during its
    construction process.</para><para id="para_the_output_of_linearization_">The output of the first
    linearization script is actually missing three types at the end. The full
    linearization for reference types actually ends with
    <literal moreinfo="none">ScalaObject</literal>, <literal moreinfo="none">AnyRef</literal>, and
    <literal moreinfo="none">Any</literal>. So the linearization for <literal moreinfo="none">C2</literal> is
    actually:</para><screen format="linespecific">List(C2, T3, T2, T1, C1, ScalaObject, AnyRef, Any)</screen><para id="para_scala_inserts_the_scalaobject">Scala inserts the
    <literal moreinfo="none">ScalaObject</literal> trait as the last mixin, just before
    <literal moreinfo="none">AnyRef</literal> and <literal moreinfo="none">Any</literal> that are the
    penultimate and ultimate parent classes of any reference type. Of course,
    these three types do not show up in the output of the scripts, because we
    used an ad hoc <literal moreinfo="none">m</literal> method to figure out the behavior by
    building up an output string.</para><para id="para_the_value_types_subclasse">The “value types,” subclasses of
    <literal moreinfo="none">AnyVal</literal>, are all declared <literal moreinfo="none">abstract
    final</literal>. The compiler manages instantiation of them. Since we
    can’t subclass them, their linearizations are simple and
    straightforward.</para><para id="para_the_linearization_defines_the_">The linearization defines
    the order in which method lookup occurs. Let’s examine it more
    closely.</para><para id="para_all_our_classes_and_traits_def">All our classes and traits
    define the method <literal moreinfo="none">m</literal>. The one in <literal moreinfo="none">C2</literal>
    is called first, since the instance is of that type.
    <literal moreinfo="none">C2.m</literal> calls <literal moreinfo="none">super.m</literal>, which resolves
    to <literal moreinfo="none">T3.m</literal>. The search appears to be
    <emphasis>breadth-first</emphasis>, rather than
    <emphasis>depth-first</emphasis>. If it were depth-first, it would invoke
    <literal moreinfo="none">C1.m</literal> after <literal moreinfo="none">T3.m</literal>. Afterward,
    <literal moreinfo="none">T3.m</literal>, <literal moreinfo="none">T2.m</literal>, then
    <literal moreinfo="none">T1.m</literal>, and finally <literal moreinfo="none">C1.m</literal> are invoked.
    <literal moreinfo="none">C1</literal> is the parent of the three traits. From which of the
    traits did we traverse to <literal moreinfo="none">C1</literal>? Actually, it is
    breadth-first, with “delayed” evaluation, as we will see. Let’s modify our
    first example and see how we got to <literal moreinfo="none">C1</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/linearization/linearization3-script.scala</code>

<code role="statement">class</code> <code role="special">C1</code> {
  <code role="statement">def</code> <code role="identifier">m</code>(previous:<code role="type"> String</code>) = <code role="special">List</code>(<code role="constant">"C1("</code>+previous+<code role="constant">")"</code>)
}

<code role="statement">trait</code> <code role="special">T1</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code>(p:<code role="type"> String</code>) = { <code role="constant">"T1"</code> :: <code role="statement">super</code>.m(<code role="constant">"T1"</code>) }
}

<code role="statement">trait</code> <code role="special">T2</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code>(p:<code role="type"> String</code>) = { <code role="constant">"T2"</code> :: <code role="statement">super</code>.m(<code role="constant">"T2"</code>) }
}

<code role="statement">trait</code> <code role="special">T3</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code>(p:<code role="type"> String</code>) = { <code role="constant">"T3"</code> :: <code role="statement">super</code>.m(<code role="constant">"T3"</code>) }
}

<code role="statement">class</code> <code role="special">C2</code> <code role="statement">extends</code> <code role="special">T1</code> <code role="statement">with</code> <code role="special">T2</code> <code role="statement">with</code> <code role="special">T3</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code>(p:<code role="type"> String</code>) = { <code role="constant">"C2"</code> :: <code role="statement">super</code>.m(<code role="constant">"C2"</code>) }
}

<code role="statement">val</code> c2 = <code role="statement">new</code> <code role="special">C2</code>
println(c2.m(<code role="constant">""</code>))
</programlisting><para id="para_now_we_pass_the_name_of_the_ca">Now we pass the name of the
    caller of <literal moreinfo="none">super.m</literal> as a parameter, then
    <literal moreinfo="none">C1</literal> prints out who called it. Running this script yields
    the following output:</para><screen format="linespecific">List(C2, T3, T2, T1, C1(T1))</screen><para id="para_it_s_the_last_one_t1_we_mi">It’s the last one,
    <literal moreinfo="none">T1</literal>. We might have expected <literal moreinfo="none">T3</literal> from a
    “naïve” application of breadth-first traversal.<indexterm significance="normal"><primary>linearization of object hierarchy</primary><secondary>algorithm for reference types</secondary></indexterm></para><para id="para_here_is_the_actual_algorithm_f">Here is the actual
    algorithm for calculating the linearization. A more formal definition is
    given in <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>.<indexterm significance="normal"><primary>reference types</primary><secondary>linearization algorithm for</secondary></indexterm></para><?dbfo-need height=”1in”
?><sidebar><title>Linearization Algorithm for Reference Types</title><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>Put the actual type of the instance as the first
          element.</para></listitem><listitem><para>Starting with the <emphasis>rightmost</emphasis> parent type
          and working <emphasis>left</emphasis>, compute the linearization of
          each type, appending its linearization to the cumulative
          linearization. (Ignore <literal moreinfo="none">ScalaObject</literal>,
          <literal moreinfo="none">AnyRef</literal>, and <literal moreinfo="none">Any</literal> for
          now.)</para></listitem><listitem><para>Working from <emphasis>left to right</emphasis>, remove any
          type if it appears again to the <emphasis>right</emphasis> of the
          current position.</para></listitem><listitem><para>Append <literal moreinfo="none">ScalaObject</literal>,
          <literal moreinfo="none">AnyRef</literal>, and <literal moreinfo="none">Any</literal>.</para></listitem></orderedlist></sidebar><para id="para_this_explains_how_we_got_to_c">This explains how we got to
    <literal moreinfo="none">C1</literal> from <literal moreinfo="none">T1</literal> in the previous example.
    <literal moreinfo="none">T3</literal> and <literal moreinfo="none">T2</literal> also have it in their
    linearizations, but they come before <literal moreinfo="none">T1</literal>, so the
    <literal moreinfo="none">C1</literal> terms they contributed were deleted.</para><para id="para_let_s_work_through_the_algorit">Let’s work through the
    algorithm using a slightly more involved example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/linearization/linearization4-script.scala</code>

<code role="statement">class</code> <code role="special">C1</code> {
  <code role="statement">def</code> <code role="identifier">m</code> = <code role="special">List</code>(<code role="constant">"C1"</code>)
}

<code role="statement">trait</code> <code role="special">T1</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"T1"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">trait</code> <code role="special">T2</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"T2"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">trait</code> <code role="special">T3</code> <code role="statement">extends</code> <code role="special">C1</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"T3"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">class</code> <code role="special">C2A</code> <code role="statement">extends</code> <code role="special">T2</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"C2A"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">class</code> <code role="special">C2</code> <code role="statement">extends</code> <code role="special">C2A</code> <code role="statement">with</code> <code role="special">T1</code> <code role="statement">with</code> <code role="special">T2</code> <code role="statement">with</code> <code role="special">T3</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">m</code> = { <code role="constant">"C2"</code> :: <code role="statement">super</code>.m }
}

<code role="statement">def</code> <code role="identifier">calcLinearization</code>(obj:<code role="type"> C1</code>, name:<code role="type"> String</code>) = {
  <code role="statement">val</code> lin = obj.m ::: <code role="special">List</code>(<code role="constant">"ScalaObject"</code>, <code role="constant">"AnyRef"</code>, <code role="constant">"Any"</code>)
  println(name + <code role="constant">":  "</code> + lin)
}

calcLinearization(<code role="statement">new</code> <code role="special">C2</code>, <code role="constant">"C2 "</code>)
println(<code role="constant">""</code>)
calcLinearization(<code role="statement">new</code> <code role="special">T3</code> {}, <code role="constant">"T3 "</code>)
calcLinearization(<code role="statement">new</code> <code role="special">T2</code> {}, <code role="constant">"T2 "</code>)
calcLinearization(<code role="statement">new</code> <code role="special">T1</code> {}, <code role="constant">"T1 "</code>)
calcLinearization(<code role="statement">new</code> <code role="special">C2A</code>, <code role="constant">"C2A"</code>)
calcLinearization(<code role="statement">new</code> <code role="special">C1</code>, <code role="constant">"C1 "</code>)
</programlisting><para id="para_out1">The output is the following:</para><screen format="linespecific">C2 :  List(C2, T3, T1, C2A, T2, C1, ScalaObject, AnyRef, Any)

T3 :  List(T3, C1, ScalaObject, AnyRef, Any)
T2 :  List(T2, C1, ScalaObject, AnyRef, Any)
T1 :  List(T1, C1, ScalaObject, AnyRef, Any)
C2A:  List(C2A, T2, C1, ScalaObject, AnyRef, Any)
C1 :  List(C1, ScalaObject, AnyRef, Any)</screen><para id="para_to_help_us_along_we_calculate">To help us along, we
    calculated the linearizations for the other types, and we also appended
    <literal moreinfo="none">ScalaObject</literal>, <literal moreinfo="none">AnyRef</literal>, and
    <literal moreinfo="none">Any</literal> to remind ourselves that they should also be there.
    We also removed the logic to pass the caller’s name to
    <literal moreinfo="none">m</literal>. That caller of <literal moreinfo="none">C1</literal> will
    <emphasis>always</emphasis> be the element to its immediate
    left.<indexterm significance="normal"><primary>linearization of object hierarchy</primary><secondary>hand calculation for C2 (example)</secondary></indexterm></para><para id="para_so_let_s_work_through_the_alg">So, let’s work through the
    algorithm for <literal moreinfo="none">C2</literal> and confirm our results. We’ll
    suppress the <literal moreinfo="none">ScalaObject</literal>, <literal moreinfo="none">AnyRef</literal>,
    and <literal moreinfo="none">Any</literal> for clarity, until the end. See <xref linkend="table_7-5"/>.</para><table id="table_7-5"><title>Hand calculation of C2 linearization: C2 extends C2A with T1 with
      T2 with T3 {...}</title><tgroup cols="3"><thead valign="top"><row><entry>#</entry><entry><phrase role="keep-together">Linearization</phrase></entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para>1</para></entry><entry><para><literal moreinfo="none">C2</literal></para></entry><entry><para>Add the type of the instance.</para></entry></row><row><entry><para>2</para></entry><entry><para><literal moreinfo="none">C2, T3, C1</literal></para></entry><entry><para>Add the linearization for <literal moreinfo="none">T3</literal>
            (farthest on the right).</para></entry></row><row><entry><para>3</para></entry><entry><para><literal moreinfo="none">C2, T3, C1, T2, C1</literal></para></entry><entry><para>Add the linearization for
            <literal moreinfo="none">T2</literal>.</para></entry></row><row><entry><para>4</para></entry><entry><para><literal moreinfo="none">C2, T3, C1, T2, C1, T1,
            C1</literal></para></entry><entry><para>Add the linearization for
            <literal moreinfo="none">T1</literal>.</para></entry></row><row><entry><para>5</para></entry><entry><para><literal moreinfo="none">C2, T3, C1, T2, C1, T1, C1, C2A, T2,
            C1</literal></para></entry><entry><para>Add the linearization for
            <literal moreinfo="none">C2A</literal>.</para></entry></row><row><entry><para>6</para></entry><entry><para><literal moreinfo="none">C2, T3, T2, T1, C2A, T2,
            C1</literal></para></entry><entry><para>Remove duplicates of <literal moreinfo="none">C1</literal>; all but
            the <emphasis>last</emphasis>
            <literal moreinfo="none">C1</literal>.</para></entry></row><row><entry><para>7</para></entry><entry><para><literal moreinfo="none">C2, T3, T1, C2A, T2,
            C1</literal></para></entry><entry><para>Remove duplicate <literal moreinfo="none">T2</literal>; all but the
            <emphasis>last</emphasis> <literal moreinfo="none">T2</literal>.</para></entry></row><row><entry><para>8</para></entry><entry><para><literal moreinfo="none">C2, T3, T1, C2A, T2, C1, ScalaObject,<?lb?>
            AnyRef, Any</literal></para></entry><entry><para>Finish!</para></entry></row></tbody></tgroup></table><para id="para_what_the_algorithm_does_is_pus">What the algorithm does is
    push any shared types to the right until they come after
    <emphasis>all</emphasis> the types that derive from them.</para><para id="para_try_modifying_the_last_script_">Try modifying the last
    script with different hierarchies and see if you can reproduce the results
    using the algorithm.<indexterm class="endofrange" startref="ch07_ojectsyslinearization" significance="normal"/><indexterm class="endofrange" startref="ch07_linearization" significance="normal"/><indexterm class="endofrange" startref="ch07_inheritlinearization" significance="normal"/></para><tip id="para_tip_overly_complex_type_hiera"><para>Overly complex type hierarchies can result in method lookup
      “surprises.” If you have to work through this algorithm to figure out
      what’s going on, try to simplify your code.</para></tip></sect1><?dbfo-need height=”1in”
?><sect1 id="_recap_and_what_8217_s_next_4"><title>Recap and What’s Next</title><para id="para_we_have_finished_our_survey_of">We have finished our survey
    of Scala’s object model. If you come from an <phrase role="keep-together">object-</phrase><phrase role="keep-together">oriented</phrase> language background, you now know
    enough about Scala to replace your existing object-oriented language with
    object-oriented Scala.</para><para id="para_however_there_is_much_more_to">However, there is much more
    to come. Scala supports <emphasis>functional programming</emphasis>, which
    offers powerful mechanisms for addressing a number of design problems,
    such as concurrency. We’ll see that functional programming appears to
    contradict object-oriented programming, at least on the surface. That
    said, a guiding principle behind Scala is that these two paradigms
    complement each other more than they conflict. Combined, they give you
    more options for building robust, scalable software. Scala lets you choose
    the techniques that work best for your needs.<indexterm class="endofrange" startref="ch07_objectsys" significance="normal"/></para></sect1></chapter><chapter id="FunctionalProgramming"><title>Functional Programming in Scala</title><para id="para_every_decade_or_two_a_major_c">Every decade or two, a major
  computing idea goes mainstream. These ideas may have lurked in the
  background of academic computer science research, or possibly in some
  lesser-known field of industry. The transition to mainstream acceptance
  comes in response to a perceived problem for which the idea is well suited.
  Object-oriented programming, which was invented in the 1960s, went
  mainstream in the 1980s, arguably in response to the emergence of graphical
  user interfaces, for which the OOP paradigm is a natural fit.<indexterm class="startofrange" id="ch08_functional" significance="normal"><primary>functional programming</primary></indexterm></para><para id="para_functional_programming_appears">Functional programming
  appears to be experiencing a similar breakout. Long the topic of computer
  science research and even older than object-oriented programming, functional
  programming offers effective techniques for concurrent programming, which is
  growing in importance.</para><para id="para_because_functional_programming">Because functional
  programming is less widely understood than object-oriented programming, we
  won’t assume that you have prior experience with it. We’ll start this
  chapter with plenty of background information. As you’ll see, functional
  programming is not only a very effective way to approach concurrent
  programming, which we’ll explore in depth in <xref linkend="Concurrency"/>,
  but functional programming can also improve your objects.</para><para id="para_to_learn_more_about_functional">Of course, we can’t provide
  an exhaustive introduction to functional programming. To learn more about
  it, <link linkend="OSullivan2009" xrefstyle="select:nopage">[O’Sullivan2009]</link> has a more detailed
  introduction in the context of the Haskell language. <link linkend="Abelson1996" xrefstyle="select:nopage">[Abelson1996]</link>, <link linkend="VanRoy2004" xrefstyle="select:nopage">[VanRoy2004]</link>, and
  <link linkend="Turbak2008" xrefstyle="select:nopage">[Turbak2008]</link>
  offer thorough introductions to general programming approaches, including
  functional programming. Finally, <link linkend="Okasaki1998" xrefstyle="select:nopage">[Okasaki1998]</link> and <link linkend="Rabhi1999" xrefstyle="select:nopage">[Rabhi1999]</link> discuss functional data
  structures and algorithms in detail.<indexterm significance="normal"><primary>functions</primary><seealso>functional programming</seealso></indexterm></para><sect1 id="WhatIsFunctionalProgramming"><title>What Is Functional Programming?</title><para id="para_based_on_mathematics_">Don’t all programming languages have
    functions of some sort? Whether they are called methods, procedures, or
    <literal moreinfo="none">GOTOs</literal>, programmers are always dealing in functions.
    <phrase role="keep-together">Functional</phrase> programming is based on
    the behavior of functions in the mathematical sense, with all the
    implications that starting point implies.<indexterm significance="normal"><primary>functional programming</primary><secondary>definition of</secondary></indexterm></para><sect2 id="FunctionsInMathematics"><title>Functions in Mathematics</title><para id="para_fp_in_mathematics">In mathematics, functions have no
      <emphasis>side effects</emphasis>. Consider the classic function
      <literal moreinfo="none">sin(x)</literal>:<indexterm significance="normal"><primary>functional programming</primary><secondary>functions in mathematics</secondary></indexterm><indexterm significance="normal"><primary>mathematics, functions in</primary></indexterm></para><programlisting language="scala" format="linespecific">y = sin(x)
</programlisting><para id="para_no_matter_how_much_work_y_s">No matter how much work
      <literal moreinfo="none">sin(x)</literal> does, all the results are returned and
      assigned to <literal moreinfo="none">y</literal>. No global state of any kind is
      modified internally by <literal moreinfo="none">sin(x)</literal>. Hence, we say that
      such a function is free of <emphasis>side effects</emphasis>, or
      <emphasis>pure</emphasis>.</para><para id="para_this_property_simplifies_enorm">This property simplifies
      enormously the challenge of analyzing, testing, and debugging a
      function. You can do these things without having to know anything about
      the context in which the function is invoked, except for any other
      functions it might call. However, you can analyze them in the same way,
      working bottom up to verify the whole “stack.”</para><para id="para_the_obliviousness_to_the_surro">This obliviousness to the
      surrounding context is known as <emphasis>Referential
      Transparency</emphasis>. You can call such a function anywhere and be
      confident that it will always behave the same way. If no global state is
      modified, concurrent invocation of the function is straightforward and
      reliable.</para><para id="para_in_functional_programming_the">In functional programming,
      you can compose functions from other functions. For example,
      <literal moreinfo="none">tan(x) = sin(x)/cos(x)</literal>. An implication of
      composability is that functions can be treated as values. In other
      words, functions are <emphasis>first-class</emphasis>, just like data.
      You can assign functions to variables. You can pass functions to other
      functions. You can return functions as values from functions. In the
      functional paradigm, functions become a primitive type, a building block
      that’s just as essential to the work of programming as integers or
      strings.</para><para id="para_when_a_function_takes_other_fu">When a function takes
      other functions as arguments or returns a function, it is called a
      <emphasis>higher-order function</emphasis>. In mathematics, two examples
      of higher-order functions from calculus are derivation and
      integration.<indexterm significance="normal"><primary>functions</primary><secondary>higher order</secondary></indexterm><indexterm significance="normal"><primary>higher-order functions</primary></indexterm></para></sect2><sect2 id="VariablesThatArent"><title>Variables that Aren’t</title><para id="para_fp_variables_are_immutable">The word “variable” takes on
      a new meaning in functional programming. If you come from a procedural
      or object-oriented programming background, you are accustomed to
      variables that are <emphasis>mutable</emphasis>. In functional
      programming, variables are <emphasis>immutable</emphasis>.<indexterm significance="normal"><primary>variables</primary><secondary>immutable values in functional programming</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>variables, immutable values of</secondary></indexterm></para><para id="para_this_is_another_consequence_of">This is another
      consequence of the mathematical orientation. In the expression
      <literal moreinfo="none">y = sin(x)</literal>, once you pick <literal moreinfo="none">x</literal>, then
      <literal moreinfo="none">y</literal> is fixed. As another example, if you increment the
      integer 3 by 1, you don’t “modify the 3 object,” you create a new value
      to represent 4.</para><para id="para_to_be_more_precise_it_is_the_">To be more precise, it is
      the values that are immutable. Functional programming languages prevent
      you from assigning a new value to a variable that already has a
      value.</para><para id="para_immutability_is_difficult_when">Immutability is difficult
      when you’re not used to it. If you can’t change a variable, then you
      can’t have loop counters, for example. We’re accustomed to objects that
      change their state when we call methods on them. Learning to think in
      immutable terms takes some effort.</para><para id="para_however_immutability_has_enor">However, immutability has
      enormous benefits for concurrency. Almost all the difficulty of
      multithreaded programming lies in synchronizing access to shared,
      mutable state. If you remove mutability, then the problems essentially
      go away. It is the combination of referentially transparent functions
      and immutable values that make functional programming compelling as a
      better way to write concurrent software.</para><para id="para_these_qualities_benefit_progra">These qualities benefit
      programs in other ways. Almost all the constructs we have <phrase role="keep-together">invented</phrase> in 60-odd years of computer
      programming have been attempts to manage complexity. Higher-order
      functions and referential transparency provide very flexible building
      blocks for composing programs.</para><para id="para_immutability_greatly_reduces_r">Immutability greatly
      reduces regression bugs, many of which are caused by
      <emphasis>unintended</emphasis> state changes in one part of a program
      due to <emphasis>intended</emphasis> changes in another part. There are
      other contributors to such <emphasis>non-local</emphasis> effects, but
      mutability is one of the most important.</para><para id="para_it_s_common_in_object_oriented">It’s common in
      object-oriented designs to encapsulate access to data structures in
      objects. If these structures are mutable, we can’t simply share them
      with clients. We have to add special accessor methods to control access,
      so clients can’t modify them outside our control. These additions
      increase code size, which increases the testing and maintenance burden,
      and they increase the effort required by clients to understand the ad
      hoc features of our APIs.</para><para id="para_in_contrast_when_we_have_immu">In contrast, when we have
      immutable data structures, many of these problems simply go away. We can
      provide access to collections without fear of data loss or corruption.
      Of course, the general principles of minimal coupling still apply;
      should clients care if a <literal moreinfo="none">Set</literal> or
      <literal moreinfo="none">List</literal> is used, as long <literal moreinfo="none">foreach</literal> is
      available?</para><para id="para_immutable_data_also_implies_th">Immutable data also
      implies that lots of copies will be made, which can be expensive.
      Functional data structures optimize for this problem (see <link linkend="Okasaki1998" xrefstyle="select:nopage">[Okasaki1998]</link>)
      and many of the built-in Scala types are efficient at creating new
      copies from existing copies.</para><para id="para_we_ll_discuss_other_aspects_of">It’s time to dive into
      the practicalities of functional programming in Scala. We’ll discuss
      other aspects and benefits of the approach as we proceed.</para></sect2></sect1><sect1 id="FunctionalProgrammingInScala"><title>Functional Programming in Scala</title><para id="para_as_a_hybrid_object_functional_">As a hybrid
    object-functional language, Scala does not require functions to be pure,
    nor does it require variables to be immutable. It does, however, encourage
    you to write your code this way whenever possible. You have the freedom to
    use procedural or object-oriented techniques when and where they seem most
    appropriate.<indexterm class="startofrange" id="ch08_functionalScala" significance="normal"><primary>functional programming</primary><secondary sortas="Scala">in Scala</secondary></indexterm></para><para id="para_if_you_think_about_what_we_sai">Though functional languages
    are all about eliminating side effects, a language that
    <emphasis>never</emphasis> allowed for side effects would be useless.
    Input and output (IO) are inherently about side effects, and IO is
    essential to all programming tasks. For this reason, all functional
    languages provide mechanisms for performing side effects in a controlled
    way.</para><para id="para_scala_doesn_t_restrict_what_yo">Scala doesn’t restrict what
    you can do, but we encourage you to use immutable values and pure
    functions and methods whenever possible. When mutability and side effects
    are necessary, pursue them in a “principled” way, isolated in well-defined
    modules and focused on individual tasks.</para><para id="para_however_if_you_are_new_to_fun">If you’re new to functional
    programming, keep in mind that it’s easy to fall back to old habits. We
    encourage you to master the functional side of Scala and to learn to use
    it effectively.</para><tip id="para_tip_a_function_that_returns_"><para>A function that returns <literal moreinfo="none">Unit</literal> implies that the
      function has pure side effects, meaning that if it does any useful work,
      that work must be all side effects, since the function doesn’t return
      anything.</para></tip><para id="para_we_ve_seen_many_examples_of_hi">We’ve seen many examples of
    higher-order functions and composability in Scala. For example,
    <literal moreinfo="none">List.map</literal> takes a function to transform each element of
    the list to something else:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/basics/list-map-example-script.scala</code>

<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>) map { <code role="statement">_</code> * <code role="constant">2</code> }
</programlisting><para id="para_recall_that_095_042_2_">Recall that <literal moreinfo="none">_ *
    2</literal> is a <emphasis>function literal</emphasis> that is shorthand
    for <literal moreinfo="none">i =&gt; i * 2</literal>. For each argument to the function,
    you can use <literal moreinfo="none">_</literal> if the argument is used only once. We
    also used the infix operator notation to invoke <literal moreinfo="none">map</literal>.
    Here’s an example that “reduces” the same list by multiplying all the
    elements together:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/basics/list-reduceLeft-example-script.scala</code>

<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>) reduceLeft { <code role="statement">_</code> * <code role="statement">_</code> }
</programlisting><para id="para_the_first_095_represents_th">The first <literal moreinfo="none">_</literal>
    represents the argument that is accumulating the value of the reduction,
    and the second <literal moreinfo="none">_</literal> represents the current element of the
    list.</para><para id="para_by_the_way_this_example_succe">Both examples successfully
    “looped” through the list without the use of a mutable counter to track
    iterations. Most containers in the Scala library provide functionally pure
    iteration methods. In other cases, recursion is the preferred way to
    traverse a data structure or perform an algorithm. We’ll return to this
    topic in <xref linkend="Recursion"/>.</para><?dbfo-need height=”1in”
?><sect2 id="FunctionLiteralsAndClosures"><title>Function Literals and Closures</title><para id="para_let_s_expand_our_previous_exam">Let’s expand our previous
      <literal moreinfo="none">map</literal> example a bit:<indexterm significance="normal"><primary>function literals</primary><secondary>closures and</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary sortas="Scala">in Scala</secondary><tertiary>function literals and closures</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/basics/list-map-closure-example-script.scala</code>

<code role="statement">var</code> factor = <code role="constant">3</code>
<code role="statement">val</code> multiplier = (i:<code role="type">Int</code>) <code role="statement">=&gt;</code> i * factor

<code role="statement">val</code> l1 = <code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>) map multiplier

factor = <code role="constant">5</code>
<code role="statement">val</code> l2 = <code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>) map multiplier

println(l1)
println(l2)
</programlisting><para id="para_we_defined_a_var_factor_to">We defined a variable,
      <literal moreinfo="none">factor</literal>, to use as the multiplication factor, and we
      pulled out the previous anonymous function into a value called
      <literal moreinfo="none">multiplier</literal> that now uses <literal role="keep-together" moreinfo="none">factor</literal>. Then we map over a list of
      integers, as we did before. After the first call to
      <literal moreinfo="none">map</literal>, we change <literal moreinfo="none">factor</literal> and map
      again. Here is the output:</para><screen format="linespecific">List(3, 6, 9, 12, 15)
List(5, 10, 15, 20, 25)</screen><para id="para_even_though_multiplier_was_a">Even though
      <literal moreinfo="none">multiplier</literal> was an immutable function value, its
      behavior changed when <literal moreinfo="none">factor</literal> changed.</para><para id="para_there_are_two__free_variables_">There are two
      <emphasis>free variables</emphasis> in <literal moreinfo="none">multiplier</literal>:
      <literal moreinfo="none">i</literal> and <literal moreinfo="none">factor</literal>. One of them,
      <literal moreinfo="none">i</literal>, is a <emphasis>formal parameter</emphasis> to the
      function. Hence, it is <emphasis>bound</emphasis> to a new value each
      time <literal moreinfo="none">multiplier</literal> is called.</para><para id="para_however_factor_is_not_a_for">However,
      <literal moreinfo="none">factor</literal> is not a formal parameter, but a reference to
      a variable in the enclosing scope. Hence, the compiler creates a
      <emphasis>closure</emphasis> that encompasses (or “closes over”)
      <literal role="keep-together" moreinfo="none">multiplier</literal> and the external
      context of the unbound variables <literal moreinfo="none">multiplier</literal>
      references, thereby binding those variables as well.<indexterm significance="normal"><primary>closures</primary></indexterm></para><para id="para_this_is_why_the_behavior_of_m">This is why the behavior
      of <literal moreinfo="none">multiplier</literal> changed after changing
      <literal moreinfo="none">factor</literal>. It references <literal moreinfo="none">factor</literal> and
      reads its current value each time. If a function has no external
      references, then it is trivially closed over itself. No external context
      is required.</para></sect2><sect2 id="PurityInsideVsOutside"><title>Purity Inside Versus Outside</title><para id="para_if_we_called_sin_x_thousand">If we called
      <literal moreinfo="none">sin(x)</literal> thousands of times with the same value of
      <literal moreinfo="none">x</literal>, it would be wasteful if it calculated the same
      value every single time. Even in “pure” functional libraries, it is
      common to perform internal optimizations like caching previously
      computed values (sometimes called <emphasis>memoization</emphasis>).
      Caching introduces side effects, as the state of the cache is
      modified.<indexterm significance="normal"><primary>memoization</primary></indexterm></para><para id="para_however_this_lack_of_purity_s">However, this lack of
      purity should be opaque to the user (except perhaps in terms of the
      performance impact). If you are designing functional libraries, ensure
      that they preserve the purity of their abstractions, including the
      behavior of referential transparency and its implications for
      concurrency.</para><para id="para_you_can_see_examples_of_this_i">You can see examples of
      functional libraries with mutable internals in the Scala library. The
      methods in <literal moreinfo="none">List</literal> often use mutable local variables for
      efficient traversal. The local variables are thread-safe, as are the
      traversals, since <literal moreinfo="none">Lists</literal> themselves are
      immutable.<indexterm class="endofrange" startref="ch08_functionalScala" significance="normal"/></para></sect2></sect1><sect1 id="Recursion"><title>Recursion</title><para id="para_recursion_plays_a_larger_role_">Recursion plays a larger
    role in pure functional programming than in imperative programming, in
    part because of the restriction that variables are immutable. For example,
    you can’t have loop counters, which would change on each pass through a
    loop. One way to implement looping in a purely functional way is with
    recursion.<indexterm significance="normal"><primary>recursion</primary><secondary sortas="functional programming">in functional
        programming</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>recursion</secondary></indexterm></para><para id="para_loop_by_recursion_example_">Calculating factorials provides
    a good example. Here is an imperative loop <phrase role="keep-together">implementation</phrase>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/recursion/factorial-loop-script.scala</code>

<code role="statement">def</code> <code role="identifier">factorial_loop</code>(i:<code role="type"> BigInt</code>):<code role="type"> BigInt</code> = {
  <code role="statement">var</code> result = <code role="special">BigInt</code>(<code role="constant">1</code>)
  <code role="statement">for</code> (j <code role="statement">&lt;-</code> <code role="constant">2</code> to i.intValue)
    result *= j
  result
}

<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">10</code>)
  format(<code role="constant">"%s: %s</code><code role="special">\n</code><code role="constant">"</code>, i, factorial_loop(i))
</programlisting><para id="para_both_the_loop_counter_j_and_">Both the loop counter
    <literal moreinfo="none">j</literal> and the <literal moreinfo="none">result</literal> are mutable
    variables. (For simplicity, we’re ignoring input numbers that are less
    than or equal to zero.) The output of the script is the following:</para><screen format="linespecific">1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800</screen><para id="para_fact_recur1_impl">Here’s a first pass at a recursive
    implementation:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/recursion/factorial-recur1-script.scala</code>

<code role="statement">def</code> <code role="identifier">factorial</code>(i:<code role="type"> BigInt</code>):<code role="type"> BigInt</code> = i <code role="statement">match</code> {
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">if</code> i == <code role="constant">1</code> <code role="statement">=&gt;</code> i
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> i * factorial(i - <code role="constant">1</code>)
}

<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">10</code>)
  format(<code role="constant">"%s: %s</code><code role="special">\n</code><code role="constant">"</code>, i, factorial(i))
</programlisting><para id="para_the_output_is_the_same_but_no">The output is the same, but
    now there are no mutable variables. Recursion not only helps us avoid
    mutable variables, it is also the most natural way to express some <phrase role="keep-together">functions</phrase>, particularly mathematical
    functions. The recursive definition in our second <literal role="keep-together" moreinfo="none">factorial</literal> is structurally similar to a
    definition for factorials that you might see in a mathematics book.</para><para id="para_two_potential_problems_with_re">However, there are two
    potential problems with recursion: the performance overhead of repeated
    function invocations and the risk of stack overflow.</para><para id="para_performance_problems_in_a_recu">Performance problems in a
    recursive scenario can sometimes be addressed with
    <emphasis>memoization</emphasis>, but care should be taken that the space
    requirements of caching don’t outweigh the performance benefits.</para><para id="para_stack_overflow_can_be_avoided_">Stack overflow can be
    avoided by converting the recursive invocation into a loop of some kind.
    In fact, the Scala compiler can do this conversion for you for some kinds
    of recursive invocations, which we describe next.</para></sect1><sect1 id="TailCalls"><title>Tail Calls and Tail-Call Optimization</title><para id="para_a_particular_kind_of_recursion">A particular kind of
    recursion is called <emphasis>tail-call</emphasis> recursion, which occurs
    when a function calls itself as its final operation. Tail-call recursion
    is very important because it is the easiest kind of recursion to optimize
    by conversion into a loop. Loops eliminate the potential of a stack
    overflow, and they improve performance by eliminating the recursive
    function call overhead. While tail recursion optimizations are not yet
    supported natively on the JVM, <literal moreinfo="none">scalac</literal> can do
    them.<indexterm significance="normal"><primary>functional programming</primary><secondary>tail calls and tail-call optimization</secondary></indexterm><indexterm significance="normal"><primary>tail calls</primary></indexterm><indexterm significance="normal"><primary>recursion</primary><secondary>tail-call</secondary></indexterm></para><para id="para_the_fact_example_above_is_not">However, our factorial
    example is not a tail recursion, because <literal moreinfo="none">factorial</literal>
    calls itself and <emphasis>then</emphasis> does a multiplication with the
    results. There is a way to implement <literal moreinfo="none">factorial</literal> in a
    tail recursive way. We actually saw an implementation in <xref linkend="NestingMethodDefinitions"/>. However, that example didn’t use
    some constructs we’ve learned about since, such as <literal moreinfo="none">for</literal>
    comprehensions and pattern matching. So, here’s a new implementation of
    <literal moreinfo="none">factorial</literal>, calculated with tail-call recursion:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/recursion/factorial-recur2-script.scala</code>

<code role="statement">def</code> <code role="identifier">factorial</code>(i:<code role="type"> BigInt</code>):<code role="type"> BigInt</code> = {
  <code role="statement">def</code> <code role="identifier">fact</code>(i:<code role="type"> BigInt</code>, accumulator:<code role="type"> BigInt</code>):<code role="type"> BigInt</code> = i <code role="statement">match</code> {
    <code role="statement">case</code> <code role="statement">_</code> <code role="statement">if</code> i == <code role="constant">1</code> <code role="statement">=&gt;</code> accumulator
    <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fact(i - <code role="constant">1</code>, i * accumulator)
  }
  fact(i, <code role="constant">1</code>)
}

<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">10</code>)
  format(<code role="constant">"%s: %s</code><code role="special">\n</code><code role="constant">"</code>, i, factorial(i))
</programlisting><para id="fact-script-output">This script produces the same output as
    before. Now, <literal moreinfo="none">factorial</literal> does all the work with a nested
    method, <literal moreinfo="none">fact</literal>, that is tail recursive because it passes
    an <literal moreinfo="none">accumulator</literal> argument to hold the computation in
    progress. This argument is computed with a multiplication
    <emphasis>before</emphasis> the recursive call to <literal moreinfo="none">fact</literal>,
    which is now the very last thing that is done. In our previous
    implementation, this multiplication was done <emphasis>after</emphasis>
    the call to <literal moreinfo="none">fact</literal>. When we call
    <literal moreinfo="none">fact(1)</literal>, we simply return the accumulated value.</para><para id="para_calling_fact_not_tc_10000_r">If you call our original
    non-tail recursive implementation of <literal moreinfo="none">factorial</literal> with a
    large number—say 10,000—you’ll cause a stack overflow on a typical desktop
    computer. The tail-recursive implementation works successfully, returning
    a very large number.</para><para id="para_this_idiom_of_nesting_a">This idiom of nesting a
    tail-recursive function that uses an accumulator is a very useful
    technique for converting many recursive algorithms into tail recursions
    that can be optimized into loops by <literal moreinfo="none">scalac</literal>.</para><note id="para_note_the_tail_call_optimizati"><simpara>The tail-call optimization won’t be applied when a method that
      calls itself might be overridden in a derived type. The method must be
      private or final, defined in an <literal moreinfo="none">object</literal>, or nested in
      another method (like <literal moreinfo="none">fact</literal> earlier). The new
      <literal moreinfo="none">@tailrec</literal> annotation in version 2.8 will trigger an
      error if the compiler can’t optimize the annotated method. (See <xref linkend="Annotations"/>.)</simpara></note><sect2 id="TrampolineTailCalls"><title>Trampoline for Tail Calls</title><para id="para_trampoline_and_recursion">A
      <emphasis>trampoline</emphasis> is a loop that works through a list of
      functions, calling each one in turn. The metaphor of bouncing the
      functions off a trampoline is the source of the name.<indexterm significance="normal"><primary>loops</primary><secondary>trampoline</secondary></indexterm><indexterm significance="normal"><primary>trampolines</primary></indexterm><indexterm significance="normal"><primary>tail calls</primary><secondary>trampoline for</secondary></indexterm></para><para id="para_consider_a_kind_of_recursion_w">Consider a kind of
      recursion where a function <literal moreinfo="none">A</literal> doesn’t call itself
      recursively, but instead it calls another function <literal moreinfo="none">B</literal>,
      which calls <literal moreinfo="none">A</literal>, which calls <literal moreinfo="none">B</literal>, etc.
      This kind of back-and-forth recursion can also be converted into a loop
      using a trampoline. Note that trampolines impose a performance overhead,
      but they are ideal for pure functional recursions (versus an imperative
      equivalent) that would otherwise exhaust the stack.</para><para id="para_scala_version_2_8_will_support">Support for this
      optimization is planned for Scala version 2.8, although it has not yet
      been implemented at the time of this writing.</para></sect2></sect1><sect1 id="FunctionalDataStructures"><title>Functional Data Structures</title><para id="para_list_in_fp">There are several data structures that are
    common in functional programming, most of which are containers, like
    collections. Languages like Erlang rely on very few types, while other
    functional languages provide a richer type system.<indexterm significance="normal"><primary>functional programming</primary><secondary>data structures</secondary></indexterm></para><para id="para_the_common_data_structures_sup">The common data structures
    support the same subset of higher-order functions for read-only traversal
    and access to the elements in the data structures. These features make
    them suitable as “protocols” for minimizing the coupling between
    components, while supporting data exchange.</para><para id="para_in_fact_these_data_structures">In fact, these data
    structures and their operations are so useful that many languages support
    them, including those that are not considered functional languages, like
    Java and Ruby. Java doesn’t support higher-order functions directly.
    Instead, function values have to be wrapped in objects. Ruby uses
    <literal moreinfo="none">procs</literal> and <literal moreinfo="none">lambdas</literal> as function
    values.</para><sect2 id="ListsInFunctionalProgramming"><title>Lists in Functional Programming</title><para id="para_lists_are_the_most_common_data">Lists are the most common
      data structure in functional programming. They are the core of the first
      functional programming language, Lisp.<indexterm significance="normal"><primary>functional programming</primary><secondary>data structures</secondary><tertiary>lists</tertiary></indexterm><indexterm significance="normal"><primary>lists in functional programming</primary></indexterm></para><para id="para_supporting_immutability_when_">In the interest of
      immutability, a new list is created when you add an element to a list.
      It is conventional to prepend the new element to the list, as we’ve seen
      before:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/list-script.scala</code>

<code role="statement">val</code> list1 = <code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>)
<code role="statement">val</code> list2 = <code role="constant">"People"</code> :: <code role="constant">"should"</code> :: <code role="constant">"read"</code> :: list1
println(list2)
</programlisting><para id="para_because_the_095_095_ope">Because the
      <literal moreinfo="none">::</literal> operator binds to the right, the definition of
      <literal moreinfo="none">list2</literal> is equivalent to both of the following
      variations:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> list2 = (<code role="constant">"People"</code> :: (<code role="constant">"should"</code> :: (<code role="constant">"read"</code> :: list1)))
<code role="statement">val</code> list2 = list1.::(<code role="constant">"read"</code>).::(<code role="constant">"should"</code>).::(<code role="constant">"People"</code>)
</programlisting><para id="para_in_terms_of_performance_prepe">In terms of performance,
      prepending is O(1). We’ll see why when we dive into Scala’s
      implementation of <literal moreinfo="none">List</literal> in <xref linkend="ACloserLookAtLists"/>, after we have learned more about
      <emphasis>parameterized types</emphasis> in Scala.</para><para id="para_unlike_some_of_the_other_colle">Unlike some of the other
      collections, Scala only defines an immutable <literal moreinfo="none">List</literal>.
      However, it also defines some mutable list types, such as
      <literal moreinfo="none">ListBuffer</literal> and <literal moreinfo="none">LinkedList</literal></para></sect2><sect2 id="MapsInFunctionalProgramming"><title>Maps in Functional Programming</title><para id="para_perhaps_the_second_most_common">Perhaps the second most
      common data structure is the map, referred to as a
      <emphasis>hash</emphasis> or <emphasis>dictionary</emphasis> in other
      languages, and not to be confused with the <literal moreinfo="none">map</literal>
      function we saw earlier. Maps are used to hold pairs of keys and
      values.<indexterm significance="normal"><primary>functional programming</primary><secondary>data structures</secondary><tertiary>maps</tertiary></indexterm><indexterm significance="normal"><primary>maps in functional programming</primary></indexterm></para><para id="para_in_the_interest_of_minimalism_">In the interest of
      minimalism, maps could be implemented with lists. Every even element in
      the list (counting from zero) could be a key, followed by the value in
      the next odd position. In practice, maps are usually implemented in
      other ways for efficiency.</para><para id="para_scala_supports_the_special_ini">Scala supports the
      special initialization syntax we saw previously:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> stateCapitals = <code role="special">Map</code>(
  <code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>,
  <code role="constant">"Alaska"</code>  -&gt; <code role="constant">"Juneau"</code>,
  <code role="comment">// ...</code>
  <code role="constant">"Wyoming"</code> -&gt; <code role="constant">"Cheyenne"</code>)
</programlisting><?dbfo-need height=”1in”
?><para id="para_the_scala_collection_map_a_">The
      <literal moreinfo="none">scala.collection.Map[A,+B]</literal> trait only defines methods
      for reading the <literal moreinfo="none">Map</literal>. There are derived traits for
      immutable and mutable maps,
      <literal moreinfo="none">scala.collection.immutable.Map[A,+B]</literal> and
      <literal moreinfo="none">scala.collection.mutable.Map[A,B]</literal>, respectively. They
      define <literal moreinfo="none">+</literal> and <literal moreinfo="none">-</literal> operators for
      adding and removing elements, and <literal moreinfo="none">++</literal> and
      <literal moreinfo="none">--</literal> operators for adding and removing elements defined
      in <literal moreinfo="none">Iterators</literal> of <literal moreinfo="none">Pairs</literal>, where each
      <literal moreinfo="none">Pair</literal> is a key-value pair.</para><note id="para_note_you_might_have_noticed_t"><para>You might have noticed that the <literal moreinfo="none">+</literal> does not
        appear in front of the <literal moreinfo="none">B</literal> type parameters for
        <literal moreinfo="none">scala.collection.mutable.Map</literal>. You’ll see why in
        <xref linkend="VarianceOfMutableTypes"/>.</para></note></sect2><sect2 id="SetsInFunctionalProgramming"><title>Sets in Functional Programming</title><para id="para_sets_are_like_lists_but_they_">Sets are like lists, but
      they require each element to be unique. Sets could also be implemented
      using lists, as long as the equivalent of the list “cons” operator
      (<literal moreinfo="none">::</literal>) first checks that the element doesn’t already
      exist in the storage list. This property means that element insertion
      would be O(N) if a storage list were used, and the order of the elements
      in the set wouldn’t necessarily match the order of “insertion”
      operations. In practice, sets are usually implemented with more
      efficient data structures.<indexterm significance="normal"><primary>sets in functional programming</primary></indexterm></para><para id="para_just_as_for_map_the_scala_">Just as for
      <literal moreinfo="none">Map</literal>, the <literal moreinfo="none">scala.collection.Set[A]</literal>
      trait only defines methods for reading the <literal moreinfo="none">Set</literal>. There
      are derived traits for immutable and mutable sets,
      <literal moreinfo="none">scala.collection.immut⁠able.Set[A]</literal> and
      <literal moreinfo="none">scala.collection.mutable.Set[A]</literal>, respectively. They
      define <literal moreinfo="none">+</literal> and <literal moreinfo="none">-</literal> operators for
      adding and removing elements, and <literal moreinfo="none">++</literal> and
      <literal moreinfo="none">--</literal> operators for adding and removing elements defined
      in <literal moreinfo="none">Iterators</literal> (which could be other sets, lists,
      etc.).</para></sect2><sect2 id="OtherDataStructuresInFunctionalProgramming"><title>Other Data Structures in Functional Programming</title><para id="para_other_common_data_structures_">Other familiar data
      structures, like <literal moreinfo="none">Tuples</literal> and
      <literal moreinfo="none">Arrays</literal>, will appear in functional languages.
      Typically, they’re used to provide some convenient feature not supported
      by a more common functional type. In most cases they could be replaced
      with lists.</para></sect2></sect1><sect1 id="TraversingMappingFilteringFolding"><title>Traversing, Mapping, Filtering, Folding, and Reducing</title><para id="para_fundamental_operations_in_fp">The functional collections we
    just discussed—lists, maps, sets, as well as tuples and arrays—all support
    several common operations based on read-only traversal. In fact, this
    uniformity can be exploited if any “container” type also supports these
    operations. For example, an <literal moreinfo="none">Option</literal> contains zero or one
    elements, if it is a <literal moreinfo="none">None</literal> or <literal moreinfo="none">Some</literal>,
    respectively.</para><sect2 id="FunctionalTraversal"><title>Traversal</title><para id="para_the_standard_traversal_method_">The standard traversal
      method for Scala containers is <literal moreinfo="none">foreach</literal>, which is
      defined by the <literal moreinfo="none">Iterable</literal> traits that the containers
      mix in. It is O(N) in the number of elements. Here is an example of its
      use for lists and maps:<indexterm significance="normal"><primary>Iterable object</primary></indexterm><indexterm significance="normal"><primary>foreach method</primary><secondary>traversal operations in functional
          programming</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>traversal of data structures</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/foreach-script.scala</code>

<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>) foreach { i <code role="statement">=&gt;</code> println(<code role="constant">"Int: "</code> + i) }

<code role="statement">val</code> stateCapitals = <code role="special">Map</code>(
  <code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>,
  <code role="constant">"Alaska"</code>  -&gt; <code role="constant">"Juneau"</code>,
  <code role="constant">"Wyoming"</code> -&gt; <code role="constant">"Cheyenne"</code>)

stateCapitals foreach { kv <code role="statement">=&gt;</code> println(kv._1 + <code role="constant">": "</code> + kv._2) }
</programlisting><para id="para_the_signature_of_foreach_is_">The signature of
      <literal moreinfo="none">foreach</literal> is the following:</para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">Iterable</code><code role="special">[+A]</code> {
  ...
  <code role="statement">def</code> <code role="identifier">foreach</code>(f : (<code role="special">A</code>) <code role="statement">=&gt;</code> <code role="special">Unit</code>) :<code role="type"> Unit</code> = ...
  ...
}
</programlisting><para id="para_it_is_a_higher_order_function_"><literal moreinfo="none">foreach</literal> is a
      higher-order function that takes a function argument: the operation to
      perform on each element. Note that for a map, <literal moreinfo="none">A</literal> is
      actually a tuple, as shown in the example. Also,
      <literal moreinfo="none">foreach</literal> returns <literal moreinfo="none">Unit</literal>.
      <literal moreinfo="none">foreach</literal> is not intended to create new collections;
      we’ll see examples of operations that create collections shortly.</para><para id="para_once_you_have_foreach_you_c">Once you have
      <literal moreinfo="none">foreach</literal>, you can implement all the other traversal
      operations we’ll discuss next, and more. A look at
      <literal moreinfo="none">Iterable</literal> will show that it supports methods for
      filtering collections, finding elements that match specified criteria,
      calculating the number of elements, and so forth.</para><para id="para_the_methods_we_ll_discuss_next">The methods we’ll discuss
      next are hallmarks of functional programming: mapping, filtering,
      folding, and reducing.</para></sect2><sect2 id="FunctionalMapping"><title>Mapping</title><para id="para_we_have_encountered_the_map_">We’ve encountered the
      <literal moreinfo="none">map</literal> method before. It returns a new collection of the
      same size as the original collection. It is also a member of
      <literal moreinfo="none">Iterable</literal>, and its signature is:<indexterm significance="normal"><primary>Iterable object</primary><secondary>map method</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>mapping operations</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">Iterable</code><code role="special">[+A]</code> {
  ...
  <code role="statement">def</code> <code role="identifier">map</code><code role="identifier">[B]</code>(f : (<code role="special">A</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> Iterable[B]</code> = ...
  ...
}
</programlisting><?dbfo-need height=”1in”
?><para id="para_the_passed_in_function_can_tra">The passed-in function
      (<literal moreinfo="none">f</literal>) can transform an original element of type
      <literal moreinfo="none">A</literal> to a new type <literal moreinfo="none">B</literal>. Here is an
      example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/map-script.scala</code>

<code role="statement">val</code> stateCapitals = <code role="special">Map</code>(
  <code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>,
  <code role="constant">"Alaska"</code>  -&gt; <code role="constant">"Juneau"</code>,
  <code role="constant">"Wyoming"</code> -&gt; <code role="constant">"Cheyenne"</code>)

<code role="statement">val</code> lengths = stateCapitals map { kv <code role="statement">=&gt;</code> (kv._1, kv._2.length) }
println(lengths)
</programlisting><para id="para_we_convert_the_pair_string_st">This script produces the
      output <literal moreinfo="none">ArrayBuffer((Alabama,10), (Alaska,6),
      (Wyoming,8))</literal>. That is, we convert the
      <literal moreinfo="none">Pair[String,String]</literal> elements to an
      <literal moreinfo="none">ArrayBuffer</literal> of <literal moreinfo="none">Pair[String,Int]</literal>
      elements. Where did the <literal moreinfo="none">ArrayBuffer</literal> come from? It
      turns out that <literal moreinfo="none">Iterable.map</literal> creates and returns an
      <literal moreinfo="none">ArrayBuffer</literal> as the new <literal moreinfo="none">Iterable</literal>
      collection.<indexterm significance="normal"><primary>ArrayBuffer object</primary></indexterm></para><para id="para_this_brings_up_a_general_confl">This brings up a general
      conflict between immutable types and object-oriented type hierarchies.
      If a base type creates a new instance on modification, how does it know
      what kind of type to create?</para><para id="para_you_could_solve_this_problem_t">You could solve this
      problem two ways. First, you could have each type in the hierarchy
      override methods like <literal moreinfo="none">map</literal> to return an instance of
      their own type. This approach is error-prone, though, as it would be
      easy to forget to override all such methods when a new type is
      added.</para><para id="para_even_if_you_always_remember_to">Even if you always
      remember to override each method, you have the dilemma of how to
      implement the override. Do you call the <literal moreinfo="none">super</literal> method
      to reuse the algorithm, then iterate through the returned instance to
      create a new instance of the correct type? That would be inefficient.
      You could copy and paste the algorithm into each override, but that
      creates issues of code bloat, maintainability, and skew.</para><para id="para_there_is_an_alternative_approa">There’s an alternative
      approach: don’t even try. How is the new instance that is returned
      actually used? Do we really care if it has the “wrong” type? Keep in
      mind that all we usually care about are the low-level abstractions like
      lists, maps, and sets. In the case of functional data structures, the
      derived types we might implement using <phrase role="keep-together">object-</phrase><phrase role="keep-together">oriented</phrase> inheritance are most often
      implementation optimizations. The Scala type hierarchy for containers
      does have a few levels of abstractions at the bottom, e.g., <literal role="keep-together" moreinfo="none">Collec⁠tion</literal> extends
      <literal moreinfo="none">Iterable</literal> extends <literal moreinfo="none">AnyRef</literal>, but above
      <literal moreinfo="none">Collection</literal> are <literal moreinfo="none">Seq</literal> (parent of
      <literal moreinfo="none">List</literal>), <literal moreinfo="none">Map</literal>,
      <literal moreinfo="none">Set</literal>, etc.</para><para id="para_however_if_you_really_need_a_">That said, if you really
      need a <literal moreinfo="none">Map</literal>, you can create one easily enough:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/map2-script.scala</code>

<code role="statement">val</code> stateCapitals = <code role="special">Map</code>(
  <code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>,
  <code role="constant">"Alaska"</code>  -&gt; <code role="constant">"Juneau"</code>,
  <code role="constant">"Wyoming"</code> -&gt; <code role="constant">"Cheyenne"</code>)

<code role="statement">val</code> map2 = stateCapitals map { kv <code role="statement">=&gt;</code> (kv._1, kv._2.length) }

<code role="comment">// val lengths = Map(map2)  // ERROR: won't work</code>
<code role="statement">val</code> lengths = <code role="special">Map</code><code role="special">[String,Int]</code>() ++ map2

println(lengths)
</programlisting><para id="para_the_line_that_is_commented_out">The commented-out line
      suggests that it would be nice if you could simply pass the new
      <literal moreinfo="none">Iterable</literal> to <literal moreinfo="none">Map.apply</literal>, but this
      doesn’t work. Here is the signature of
      <literal moreinfo="none">Map.apply</literal>:<indexterm significance="normal"><primary>Map.apply method</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">object</code> <code role="special">Map</code> {
  ...
  <code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[A, B]</code>(elems : (<code role="special">A</code>, <code role="special">B</code>)*) :<code role="type"> Map[A, B]</code> = ...
  ...
}
</programlisting><para id="para_it_expects_a_variable_argument">It expects a variable
      argument list, not an <literal moreinfo="none">Iterable</literal>. However, we can
      create an empty map of the right type and then add the new
      <literal moreinfo="none">Iterable</literal> to it, using the <literal moreinfo="none">++</literal>
      method, which returns a new <literal moreinfo="none">Map</literal>.</para><para id="para_so_we_get_the_map_the_want_">So, we can get the
      <literal moreinfo="none">Map</literal> we want when we must have one. While it would be
      nice if methods like <literal moreinfo="none">map</literal> returned the same collection
      type, we saw that there is no easy way to do this. Instead, we accept
      that <literal moreinfo="none">map</literal> and similar methods return an abstraction
      like <literal moreinfo="none">Iterable</literal> and then rely on the specific subtypes
      to take <literal moreinfo="none">Iterables</literal> as input arguments for populating
      the collection.</para><para id="para_a_related_map_operation_is_">A related
      <literal moreinfo="none">Map</literal> operation is <literal moreinfo="none">flatMap</literal>, which
      can be used to “flatten” a hierarchical data structure, remove “empty”
      elements, etc. Hence, unlike <literal moreinfo="none">map</literal>, it may not return a
      new collection of the same size as the original collection:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/flatmap-script.scala</code>

<code role="statement">val</code> graph = <code role="special">List</code>(
  <code role="constant">"a"</code>, <code role="special">List</code>(<code role="constant">"b1"</code>, <code role="constant">"b2"</code>, <code role="constant">"b3"</code>), <code role="special">List</code>(<code role="constant">"c1"</code>, <code role="special">List</code>(<code role="constant">"c21"</code>, <code role="special">Nil</code>, <code role="constant">"c22"</code>), <code role="special">Nil</code>, <code role="constant">"e"</code>)
)

<code role="statement">def</code> <code role="identifier">flatten</code>(list:<code role="type"> List[_]</code>):<code role="type"> List[_]</code> = list flatMap {
  <code role="statement">case</code> head :: tail <code role="statement">=&gt;</code> head :: flatten(tail)
  <code role="statement">case</code> <code role="special">Nil</code> <code role="statement">=&gt;</code> <code role="special">Nil</code>
  <code role="statement">case</code> x <code role="statement">=&gt;</code> <code role="special">List</code>(x)
}

println(flatten(graph))
</programlisting><para id="para_this_script_reduces_the_hierar">This script reduces the
      hierarchical <literal moreinfo="none">graph</literal> to <literal moreinfo="none">List(a, b1, b2, b3,
      c1, c21, c22, e)</literal>. Notice that the <literal moreinfo="none">Nil</literal>
      elements have been removed. We used <literal moreinfo="none">List[_]</literal> because
      we won’t know what the type parameters are for any embedded lists when
      we’re traversing the outer list, due to <emphasis>type
      erasure</emphasis>.</para><para id="para_here_is_the_signature_for_fla">Here is the signature for
      <literal moreinfo="none">flatMap</literal>, along with <literal moreinfo="none">map</literal>, for
      comparison:</para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">Iterable</code><code role="special">[+A]</code> {
  ...
  <code role="statement">def</code> <code role="identifier">map</code><code role="identifier">[B]</code>    (f : (<code role="special">A</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> Iterable[B]</code> = ...
  <code role="statement">def</code> <code role="identifier">flatMap</code><code role="identifier">[B]</code>(f : (<code role="special">A</code>) <code role="statement">=&gt;</code> <code role="special">Iterable</code><code role="special">[B]</code>) :<code role="type"> Iterable[B]</code>
  ...
}
</programlisting><para id="para_each_pass_must_return_an_iter">Each pass must return an
      <literal moreinfo="none">Iterable[B]</literal>, not a <literal moreinfo="none">B</literal>. After going
      through the collection, <literal moreinfo="none">flatMap</literal> will “flatten” all
      those <literal moreinfo="none">Iterables</literal> into one collection. Note that
      <literal moreinfo="none">flatMap</literal> won’t flatten elements beyond one level. If
      our function literal leaves nested lists intact, they won’t be flattened
      for us.</para></sect2><sect2 id="FunctionalFiltering"><title>Filtering</title><para id="para_it_is_common_to_traverse_a_col">It is common to traverse
      a collection and extract a new collection from it with elements that
      match certain criteria:<indexterm significance="normal"><primary>filtering</primary><secondary>in functional programming</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>filtering operations</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/filter-script.scala</code>

<code role="statement">val</code> stateCapitals = <code role="special">Map</code>(
  <code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>,
  <code role="constant">"Alaska"</code>  -&gt; <code role="constant">"Juneau"</code>,
  <code role="constant">"Wyoming"</code> -&gt; <code role="constant">"Cheyenne"</code>)

<code role="statement">val</code> map2 = stateCapitals filter { kv <code role="statement">=&gt;</code> kv._1 startsWith <code role="constant">"A"</code> }

println( map2 )
</programlisting><para id="para_there_are_several_different_ki">There are several
      different kinds of methods defined in <literal moreinfo="none">Iterable</literal> for
      filtering or otherwise returning part of the original collection
      (comments adapted from the Scaladocs):<indexterm significance="normal"><primary>Iterable object</primary><secondary>filtering methods</secondary></indexterm></para><screen format="linespecific">trait Iterable[+A] {
  ...
  // Returns this iterable without its n first elements. If this iterable
  // has less than n elements, the empty iterable is returned.
  def drop (n : Int) : Collection[A] = ...

  // Returns the longest suffix of this iterable whose first element does
  // not satisfy the predicate p.
  def dropWhile (p : (A) =&gt; Boolean) : Collection[A] = ...

  // Apply a predicate p to all elements of this iterable object and
  // return true, iff there is at least one element for which p yields true.
  def exists (p : (A) =&gt; Boolean) : Boolean = ...

  // Returns all the elements of this iterable that satisfy the predicate p.
  // The order of the elements is preserved.
  def filter (p : (A) =&gt; Boolean) : Iterable[A] = ...

  // Find and return the first element of the iterable object satisfying a
  // predicate, if any.
  def find (p : (A) =&gt; Boolean) : Option[A] = ...

  // Returns index of the first element satisying a predicate, or -1.
  def findIndexOf (p : (A) =&gt; Boolean) : Int = ...

  // Apply a predicate p to all elements of this iterable object and return
  // true, iff the predicate yields true for all elements.
  def forall (p : (A) =&gt; Boolean) : Boolean = ...

  // Returns the index of the first occurence of the specified object in
  // this iterable object.
  def indexOf [B &gt;: A](elem : B) : Int = ...

  // Partitions this iterable in two iterables according to a predicate.
  def partition (p : (A) =&gt; Boolean) : (Iterable[A], Iterable[A]) = ...

  // Checks if the other iterable object contains the same elements.
  def sameElements [B &gt;: A](that : Iterable[B]) : Boolean = ...

  // Returns an iterable consisting only over the first n elements of this
  // iterable, or else the whole iterable, if it has less than n elements.
  def take (n : Int) : Collection[A] = ...

  // Returns the longest prefix of this iterable whose elements satisfy the
  // predicate p.
  def takeWhile (p : (A) =&gt; Boolean) : Iterable[A] = ...
}</screen><para id="para_types_like_map_and_set_hav">Types like
      <literal moreinfo="none">Map</literal> and <literal moreinfo="none">Set</literal> have additional
      methods.</para></sect2><sect2 id="FunctionalFoldingAndReducing"><title>Folding and Reducing</title><para id="para_we_ll_discuss_folding_and_redu">We’ll discuss folding and
      reducing in the same section, as they’re similar. Both are operations
      for “shrinking” a collection down to a smaller collection or a single
      value.<indexterm class="startofrange" id="ch08_reducing" significance="normal"><primary>reducing data structures</primary></indexterm><indexterm class="startofrange" id="ch08_folding" significance="normal"><primary>folding data structures</primary></indexterm><indexterm class="startofrange" id="ch08_functionalfoldreduce" significance="normal"><primary>functional programming</primary><secondary>folding and reducing operations</secondary></indexterm></para><para id="para_folding_starts_with_an_initial">Folding starts with an
      initial “seed” value and processes each element in the context of that
      value. In contrast, reducing doesn’t start with a user-supplied initial
      value. Rather, it uses the first element as the initial value:<indexterm significance="normal"><primary>List object</primary><secondary>folding</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/foldreduce-script.scala</code>

<code role="special">List</code>(<code role="constant">1</code>,<code role="constant">2</code>,<code role="constant">3</code>,<code role="constant">4</code>,<code role="constant">5</code>,<code role="constant">6</code>) reduceLeft(<code role="statement">_</code> + <code role="statement">_</code>)

<code role="special">List</code>(<code role="constant">1</code>,<code role="constant">2</code>,<code role="constant">3</code>,<code role="constant">4</code>,<code role="constant">5</code>,<code role="constant">6</code>).foldLeft(<code role="constant">10</code>)(<code role="statement">_</code> * <code role="statement">_</code>)
</programlisting><para id="para_this_script_reduces_the_list_o">This script reduces the
      list of integers by adding them together, returning 21. It then folds
      the same list using multiplication with a seed of 10, returning
      7,200.</para><para id="para_reducing_can_t_work_on_an_empt">Reducing can’t work on an
      empty collection, since there would be nothing to return. In this case,
      an exception is thrown. Folding on an empty collection will simply
      return the seed value.</para><para id="para_folding_also_offers_more_optio">Folding also offers more
      options for the final result. Here is a “fold” operation that is really
      a map operation:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/foldleft-map-script.scala</code>

<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>, <code role="constant">6</code>).foldLeft(<code role="special">List</code><code role="special">[String]</code>()) {
  (list, x) <code role="statement">=&gt;</code> (<code role="constant">"&lt;"</code> + x + <code role="constant">"&gt;"</code>) :: list
}.reverse
</programlisting><para id="para_it_returns_list_1_2_3_">It returns
      <literal moreinfo="none">List(&lt;1&gt;, &lt;2&gt;, &lt;3&gt;, &lt;4&gt;, &lt;5&gt;,
      &lt;6&gt;)</literal>. Note that we had to call
      <literal moreinfo="none">reverse</literal> on the result to get back a list in the same
      order as the input list.</para><para id="para_here_are_the_signatures_for_th">Here are the signatures
      for the various fold and reduce operations in
      <literal moreinfo="none">Iterable</literal>:<indexterm significance="normal"><primary>Iterable object</primary><secondary>fold and reduce methods</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">Iterable</code><code role="special">[+A]</code> {
  ...
  <code role="comment">// Combines the elements of this iterable object together using the</code>
  <code role="comment">// binary function op, from left to right, and starting with the value z.</code>
  <code role="statement">def</code> <code role="identifier">foldLeft</code> <code role="identifier">[B]</code>(z :<code role="type"> B</code>)(op : (<code role="special">B</code>, <code role="special">A</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> B</code>

  <code role="comment">// Combines the elements of this list together using the binary function</code>
  <code role="comment">// op, from right to left, and starting with the value z.</code>
  <code role="statement">def</code> <code role="identifier">foldRight</code> <code role="identifier">[B]</code>(z :<code role="type"> B</code>)(op : (<code role="special">A</code>, <code role="special">B</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> B</code>

  <code role="comment">// Similar to foldLeft but can be used as an operator with the order of</code>
  <code role="comment">// list and zero arguments reversed. That is, z /: xs is the same as</code>
  <code role="comment">// xs foldLeft z</code>
  <code role="statement">def</code> <code role="identifier">/</code>: [<code role="special">B</code>](z :<code role="type"> B</code>)(op : (<code role="special">B</code>, <code role="special">A</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> B</code>

  <code role="comment">// An alias for foldRight. That is, xs :\ z is the same as xs foldRight z</code>
  <code role="statement">def</code> :\ [<code role="special">B</code>](z :<code role="type"> B</code>)(op : (<code role="special">A</code>, <code role="special">B</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> B</code>

  <code role="comment">// Combines the elements of this iterable object together using the</code>
  <code role="comment">// binary operator op, from left to right</code>
  <code role="statement">def</code> <code role="identifier">reduceLeft</code> <code role="identifier">[B &gt;: A]</code>(op : (<code role="special">B</code>, <code role="special">A</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> B</code>

  <code role="comment">// Combines the elements of this iterable object together using the</code>
  <code role="comment">// binary operator op, from right to left</code>
  <code role="statement">def</code> <code role="identifier">reduceRight</code> <code role="identifier">[B &gt;: A]</code>(op : (<code role="special">A</code>, <code role="special">B</code>) <code role="statement">=&gt;</code> <code role="special">B</code>) :<code role="type"> B</code>
</programlisting><para id="para_many_people_consider_the_opera">Many people consider the
      operator forms, <literal moreinfo="none">:\</literal> for <literal moreinfo="none">foldRight</literal>
      and <literal moreinfo="none">/:</literal> for <literal moreinfo="none">foldLeft</literal>, to be a
      little too obscure and hard to remember. Don’t forget the importance of
      communicating with your readers when writing code.<indexterm significance="normal"><primary>: (colon)</primary><secondary>:\ (foldRight) and :/ (foldLeft)</secondary></indexterm></para><para id="para_why_are_their_left_and_right_f">Why are there left and
      right forms of fold and reduce? For the first examples we showed, adding
      and multiplying a list of integers, they would return the same result.
      Consider a <literal moreinfo="none">foldRight</literal> version of our last example that
      used fold to map the integers to strings:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/foldright-map-script.scala</code>

<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>, <code role="constant">6</code>).foldRight(<code role="special">List</code><code role="special">[String]</code>()) {
  (x, list) <code role="statement">=&gt;</code> (<code role="constant">"&lt;"</code> + x + <code role="constant">"&gt;"</code>) :: list
}
</programlisting><para id="para_this_script_produces_list_1_">This script produces
      <literal moreinfo="none">List(&lt;1&gt;, &lt;2&gt;, &lt;3&gt;, &lt;4&gt;, &lt;5&gt;,
      &lt;6&gt;)</literal>, without having to call <literal moreinfo="none">reverse</literal>,
      as we did before. Note also that the arguments to the function literal
      are reversed compared to the arguments for <literal moreinfo="none">foldLeft</literal>,
      as required by the definition of <literal role="keep-together" moreinfo="none">foldRight</literal>.</para><para id="para_both_foldleft_and_reducelef">Both
      <literal moreinfo="none">foldLeft</literal> and <literal moreinfo="none">reduceLeft</literal> process
      the elements from left to right. Here is the <literal role="keep-together" moreinfo="none">foldLeft</literal> sequence for
      <literal moreinfo="none">List(1,2,3,4,5,6).foldLeft(10)(_ * _)</literal>:</para><screen format="linespecific">((((((10 * 1) * 2) * 3) * 4) * 5) * 6)
((((((10) * 2) * 3) * 4) * 5) * 6)
(((((20) * 3) * 4) * 5) * 6)
((((60) * 4) * 5) * 6)
(((240) * 5) * 6)
((1200) * 6)
(7200)</screen><para id="para_here_is_the_foldright_sequen">Here is the
      <literal moreinfo="none">foldRight</literal> sequence:</para><screen format="linespecific">(1 * (2 * (3 * (4 * (5 * (6 * 10))))))
(1 * (2 * (3 * (4 * (5 * (60))))))
(1 * (2 * (3 * (4 * (300)))))
(1 * (2 * (3 * (1200))))
(1 * (2 * (3600)))
(1 * (7200))
(7200)</screen><para id="para_it_turns_out_that_foldleft_a">It turns out that
      <literal moreinfo="none">foldLeft</literal> and <literal moreinfo="none">reduceLeft</literal> have one
      very important advantage over their “right-handed” brethren: they are
      tail-call recursive, and as such they can benefit from tail-call
      optimization.<indexterm significance="normal"><primary>recursion</primary><secondary>tail-call</secondary><tertiary>foldLeft and reduceLeft</tertiary></indexterm><indexterm significance="normal"><primary>tail calls</primary><secondary>foldLeft and reduceLeft operations</secondary></indexterm></para><para id="para_if_you_stare_at_the_previous_b">If you stare at the
      previous breakdowns for multiplying the integers, you can probably see
      why they are tail-call recursive. Recall that a tail call must be the
      last operation in an iteration. For each line in the
      <literal moreinfo="none">foldRight</literal> sequence, the outermost multiplication
      can’t be done until the innermost multiplications all complete, so the
      operation isn’t tail recursive.</para><para id="para_in_the_following_script_the_f">In the following script,
      the first line prints 1784293664, while the second line causes a stack
      overflow:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/reduceleftright-script.scala</code>

println((<code role="constant">1</code> to <code role="constant">1000000</code>) reduceLeft(<code role="statement">_</code> + <code role="statement">_</code>))
println((<code role="constant">1</code> to <code role="constant">1000000</code>) reduceRight(<code role="statement">_</code> + <code role="statement">_</code>))
</programlisting><para id="para_so_why_have_both_kinds_of_recu">So why have both kinds of
      recursion? If you’re not worried about overflow, a right recursion might
      be the most natural fit for the operation you are doing. Recall that
      when we used <literal moreinfo="none">foldLeft</literal> to map integers to strings, we
      had to reverse the result. That was easy enough to do in that case, but
      in general, the result of a left recursion might not always be easy to
      convert to the right form.<indexterm class="endofrange" startref="ch08_reducing" significance="normal"/><indexterm class="endofrange" startref="ch08_folding" significance="normal"/><indexterm class="endofrange" startref="ch08_functionalfoldreduce" significance="normal"/></para></sect2><sect2 id="OptionsAndOtherContainers"><title>Functional Options</title><para id="para_you_ll_find_the_functional_ope">You’ll find the
      functional operations we’ve explored throughout the Scala library, and
      not exclusively on collection classes. The always handy
      <literal moreinfo="none">Option</literal> container supports <literal moreinfo="none">filter</literal>,
      <literal moreinfo="none">map</literal>, <literal moreinfo="none">flatMap</literal>, and other
      functionally oriented methods that are applied only if the
      <literal moreinfo="none">Option</literal> isn’t empty (that is, if it’s a
      <literal moreinfo="none">Some</literal> and not a <literal moreinfo="none">None</literal>).<indexterm significance="normal"><primary>functional programming</primary><secondary>Options object</secondary></indexterm><indexterm significance="normal"><primary>Option class</primary><secondary>functional operations on</secondary></indexterm></para><para id="para_let_s_see_this_in_practice_">Let’s see this in
      practice:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/datastructs/option-script.scala</code>

<code role="statement">val</code> someNumber = <code role="special">Some</code>(<code role="constant">5</code>)
<code role="statement">val</code> noneNumber = <code role="special">None</code>

<code role="statement">for</code> (option <code role="statement">&lt;-</code> <code role="special">List</code>(noneNumber, someNumber)) {
  option.map(n <code role="statement">=&gt;</code> println(n * <code role="constant">5</code>))
}
</programlisting><para id="para_in_this_example_we_attempt_to">In this example, we
      attempt to multiply the contents of two <literal moreinfo="none">Options</literal> by
      five. Normally, trying to multiply a <literal moreinfo="none">null</literal> value would
      result in an error. But because the implementation of
      <literal moreinfo="none">map</literal> on <literal moreinfo="none">Option</literal> only applies the
      passed-in function when it’s non-empty, we don’t have to worry about
      testing for the presence of a value or handling an exception when we map
      over the <literal moreinfo="none">None</literal>.</para><para id="para_functional_operations_on_opti">Functional operations on
      <literal moreinfo="none">Options</literal> save us from extra conditional expressions or
      pattern matching. Pattern matching, though, is a powerful tool within
      the context of functional programming, as we’ll explore in the next
      section.</para></sect2></sect1><sect1 id="_pattern_matching"><title>Pattern Matching</title><para id="para_fp_pattern_matching">We’ve seen many examples of pattern
    matching throughout this book. We got our first taste in <xref linkend="ATasteOfConcurrency"/>, where we used pattern matching in our
    Actor that drew geometric shapes. We discussed pattern matching in depth
    in <xref linkend="PatternMatching"/>.<indexterm significance="normal"><primary>polymorphism</primary><secondary>pattern matching versus</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>pattern matching</secondary></indexterm><indexterm significance="normal"><primary>pattern matching</primary><secondary sortas="functional programming">in functional
        programming</secondary></indexterm></para><para id="para_pattern_matching_is_a_fundamen">Pattern matching is a
    fundamental tool in functional programming. It’s just as important as
    polymorphism is in object-oriented programming, although the goals of the
    two techniques are very different.</para><para id="para_pattern_matching_is_an_elegant">Pattern matching is an
    elegant way to decompose objects into their constituent parts for
    processing. On the face of it, pattern matching for this purpose seems to
    violate the goal of encapsulation that objects provide. Immutability,
    though, largely rectifies this conflict. The risk that the parts of an
    object might be changed outside of the control of the enclosing object is
    avoided.</para><para id="para_for_example_if_we_have_a_per">For example, if we have a
    <literal moreinfo="none">Person</literal> class that contains a list of addresses, we
    don’t mind exposing that list to clients if the list is immutable. They
    can’t unexpectedly change the list.</para><para id="para_however_the_other_problem_wit">However, exposing
    constituent parts potentially couples clients to the
    <emphasis>types</emphasis> of those parts. We can’t change how the parts
    are implemented without breaking the clients. A way to minimize this risk
    is to expose the lowest-level abstractions possible. When clients access a
    person’s addresses, do they really need to know that they are stored in a
    <literal moreinfo="none">List</literal>, or is it sufficient to know that they are stored
    in an <literal moreinfo="none">Iterable</literal> or <literal moreinfo="none">Seq</literal>? If so, then
    we can change the implementation of the addresses as long as they still
    support those abstractions. Of course, we’ve known for a long time in
    object-oriented programming that you should only couple to abstractions,
    not concrete details (for example, see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>).</para><?dbfo-need height=”1in”
?><para id="para_functional_pattern_matching_an">Functional pattern matching
    and object-oriented polymorphism are powerful <phrase role="keep-together">complements</phrase> to each other. We saw this in
    the Actor example in <xref linkend="ATasteOfConcurrency"/>, where we
    matched on the <literal moreinfo="none">Shape</literal> abstraction, but called the
    polymorphic <literal moreinfo="none">draw</literal> operation.</para></sect1><sect1 id="PartialFunctions"><title>Partial Functions</title><para id="para_you_ve_seen__partially_applied">You’ve seen
    <emphasis>partially applied</emphasis> functions, or partial functions,
    throughout this book. When you’ve seen an underscore passed to a method,
    you’ve probably seen partial application at work.<indexterm significance="normal"><primary>partial functions</primary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>partial functions</secondary></indexterm></para><para id="para_partial_functions_are_expressi">Partial functions are
    expressions in which not all of the arguments defined in a function are
    supplied as parameters to the function. In Scala, partial functions are
    used to bundle up a function, including its parameters and return type,
    and assign that function to a variable or pass it as an argument to
    another function.</para><para id="para_this_is_a_bit_confusing_until_">This is a bit confusing
    until we see it in practice:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/partial/partial-script.scala</code>

<code role="statement">def</code> <code role="identifier">concatUpper</code>(s1:<code role="type"> String</code>, s2:<code role="type"> String</code>):<code role="type"> String</code> = (s1 + <code role="constant">" "</code> + s2).toUpperCase

<code role="statement">val</code> c = concatUpper <code role="statement">_</code>
println(c(<code role="constant">"short"</code>, <code role="constant">"pants"</code>))

<code role="statement">val</code> c2 = concatUpper(<code role="constant">"short"</code>, <code role="statement">_</code>:<code role="type"> String</code>)
println(c2(<code role="constant">"pants"</code>))
</programlisting><para id="para_calling_concatupper_with_an_">Calling
    <literal moreinfo="none">concatUpper</literal> with an underscore ( <literal moreinfo="none">_</literal> )
    turns the method into a function value. <phrase role="keep-together">In
    the first part</phrase> of the example, we’ve assigned a partially applied
    version of <literal role="keep-together" moreinfo="none">concatUp⁠per</literal> to the
    value <literal moreinfo="none">c</literal>. We then <emphasis>apply</emphasis> it,
    implicitly calling the <literal moreinfo="none">apply</literal> method on
    <literal moreinfo="none">c</literal> by passing parameters to it directly. The returned
    value is then printed.</para><para id="para_in_the_second_part_we_ve_spec">In the second part, we’ve
    specified the first parameter to <literal moreinfo="none">concatUpper</literal> but not
    the second, although we have specified the type of the second parameter.
    We’ve assigned this variant to a second value, <literal moreinfo="none">c2</literal>. To
    produce the same output as we saw before, we need only pass in a single
    value when we apply <literal moreinfo="none">c2</literal>. We’ve applied part of the
    function in the assignment to <literal moreinfo="none">c2</literal>, and we “fill in the
    blanks” when we call <literal moreinfo="none">c2</literal> on the next line.</para><para id="para_we_ve_seen_partially_applied_f">We’ve seen partially
    applied functions without the underscore syntax as well:</para><programlisting language="scala" format="linespecific"><code role="special">List</code>(<code role="constant">"short"</code>, <code role="constant">"pants"</code>).map(println)
</programlisting><para id="para_in_this_example_println_is_">In this example,
    <literal moreinfo="none">println</literal> is the partially applied function. It’s applied
    when invoked by mapping over each element in the list. Because the map
    operation expects a function as an argument, we don’t need to write
    <literal moreinfo="none">map(println _)</literal>. The trailing underscore that turns
    <literal moreinfo="none">println</literal> into a function value is implied, in this
    context.<indexterm significance="normal"><primary>println function</primary><secondary>partially applied (example)</secondary></indexterm></para><para id="para_another_way_of_thinking_of_par">Another way of thinking of
    partial functions is as functions that will inform you when you supply
    them with parameters that are out of their domain. Every partial function
    is, as you might guess, of the type <literal moreinfo="none">PartialFunction</literal>.
    This trait defines a method <literal moreinfo="none">orElse</literal> that takes another
    <literal moreinfo="none">PartialFunction</literal>. Should the first partial function not
    apply, the second will be invoked.</para><para id="para_again_this_is_easier_understo">Again, this is easier
    understood in practice:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/partial/orelse-script.scala</code>

<code role="statement">val</code> truthier:<code role="type"> PartialFunction[Boolean, String]</code> = { <code role="statement">case</code> <code role="constant">true</code> <code role="statement">=&gt;</code> <code role="constant">"truthful"</code> }
<code role="statement">val</code> fallback:<code role="type"> PartialFunction[Boolean, String]</code> = { <code role="statement">case</code> x <code role="statement">=&gt;</code> <code role="constant">"sketchy"</code> }
<code role="statement">val</code> tester = truthier orElse fallback

println(tester(<code role="constant">1</code> == <code role="constant">1</code>))
println(tester(<code role="constant">2</code> + <code role="constant">2</code> == <code role="constant">5</code>))
</programlisting><para id="para_in_this_example_tester_is_a">In this example,
    <literal moreinfo="none">tester</literal> is a partial function composed of two other
    partial functions, <literal moreinfo="none">truthier</literal> and
    <literal moreinfo="none">fallback</literal>. In the first <literal moreinfo="none">println</literal>
    statement, <literal moreinfo="none">truthier</literal> is executed because the partial
    function’s internal case matches. In the second,
    <literal moreinfo="none">fallback</literal> is executed because the value of the
    expression is outside of the domain of <literal moreinfo="none">truthier</literal>.</para><para id="para_the_case_statements_we_ve_se">The <literal moreinfo="none">case</literal>
    statements we’ve seen through our exploration of Scala are expanded
    internally to partially applied functions. The functions provide the
    abstract method <literal role="keep-together" moreinfo="none">isDefinedAt</literal>, a
    feature of the <literal moreinfo="none">PartialFunction</literal> trait used to specify
    the boundaries of a partial function’s domain:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/partial/isdefinedat-script.scala</code>

<code role="statement">val</code> pantsTest:<code role="type"> PartialFunction[String, String]</code> = {
  <code role="statement">case</code> <code role="constant">"pants"</code> <code role="statement">=&gt;</code> <code role="constant">"yes, we have pants!"</code>
}

println(pantsTest.isDefinedAt(<code role="constant">"pants"</code>))
println(pantsTest.isDefinedAt(<code role="constant">"skort"</code>))
</programlisting><para id="para_here_our_partial_function_is_">Here, our partial function
    is a test for the string <literal moreinfo="none">"pants"</literal>. When we inquire as to
    whether the string <literal moreinfo="none">"pants"</literal> is defined for this
    function, the result is <literal moreinfo="none">true</literal>. But for the string
    <literal moreinfo="none">"skort"</literal>, the result is <literal moreinfo="none">false</literal>. Were
    we defining our own partial function, we could provide an implementation
    of <literal moreinfo="none">isDefinedAt</literal> that performs any arbitrary test for the
    boundaries of our function.</para></sect1><sect1 id="Currying"><title>Currying</title><para id="para_just_as_you_encountered_partia">Just as you encountered
    partially applied functions before we defined them, you’ve also seen
    <emphasis>curried</emphasis> functions. Named after mathematician Haskell
    Curry (from whom the Haskell language also get its name), currying
    transforms a function that takes multiple parameters into a chain of
    functions, each taking a single parameter.<indexterm significance="normal"><primary>functional programming</primary><secondary>currying</secondary></indexterm><indexterm significance="normal"><primary>curried functions</primary></indexterm></para><para id="para_in_scala_curried_functions_ar">In Scala, curried functions
    are defined with multiple parameter lists, as follows:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">cat</code>(s1:<code role="type"> String</code>)(s2:<code role="type"> String</code>) = s1 + s2
</programlisting><para id="para_of_course_we_could_define_mor">Of course, we could define
    more than two parameters on a curried function, if we like.</para><para id="para_you_also_use_the_syntax_below_">We can also use the
    following syntax to define a curried function:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">cat</code>(s1:<code role="type"> String</code>) = (s2:<code role="type"> String</code>) <code role="statement">=&gt;</code> s1 + s2
</programlisting><para>While the previous syntax is more readable, in our estimation, using
    this syntax eliminates the requirement of a trailing underscore when
    treating the curried function as a partially applied function.</para><para id="para_calling_our_curried_string_con">Calling our curried string
    concatenation function looks like this in the Scala REPL:</para><screen format="linespecific">scala&gt; cat("foo")("bar")
res1: java.lang.String = foobar</screen><para id="para_we_can_also_convert_methods_th">We can also convert methods
    that take multiple parameters into a curried form with the
    <literal moreinfo="none">Function.curried</literal> method:<indexterm significance="normal"><primary>Function.curried method</primary></indexterm></para><screen format="linespecific">scala&gt; def cat(s1: String, s2: String) = s1 + s2
cat: (String,String)java.lang.String

scala&gt; val curryCat = Function.curried(cat _)
curryCat: (String) =&gt; (String) =&gt; java.lang.String = &lt;function&gt;

scala&gt; cat("foo", "bar") == curryCat("foo")("bar")
res2: Boolean = true</screen><para id="para_in_this_example_we_transform_">In this example, we
    transform a function that takes two arguments, <literal moreinfo="none">cat</literal>,
    into its curried equivalent that takes multiple parameter lists. If
    <literal moreinfo="none">cat</literal> had taken three parameters, its curried equivalent
    would take three lists of arguments, and so on. The two forms are
    functionally equivalent, as demonstrated by the equality test, but
    <literal moreinfo="none">curryCat</literal> can now be used as the basis of a partially
    applied function as well:</para><screen format="linespecific">scala&gt; val partialCurryCat = curryCat("foo")(_)
partialCurryCat: (String) =&gt; java.lang.String = &lt;function&gt;

scala&gt; partialCurryCat("bar")
res3: java.lang.String = foobar</screen><para id="para_in_practice_the_primary_use_f">In practice, the primary use
    for currying is to specialize functions for particular types of data. You
    can start with an extremely general case, and use the curried form of a
    function to narrow down to particular cases.</para><para id="para_as_a_simple_example_of_this_ap">As a simple example of this
    approach, the following code provides specialized forms of a base function
    that handles multiplication:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">multiplier</code>(i:<code role="type"> Int</code>)(factor:<code role="type"> Int</code>) = i * factor
<code role="statement">val</code> byFive = multiplier(<code role="constant">5</code>) <code role="statement">_</code>
<code role="statement">val</code> byTen = multiplier(<code role="constant">10</code>) <code role="statement">_</code>
</programlisting><para id="para_we_start_with_multiplier_wh">We start with
    <literal moreinfo="none">multiplier</literal>, which takes two parameters: an integer, and
    another integer to multiply the first one by. We then curry two special
    cases of <literal moreinfo="none">multiplier</literal> into function values. Note the
    trailing underscores, which indicate to the compiler that the preceding
    expression is to be curried. In particular, the wildcard underscores
    indicate that the remaining arguments (in this example, one argument) are
    unspecified.</para><?dbfo-need height=”1in”
?><para id="para_in_the_scala_console_we_get_p">In the Scala console, we get
    predictable output when calling our curried functions:</para><screen format="linespecific">scala&gt; byFive(2)
res4: Int = 10

scala&gt; byTen(2)
res5: Int = 20</screen><para id="para_we_ll_revisit_the_curry_meth">We’ll revisit the
    <literal moreinfo="none">curry</literal> method in <xref linkend="FunctionTypes"/>.</para><para id="para_as_you_can_see_currying_and_p">As you can see, currying and
    partially applied functions are closely related concepts. You may see them
    referred to almost interchangeably, but what’s important is their
    application (no pun intended).</para></sect1><sect1 id="Implicits"><title>Implicits</title><para id="para_there_are_times_when_you_have_">There are times when you
    have an instance of one type and you need to use it in a context where a
    different, but perhaps a similar type is required. For the “one-off” case,
    you might create an instance of the required type using the state of the
    instance you already have. However, for the general case, if there are
    many such occurrences in the code, you would rather have an automated
    conversion mechanism.</para><para id="para_a_similar_problem_occurs_when_">A similar problem occurs
    when you call one or more functions repeatedly and have to pass the same
    value to all the invocations. You might like a way of specifying a default
    value for that parameter, so it is not necessary to specify it explicitly
    all the time.<indexterm significance="normal"><primary>implicit keyword</primary></indexterm></para><para id="para_the_scala_keyword_implicit_c">The Scala keyword
    <literal moreinfo="none">implicit</literal> can be used to support both needs.<indexterm significance="normal"><primary>implicit conversions</primary><secondary sortas="functional programming">in functional
        programming</secondary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>implicit conversions</secondary></indexterm></para><sect2 id="ImplicitConversions"><title>Implicit Conversions</title><para id="para_consider_the_following_code_fr">Consider the following
      code fragment:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> name:<code role="type"> String</code> = <code role="constant">"scala"</code>
println(name.capitalize.reverse)
</programlisting><para id="para_it_prints_the_following_">It prints the following:</para><screen format="linespecific">alacS</screen><para id="para_how_work_capitalize_string">We saw in <xref linkend="PredefObject"/> that <literal moreinfo="none">Predef</literal> defines the
      <literal moreinfo="none">String</literal> type to be
      <literal moreinfo="none">java.lang.String</literal>, yet the methods
      <literal moreinfo="none">capitalize</literal> and <literal moreinfo="none">reverse</literal> aren’t
      defined on <literal moreinfo="none">java.lang.String</literal>. How did this code
      work?<indexterm significance="normal"><primary>java.lang.String class</primary></indexterm><indexterm significance="normal"><primary>String class</primary></indexterm></para><para id="para_the_scala_library_defines_a_">The Scala library defines a
      “wrapper” class called <literal moreinfo="none">scala.runtime.RichString</literal> that
      has these methods, and the compiler converted the
      <literal moreinfo="none">name</literal> string to it implicitly using a special method
      defined in <literal moreinfo="none">Predef</literal> called
      <literal moreinfo="none">stringWrapper</literal>:<indexterm significance="normal"><primary>wrapper classes in Scala</primary></indexterm><indexterm significance="normal"><primary>RichString class</primary></indexterm><indexterm significance="normal"><primary>Predef object</primary><secondary>stringWrapper method</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">stringWrapper</code>(x:<code role="type"> String</code>) = <code role="statement">new</code> runtime.<code role="special">RichString</code>(x)
</programlisting><para id="para_the_implicit_keyword_tells_t">The
      <literal moreinfo="none">implicit</literal> keyword tells the compiler it can use this
      method for an “implicit” conversion from a <literal moreinfo="none">String</literal> to
      a <literal moreinfo="none">RichString</literal>, whenever the latter is required. The
      compiler detected an attempt to call a <literal moreinfo="none">capitalize</literal>
      method, and it determined that <literal moreinfo="none">RichString</literal> <phrase role="keep-together">has such</phrase> a method. Then it looked within
      the current scope for an <literal moreinfo="none">implicit</literal> method that
      converts <literal moreinfo="none">String</literal> to <literal moreinfo="none">RichString</literal>,
      finding <literal moreinfo="none">stringWrapper</literal>.<indexterm significance="normal"><primary>String class</primary><secondary>implicit conversion to RichString</secondary></indexterm></para><para id="para_as_we_ll_see_in_viewsandview">As we’ll see in <xref linkend="ViewsAndViewBounds"/>, these conversion methods are sometimes
      called <emphasis>views</emphasis>, in the sense that our
      <literal moreinfo="none">stringWrapper</literal> conversion provides a view from
      <literal moreinfo="none">String</literal> to <literal moreinfo="none">RichString</literal>.<indexterm significance="normal"><primary>views</primary></indexterm></para><para id="para__predef_defines_many_other_im"><literal moreinfo="none">Predef</literal>
      defines many other implicit conversion methods, most of which follow the
      naming convention <literal moreinfo="none">old2New</literal>, where
      <literal moreinfo="none">old</literal> is the type of object available and
      <literal moreinfo="none">New</literal> is the desired type. However, there is no
      restriction on the names of conversion methods. There are also a number
      of other <literal moreinfo="none">Rich</literal> wrapper classes defined in the
      <literal moreinfo="none">scala.run⁠time</literal> package.<indexterm significance="normal"><primary>wrapper classes in Scala</primary><secondary>Rich wrapper classes defined in scala.runtime
          package</secondary></indexterm></para><para id="para_here_is_a_summary_of_the_looku">Here is a summary of the
      lookup rules used by the compiler to find and apply conversion methods.
      For more details, see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>:<indexterm significance="normal"><primary>companion objects</primary><secondary>conversion methods defined in</secondary></indexterm><indexterm significance="normal"><primary>implicit conversions</primary><secondary>rules for compiler to find and use conversion
          methods</secondary></indexterm></para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>No conversion will be attempted if the object and method
          combination type check successfully.</para></listitem><listitem><para>Only methods with the <literal moreinfo="none">implicit</literal> keyword are
          considered.</para></listitem><listitem><para>Only implicit methods in the current scope are considered, as
          well as implicit methods defined in the <emphasis>companion
          object</emphasis> of the <emphasis>target</emphasis> type.</para></listitem><listitem><para>Implicit methods aren’t chained to get from the available
          type, through intermediate types, to the <literal moreinfo="none">target</literal>
          type. Only a method that takes a single available type instance and
          returns a target type instance will be considered.</para></listitem><listitem><para>No conversion is attempted if more than one possible
          conversion method could be applied. There must be one and only one
          possibility.</para></listitem></orderedlist><para id="para_what_if_can_t_define_a_convers">What if you can’t define
      a conversion method in a companion object, to satisfy the third rule,
      perhaps because you can’t modify or create the companion object? In this
      case, define the method somewhere else and import it. Normally, you will
      define an <literal moreinfo="none">object</literal> with just the conversion method(s)
      needed. Here is an example:<indexterm significance="normal"><primary>implicit conversions</primary><secondary>defining custom object and conversion method</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/implicits/implicit-conversion-script.scala</code>
<code role="preproc">import</code> scala.runtime.RichString

<code role="statement">class</code> <code role="special">FancyString</code>(<code role="statement">val</code> str:<code role="type"> String</code>)

<code role="statement">object</code> <code role="special">FancyString2RichString</code> {
    <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">fancyString2RichString</code>(fs:<code role="type"> FancyString</code>) =
        <code role="statement">new</code> <code role="special">RichString</code>(fs.str)
}

<code role="preproc">import</code> FancyString2RichString._

<code role="statement">val</code> fs = <code role="statement">new</code> <code role="special">FancyString</code>(<code role="constant">"scala"</code>)
println(fs.capitalize.reverse)
</programlisting><?dbfo-need height=”1in”
?><para id="para_we_can_t_modify_richstring_o">We can’t modify
      <literal moreinfo="none">RichString</literal> or <literal moreinfo="none">Predef</literal> to add an
      implicit conversion method for our custom <literal moreinfo="none">FancyString</literal>
      class. Instead, we define an <literal moreinfo="none">object</literal> named
      <literal moreinfo="none">FancyString2RichString</literal> and define the conversion
      method in it. We then import the contents of this object and the
      converter gets invoked implicitly in the last line. The output of this
      script is the following:</para><screen format="linespecific">alacS</screen><para id="para_pimp_my_library">This pattern for effectively adding new
      methods to classes has been called <emphasis>Pimp My Library</emphasis>
      (see <link linkend="Odersky2006" xrefstyle="select:nopage">[Odersky2006]</link>).<indexterm significance="normal"><primary>Pimp My Library design pattern</primary></indexterm><indexterm significance="normal"><primary>methods</primary><secondary>adding new methods to classes</secondary></indexterm><indexterm significance="normal"><primary>classes</primary><secondary>adding new methods to</secondary></indexterm></para></sect2></sect1><sect1 id="ImplicitFunctionParameters"><title>Implicit Function Parameters</title><para id="para_one_possible_mechanism_is_to_u">We saw in <xref linkend="TypeLessDoMore"/> that Scala version 2.8 adds support for
    default argument values, like you find in other languages like Ruby and
    C++. There are two other ways to achieve the same effect in all versions
    of Scala. The first is to use function currying, as we have seen. The
    second way is to define <emphasis>implicit</emphasis> values, using the
    <literal moreinfo="none">implicit</literal> keyword.<indexterm significance="normal"><primary>parameters</primary><secondary>implicit function parameters</secondary></indexterm><indexterm significance="normal"><primary>implicit function parameters</primary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>implicit function parameters</secondary></indexterm></para><para id="para_let_s_examine_how_implicit_val">Let’s examine how implicit
    values work:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/implicits/implicit-parameter-script.scala</code>
<code role="preproc">import</code> scala.runtime.RichString

<code role="statement">def</code> <code role="identifier">multiplier</code>(i:<code role="type"> Int</code>)(<code role="statement">implicit</code> factor:<code role="type"> Int</code>) {
  println(i * factor)
}

<code role="statement">implicit</code> <code role="statement">val</code> factor = <code role="constant">2</code>

multiplier(<code role="constant">2</code>)
multiplier(<code role="constant">2</code>)(<code role="constant">3</code>)
</programlisting><para id="para_our_multiplier_takes_two_lists">Our multiplier takes two
    lists of parameters. The latter includes an integer value, <literal role="keep-together" moreinfo="none">factor</literal>, marked <literal moreinfo="none">implicit</literal>.
    This keyword informs the compiler to seek the value for <literal role="keep-together" moreinfo="none">factor</literal> from the surrounding scope, if
    available, or to use whatever parameter has been explicitly supplied to
    the function.</para><para id="para_we_ve_defined_our_own_factor_">We’ve defined our own
    <literal moreinfo="none">factor</literal> value in scope, and that value is used in the
    first call to <literal moreinfo="none">multiplier</literal>. In the second call, we’re
    explicitly passing in a value for <literal moreinfo="none">factor</literal> and it
    overrides the value in the surrounding scope.</para><para id="para_essentially_implicit_function">Essentially, implicit
    function parameters behave as parameters with a default value, with the
    key difference being that the value comes from the surrounding scope. Had
    our <literal moreinfo="none">factor</literal> value resided in a class or object, we would
    have had to import it into the local scope. If the compiler can’t
    determine the value to use for an implicit parameter, an error of “no
    implicit argument matching parameter” will occur.</para><sect2 id="FinalThoughtsOnImplicits"><title>Final Thoughts on Implicits</title><para id="para_implicits_can_be_perilously_cl">Implicits can be
      perilously close to “magic.” When used excessively, they obfuscate the
      code’s behavior for the reader. Also, be careful about the
      implementation of a conversion method, especially if the return type is
      not explicitly declared. If a future change to the method also changes
      the return type in some subtle way, the conversion may suddenly fail to
      work. In general, implicits can cause mysterious behavior that is hard
      to debug!<indexterm significance="normal"><primary>functional programming</primary><secondary>implicits, caution with</secondary></indexterm><indexterm significance="normal"><primary>implicit function parameters</primary><secondary>caution with</secondary></indexterm><indexterm significance="normal"><primary>implicit conversions</primary><secondary>caution with</secondary></indexterm></para><para id="para_the_advantage_of_this_approach">When deciding how to
      implement “default” values for method arguments, a major advantage of
      using default argument values (in Scala version 2.8) is that the method
      maintainer decides what to use as the default value. The implementation
      is more straightforward and you avoid the “magic” of implicit methods.
      However, a disadvantage of using default argument values is that it
      might be desirable to use a different “default” value based on the
      context in which the method is being called. Scala version 2.8 provides
      some flexibility, as you can use an expression for an argument, not just
      a constant value. However, that flexibility might not be enough, in
      which case implicits are a very flexible and powerful
      alternative.</para><tip id="para_tip_use_implicits_sparingly_a"><para>Use implicits sparingly and cautiously. Also, consider adding an
        explicit return type to “non-trivial” conversion methods.</para></tip></sect2></sect1><sect1 id="_call_by_name_call_by_value"><title>Call by Name, Call by Value</title><para id="para_typically_parameters_to_funct">Typically, parameters to
    functions are <emphasis>by-value</emphasis> parameters; that is, the value
    of the parameter is determined before it is passed to the function. In
    most circumstances, this is the behavior we want and expect.<indexterm significance="normal"><primary>by-value parameters</primary></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>call by name and call by value</secondary></indexterm></para><para id="para_but_what_if_we_need_to_write_a">But what if we need to
    write a function that accepts as a parameter an expression that we don’t
    want evaluated until it’s called within our function? For this
    circumstance, Scala offers <emphasis>by-name</emphasis> parameters.</para><para id="para_a_by_name_parameter_is_specifi">A by-name parameter is
    specified by omitting the parentheses that normally accompany a function
    parameter, as follows:<indexterm significance="normal"><primary>( ) (parentheses)</primary><secondary>omitting for by-name function parameter</secondary></indexterm><indexterm significance="normal"><primary>by-name parameters</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">myCallByNameFunction</code>(callByNameParameter:<code role="type"> =&gt; ReturnType</code>)
</programlisting><para id="para_without_this_syntactic_shortcu">Without this syntactic
    shortcut, this method definition would look like the following:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">myCallByNameFunction</code>(callByNameParameter: () <code role="statement">=&gt;</code> <code role="special">ReturnType</code>)
</programlisting><para id="para_and_what_s_more_we_d_have_to_">And what’s more, we would
    have to include those unsightly, empty parentheses in every call to that
    method. Use of by-name parameters removes that requirement.<indexterm significance="normal"><primary>while loops</primary><secondary>implementing using by-name parameters and
        currying</secondary></indexterm></para><para id="para_we_can_use_by_name_parameters_">We can use by-name
    parameters to implement powerful looping constructs, among other things.
    Let’s go crazy and implement our own <literal moreinfo="none">while</literal> loop,
    throwing currying into the mix:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/overrides/call-by-name-script.scala</code>

<code role="statement">def</code> <code role="identifier">whileAwesome</code>(conditional:<code role="type"> =&gt; Boolean</code>)(f:<code role="type"> =&gt; Unit</code>) {
  <code role="statement">if</code> (conditional) {
    f
    whileAwesome(conditional)(f)
  }
}

<code role="statement">var</code> count = <code role="constant">0</code>

whileAwesome(count &lt; <code role="constant">5</code>) {
  println(<code role="constant">"still awesome"</code>)
  count += <code role="constant">1</code>
}
</programlisting><para id="para_what_would_happen_if_we_remove">What would happen if we
    removed the arrow between <literal moreinfo="none">conditional:</literal> and
    <literal moreinfo="none">Boolean</literal>? The expression <literal moreinfo="none">count &lt; 5</literal>
    would be evaluated to <literal moreinfo="none">true</literal> before being passed into our
    custom <literal moreinfo="none">while</literal> loop, and the message “still awesome”
    would be printed to the console indefinitely. By delaying evaluation until
    <literal moreinfo="none">conditional</literal> is called inside our function with a
    by-name parameter, we get the behavior we expect.</para></sect1><sect1 id="LazyVals"><title>Lazy Vals</title><para id="para_in_overridingfieldsintraits_">In <xref linkend="OverridingFieldsInTraits"/>, we showed several scenarios where
    the order of initialization for fields in override scenarios can be
    problematic. We discussed one solution, <emphasis>pre-initialized
    fields</emphasis>. Now we discuss the other solution we mentioned
    previously, <literal moreinfo="none">lazy val</literal>s.<indexterm significance="normal"><primary>fields</primary><secondary>order of initialization, using lazy vals</secondary></indexterm><indexterm significance="normal"><primary>vals, lazy</primary><see>lazy values</see></indexterm><indexterm significance="normal"><primary>functional programming</primary><secondary>lazy vals</secondary></indexterm><indexterm significance="normal"><primary>lazy values</primary></indexterm></para><para id="para_here_is_ui3_vetoable_clicks_">Here is that example
    rewritten with a <literal moreinfo="none">lazy val</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/FP/overrides/trait-lazy-init-val-script.scala</code>

<code role="statement">trait</code> <code role="special">AbstractT2</code> {
  println(<code role="constant">"In AbstractT2:"</code>)
  <code role="statement">val</code> value:<code role="type"> Int</code>
  <code role="statement">lazy</code> <code role="statement">val</code> inverse = { println(<code role="constant">"initializing inverse:"</code>); <code role="constant">1.0</code>/value }
  <code role="comment">//println("AbstractT2: value = "+value+", inverse = "+inverse)</code>
}

<code role="statement">val</code> c2d = <code role="statement">new</code> <code role="special">AbstractT2</code> {
  println(<code role="constant">"In c2d:"</code>)
  <code role="statement">val</code> value = <code role="constant">10</code>
}

println(<code role="constant">"Using c2d:"</code>)
println(<code role="constant">"c2d.value = "</code>+c2d.value+<code role="constant">", inverse = "</code>+c2d.inverse)
</programlisting><para id="para_the_is_the_output_of_the_scrip">The is the output of the
    script:</para><screen format="linespecific">In AbstractT2:
In c2d:
Using c2d:
initializing inverse:
c2d.value = 10, inverse = 0.1</screen><para id="para_as_before_we_are_using_an_ano">As before, we are using an
    anonymous inner class that implicitly extends the trait. The body of the
    class, which initializes <literal moreinfo="none">value</literal>, is evaluated
    <emphasis>after</emphasis> the trait’s body. However, note that
    <literal moreinfo="none">inverse</literal> is declared <literal moreinfo="none">lazy</literal>, which
    means that the righthand side will be evaluated only when
    <literal moreinfo="none">inverse</literal> is actually <emphasis>used</emphasis>. In this
    case, that happens in the last <literal moreinfo="none">println</literal> statement. Only
    then is <literal moreinfo="none">inverse</literal> initialized, using
    <literal moreinfo="none">value</literal>, which is properly initialized at this
    point.</para><para id="para_try_uncommenting_the_println_">Try uncommenting the
    <literal moreinfo="none">println</literal> statement at the end of the
    <literal moreinfo="none">AbstractT2</literal> body. What happens now?</para><screen format="linespecific">In AbstractT2:
initializing inverse:
AbstractT2: value = 0, inverse = Infinity
In c2d:
Using c2d:
c2d.value = 10, inverse = Infinity</screen><para id="para_this_println_forces_inverse">This
    <literal moreinfo="none">println</literal> forces <literal moreinfo="none">inverse</literal> to be
    evaluated inside the body of <literal moreinfo="none">AbstractT2</literal>, before
    <literal moreinfo="none">value</literal> is initialized by the class body, thereby
    reproducing the problem we had before.</para><para id="para_this_example_raises_an_importa">This example raises an
    important point; if other <literal moreinfo="none">val</literal>s use the <literal moreinfo="none">lazy
    val</literal> in the same class or trait body, they should be declared
    <literal moreinfo="none">lazy</literal>, too. Also, watch out for function calls in the
    body that use the <literal moreinfo="none">lazy val</literal>.</para><tip id="para_tip_if_a_val_is_lazy_mak"><para>If a <literal moreinfo="none">val</literal> is <literal moreinfo="none">lazy</literal>, make sure
      all uses of the <literal moreinfo="none">val</literal> are also
      <literal moreinfo="none">lazy</literal>!</para></tip><para id="para_so_how_is_a_lazy_val_differ">So, how is a <literal moreinfo="none">lazy
    val</literal> different from a method call? In a method call, the body is
    executed <emphasis>every</emphasis> time the method is invoked. For a
    <literal moreinfo="none">lazy val</literal>, the initialization “body” is evaluated only
    once, when the variable is used for the first time. This one-time
    evaluation makes little sense for a mutable field. Therefore, the
    <literal moreinfo="none">lazy</literal> keyword is not allowed on <literal moreinfo="none">var</literal>s.
    (They can’t really make use of it anyway.)</para><para id="para_use_lazy_val_s_for_costly_co">You can also use
    <literal moreinfo="none">lazy val</literal>s to avoid costly initializations that you may
    not actually need and to defer initializations that slow down application
    startup. They work well in constructors, where it’s clear to other
    programmers that all the one-time heavy lifting for initializing an
    instance is done in one place.<indexterm significance="normal"><primary>infinite data structures</primary><secondary>using lazy vals to manage</secondary></indexterm></para><para id="para_another_use_for_laziness_i">Another use for laziness is to
    manage potentially infinite data structures where only a manageable subset
    of the data will actually be used. In fact, mathematic notation is
    inherently lazy. When we write the Fibonacci sequence, for example, we
    might write it as an infinite sequence, something like this:</para><screen format="linespecific">Fib = 1, 1, 2, 3, 5, 8, ...</screen><para id="para_some_pure_functional_languages">Some pure functional
    languages are lazy by default, so they mimic this behavior as closely as
    possible. This can work without exhausting resources if the user never
    tries to use more than a finite subset of these values. Scala is not lazy
    by default, but it does offer support for working with infinite data
    structures. We’ll address this topic in <xref linkend="InfiniteDataStructuresAndLaziness"/>.</para></sect1><sect1 id="FunctionalComponentAbstractions"><title>Recap: Functional Component Abstractions</title><para id="para_when_object_oriented_programmi">When object-oriented
    programming went mainstream in the late ’80s and early ’90s, there was
    great hope that it would usher in an era of reusable software components.
    It didn’t really work out that way, except in some rare cases, like the
    windowing APIs of various platforms.<indexterm significance="normal"><primary>functional programming</primary><secondary>component model and</secondary></indexterm><indexterm significance="normal"><primary>component model, functional programming and</primary></indexterm><indexterm significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>reusable software components and</secondary></indexterm></para><para id="para_why_did_this_not_happen_there">Why did this not happen?
    There are certainly many reasons, but a likely source is the fact that
    simple source or binary interoperability protocols never materialized that
    would glue these components together. The richness of object APIs was the
    very factor that undermined componentization.</para><para id="para_component_models_that_have_suc">Component models that have
    succeeded are all based on very simple foundations. Integrated circuits
    (ICs) in electronics plug into buses with 2<superscript>n</superscript>
    signaling wires that are boolean, either on or off. From that very simple
    protocol, the most explosive growth of any industry in human history was
    born.</para><para id="para_http_is_another_good_example_">HTTP is another good
    example. With a handful of message types and a very simple standard for
    message content, it set the stage for the Internet revolution. RESTful web
    services built on top of HTTP are also proving successful as components,
    but they are just complex enough that care is required to ensure that they
    work successfully.</para><para id="para_so_is_there_hope_for_a_binary">So, is there hope for a
    binary or source-level component model? It probably won’t be
    object-oriented, as we’ve seen. Rather, it could be more
    functional.</para><para id="para_components_should_interoperate">Components should
    interoperate by exchanging a few immutable data structures, e.g., lists
    and maps, that carry both data and “commands.” Such a component model
    would have the simplicity necessary for success and the richness required
    to perform real work. Notice how that sounds a lot like HTTP and
    REST.</para><para id="para_in_fact_the_actor_model_has_m">In fact, the Actor model has
    many of these qualities, as we’ll explore in the next chapter.<indexterm class="endofrange" startref="ch08_functional" significance="normal"/></para></sect1></chapter><chapter id="Concurrency"><title>Robust, Scalable Concurrency <phrase role="keep-together">with
  Actors</phrase></title><sect1 id="ProblemsOfSharedSynchronizedState"><title>The Problems of Shared, Synchronized State</title><para id="para_concurrency_isn_t_easy_as_a_p">Concurrency isn’t easy.
    Getting a program to do more than one thing at a time has traditionally
    meant hassling with mutexes, race conditions, lock contention, and the
    rest of the unpleasant baggage that comes along with multithreading.
    Event-based concurrency models alleviate some of these concerns, but can
    turn large programs into a rat’s nest of callback functions. No wonder,
    then, that concurrent programming is a task most programmers dread, or
    avoid altogether by retreating to multiple independent processes that
    share data externally (for example, through a database or message
    queue).<indexterm significance="normal"><primary>concurrency</primary><secondary>problems of shared, synchronized state</secondary></indexterm></para><para id="para_a_large_part_of_the_difficulty">A large part of the
    difficulty of concurrent programming comes down to state: how do you know
    what your multithreaded program is doing, and when? What value does a
    particular variable hold when you have 2 threads running, or 5, or 50? How
    can you guarantee that your program’s many tendrils aren’t clobbering one
    another in a race to take action? A thread-based concurrency paradigm
    poses more questions than it <phrase role="keep-together">answers</phrase>.</para><para id="para_thankfully_scala_offers_a_rea">Thankfully, Scala offers a
    reasonable, flexible approach to concurrency that we’ll <phrase role="keep-together">explore</phrase> in this chapter.</para></sect1><sect1 id="_actors"><title>Actors</title><para id="para_though_you_may_have_heard_of_s">Though you may have heard
    of Scala and Actors in the same breath, Actors aren’t a concept unique to
    Scala. Actors, originally intended for use in Artificial Intelligence
    research, were first put forth in 1973 (see <link linkend="Hewitt1973" xrefstyle="select:nopage">[Hewitt1973]</link> and <link linkend="Agha1987" xrefstyle="select:nopage">[Agha1987]</link>). Since then, variations on
    the idea of Actors have appeared in a number of programming languages,
    most notably in Erlang and Io. As an abstraction, Actors are general
    enough that they can be implemented as a library (as in Scala), or as the
    fundamental unit of a computational system.<indexterm class="startofrange" id="ch09_concurrentActors" significance="normal"><primary>concurrency</primary><secondary>using Actors</secondary></indexterm><indexterm class="startofrange" id="ch09_Actors" significance="normal"><primary>Actors</primary></indexterm></para><sect2 id="_actors_in_abstract"><title>Actors in Abstract</title><para id="para_fundamentally_an_actor_is_an_">Fundamentally, an Actor is
      an object that receives messages and takes action on those messages. The
      order in which messages arrive is unimportant to an Actor, though some
      Actor implementations (such as Scala’s) queue messages in order. An
      Actor might handle a message internally, or it might send a message to
      another Actor, or it might create another Actor to take action based on
      the message. Actors are a very high-level abstraction.<indexterm significance="normal"><primary>Actors</primary><secondary sortas="abstract">in abstract</secondary></indexterm><indexterm significance="normal"><primary>concurrency</primary><secondary>using Actors</secondary><tertiary>Actors in abstract</tertiary></indexterm></para><para id="para_unlike_traditional_object_syst">Unlike traditional object
      systems (which, you might be thinking to yourself, have many of the same
      properties we’ve described), Actors don’t enforce a sequence or ordering
      to their actions. This inherent eschewing of sequentiality, coupled with
      independence from shared global state, allow Actors to do their work in
      parallel. As we’ll see later on, the judicious use of immutable data
      fits the Actor model ideally, and further aids in safe, comprehensible
      concurrent programming.</para><para id="para_enough_theory_let_s_see_actor">Enough theory. Let’s see
      Actors in action.</para></sect2></sect1><sect1 id="_actors_in_scala"><title>Actors in Scala</title><para id="para_at_their_most_basic_actors_in">At their most basic, Actors
    in Scala are objects that inherit from
    <literal moreinfo="none">scala.actors.Actor</literal>:<indexterm significance="normal"><primary>Actors</primary><secondary>Actor class</secondary></indexterm><indexterm significance="normal"><primary>scala.actors.Actor class</primary></indexterm><indexterm class="startofrange" id="ch09_concurrentActorsScala" significance="normal"><primary>concurrency</primary><secondary>using Actors</secondary><tertiary>Actors in Scala</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/simple-actor-script.scala</code>

<code role="preproc">import</code> scala.actors.Actor

<code role="statement">class</code> <code role="special">Redford</code> <code role="statement">extends</code> <code role="special">Actor</code> {
  <code role="statement">def</code> <code role="identifier">act</code>() {
    println(<code role="constant">"A lot of what acting is, is paying attention."</code>)
  }
}

<code role="statement">val</code> robert = <code role="statement">new</code> <code role="special">Redford</code>
robert.start
</programlisting><para id="para_as_we_can_see_in_the_above_exa">As we can see, an Actor
    defined in this way must be both instantiated and started, similar to how
    threads are handled in Java. It must also implement the abstract method
    <literal moreinfo="none">act</literal>, which returns <literal moreinfo="none">Unit</literal>. Once we’ve
    started this simple Actor, the following sage advice for thespians is
    printed to the console:</para><screen format="linespecific">A lot of what acting is, is paying attention.</screen><para id="para_the_scala_actors_library_def">The
    <literal moreinfo="none">scala.actors</literal> package contains a factory method for
    creating Actors that avoids much of the setup in the above example. We can
    import this method and other convenience methods from
    <literal moreinfo="none">scala.actors.Actors._</literal>. Here is a factory-made
    Actor:<indexterm significance="normal"><primary>Actors</primary><secondary>factory method for creating</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/factory-actor-script.scala</code>

<code role="preproc">import</code> scala.actors.Actor
<code role="preproc">import</code> scala.actors.Actor._

<code role="statement">val</code> paulNewman = actor {
  println(<code role="constant">"To be an actor, you have to be a child."</code>)
}
</programlisting><para id="para_while_a_subclass_that_extends_">While a subclass that
    extends the <literal moreinfo="none">Actor</literal> class must define
    <literal moreinfo="none">act</literal> in order to be concrete, a factory-produced Actor
    has no such limitation. In this shorter example, the body of the method
    passed to <literal moreinfo="none">actor</literal> is effectively promoted to the
    <literal moreinfo="none">act</literal> method from our first example. Predictably, this
    Actor also prints a message when run. Illuminating, but we still haven’t
    shown the essential piece of the Actors puzzle: sending messages.</para><sect2 id="_sending_messages_to_actors"><title>Sending Messages to Actors</title><para id="para_actors_can_receive_any_sort_of">Actors can receive any
      sort of object as a message, from strings of text to numeric types to
      whatever classes you’ve cooked up in your programs. For this reason,
      Actors and pattern matching go hand in hand. An Actor should only act on
      messages of familiar types; a pattern match on the class and/or contents
      of a message is good defensive programming and increases the readability
      of Actor code:<indexterm significance="normal"><primary>Actors</primary><secondary>sending messages to</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/pattern-match-actor-script.scala</code>

<code role="preproc">import</code> scala.actors.Actor
<code role="preproc">import</code> scala.actors.Actor._

<code role="statement">val</code> fussyActor = actor {
  loop {
    receive {
      <code role="statement">case</code> s:<code role="type"> String =&gt; println</code>(<code role="constant">"I got a String: "</code> + s)
      <code role="statement">case</code> i:<code role="type"> Int =&gt; println</code>(<code role="constant">"I got an Int: "</code> + i.toString)
      <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> println(<code role="constant">"I have no idea what I just got."</code>)
    }
  }
}

fussyActor ! <code role="constant">"hi there"</code>
fussyActor ! <code role="constant">23</code>
fussyActor ! <code role="constant">3.33</code>
</programlisting><para id="para_this_example_prints_the_follow">This example prints the
      following when run:</para><screen format="linespecific">I got a String: hi there
I got an Int: 23
I have no idea what I just got.</screen><para id="para_the_body_of_fussyactor_is_a_">The body of
      <literal moreinfo="none">fussyActor</literal> is a <literal moreinfo="none">receive</literal> method
      wrapped in a <literal moreinfo="none">loop</literal>. <literal moreinfo="none">loop</literal> is
      essentially a nice shortcut for <literal moreinfo="none">while(true)</literal>; it does
      whatever is inside its block repeatedly. <literal moreinfo="none">receive</literal>
      blocks until it gets a message of a type that will satisfy one of its
      internal pattern matching cases.</para><para id="para_the_final_lines_of_this_exampl">The final lines of this
      example demonstrate use of the <literal moreinfo="none">!</literal> (exclamation point,
      or <emphasis>bang</emphasis>) method to send messages to our Actor. If
      you’ve ever seen Actors in Erlang, you’ll find this syntax familiar. The
      Actor is always on the lefthand side of the bang, and the message being
      sent to said Actor is always on the right. If you need a mnemonic for
      this granule of syntactic sugar, imagine that you’re an irate director
      shouting commands at your Actors.<indexterm significance="normal"><primary>bang method</primary><see>! (exclamation point), under Symbols</see></indexterm><indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>! method, sending messages to Actors</secondary></indexterm></para></sect2><sect2 id="_the_mailbox"><title>The Mailbox</title><para id="para_every_actor_has_a__mailbox__in">Every Actor has a
      <emphasis>mailbox</emphasis> in which messages sent to that Actor are
      queued. Let’s see an example where we inspect the size of an Actor’s
      mailbox:<indexterm significance="normal"><primary>mailbox for Actors</primary></indexterm><indexterm significance="normal"><primary>Actors</primary><secondary>mailbox</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/actor-mailbox-script.scala</code>

<code role="preproc">import</code> scala.actors.Actor
<code role="preproc">import</code> scala.actors.Actor._

<code role="statement">val</code> countActor = actor {
  loop {
    react {
      <code role="statement">case</code> <code role="constant">"how many?"</code> <code role="statement">=&gt;</code> {
        println(<code role="constant">"I've got "</code> + mailboxSize.toString + <code role="constant">" messages in my mailbox."</code>)
      }
    }
  }
}

countActor ! <code role="constant">1</code>
countActor ! <code role="constant">2</code>
countActor ! <code role="constant">3</code>
countActor ! <code role="constant">"how many?"</code>
countActor ! <code role="constant">"how many?"</code>
countActor ! <code role="constant">4</code>
countActor ! <code role="constant">"how many?"</code>
</programlisting><para id="para_this_example_produces_the_foll">This example produces the
      following output:</para><screen format="linespecific">I've got 3 messages in my mailbox.
I've got 3 messages in my mailbox.
I've got 4 messages in my mailbox.</screen><para id="para_note_that_the_first_and_second">Note that the first and
      second lines of output are identical. Because our Actor was set up
      solely to process messages of the string <literal moreinfo="none">"how many?"</literal>,
      those messages didn’t remain in its mailbox. Only the messages of types
      we didn’t know about—in this case, <literal moreinfo="none">Int</literal>—remained
      unprocessed.</para><tip id="para_tip_keep_this_example_in_mind"><para>If you see an Actor’s mailbox size ballooning unexpectedly,
        you’re probably sending messages of a type that the Actor doesn’t know
        about. Include a catchall case ( <literal moreinfo="none">_</literal> ) when pattern
        matching messages to find out what’s harassing your Actors.</para></tip></sect2><sect2 id="_actors_in_depth"><title>Actors in Depth</title><para id="para_now_that_we_ve_got_a_basic_sen">Now that we’ve got a
      basic sense of what Actors are and how they’re used in Scala, let’s put
      them to work. Specifically, let’s put them to work cutting hair. The
      <emphasis>sleeping barber problem</emphasis> (see <link linkend="SleepingBarberProblem" xrefstyle="select:nopage">[SleepingBarberProblem]</link>) is one of a
      popular set of computer science hypotheticals designed to demonstrate
      issues of concurrency and synchronization.<indexterm class="startofrange" id="ch09_sleepingbarber" significance="normal"><primary>sleeping barber problem (demonstrating Actors)</primary></indexterm><indexterm class="startofrange" id="ch09_Actorsexample" significance="normal"><primary>Actors</primary><secondary>example using sleeping barber problem</secondary></indexterm></para><para id="para_the_problem_is_this_a_hypothe">The problem is this: a
      hypothetical barber shop has just one barber with one barber chair, and
      three chairs in which customers may wait for a haircut. Without
      customers around, the barber sleeps. When a customer arrives, the barber
      wakes up to cut his hair. If the barber is busy cutting hair when a
      customer arrives, the customer sits down in an available chair. If a
      chair isn’t available, the customer leaves.</para><para id="para_strait_away_we_see_several_ob">The sleeping barber
      problem is usually solved with semaphores and mutexes, but we’ve got
      better tools at our disposal. Straight away, we see several things to
      model as Actors: the barber is clearly one, as are the customers. The
      barbershop itself could be modeled as an Actor, too; there need not be a
      real-world parallel to verbal communication in an Actor system, even
      though we’re sending messages.</para><para id="para_let_s_start_with_the_customers">Let’s start with the
      sleeping barber’s customers, as they have the simplest <phrase role="keep-together">responsibilities</phrase>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/sleepingbarber/customer.scala</code>

<code role="preproc">package</code> sleepingbarber

<code role="preproc">import</code> scala.actors.Actor
<code role="preproc">import</code> scala.actors.Actor._

<code role="statement">case</code> <code role="statement">object</code> <code role="special">Haircut</code>

<code role="statement">class</code> <code role="special">Customer</code>(<code role="statement">val</code> id:<code role="type"> Int</code>) <code role="statement">extends</code> <code role="special">Actor</code> {
  <code role="statement">var</code> shorn = <code role="constant">false</code>

  <code role="statement">def</code> <code role="identifier">act</code>() = {
    loop {
      react {
        <code role="statement">case</code> <code role="special">Haircut</code> <code role="statement">=&gt;</code> {
          shorn = <code role="constant">true</code>
          println(<code role="constant">"[c] customer "</code> + id + <code role="constant">" got a haircut"</code>)
        }
      }
    }
  }
}
</programlisting><para id="para_for_the_most_part_this_should">For the most part, this
      should look pretty familiar: we declare the package in which this code
      lives, we import code from the <literal moreinfo="none">scala.actors</literal> package,
      and we define a class that extends <literal moreinfo="none">Actor</literal>. There are a
      few details worth noting, however.</para><para id="para_first_of_all_there_s_our_decl">First of all, there’s our
      declaration of <literal moreinfo="none">case object Haircut</literal>. A common pattern
      when working with Actors in Scala is to use a <literal moreinfo="none">case
      object</literal> to represent a message without internal data. If we
      wanted to include, say, the time at which the haircut was completed,
      we’d use a <literal moreinfo="none">case class</literal> instead. We declare
      <literal moreinfo="none">Haircut</literal> here because it’s a message type that will be
      sent solely to customers.<indexterm significance="normal"><primary>case objects</primary></indexterm></para><para id="para_note_as_well_that_we_re_storin">Note as well that we’re
      storing one bit of mutable state in each <literal moreinfo="none">Customer</literal>:
      whether or not they’ve gotten a haircut. In their internal loop, each
      <literal moreinfo="none">Customer</literal> waits for a <literal moreinfo="none">Haircut</literal>
      message and, upon receipt of one, we set the <literal moreinfo="none">shorn</literal>
      boolean to <literal moreinfo="none">true</literal>. <literal moreinfo="none">Customer</literal> uses the
      asynchronous <literal moreinfo="none">react</literal> method to respond to incoming
      messages. If we needed to return the result of processing the message,
      we would use <literal moreinfo="none">receive</literal>, but we don’t, and in the
      process we save some memory and thread use under the hood.</para><para id="para_let_s_move_on_to_the_barber_hi">Let’s move on to the
      barber himself. Because there’s only one barber, we could have used the
      <literal moreinfo="none">actor</literal> factory method technique mentioned earlier to
      create him. For testing purposes, we’ve instead defined our own
      <literal moreinfo="none">Barber</literal> class:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/sleepingbarber/barber.scala</code>

<code role="preproc">package</code> sleepingbarber

<code role="preproc">import</code> scala.actors.Actor
<code role="preproc">import</code> scala.actors.Actor._
<code role="preproc">import</code> scala.util.Random

<code role="statement">class</code> <code role="special">Barber</code> <code role="statement">extends</code> <code role="special">Actor</code> {
  <code role="statement">private</code> <code role="statement">val</code> random = <code role="statement">new</code> <code role="special">Random</code>()

  <code role="statement">def</code> <code role="identifier">helpCustomer</code>(customer:<code role="type"> Customer</code>) {
    <code role="statement">if</code> (self.mailboxSize &gt;= <code role="constant">3</code>) {
      println(<code role="constant">"[b] not enough seats, turning customer "</code> + customer.id + <code role="constant">" away"</code>)
    } <code role="statement">else</code> {
      println(<code role="constant">"[b] cutting hair of customer "</code> + customer.id)
      Thread.sleep(<code role="constant">100</code> + random.nextInt(<code role="constant">400</code>))
      customer ! <code role="special">Haircut</code>
    }
  }

  <code role="statement">def</code> <code role="identifier">act</code>() {
    loop {
      react {
        <code role="statement">case</code> customer:<code role="type"> Customer =&gt; helpCustomer</code>(customer)
      }
    }
  }
}
</programlisting><para id="para_the_core_of_the_barber_class">The core of the
      <literal moreinfo="none">Barber</literal> class looks very much like the
      <literal moreinfo="none">Customer</literal>. We loop around <literal moreinfo="none">react</literal>,
      waiting for a particular type of object. To keep that loop tight and
      readable, we call a method, <literal moreinfo="none">helpCustomer</literal>, when a new
      <literal moreinfo="none">Customer</literal> is sent to the barber. Within that method we
      employ a check on the mailbox size to serve as our “chairs” that
      customers may occupy; we could have the <literal moreinfo="none">Barber</literal> or
      <literal moreinfo="none">Shop</literal> classes maintain an internal
      <literal moreinfo="none">Queue</literal>, but why bother when each Actor’s mailbox
      already is one?</para><para id="para_if_three_or_more_customers_are">If three or more
      customers are in the queue, we simply ignore that message; it’s then
      discarded from the barber’s mailbox. Otherwise, we simulate a
      semi-random delay (always at least 100 milliseconds) for the time it
      takes to cut a customer’s hair, then send off a
      <literal moreinfo="none">Haircut</literal> message to that customer. (Were we not trying
      to simulate a <phrase role="keep-together">real-world</phrase> scenario,
      we would of course remove the call to <literal moreinfo="none">Thread.sleep()</literal>
      and allow our barber to run full tilt.)</para><para id="para_next_up_we_have_a_simple_clas">Next up, we have a simple
      class to represent the barbershop itself:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/sleepingbarber/shop.scala</code>

<code role="preproc">package</code> sleepingbarber

<code role="preproc">import</code> scala.actors.Actor
<code role="preproc">import</code> scala.actors.Actor._

<code role="statement">class</code> <code role="special">Shop</code> <code role="statement">extends</code> <code role="special">Actor</code> {
  <code role="statement">val</code> barber = <code role="statement">new</code> <code role="special">Barber</code>()
  barber.start

  <code role="statement">def</code> <code role="identifier">act</code>() {
    println(<code role="constant">"[s] the shop is open"</code>)

    loop {
      react {
        <code role="statement">case</code> customer:<code role="type"> Customer =&gt; barber</code> ! customer
      }
    }
  }
}
</programlisting><para id="para_by_now_this_should_all_look_v">By now, this should all
      look very familiar. Each <literal moreinfo="none">Shop</literal> creates and starts a
      new <literal moreinfo="none">Barber</literal>, prints a message telling the world that
      the shop is open, and sits in a loop waiting for customers. When a
      <literal moreinfo="none">Customer</literal> comes in, he’s sent to the barber. We now
      see an unexpected benefit of Actors: they allow us to describe
      concurrent business logic in easily understood terms. “Send the customer
      to the barber” makes perfect sense, much more so than “Notify the
      barber, unlock the mutex around the customer seats, increment the number
      of free seats,” and so forth. Actors get us closer to our domain.</para><para id="para_finally_we_have_a_driver_for_">Finally, we have a driver
      for our simulation:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/sleepingbarber/barbershop-simulator.scala</code>

<code role="preproc">package</code> sleepingbarber

<code role="preproc">import</code> scala.actors.Actor._
<code role="preproc">import</code> scala.collection.{immutable, mutable}
<code role="preproc">import</code> scala.util.Random

<code role="statement">object</code> <code role="special">BarbershopSimulator</code> {
  <code role="statement">private</code> <code role="statement">val</code> random = <code role="statement">new</code> <code role="special">Random</code>()
  <code role="statement">private</code> <code role="statement">val</code> customers = <code role="statement">new</code> mutable.<code role="special">ArrayBuffer</code><code role="special">[Customer]</code>()
  <code role="statement">private</code> <code role="statement">val</code> shop = <code role="statement">new</code> <code role="special">Shop</code>()

  <code role="statement">def</code> <code role="identifier">generateCustomers</code> {
    <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">20</code>) {
      <code role="statement">val</code> customer = <code role="statement">new</code> <code role="special">Customer</code>(i)
      customer.start()
      customers += customer
    }

    println(<code role="constant">"[!] generated "</code> + customers.size + <code role="constant">" customers"</code>)
  }

  <code role="comment">// customers arrive at random intervals</code>
  <code role="statement">def</code> <code role="identifier">trickleCustomers</code> {
    <code role="statement">for</code> (customer <code role="statement">&lt;-</code> customers) {
      shop ! customer
      Thread.sleep(random.nextInt(<code role="constant">450</code>))
    }
  }

  <code role="statement">def</code> <code role="identifier">tallyCuts</code> {
    <code role="comment">// wait for any remaining concurrent actions to complete</code>
    Thread.sleep(<code role="constant">2000</code>)

    <code role="statement">val</code> shornCount = customers.filter(c <code role="statement">=&gt;</code> c.shorn).size
    println(<code role="constant">"[!] "</code> + shornCount + <code role="constant">" customers got haircuts today"</code>)
  }

  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) {
    println(<code role="constant">"[!] starting barbershop simulation"</code>)
    shop.start()

    generateCustomers
    trickleCustomers
    tallyCuts

    System.exit(<code role="constant">0</code>)
  }
}
</programlisting><para id="para_after_opening_the_shop_we_g">After “opening the shop,” we
      generate a number of <literal moreinfo="none">Customer</literal> objects, assigning a
      numeric ID to each and storing the lot in an
      <literal moreinfo="none">ArrayBuffer</literal>. Next, we “trickle” the customers in by
      sending them as messages to the shop and sleeping for a semi-random
      amount of time between loops. At the end of our simulated day, we tally
      up the number of customers who got haircuts by filtering out the
      customers whose internal <literal moreinfo="none">shorn</literal> boolean was set to
      <literal moreinfo="none">true</literal> and asking for the size of the resulting
      sequence.</para><para id="para_compile_and_run_the_code_withi">Compile and run the code
      within the <literal moreinfo="none">sleepingbarber</literal> directory as
      follows:</para><screen format="linespecific">fsc *.scala
scala -classpath . sleepingbarber.BarbershopSimulator</screen><para id="para_throughout_our_code_we_ve_pre">Throughout our code, we’ve
      prefixed console messages with abbreviations for the classes from which
      the messages were printed. When we look at an example run of our
      simulator, it’s easy to see where each message came from:</para><screen format="linespecific">[!] starting barbershop simulation
[s] the shop is open
[!] generated 20 customers
[b] cutting hair of customer 1
[b] cutting hair of customer 2
[c] customer 1 got a haircut
[c] customer 2 got a haircut
[b] cutting hair of customer 3
[c] customer 3 got a haircut
[b] cutting hair of customer 4
[b] cutting hair of customer 5
[c] customer 4 got a haircut
[b] cutting hair of customer 6
[c] customer 5 got a haircut
[b] cutting hair of customer 7
[c] customer 6 got a haircut
[b] not enough seats, turning customer 8 away
[b] cutting hair of customer 9
[c] customer 7 got a haircut
[b] not enough seats, turning customer 10 away
[c] customer 9 got a haircut
[b] cutting hair of customer 11
[b] cutting hair of customer 12
[c] customer 11 got a haircut
[b] cutting hair of customer 13
[c] customer 12 got a haircut
[b] cutting hair of customer 14
[c] customer 13 got a haircut
[b] not enough seats, turning customer 15 away
[b] not enough seats, turning customer 16 away
[b] not enough seats, turning customer 17 away
[b] cutting hair of customer 18
[c] customer 14 got a haircut
[b] cutting hair of customer 19
[c] customer 18 got a haircut
[b] cutting hair of customer 20
[c] customer 19 got a haircut
[c] customer 20 got a haircut
[!] 15 customers got haircuts today</screen><para id="para_you_ll_find_that_each_run_s_ou">You’ll find that each
      run’s output is, predictably, slightly different. Every time the barber
      takes a bit longer to cut hair than it does for several customers to
      enter, the “chairs” (the barber’s mailbox queue) fill up, and new
      customers simply leave.</para><para>Of course, we have to include the standard caveats that come with
      simple examples. For one, it’s possible that our example may not be
      suitably random, particularly if random values are retrieved within a
      millisecond of one another. This is a byproduct of the way the JVM
      generates random numbers, and a good reminder to be careful about
      randomness in concurrent programs. You’d also want to replace the
      <literal moreinfo="none">sleep</literal> inside <literal moreinfo="none">tallyCuts</literal> with a
      clearer signal that the various actors in the system are done doing
      their work, perhaps by making the
      <literal moreinfo="none">BarbershopSimulation</literal> an Actor and sending it messages
      that indicate completion.</para><para id="para_try_modifying_the_code_to_intr">Try modifying the code to
      introduce more customers, additional message types, <phrase role="keep-together">different</phrase> delays, or to remove the
      randomness altogether. If you’re an experienced multithreaded
      programmer, you might try writing your own sleeping barber
      implementation just to compare and contrast. We’re willing to bet that
      an implementation in <phrase role="keep-together">Scala</phrase> with
      Actors will be terser and easier to maintain.<indexterm class="endofrange" startref="ch09_sleepingbarber" significance="normal"/><indexterm class="endofrange" startref="ch09_Actorsexample" significance="normal"/></para></sect2><sect2 id="_effective_actors"><title>Effective Actors</title><para id="para_in_order_to_get_the_most_out_o">To get the most out of
      Actors, there are few things to remember. First, note that there are
      several methods you can use to get different types of behavior out of
      your Actors. <xref linkend="actor-methods"/> should help clarify when
      to use each method.<indexterm significance="normal"><primary>Actors</primary><secondary>methods, listed</secondary></indexterm></para><table id="actor-methods"><title>Actor methods</title><tgroup cols="3"><thead valign="top"><row><entry><phrase role="keep-together">Method</phrase></entry><entry><phrase role="keep-together">Returns</phrase></entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">act</literal></para></entry><entry><para><literal moreinfo="none">Unit</literal></para></entry><entry><para>Abstract, top-level method for an Actor. Typically
              contains one of the <phrase role="keep-together">following</phrase> methods inside
              it.</para></entry></row><row><entry><para><literal moreinfo="none">receive</literal></para></entry><entry><para>Result of processing <phrase role="keep-together">message</phrase></para></entry><entry><para>Blocks until a message of matched type is
              received.</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">receiveWithin</literal></para></entry><entry><para>Result of processing <phrase role="keep-together">message</phrase></para></entry><entry><para>Like <literal moreinfo="none">receive</literal>, but unblocks after
              specified number of milliseconds.</para></entry></row><row><entry><para><literal moreinfo="none">react</literal></para></entry><entry><para><literal moreinfo="none">Nothing</literal></para></entry><entry><para>Requires less overhead (threads) than
              <literal moreinfo="none">receive</literal>.</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">reactWithin</literal></para></entry><entry><para><literal moreinfo="none">Nothing</literal></para></entry><entry><para>Like <literal moreinfo="none">react</literal>, but unblocks after
              specified number of milliseconds.</para></entry></row></tbody></tgroup></table><para id="para_typically_you_ll_want_to_use_">Typically, you’ll want to
      use <literal moreinfo="none">react</literal> wherever possible. If you need the results
      of processing a message (that is, you need a synchronous response from
      sending a message to an Actor), use the <literal moreinfo="none">receiveWithin</literal>
      variant to reduce your chances of blocking indefinitely on an Actor
      that’s gotten wedged.<indexterm significance="normal"><primary>Actors</primary><secondary>effective use of</secondary></indexterm></para><para>Another strategy to keep your Actor-based code asynchronous is the
      use of <emphasis>futures</emphasis>. A future is a placeholder object
      for a value that hasn’t yet been returned from an asynchronous process.
      You can send a message to an Actor with the <literal moreinfo="none">!!</literal>
      method; a variant of this method allows you to pass along a partial
      function that is applied to the future value. As you can see from the
      following example, retrieving a value from a <literal moreinfo="none">Future</literal>
      is as straightforward as invoking its <literal moreinfo="none">apply</literal> method.
      Note that retrieving a value from a <literal moreinfo="none">Future</literal> is a
      blocking operation:<indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>!! method, sending messages to Actors</secondary></indexterm><indexterm significance="normal"><primary>futures</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/future-script.scala </code>
<code role="preproc">import</code> scala.actors.Futures._

<code role="statement">val</code> eventually = future(<code role="constant">5</code> * <code role="constant">42</code>)
println(eventually())
</programlisting><para id="para_each_actor_in_your_system_shou">Each Actor in your system
      should have clear responsibilities. Don’t use Actors for <phrase role="keep-together">general-purpose</phrase>, highly stateful tasks.
      Instead, think like a director: what are the <phrase role="keep-together">distinct</phrase> roles in the “script” of your
      application, and what’s the least amount of <phrase role="keep-together">information</phrase> each Actor needs to do its
      job? Give each Actor just a couple of responsibilities, and use messages
      (usually in the form of a <literal moreinfo="none">case class</literal> or <literal moreinfo="none">case
      object</literal>) to delegate those responsibilities to other
      Actors.</para><para id="para_don_t_be_hesitant_to_copy_data">Don’t be hesitant to copy
      data when writing Actor-centric code. The more immutable your design,
      the less likely you are to end up with unexpected state. The more you
      communicate via messages, the less you have to worry about
      synchronization. All those messages and immutable variables might appear
      to be overly costly. But, with today’s plentiful hardware, trading
      memory overhead for clarity and predictability seems more than fair for
      most applications.</para><para id="para_lastly_know_when_actors_aren_">Lastly, know when Actors
      aren’t appropriate. Just because Actors are a great way to handle
      concurrency in Scala doesn’t mean that they’re the
      <emphasis>only</emphasis> way, as we’ll see soon. Traditional threading
      and locking may better suit write-heavy critical paths for which a
      messaging approach would incur too much overhead. In our experience, you
      can use a purely Actor-based design to prototype a concurrent solution,
      then use profiling tools to suss out parts of your application that
      might benefit from a different approach.<indexterm class="endofrange" startref="ch09_concurrentActors" significance="normal"/><indexterm class="endofrange" startref="ch09_concurrentActorsScala" significance="normal"/><indexterm class="endofrange" startref="ch09_Actors" significance="normal"/></para></sect2></sect1><sect1 id="_traditional_concurrency_in_scala_threading_and_events"><title>Traditional Concurrency in Scala: Threading and Events</title><para id="para_while_actors_are_a_great_way_t">While Actors are a great
    way to handle concurrent operations, they’re not the only way to do so in
    Scala. As Scala is interoperable with Java, the concurrency concepts that
    you may be familiar with on the JVM still apply.<indexterm significance="normal"><primary>threading in Scala</primary></indexterm><indexterm class="startofrange" id="ch09_concurrenttraditional" significance="normal"><primary>concurrency</primary><secondary>traditional, using threading and events</secondary></indexterm></para><sect2 id="_one_off_threads"><title>One-Off Threads</title><para id="para_for_starters_scala_provides_a">For starters, Scala
      provides a handy way to run a block of code in a new thread:<indexterm significance="normal"><primary>threading in Scala</primary><secondary>one-off threads</secondary></indexterm><indexterm significance="normal"><primary>concurrency</primary><secondary>traditional, using threading and events</secondary><tertiary>one-off threads</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/threads/by-block-script.scala</code>

<code role="statement">new</code> <code role="special">Thread</code> { println(<code role="constant">"this will run in a new thread"</code>) }
</programlisting><para id="para_a_similar_construct_is_availab">A similar construct is
      available in the <literal moreinfo="none">scala.concurrent</literal> package, as a
      method on the <literal moreinfo="none">ops</literal> object to run a block
      asynchronously with <literal moreinfo="none">spawn</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/threads/spawn.scala</code>

<code role="preproc">import</code> scala.concurrent.ops._

<code role="statement">object</code> <code role="special">SpawnExample</code> {
  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) {
    println(<code role="constant">"this will run synchronously"</code>)

    spawn {
      println(<code role="constant">"this will run asychronously"</code>)
    }
  }
}
</programlisting></sect2><sect2 id="_using_literal_java_util_concurrent_literal"><title>Using java.util.concurrent</title><para id="para_if_you_re_familiar_with_the_ve">If you’re familiar with
      the venerable <literal moreinfo="none">java.util.concurrent</literal> package, you’ll
      find it just as easy to use from Scala (or hard to use, depending on
      your point of view). Let’s use <literal moreinfo="none">Executors</literal> to create a
      pool of threads. We’ll use the thread pool to run a simple class,
      implementing Java’s <literal moreinfo="none">Runnable</literal> interface for
      thread-friendly classes, that identifies which thread it’s running
      on:<indexterm significance="normal"><primary>concurrency</primary><secondary>traditional, using threading and events</secondary><tertiary>using java.util.concurrent</tertiary></indexterm><indexterm significance="normal"><primary>java.util.concurrent package</primary></indexterm><indexterm significance="normal"><primary>threading in Scala</primary><secondary>using java.util.concurrent</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Concurrency/threads/util-concurrent-script.scala</code>

<code role="preproc">import</code> java.util.concurrent._

<code role="statement">class</code> <code role="special">ThreadIdentifier</code> <code role="statement">extends</code> <code role="special">Runnable</code> {
  <code role="statement">def</code> <code role="identifier">run</code> {
    println(<code role="constant">"hello from Thread "</code> + currentThread.getId)
  }
}

<code role="statement">val</code> pool = Executors.newFixedThreadPool(<code role="constant">5</code>)

<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">10</code>) {
  pool.execute(<code role="statement">new</code> <code role="special">ThreadIdentifier</code>)
}
</programlisting><para id="para_as_is_standard_in_java_concurr">As is standard in Java
      concurrency, the <literal moreinfo="none">run</literal> method is where a threaded class
      starts. Every time our <literal moreinfo="none">pool</literal> executes a new
      <literal moreinfo="none">ThreadIdentifier</literal>, its <literal moreinfo="none">run</literal> method
      is invoked. A look at the output tells us that we’re running on the five
      threads in the pool, with IDs ranging from 9 to 13:</para><screen format="linespecific">hello from Thread 9
hello from Thread 10
hello from Thread 11
hello from Thread 12
hello from Thread 13
hello from Thread 9
hello from Thread 11
hello from Thread 10
hello from Thread 10
hello from Thread 13</screen><para id="para_this_is_of_course_just_scrat">This is, of course, just
      scratching the surface of what is available in
      <literal moreinfo="none">java.util.con⁠cur⁠rent</literal>. You’ll find that your
      existing knowledge of Java’s approach to multithreading still applies in
      Scala. What’s more, you’ll be able to accomplish the same tasks using
      less code, which should contribute to maintainability and
      productivity.</para></sect2><sect2 id="_events"><title>Events</title><para id="para_threading_and_actors_aren_t_th">Threading and Actors
      aren’t the only way to do concurrency. Event-based concurrency, a
      particular approach to asynchronous or <emphasis>non-blocking
      I/O</emphasis> (NIO), has become a favored way to write servers that
      need to scale to thousands of simultaneous clients. Eschewing the
      traditional one-to-one relationship of threads to clients, this model of
      concurrency exposes events that occur when particular conditions are met
      (for <phrase role="keep-together">example</phrase>, when data is
      received from a client over a network socket). Typically, the <phrase role="keep-together">programmer</phrase> will associate a callback
      method with each event that’s relevant to her <phrase role="keep-together">program</phrase>.<indexterm class="startofrange" id="ch09_ActorsMINANagatti" significance="normal"><primary>Actors</primary><secondary>using with MINA NIO and Naggati library for SMTP
          server</secondary></indexterm><indexterm significance="normal"><primary>I/O (input/output)</primary><secondary>NIO (non-blocking I/O)</secondary></indexterm><indexterm significance="normal"><primary>NIO (non-blocking I/O)</primary></indexterm><indexterm class="startofrange" id="ch09_events" significance="normal"><primary>events</primary><secondary>using for concurrency</secondary></indexterm><indexterm class="startofrange" id="ch09_concurrentevents" significance="normal"><primary>concurrency</primary><secondary>traditional, using threading and events</secondary><tertiary>events</tertiary></indexterm></para><para id="para_while_the_java_nio_package_p">While the
      <literal moreinfo="none">java.nio</literal> package provides a variety of useful
      primitives for non-blocking <phrase role="keep-together">I/O</phrase>
      (buffers, channels, etc.), it’s still a fair bit of work to cobble
      together an event-based concurrent program from those simple parts.
      Enter Apache MINA, built atop Java NIO and described on its home page as
      “a network application framework which helps users develop high
      performance and high scalability network applications easily” (see <link linkend="MINA" xrefstyle="select:nopage">[MINA]</link>).<indexterm significance="normal"><primary>MINA (Apache)</primary></indexterm><indexterm significance="normal"><primary>Apache MINA</primary></indexterm><indexterm significance="normal"><primary>java.nio package</primary></indexterm></para><para id="para_while_mina_may_be_easier_to_us">While MINA may be easier
      to use than Java’s built-in NIO libraries, we’ve gotten used to some
      conveniences of Scala that just aren’t available in MINA. The open
      source Naggati library (see <link linkend="Naggati" xrefstyle="select:nopage">[Naggati]</link>) adds a Scala-friendly layer
      atop MINA that, according to its author, “makes it easy to build
      protocol filters [using a] sequential style.” Essentially, Naggati is a
      DSL for parsing network protocols, with MINA’s powerful NIO abilities
      under the hood.<indexterm significance="normal"><primary>Naggati library</primary></indexterm></para><para id="para_let_s_use_naggati_to_write_the">Let’s use Naggati to
      write the foundations of an SMTP email server. To keep things simple,
      we’re only dealing with two SMTP commands: <literal moreinfo="none">HELO</literal> and
      <literal moreinfo="none">QUIT</literal>. The former command identifies a client, and the
      latter ends the client’s session.<indexterm class="startofrange" id="ch09_SMTPserver" significance="normal"><primary>SMTP mail server (example)</primary></indexterm></para><para id="para_we_ll_drive_our_experiment_wit">We’ll keep ourselves
      honest with a test suite, facilitated by the Specs Behavior-Driven
      Development library (see <xref linkend="ScalaSpecs"/>):</para><programlisting language="scala" format="linespecific"><code role="comment">// .../smtpd/src/test/scala/com/programmingscala/smtpd/SmtpDecoderSpec.scala</code>

<code role="preproc">package</code> com.programmingscala.smtpd

<code role="preproc">import</code> java.nio.ByteOrder
<code role="preproc">import</code> net.lag.naggati._
<code role="preproc">import</code> org.apache.mina.core.buffer.IoBuffer
<code role="preproc">import</code> org.apache.mina.core.filterchain.IoFilter
<code role="preproc">import</code> org.apache.mina.core.session.{DummySession, IoSession}
<code role="preproc">import</code> org.apache.mina.filter.codec._
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> scala.collection.{immutable, mutable}

<code role="statement">object</code> <code role="special">SmtpDecoderSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="statement">private</code> <code role="statement">var</code> fakeSession:<code role="type"> IoSession</code> = <code role="statement">null</code>
  <code role="statement">private</code> <code role="statement">var</code> fakeDecoderOutput:<code role="type"> ProtocolDecoderOutput</code> = <code role="statement">null</code>
  <code role="statement">private</code> <code role="statement">var</code> written = <code role="statement">new</code> mutable.<code role="special">ListBuffer</code><code role="special">[Request]</code>

  <code role="statement">def</code> <code role="identifier">quickDecode</code>(s:<code role="type"> String</code>):<code role="type"> Unit</code> = {
    Codec.decoder.decode(fakeSession, IoBuffer.wrap(s.getBytes), fakeDecoderOutput)
  }

  <code role="constant">"SmtpRequestDecoder"</code> should {
    doBefore {
      written.clear()
      fakeSession = <code role="statement">new</code> <code role="special">DummySession</code>
      fakeDecoderOutput = <code role="statement">new</code> <code role="special">ProtocolDecoderOutput</code> {
        <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">flush</code>(nextFilter:<code role="type"> IoFilter.NextFilter</code>, s:<code role="type"> IoSession</code>) = {}
        <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">write</code>(obj:<code role="type"> AnyRef</code>) = written += obj.asInstanceOf[<code role="special">Request</code>]
      }
    }

    <code role="constant">"parse HELO"</code> in {
      quickDecode(<code role="constant">"HELO client.example.org</code><code role="special">\n</code><code role="constant">"</code>)
      written.size mustEqual <code role="constant">1</code>
      written(<code role="constant">0</code>).command mustEqual <code role="constant">"HELO"</code>
      written(<code role="constant">0</code>).data mustEqual <code role="constant">"client.example.org"</code>
    }

    <code role="constant">"parse QUIT"</code> in {
      quickDecode(<code role="constant">"QUIT</code><code role="special">\n</code><code role="constant">"</code>)
      written.size mustEqual <code role="constant">1</code>
      written(<code role="constant">0</code>).command mustEqual <code role="constant">"QUIT"</code>
      written(<code role="constant">0</code>).data mustEqual <code role="statement">null</code>
    }
  }
}
</programlisting><para id="para_after_setting_up_an_environmen">After setting up an
      environment for each test run, our suite exercises the two SMTP commands
      we’re interested in. The <literal moreinfo="none">doBefore</literal> block runs before
      each test, guaranteeing that mock session and output buffers are in a
      clean state. In each test we’re passing a string of hypothetical client
      input to our as-yet-unimplemented <literal moreinfo="none">Codec</literal>, then
      verifying that the resulting <literal moreinfo="none">Request</literal> (a <literal moreinfo="none">case
      class</literal>) contains the correct <literal moreinfo="none">command</literal> and
      <literal moreinfo="none">data</literal> fields. As the <literal moreinfo="none">QUIT</literal> command
      doesn’t require any additional information from the client, we simply
      check that <literal moreinfo="none">data</literal> is <literal moreinfo="none">null</literal>.</para><para id="para_with_our_tests_in_place_let_s">With our tests in place,
      let’s implement a basic codec (an encoder and decoder) for
      SMTP:<indexterm significance="normal"><primary>SMTP mail server (example)</primary><secondary>codec for SMTP</secondary></indexterm><indexterm significance="normal"><primary>codec for SMTP (example)</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// .../smtpd/src/main/scala/com/programmingscala/smtpd/Codec.scala</code>

<code role="preproc">package</code> com.programmingscala.smtpd

<code role="preproc">import</code> org.apache.mina.core.buffer.IoBuffer
<code role="preproc">import</code> org.apache.mina.core.session.{IdleStatus, IoSession}
<code role="preproc">import</code> org.apache.mina.filter.codec._
<code role="preproc">import</code> net.lag.naggati._
<code role="preproc">import</code> net.lag.naggati.Steps._

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Request</code>(command:<code role="type"> String</code>, data:<code role="type"> String</code>)
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Response</code>(data:<code role="type"> IoBuffer</code>)

<code role="statement">object</code> <code role="special">Codec</code> {
  <code role="statement">val</code> encoder = <code role="statement">new</code> <code role="special">ProtocolEncoder</code> {
    <code role="statement">def</code> <code role="identifier">encode</code>(session:<code role="type"> IoSession</code>, message:<code role="type"> AnyRef</code>, out:<code role="type"> ProtocolEncoderOutput</code>) = {
      <code role="statement">val</code> buffer = message.asInstanceOf[<code role="special">Response</code>].data
      out.write(buffer)
    }

    <code role="statement">def</code> <code role="identifier">dispose</code>(session:<code role="type"> IoSession</code>):<code role="type"> Unit</code> = {
      <code role="comment">// no-op, required by ProtocolEncoder trait</code>
    }
  }

  <code role="statement">val</code> decoder = <code role="statement">new</code> <code role="special">Decoder</code>(readLine(<code role="constant">true</code>, <code role="constant">"ISO-8859-1"</code>) { line <code role="statement">=&gt;</code>
    line.split(<code role="constant">' '</code>).first <code role="statement">match</code> {
      <code role="statement">case</code> <code role="constant">"HELO"</code> <code role="statement">=&gt;</code> state.out.write(<code role="special">Request</code>(<code role="constant">"HELO"</code>, line.split(<code role="constant">' '</code>)(<code role="constant">1</code>))); <code role="special">End</code>
      <code role="statement">case</code> <code role="constant">"QUIT"</code> <code role="statement">=&gt;</code> state.out.write(<code role="special">Request</code>(<code role="constant">"QUIT"</code>, <code role="statement">null</code>)); <code role="special">End</code>
      <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> <code role="statement">throw</code> <code role="statement">new</code> <code role="special">ProtocolError</code>(<code role="constant">"Malformed request line: "</code> + line)
    }
  })
}
</programlisting><para id="para_we_first_define_a_request_c">We first define a
      <literal moreinfo="none">Request</literal> <literal moreinfo="none">case class</literal> in which to
      store request data as it arrives. Then we specify the
      <literal moreinfo="none">encoder</literal> portion of our codec, which exists simply to
      write data out. A <literal moreinfo="none">dispose</literal> method is defined (but not
      fleshed out) to fulfill the contract of the <literal role="keep-together" moreinfo="none">ProtocolEncoder</literal> trait.<indexterm significance="normal"><primary>Request case class</primary></indexterm></para><para id="para_the_decoder_is_what_we_re_real">The decoder is what we’re
      really interested in. <literal moreinfo="none">readRequest</literal> reads a line, picks
      out the first word in that line, and pattern matches on it to find SMTP
      commands. In the case of a <literal moreinfo="none">HELO</literal> command, we also grab
      the subsequent string on that line. The results are placed in a
      <literal moreinfo="none">Request</literal> object and written out to
      <literal moreinfo="none">state</literal>. As you might imagine, <literal moreinfo="none">state</literal>
      stores our progress throughout the parsing process.</para><para id="para_though_trivial_the_above_exam">Though trivial, the above
      example demonstrates just how easy it is to parse protocols with
      Naggati. Now that we’ve got a working codec, let’s combine Naggati and
      MINA with Actors to wire up a server.</para><para id="para_first_a_few_lines_of_setup_gr">First, a few lines of
      setup grunt work to get things going for our SMTP server:<indexterm significance="normal"><primary>SMTP mail server (example)</primary><secondary>setup</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// .../smtpd/src/main/scala/com/programmingscala/smtpd/Main.scala</code>

<code role="preproc">package</code> com.programmingscala.smtpd

<code role="preproc">import</code> net.lag.naggati.IoHandlerActorAdapter
<code role="preproc">import</code> org.apache.mina.filter.codec.ProtocolCodecFilter
<code role="preproc">import</code> org.apache.mina.transport.socket.SocketAcceptor
<code role="preproc">import</code> org.apache.mina.transport.socket.nio.{NioProcessor, NioSocketAcceptor}
<code role="preproc">import</code> java.net.InetSocketAddress
<code role="preproc">import</code> java.util.concurrent.{Executors, ExecutorService}
<code role="preproc">import</code> scala.actors.Actor._

<code role="statement">object</code> <code role="special">Main</code> {
  <code role="statement">val</code> listenAddress = <code role="constant">"0.0.0.0"</code>
  <code role="statement">val</code> listenPort = <code role="constant">2525</code>

  <code role="statement">def</code> <code role="identifier">setMaxThreads</code> = {
    <code role="statement">val</code> maxThreads = (Runtime.getRuntime.availableProcessors * <code role="constant">2</code>)
    System.setProperty(<code role="constant">"actors.maxPoolSize"</code>, maxThreads.toString)
  }

  <code role="statement">def</code> <code role="identifier">initializeAcceptor</code> = {
    <code role="statement">var</code> acceptorExecutor = Executors.newCachedThreadPool()
    <code role="statement">var</code> acceptor =
      <code role="statement">new</code> <code role="special">NioSocketAcceptor</code>(acceptorExecutor, <code role="statement">new</code> <code role="special">NioProcessor</code>(acceptorExecutor))
    acceptor.setBacklog(<code role="constant">1000</code>)
    acceptor.setReuseAddress(<code role="constant">true</code>)
    acceptor.getSessionConfig.setTcpNoDelay(<code role="constant">true</code>)
    acceptor.getFilterChain.addLast(<code role="constant">"codec"</code>,
            <code role="statement">new</code> <code role="special">ProtocolCodecFilter</code>(smtpd.Codec.encoder, smtpd.Codec.decoder))
    acceptor.setHandler(
            <code role="statement">new</code> <code role="special">IoHandlerActorAdapter</code>(session <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">SmtpHandler</code>(session)))
    acceptor.bind(<code role="statement">new</code> <code role="special">InetSocketAddress</code>(listenAddress, listenPort))
  }

  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) {
    setMaxThreads
    initializeAcceptor
    println(<code role="constant">"smtpd: up and listening on "</code> + listenAddress + <code role="constant">":"</code> + listenPort)
  }
}
</programlisting><para id="para_to_ensure_that_we_re_getting_t">To ensure that we’re
      getting the most out of the Actor instances in our server, we set the
      <literal moreinfo="none">actors.maxPoolSize</literal> system property to twice the
      number of available processors on our machine. We then initialize an
      <literal moreinfo="none">NioSocketAcceptor</literal>, a key piece of MINA machinery that
      accepts new connections from clients. The final three lines of this
      configuration are critical, as they put our codec to work, tell the
      acceptor to handle requests with a special object, and start the server
      listening for new connections on port 2525 (real SMTP servers run on the
      privileged port 25).<indexterm significance="normal"><primary>actors.maxPoolSize system property</primary></indexterm><indexterm significance="normal"><primary>NioSocketAcceptor object</primary></indexterm></para><para id="para_the_aforementioned_special_obj">The aforementioned
      special object is an Actor wrapped in an
      <literal moreinfo="none">IoHandlerActorAdapter</literal>, a bridging layer between Scala
      Actors and MINA that’s provided by Naggati. This is the piece of our
      server that talks back to the client. Now that we know what the client
      is saying, thanks to the decoder, we actually know what to say
      back!<indexterm significance="normal"><primary>SMTP mail server (example)</primary><secondary>SmtpHandler class</secondary></indexterm><indexterm significance="normal"><primary>IOHandlerActorAdapter object</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// .../smtpd/src/main/scala/com/programmingscala/smtpd/SmtpHandler.scala</code>

<code role="preproc">package</code> com.programmingscala.smtpd

<code role="preproc">import</code> net.lag.naggati.{IoHandlerActorAdapter, MinaMessage, ProtocolError}
<code role="preproc">import</code> org.apache.mina.core.buffer.IoBuffer
<code role="preproc">import</code> org.apache.mina.core.session.{IdleStatus, IoSession}
<code role="preproc">import</code> java.io.IOException
<code role="preproc">import</code> scala.actors.Actor
<code role="preproc">import</code> scala.actors.Actor._
<code role="preproc">import</code> scala.collection.{immutable, mutable}

<code role="statement">class</code> <code role="special">SmtpHandler</code>(<code role="statement">val</code> session:<code role="type"> IoSession</code>) <code role="statement">extends</code> <code role="special">Actor</code> {
  start

  <code role="statement">def</code> <code role="identifier">act</code> = {
    loop {
      react {
        <code role="statement">case</code> MinaMessage.<code role="special">MessageReceived</code>(msg) <code role="statement">=&gt;</code>
            handle(msg.asInstanceOf[smtpd.<code role="special">Request</code>])
        <code role="statement">case</code> MinaMessage.<code role="special">SessionClosed</code> <code role="statement">=&gt;</code> exit()
        <code role="statement">case</code> MinaMessage.<code role="special">SessionIdle</code>(status) <code role="statement">=&gt;</code> session.close
        <code role="statement">case</code> MinaMessage.<code role="special">SessionOpened</code> <code role="statement">=&gt;</code> reply(<code role="constant">"220 localhost Tapir SMTPd 0.1</code><code role="special">\n</code><code role="constant">"</code>)

        <code role="statement">case</code> MinaMessage.<code role="special">ExceptionCaught</code>(cause) <code role="statement">=&gt;</code> {
          cause.getCause <code role="statement">match</code> {
            <code role="statement">case</code> e:<code role="type"> ProtocolError =&gt; reply</code>(<code role="constant">"502 Error: "</code> + e.getMessage + <code role="constant">"</code><code role="special">\n</code><code role="constant">"</code>)
            <code role="statement">case</code> i:<code role="type"> IOException   =&gt; reply</code>(<code role="constant">"502 Error: "</code> + i.getMessage + <code role="constant">"</code><code role="special">\n</code><code role="constant">"</code>)
            <code role="statement">case</code> <code role="statement">_</code>                <code role="statement">=&gt;</code> reply(<code role="constant">"502 Error unknown</code><code role="special">\n</code><code role="constant">"</code>)
          }
          session.close
        }
      }
    }
  }

  <code role="statement">private</code> <code role="statement">def</code> <code role="identifier">handle</code>(request:<code role="type"> smtpd.Request</code>) = {
    request.command <code role="statement">match</code> {
      <code role="statement">case</code> <code role="constant">"HELO"</code> <code role="statement">=&gt;</code> reply(<code role="constant">"250 Hi there "</code> + request.data + <code role="constant">"</code><code role="special">\n</code><code role="constant">"</code>)
      <code role="statement">case</code> <code role="constant">"QUIT"</code> <code role="statement">=&gt;</code> reply(<code role="constant">"221 Peace out girl scout</code><code role="special">\n</code><code role="constant">"</code>); session.close
    }
  }

  <code role="statement">private</code> <code role="statement">def</code> <code role="identifier">reply</code>(s:<code role="type"> String</code>) = {
    session.write(<code role="statement">new</code> smtpd.<code role="special">Response</code>(IoBuffer.wrap(s.getBytes)))
  }

}
</programlisting><para id="para_straight_away_we_see_the_same">Straight away, we see the
      same pattern that we saw in the Actors examples earlier in this chapter:
      looping around a <literal moreinfo="none">react</literal> block that pattern matches on
      a limited set of cases. In <literal moreinfo="none">SmtpHandler</literal>, all of those
      cases are <emphasis>events</emphasis> provided by MINA. For example,
      MINA will send us <literal moreinfo="none">MinaMessage.SessionOpened</literal> when a
      client connects and <literal role="keep-together" moreinfo="none">MinaMessage.Ses⁠sionClosed</literal> when a client
      disconnects.</para><para id="para_the_case_we_re_most_interested">The case we’re most
      interested in is <literal moreinfo="none">MinaMessage.MessageReceived</literal>. We’re
      handed a familiar <literal moreinfo="none">Request</literal> object with each newly
      received valid message, and we can pattern match on the
      <literal moreinfo="none">command</literal> field to take appropriate action. When the
      client says <literal moreinfo="none">HELO</literal>, we can reply with an
      acknowledgement. When the client says <literal moreinfo="none">QUIT</literal>, we say
      goodbye and disconnect him.<indexterm significance="normal"><primary>MINA (Apache)</primary><secondary>events provided by</secondary></indexterm></para><para id="para_now_that_we_ve_got_all_the_pie">Now that we’ve got all
      the pieces in place, let’s have a conversation with our
      server:<indexterm significance="normal"><primary>SMTP mail server (example)</primary><secondary>conversation with server</secondary></indexterm></para><screen format="linespecific">[al3x@jaya ~]$ telnet localhost 2525
Trying ::1...
Connected to localhost.
Escape character is '^]'.
220 localhost Tapir SMTPd 0.1
HELO jaya.local
250 Hi there jaya.local
QUIT
221 Peace out girl scout
Connection closed by foreign host.</screen><?dbfo-need height=”1in”
?><para id="para_a_brief_conversation_to_be_su">A brief conversation, to
      be sure, but our server works! Now, what happens if we throw something
      unexpected at it?</para><screen format="linespecific">[al3x@jaya ~]$ telnet localhost 2525
Trying ::1...
Connected to localhost.
Escape character is '^]'.
220 localhost Tapir SMTPd 0.1
HELO jaya.local
250 Hi there jaya.local
BAD COMMAND
502 Error: Malformed request line: BAD COMMAND
Connection closed by foreign host.</screen><para id="para_nicely_handled_good_thing_we_">Nicely handled. Good thing
      we took the time to dig out those exceptions when we received a
      <literal moreinfo="none">MinaMessage.ExceptionCaught</literal> in our
      <literal moreinfo="none">SmtpHandler</literal> Actor.</para><para id="para_of_course_what_we_ve_built_ju">Of course, what we’ve
      built just handles the beginning and end of a complete SMTP
      conversation. As an exercise, try filling out the rest of the commands.
      Or, to skip ahead to something very much akin to what we’ve built here,
      check out the open source Mailslot project on GitHub (see <link linkend="Mailslot" xrefstyle="select:nopage">[Mailslot]</link>).<indexterm class="endofrange" startref="ch09_ActorsMINANagatti" significance="normal"/><indexterm class="endofrange" startref="ch09_SMTPserver" significance="normal"/><indexterm class="endofrange" startref="ch09_events" significance="normal"/><indexterm class="endofrange" startref="ch09_concurrentevents" significance="normal"/><indexterm class="endofrange" startref="ch09_concurrenttraditional" significance="normal"/></para></sect2></sect1><sect1 id="_recap_and_what_s_next"><title>Recap and What’s Next</title><para id="para_we_learned_how_to_build_scalab">We learned how to build
    scalable, robust concurrent applications using Scala’s Actor library that
    avoid the problems of traditional approaches based on synchronized access
    to shared, mutable state. We also demonstrated that Java’s powerful
    built-in threading model is easily accessible from Scala. Finally, we
    learned how to combine Actors with the powerful MINA NIO framework and
    Naggati to develop event-driven, asynchronous network servers from the
    ground up in just a few lines of code.</para><para id="para_the_next_chapter_examines_scal">The next chapter examines
    Scala’s built-in support for working with XML.</para></sect1></chapter><chapter id="HerdingXMLInScalaDSLs"><title>Herding XML in Scala</title><para id="para_xml_has_long_since_become_the_">XML has long since become the
  <emphasis>lingua franca</emphasis> of machine-to-machine communication on
  the Internet. The format’s combination of human readability,
  standardization, and tool support has made working with XML an inevitability
  for programmers. Yet, writing code that deals in XML is an unpleasant chore
  in most programming languages. Scala improves this situation.<indexterm class="startofrange" id="ch10_XML" significance="normal"><primary>XML</primary></indexterm></para><para id="para_as_with_the_actor_library_we_l">As with the Actor
  functionality we learned about in <xref linkend="Concurrency"/>, Scala’s
  XML support is implemented partly as a library, with some built-in syntax
  support. It feels to the programmer like an entirely natural part of the
  language. Convenient operators add a spoonful of syntactic sugar to the task
  of diving deep into complex document structures, and pattern matching
  further sweetens the deal. Outputting XML is just as pleasant.</para><para id="para_unusual_in_programming_languag">Unusual in programming
  languages and particularly handy, Scala allows inline XML. Most anywhere you
  might put a string, you can put XML. This feature makes templating and
  configuration a breeze, and lets us test our use of XML without so much as
  opening a file.</para><para id="para_let_s_explore_working_with_xml">Let’s explore working with
  XML in Scala. First, we’ll look at reading and navigating an XML document.
  Finally, we’ll produce XML output programmatically and demonstrate uses for
  inline XML.</para><sect1 id="_reading_xml"><title>Reading XML</title><para id="para_we_ll_start_with_the_basics_h">We’ll start with the basics:
    how to turn a string full of XML into a data structure we can work
    with:<indexterm significance="normal"><primary>XML</primary><secondary>reading</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/XML/reading/from-string-script.scala</code>

<code role="preproc">import</code> scala.xml._

<code role="statement">val</code> someXMLInAString = <code role="constant">"""</code>
<code role="constant">&lt;sammich&gt;</code>
<code role="constant">  &lt;bread&gt;wheat&lt;/bread&gt;</code>
<code role="constant">  &lt;meat&gt;salami&lt;/meat&gt;</code>
<code role="constant">  &lt;condiments&gt;</code>
<code role="constant">    &lt;condiment expired="true"&gt;mayo&lt;/condiment&gt;</code>
<code role="constant">    &lt;condiment expired="false"&gt;mustard&lt;/condiment&gt;</code>
<code role="constant">  &lt;/condiments&gt;</code>
<code role="constant">&lt;/sammich&gt;</code>
<code role="constant">"""</code>

<code role="statement">val</code> someXML = XML.loadString(someXMLInAString)
assert(someXML.isInstanceOf[scala.xml.<code role="special">Elem</code>])
</programlisting><para id="para_all_fine_and_well_we_ve_trans">All fine and well. We’ve
    transformed the string into a <literal moreinfo="none">NodeSeq</literal>, Scala’s type for
    storing a sequence of XML nodes. Were our XML document in a file on disk,
    we could have used the <literal moreinfo="none">loadFile</literal> method from the same
    package.<indexterm significance="normal"><primary>NodeSeq object</primary></indexterm></para><para id="para_since_we_re_supplying_the_xml_">Since we’re supplying the
    XML ourselves, we can skip the <literal moreinfo="none">XML.loadString</literal> step and
    just assign a chunk of markup to a <literal moreinfo="none">val</literal> or
    <literal moreinfo="none">var</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/XML/reading/inline-script.scala</code>

<code role="preproc">import</code> scala.xml._

<code role="statement">val</code> someXML =
<code role="preproc">&lt;sammich&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;bread&gt;</code><code role="constant">wheat</code><code role="preproc">&lt;/bread&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;meat&gt;</code><code role="constant">salami</code><code role="preproc">&lt;/meat&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;condiments&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;condiment expired=</code><code role="constant">"true"</code><code role="preproc">&gt;</code><code role="constant">mayo</code><code role="preproc">&lt;/condiment&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;condiment expired=</code><code role="constant">"false"</code><code role="preproc">&gt;</code><code role="constant">mustard</code><code role="preproc">&lt;/condiment&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;/condiments&gt;</code>
<code role="preproc">&lt;/sammich&gt;</code>

assert(someXML.isInstanceOf[scala.xml.<code role="special">Elem</code>])
</programlisting><sect2 id="_exploring_xml"><title>Exploring XML</title><para id="para_if_we_paste_the_above_into_the">If we paste the previous
      example into the interpreter, we can explore our sandwich using some
      handy tools provided by <literal moreinfo="none">NodeSeq</literal>:<indexterm significance="normal"><primary>XML</primary><secondary>exploring using NodeSeq tools</secondary></indexterm></para><screen format="linespecific">scala&gt; someXML \ "bread"
res2: scala.xml.NodeSeq = &lt;bread&gt;wheat&lt;/bread&gt;</screen><para id="para_that_backslash_what_the_docu">That backslash—what the
      documentation calls a <emphasis>projection function</emphasis>—says,
      “Find me elements named <literal moreinfo="none">bread</literal>.” We’ll always get a
      <literal moreinfo="none">NodeSeq</literal> back when using a projection function. If
      we’re only interested in what’s between the tags, we can use the
      <literal moreinfo="none">text</literal> method:<indexterm significance="normal"><primary>\ (backslash)</primary><secondary>projection functions</secondary></indexterm><indexterm significance="normal"><primary>projection functions</primary></indexterm></para><screen format="linespecific">scala&gt; (someXML \ "bread").text
res3: String = wheat</screen><tip id="para_tip_it_s_valid_syntax_to_say_"><para>It’s valid syntax to say <literal moreinfo="none">someXML \ "bread"
        text</literal>, without parentheses or the dot before the call to
        <literal moreinfo="none">text</literal>. You’ll still get the same result, but it’s
        harder to read. Parentheses make your intent clear.</para></tip><para id="para_we_ve_only_inspected_the_outer">We’ve only inspected the
      outermost layer of our sandwich. Let’s try to get a
      <literal moreinfo="none">NodeSeq</literal> of the condiments:</para><screen format="linespecific">scala&gt; someXML \ "condiment"
res4: scala.xml.NodeSeq =</screen><para id="para_what_went_wrong_the_funct">What went wrong? The
      <literal moreinfo="none">\</literal> function doesn’t descend into child elements of an
      XML structure. To do that, we use its sister function,
      <literal moreinfo="none">\\</literal> (two backslashes):</para><screen format="linespecific">scala&gt; someXML \\ "condiment"
res5: scala.xml.NodeSeq = &lt;condiment expired="true"&gt;mayo&lt;/condiment&gt;
  &lt;condiment expired="false"&gt;mustard&lt;/condiment&gt;</screen><para id="para_much_better_we_dove_into_the_">Much better. (We split the
      single output line into two lines so it would fit on the page.) We dove
      into the structure and pulled out the two
      <literal moreinfo="none">&lt;condiment&gt;</literal> elements. Looks like one of the
      condiments has gone bad, though. We can find out if any of the
      condiments has expired by extracting its <literal moreinfo="none">expired</literal>
      attribute. All it takes is an <literal moreinfo="none">@</literal> before the attribute
      name:<indexterm significance="normal"><primary>@ (at sign)</primary><secondary>extracting value of XML attributes</secondary></indexterm></para><screen format="linespecific">scala&gt; (someXML \\ "condiment")(0) \ "@expired"
res6: scala.xml.NodeSeq = true</screen><para id="para_we_used_the_0_to_pick_the_">We used the
      <literal moreinfo="none">(0)</literal> to pick the first of the two condiments that were
      returned by <literal moreinfo="none">(someXML \\ "condiment")</literal>.</para></sect2><sect2 id="_looping_amp_matching_xml"><title>Looping and Matching XML</title><para id="para_this_extracts_the__value__of_t">The previous bit of code
      extracted the <emphasis>value</emphasis> of the
      <literal moreinfo="none">expired</literal> attribute (<literal moreinfo="none">true</literal>, in this
      case), but it didn’t tell us which condiment is expired. If we were
      handed an arbitrary XML sandwich, how would we identify the expired
      condiments? We can loop through the XML:<indexterm significance="normal"><primary>loops</primary><secondary>looping through and matching XML</secondary></indexterm><indexterm significance="normal"><primary>XML</primary><secondary>looping and matching</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/XML/reading/for-loop-script.scala</code>

<code role="statement">for</code> (condiment <code role="statement">&lt;-</code> (someXML \\ <code role="constant">"condiment"</code>)) {
  <code role="statement">if</code> ((condiment \ <code role="constant">"@expired"</code>).text == <code role="constant">"true"</code>)
    println(<code role="constant">"the "</code> + condiment.text + <code role="constant">" has expired!"</code>)
}
</programlisting><para id="para_because_nodeseq_inherits_the">Because
      <literal moreinfo="none">NodeSeq</literal> inherits the same familiar attributes that
      most Scala collection types carry, tools like <literal moreinfo="none">for</literal>
      loops apply directly. In the example just shown, we extract the <literal role="keep-together" moreinfo="none">&lt;condiment&gt;</literal> nodes, loop over each
      of them, and test whether or not their <literal moreinfo="none">expired</literal>
      attribute equals the string <literal moreinfo="none">"true"</literal>. We have to
      specify that we want the <literal moreinfo="none">text</literal> of a given <literal role="keep-together" moreinfo="none">condiment</literal>; otherwise, we’d get a string
      representation of the entire line of XML.</para><para id="para_we_can_also_use_pattern_matchi">We can also use pattern
      matching on XML structures. Cases in pattern matches can be written in
      terms of XML literals; expressions between curly braces
      (<literal moreinfo="none">{}</literal>) escape back to standard Scala pattern matching
      syntax. To match all XML nodes in the escaped portion of a pattern
      match, use an underscore (wildcard) followed by an asterisk
      ( <literal moreinfo="none">_*</literal>). To bind what you’ve matched on to a variable,
      prefix the match with the variable name and an <literal moreinfo="none">@</literal>
      sign.<indexterm significance="normal"><primary>pattern matching</primary><secondary>using on XML structures</secondary></indexterm></para><para id="para_let_s_put_all_that_together_in">Let’s put all that
      together into one example. We’ll include the original XML document again
      so you can follow along as we pattern match on XML:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/XML/reading/pattern-matching-script.scala</code>

<code role="preproc">import</code> scala.xml._

<code role="statement">val</code> someXML =
<code role="preproc">&lt;sammich&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;bread&gt;</code><code role="constant">wheat</code><code role="preproc">&lt;/bread&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;meat&gt;</code><code role="constant">salami</code><code role="preproc">&lt;/meat&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;condiments&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;condiment expired=</code><code role="constant">"true"</code><code role="preproc">&gt;</code><code role="constant">mayo</code><code role="preproc">&lt;/condiment&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;condiment expired=</code><code role="constant">"false"</code><code role="preproc">&gt;</code><code role="constant">mustard</code><code role="preproc">&lt;/condiment&gt;</code>
<code role="constant">  </code><code role="preproc">&lt;/condiments&gt;</code>
<code role="preproc">&lt;/sammich&gt;</code>

someXML <code role="statement">match</code> {
  <code role="statement">case</code> <code role="preproc">&lt;sammich&gt;</code><code role="special">{</code>ingredients @ <code role="statement">_</code>*<code role="special">}</code><code role="preproc">&lt;/sammich&gt;</code> <code role="statement">=&gt;</code> {
    <code role="statement">for</code> (cond @ <code role="preproc">&lt;condiments&gt;</code><code role="special">{</code><code role="statement">_</code>*<code role="special">}</code><code role="preproc">&lt;/condiments&gt;</code> <code role="statement">&lt;-</code> ingredients)
      println(<code role="constant">"condiments: "</code> + cond.text)
  }
}
</programlisting><para id="para_here_we_bind_the_contents_of_">Here, we bind the contents
      of our <literal moreinfo="none">&lt;sammich&gt;</literal> structure (that is, what’s
      inside the opening and closing tag) to a variable called
      <literal moreinfo="none">ingredients</literal>. Then, as we iterate through the
      ingredients in a <literal moreinfo="none">for</literal> loop, we assign the elements
      that are between the <literal moreinfo="none">&lt;condiments&gt;</literal> tags to a
      temporary variable, <literal moreinfo="none">cond</literal>. Each
      <literal moreinfo="none">cond</literal> is printed.</para><para id="para_the_same_tools_that_let_us_eas">The same tools that let
      us easily manipulate complex data structures in Scala are readily
      available for XML processing. As a readable alternative to XSLT, Scala’s
      XML library makes reading and parsing XML a breeze. It also gives us
      equally powerful tools for writing XML, which we’ll explore in the next
      section.</para></sect2></sect1><sect1 id="_writing_xml"><title>Writing XML</title><para id="para_while_some_languages_construct">While some languages
    construct XML through complex object serialization mechanisms, Scala’s
    support for XML literals makes writing XML far simpler. Essentially, when
    you want XML, just write XML. To interpolate variables and expressions,
    escape out to Scala with curly braces, as we did in the pattern matching
    examples earlier:<indexterm significance="normal"><primary>XML</primary><secondary>writing</secondary></indexterm></para><screen format="linespecific">scala&gt; var name = "Bob"
name: java.lang.String = Bob

scala&gt; val bobXML =
     | &lt;person&gt;
     |   &lt;name&gt;{name}&lt;/name&gt;
     | &lt;/person&gt;
bobXML: scala.xml.Elem =
&lt;person&gt;
  &lt;name&gt;Bob&lt;/name&gt;
&lt;/person&gt;</screen><para id="para_as_we_can_see_the_name_vari">As we can see, the
    <literal moreinfo="none">name</literal> variable was substituted when we constructed the
    XML document assigned to <literal moreinfo="none">bobXML</literal>. That evaluation only
    occurs once; were <literal moreinfo="none">name</literal> subsequently redefined, the
    <literal moreinfo="none">&lt;name&gt;</literal> element of <literal moreinfo="none">bobXML</literal> would
    still contain the string “Bob”.</para><sect2 id="_a_real_world_example"><title>A Real-World Example</title><para id="para_for_a_more_complete_example_l">For a more complete
      example, let’s say we’re designing that favorite latter-day “hello
      world,” a blogging system. We’ll start with a class to represent an
      Atom-friendly blog post:<indexterm class="startofrange" id="ch10_blogsys" significance="normal"><primary>blogging system (example)</primary></indexterm><indexterm class="startofrange" id="ch10_XMLwritingexample" significance="normal"><primary>XML</primary><secondary>writing</secondary><tertiary>blogging system (example)</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/XML/writing/post.scala</code>

<code role="preproc">import</code> java.text.SimpleDateFormat
<code role="preproc">import</code> java.util.Date

<code role="statement">class</code> <code role="special">Post</code>(<code role="statement">val</code> title:<code role="type"> String</code>, <code role="statement">val</code> body:<code role="type"> String</code>, <code role="statement">val</code> updated:<code role="type"> Date</code>) {
  <code role="statement">lazy</code> <code role="statement">val</code> dashedDate = {
    <code role="statement">val</code> dashed = <code role="statement">new</code> <code role="special">SimpleDateFormat</code>(<code role="constant">"yy-MM-dd"</code>)
    dashed.format(updated)
  }

  <code role="statement">lazy</code> <code role="statement">val</code> atomDate = {
    <code role="statement">val</code> rfc3339 = <code role="statement">new</code> <code role="special">SimpleDateFormat</code>(<code role="constant">"yyyy-MM-dd'T'h:m:ss'-05:00'"</code>)
    rfc3339.format(updated)
  }

  <code role="statement">lazy</code> <code role="statement">val</code> slug = title.toLowerCase.replaceAll(<code role="constant">"</code><code role="special">\\</code><code role="constant">W"</code>, <code role="constant">"-"</code>)
  <code role="statement">lazy</code> <code role="statement">val</code> atomId  = <code role="constant">"tag:example.com,"</code> + dashedDate + <code role="constant">":/"</code> + slug
}
</programlisting><para id="para_beyond_the_obvious_title_and">Beyond the obvious
      <literal moreinfo="none">title</literal> and <literal moreinfo="none">body</literal> attributes, we’ve
      defined several lazily loaded values in our <literal moreinfo="none">Post</literal>
      class. These attributes will come in handy when we transmute our posts
      into an Atom feed, the standard way to syndicate blogs between computers
      on the Web. Atom documents are a flavor of XML, and a perfect
      application for demonstrating the process of outputting XML with
      Scala.<indexterm significance="normal"><primary>lazy values</primary><secondary>Post class (example)</secondary></indexterm></para><para id="para_we_ll_define_an_atomfeed_cla">We’ll define an
      <literal moreinfo="none">AtomFeed</literal> class that takes a sequence of
      <literal moreinfo="none">Post</literal> objects as its sole argument:<indexterm significance="normal"><primary>AtomFeed class (example)</primary></indexterm><indexterm significance="normal"><primary>blogging system (example)</primary><secondary>AtomFeed class</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/XML/writing/atom-feed.scala</code>

<code role="preproc">import</code> scala.xml.XML

<code role="statement">class</code> <code role="special">AtomFeed</code>(posts:<code role="type"> Seq[Post]</code>) {
  <code role="statement">val</code> feed =
  <code role="preproc">&lt;feed xmlns=</code><code role="constant">""</code><code role="preproc">&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;title&gt;</code><code role="constant">My Blog</code><code role="preproc">&lt;/title&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;subtitle&gt;</code><code role="constant">A fancy subtitle.</code><code role="preproc">&lt;/subtitle&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;link href=</code><code role="constant">""</code><code role="preproc">/&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;link href=</code><code role="constant">""</code><code role="preproc"> rel=</code><code role="constant">"self"</code><code role="preproc">/&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;updated&gt;</code><code role="special">{</code>posts(<code role="constant">0</code>).atomDate<code role="special">}</code><code role="preproc">&lt;/updated&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;author&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;name&gt;</code><code role="constant">John Doe</code><code role="preproc">&lt;/name&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;uri&gt;</code><code role="constant"/><code role="preproc">&lt;/uri&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;/author&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;id&gt;</code><code role="constant"/><code role="preproc">&lt;/id&gt;</code>
<code role="constant">    </code><code role="special">{</code><code role="statement">for</code> (post <code role="statement">&lt;-</code> posts) <code role="statement">yield</code>
    <code role="preproc">&lt;entry&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;title&gt;</code><code role="special">{</code>post.title<code role="special">}</code><code role="preproc">&lt;/title&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;link href=</code><code role="special">{</code><code role="constant">""</code> + post.slug + <code role="constant">".html"</code><code role="special">}</code><code role="preproc"> rel=</code><code role="constant">"alternate"</code><code role="preproc">/&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;id&gt;</code><code role="special">{</code>post.atomId<code role="special">}</code><code role="preproc">&lt;/id&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;updated&gt;</code><code role="special">{</code>post.atomDate<code role="special">}</code><code role="preproc">&lt;/updated&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;content type=</code><code role="constant">"html"</code><code role="preproc">&gt;</code><code role="special">{</code>post.body<code role="special">}</code><code role="preproc">&lt;/content&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;author&gt;</code>
<code role="constant">        </code><code role="preproc">&lt;name&gt;</code><code role="constant">John Doe</code><code role="preproc">&lt;/name&gt;</code>
<code role="constant">        </code><code role="preproc">&lt;uri&gt;</code><code role="constant"/><code role="preproc">&lt;/uri&gt;</code>
<code role="constant">      </code><code role="preproc">&lt;/author&gt;</code>
<code role="constant">    </code><code role="preproc">&lt;/entry&gt;</code>
    <code role="special">}</code>
<code role="constant">  </code><code role="preproc">&lt;/feed&gt;</code>

  <code role="statement">def</code> <code role="identifier">write</code> = XML.saveFull(<code role="constant">"/tmp/atom-example.xml"</code>, feed, <code role="constant">"UTF-8"</code>, <code role="constant">true</code>, <code role="statement">null</code>)
}
</programlisting><para id="para_we_re_making_heavy_use_of_the_">We’re making heavy use of
      the ability to escape out to Scala expressions in this example. Whenever
      we need a piece of dynamic information—for example, the date of the
      first post in the sequence, formatted for the Atom standard—we simply
      escape out and write Scala as we normally would. In the latter half of
      the <literal moreinfo="none">&lt;feed&gt;</literal> element, we use a
      <literal moreinfo="none">for</literal> comprehension to <literal moreinfo="none">yield</literal>
      successive blocks of dynamically formatted XML.<indexterm significance="normal"><primary>for comprehensions</primary><secondary>yielding successive blocks of dynamically formatted
          XML</secondary></indexterm></para><para id="para_the_write_method_of_atomfee">The <literal moreinfo="none">write</literal>
      method of <literal moreinfo="none">AtomFeed</literal> demonstrates the use of the
      <literal moreinfo="none">saveFull</literal> method, provided by the
      <literal moreinfo="none">scala.xml</literal> library. <literal moreinfo="none">saveFull</literal> writes
      an XML document to disk, optionally in different encoding schemes and
      with different document type declarations. Alternately, the
      <literal moreinfo="none">save</literal> method within the same package will make use of
      any <literal moreinfo="none">java.io.Writer</literal> variant, should you need
      buffering, piping, etc.</para><para id="para_writing_xml_with_scala_is_stra">Writing XML with Scala is
      straightforward: construct the document you need with inline XML, use
      interpolation where dynamic content is to be substituted, and make use
      of the handy convenience methods to write your completed documents to
      disk or to other output streams.<indexterm class="endofrange" startref="ch10_blogsys" significance="normal"/><indexterm class="endofrange" startref="ch10_XMLwritingexample" significance="normal"/></para></sect2></sect1><sect1 id="_recap_and_what_s_next_2"><title>Recap and What’s Next</title><para id="para_xml_is_ubiquitous_in_software_">XML has become ubiquitous
    in software applications, yet few languages make working with XML a simple
    task. We learned how Scala accelerates XML development by making it easy
    to read and write XML.</para><para id="para_in_the_next_chapter_we_ll_lea">In the next chapter, we’ll
    learn how Scala provides rich support for creating your own
    Domain-Specific Languages (DSLs).<indexterm class="endofrange" startref="ch10_XML" significance="normal"/></para></sect1></chapter><chapter id="DomainSpecificLanguages"><title>Domain-Specific Languages in Scala</title><para id="para_dsl_defn">A <emphasis>Domain-Specific Language</emphasis> is
  a programming language that mimics the terms, idioms, and expressions used
  among experts in the targeted domain. Code written in a DSL reads like
  structured prose for the domain. Ideally, a domain expert with little
  experience in programming can read, understand, and validate this code.
  Sometimes, a domain expert might be able to write DSL code, even if he isn’t
  a professional programmer.<indexterm class="startofrange" id="ch11_DSLs" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary></indexterm></para><para id="para_dsls_are_a_large_topic_we_ll_">DSLs are a large topic. We’ll
  only touch the surface of DSLs and Scala’s impressive support for them. For
  more information on DSLs in general, see <link linkend="Fowler2009" xrefstyle="select:nopage">[Fowler2009]</link>, <link linkend="Ford2009" xrefstyle="select:nopage">[Ford2009]</link>, and <link linkend="Deursen" xrefstyle="select:nopage">[Deursen]</link>. The basic build tool we used for
  the book’s examples, <literal moreinfo="none">sake</literal>, uses a DSL similar to the
  venerable <literal moreinfo="none">make</literal> and its Ruby cousin
  <literal moreinfo="none">rake</literal>. (See the <phrase role="keep-together">README</phrase> in the <ulink role="orm:hideurl" url="http://examples.oreilly.com/9780596155964/">code download
  archive</ulink> for details.) For other examples of Scala “internal” and
  “external” DSLs, see <link linkend="Ghosh2008a" xrefstyle="select:nopage">[Ghosh2008a]</link> and <link linkend="Ghosh2008b" xrefstyle="select:nopage">[Ghosh2008b]</link>. For some advanced work on
  DSLs using Scala, <link linkend="Hofer2008" xrefstyle="select:nopage">[Hofer2008]</link> explores polymorphic
  substitution of alternative implementations for DSL abstractions, which is
  useful for analysis, optimization, composition, etc.</para><para id="para_well_crafted_dsls_offer_severa">Well-crafted DSLs offer
  several benefits:<indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>benefits and drawbacks of</secondary></indexterm></para><variablelist id="para_dsl_benefits_"><varlistentry id="varlistentry-encapsulation"><term>Encapsulation</term><listitem><para>A DSL hides implementation details and exposes only those
        abstractions relevant to the domain.</para></listitem></varlistentry><varlistentry id="varlistentry-efficiency"><term>Efficiency</term><listitem><para>Because implementation details are encapsulated, a DSL optimizes
        the effort required to write or modify code for application
        features.</para></listitem></varlistentry><varlistentry id="varlistentry-communication"><term>Communication</term><listitem><para>A DSL helps developers understand the domain and domain experts
        to verify that the implementation meets the requirements.</para></listitem></varlistentry><varlistentry id="varlistentry-quality"><term>Quality</term><listitem><para>A DSL minimizes the “impedance mismatch” between feature
        requirements, as expressed by domain experts, and the implementing
        source code, thereby minimizing potential bugs.</para></listitem></varlistentry></variablelist><para id="para_however_dsls_also_have_severa">However, DSLs also have
  several drawbacks:</para><variablelist id="para_dsl_drawbacks"><varlistentry id="varlistentry-difficulties-of-creating-good-dsls"><term>Difficulties of creating good DSLs</term><listitem><para>Good DSLs are harder to design than traditional APIs. The latter
        tend to follow language idioms for API design, where uniformity is
        important. Even then, elegant, effective, and easy-to-use APIs are
        difficult to design. In contrast, each DSL should reflect the unique
        language idioms of its domain. The DSL designer has much greater
        latitude, which also means it is much harder to determine the “best”
        design choices.</para></listitem></varlistentry><varlistentry id="varlistentry-long-term-maintenance"><term>Long-term maintenance</term><listitem><para>DSLs can require more maintenance over the long term to factor
        in domain changes. Also, new developers will require more time to
        learn how to use and maintain a DSL.</para></listitem></varlistentry></variablelist><para id="para_when_a_dsl_is_appropriate_for_">However, when a DSL is
  appropriate for an application—e.g., when it would be used frequently to
  implement and change functionality—a well-designed DSL can be a powerful
  tool for building flexible and robust applications.</para><para id="para_dsl_two_kinds">From the implementation point of view, DSLs
  are often classified as <emphasis>internal</emphasis> and <emphasis role="keep-together">external</emphasis>.</para><para id="para_an__internal__dsl_is_an_idioma">An
  <emphasis>internal</emphasis> (sometimes called
  <emphasis>embedded</emphasis>) DSL is an idiomatic way of writing code in a
  general-purpose programming language, like Scala. No special-purpose parser
  is necessary for internal DSLs. Instead, they are parsed just like any other
  code written in the language. In contrast, an <emphasis>external</emphasis>
  DSL is a custom language with its own custom grammar and parser.<indexterm significance="normal"><primary>external DSLs</primary></indexterm><indexterm significance="normal"><primary>internal DSLs</primary></indexterm></para><para id="para_internal_dsls_are_easier_to_cr">Internal DSLs are easier to
  create because they don’t require a special-purpose parser. On the other
  hand, the constraints of the underlying language limit the options for
  expressing domain concepts. External DSLs remove this constraint. You can
  design the language any way you want, as long as you can write a reliable
  parser for it. The downside of external DSLs is the requirement to write and
  use a custom parser.</para><para id="para_dsls_have_been_around_a_long_time">DSLs have been around a
  long time. For example, internal DSLs written in Lisp are as old as Lisp
  itself. Interest in DSLs has surged recently, driven in part by the Ruby
  community, because they are very easy to implement in Ruby. As we’ll see,
  Scala provides excellent support for the creation of internal and external
  DSLs.</para><sect1 id="InternalDSLs"><title>Internal DSLs</title><para id="para_create_internal_dsl">Let’s create an internal DSL for a
    payroll application that computes an employee’s paycheck every pay period,
    which will be two weeks long. The paycheck will include the employee’s
    <emphasis>net</emphasis> salary, which is the <emphasis>gross</emphasis>
    salary minus the <emphasis>deductions</emphasis> for taxes, insurance
    premiums (at least in some countries), retirement fund contributions,
    etc.<indexterm class="startofrange" id="ch11_DSLinternal" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal DSL for payroll application (example)</secondary></indexterm></para><para id="para_assuming_we_have_a_conventiona">To better understand the
    contrasts between code that makes use of DSLs and code that does not,
    let’s try both techniques on the same problem. Here’s how the paycheck
    might be calculated for two employees, without the help of a
    DSL:<indexterm class="startofrange" id="ch11_DSLinternalpayrollAPI" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal DSL for payroll application (example)</secondary><tertiary>payroll API</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/api/payroll-api-script.scala</code>

<code role="preproc">import</code> payroll.api._
<code role="preproc">import</code> payroll.api.DeductionsCalculator._
<code role="preproc">import</code> payroll._
<code role="preproc">import</code> payroll.Type2Money._

<code role="statement">val</code> buck = <code role="special">Employee</code>(<code role="special">Name</code>(<code role="constant">"Buck"</code>, <code role="constant">"Trends"</code>), <code role="special">Money</code>(<code role="constant">80000</code>))
<code role="statement">val</code> jane = <code role="special">Employee</code>(<code role="special">Name</code>(<code role="constant">"Jane"</code>, <code role="constant">"Doe"</code>), <code role="special">Money</code>(<code role="constant">90000</code>))

<code role="special">List</code>(buck, jane).foreach { employee <code role="statement">=&gt;</code>
  <code role="comment">// Assume annual is based on 52 weeks.</code>
  <code role="statement">val</code> biweeklyGross = employee.annualGrossSalary / <code role="constant">26.</code>

  <code role="statement">val</code> deductions = federalIncomeTax(employee, biweeklyGross) +
          stateIncomeTax(employee, biweeklyGross) +
          insurancePremiums(employee, biweeklyGross) +
          retirementFundContributions(employee, biweeklyGross)

  <code role="statement">val</code> check = <code role="special">Paycheck</code>(biweeklyGross, biweeklyGross - deductions, deductions)

  format(<code role="constant">"%s %s: %s</code><code role="special">\n</code><code role="constant">"</code>, employee.name.first, employee.name.last, check)
}
</programlisting><para id="para_the_script_iterates_through_th">For each employee, the
    script calculates the gross pay for the pay period, the deductions, and
    the resulting net. These values are placed into a
    <literal moreinfo="none">Paycheck</literal>, which is printed out. Before we describe the
    types we are using, notice a few things about the
    <literal moreinfo="none">foreach</literal> loop that does the work.</para><para id="para_first_it_is_noisy_for_exampl">First, it is noisy. For
    example, it mentions <literal moreinfo="none">employee</literal> and
    <literal moreinfo="none">biweeklyGross</literal> incessantly. A DSL will help us minimize
    that “noise” and focus on what’s really going on.</para><para id="para_second_notice_that_the_code_i">Second, notice that the code
    is imperative. It says “divide this, add that,” and so forth. We’ll see
    that our DSLs look similar, but they are more declarative, hiding the work
    from the user.</para><para id="para_here_is_the_simple_paycheck_">Here is the simple
    <literal moreinfo="none">Paycheck</literal> class used in the script:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/paycheck.scala</code>

<code role="preproc">package</code> payroll

<code role="comment">/** We're ignoring invalid (?) cases like a negative net</code>
<code role="comment"> *  when deductions exceed the gross.</code>
<code role="comment"> */</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Paycheck</code>(gross:<code role="type"> Money</code>, net:<code role="type"> Money</code>, deductions:<code role="type"> Money</code>) {

  <code role="statement">def</code> <code role="identifier">plusGross</code> (m:<code role="type"> Money</code>)      = <code role="special">Paycheck</code>(gross + m, net + m, deductions)
  <code role="statement">def</code> <code role="identifier">plusDeductions</code> (m:<code role="type"> Money</code>) = <code role="special">Paycheck</code>(gross,     net - m, deductions + m)
}
</programlisting><para id="para_an_employee_type_is_used_wh">The
    <literal moreinfo="none">Employee</literal> type uses a <literal moreinfo="none">Name</literal>
    type:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/employee.scala</code>

<code role="preproc">package</code> payroll

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Name</code>(first:<code role="type"> String</code>, last:<code role="type"> String</code>)

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Employee</code>(name:<code role="type"> Name</code>, annualGrossSalary:<code role="type"> Money</code>)
</programlisting><para id="para_the_money_type_handles_arith">The <literal moreinfo="none">Money</literal>
    type handles arithmetic, rounding to four decimal places, etc. It ignores
    currency, except for the <literal moreinfo="none">toString</literal> method. Proper
    financial arithmetic is notoriously difficult to do correctly for
    real-world transactions. This implementation is not perfectly accurate,
    but it’s close enough for our purposes. <link linkend="MoneyInJava" xrefstyle="select:nopage">[MoneyInJava]</link> provides useful information
    on doing real money calculations:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/money.scala</code>

<code role="preproc">package</code> payroll
<code role="preproc">import</code> java.math.{BigDecimal =&gt; JBigDecimal,
    MathContext =&gt; JMathContext, RoundingMode =&gt; JRoundingMode}

<code role="comment">/** Most arithmetic is done using JBigDecimals for tighter control.</code>
<code role="comment"> */</code>
<code role="statement">class</code> <code role="special">Money</code>(<code role="statement">val</code> amount:<code role="type"> BigDecimal</code>) {

  <code role="statement">def</code> <code role="identifier">+</code> (m:<code role="type"> Money</code>)  =
      <code role="special">Money</code>(amount.bigDecimal.add(m.amount.bigDecimal))
  <code role="statement">def</code> <code role="identifier">-</code> (m:<code role="type"> Money</code>)  =
      <code role="special">Money</code>(amount.bigDecimal.subtract(m.amount.bigDecimal))
  <code role="statement">def</code> <code role="identifier">*</code> (m:<code role="type"> Money</code>)  =
      <code role="special">Money</code>(amount.bigDecimal.multiply(m.amount.bigDecimal))
  <code role="statement">def</code> <code role="identifier">/</code> (m:<code role="type"> Money</code>)  =
      <code role="special">Money</code>(amount.bigDecimal.divide(m.amount.bigDecimal,
          Money.scale, Money.jroundingMode))

  <code role="statement">def</code> <code role="identifier">&lt;</code>  (m:<code role="type"> Money</code>)  = amount &lt;  m.amount
  <code role="statement">def</code> <code role="identifier">&lt;</code>= (m:<code role="type"> Money</code>)  = amount &lt;= m.amount
  <code role="statement">def</code> <code role="identifier">&gt;</code>  (m:<code role="type"> Money</code>)  = amount &gt;  m.amount
  <code role="statement">def</code> <code role="identifier">&gt;</code>= (m:<code role="type"> Money</code>)  = amount &gt;= m.amount

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">equals</code> (o:<code role="type"> Any</code>) = o <code role="statement">match</code> {
    <code role="statement">case</code> m:<code role="type"> Money =&gt; amount</code> equals m.amount
    <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> <code role="constant">false</code>
  }

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">hashCode</code> = amount.hashCode * <code role="constant">31</code>

  <code role="comment">// Hack: Must explicitly call the correct conversion: double2Double</code>
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> =
      String.format(<code role="constant">"$%.2f"</code>, double2Double(amount.doubleValue))
}

<code role="statement">object</code> <code role="special">Money</code> {
  <code role="statement">def</code> <code role="identifier">apply</code>(amount:<code role="type"> BigDecimal</code>)  = <code role="statement">new</code> <code role="special">Money</code>(amount)
  <code role="statement">def</code> <code role="identifier">apply</code>(amount:<code role="type"> JBigDecimal</code>) = <code role="statement">new</code> <code role="special">Money</code>(scaled(<code role="statement">new</code> <code role="special">BigDecimal</code>(amount)))
  <code role="statement">def</code> <code role="identifier">apply</code>(amount:<code role="type"> Double</code>)      = <code role="statement">new</code> <code role="special">Money</code>(scaled(<code role="special">BigDecimal</code>(amount)))
  <code role="statement">def</code> <code role="identifier">apply</code>(amount:<code role="type"> Long</code>)        = <code role="statement">new</code> <code role="special">Money</code>(scaled(<code role="special">BigDecimal</code>(amount)))
  <code role="statement">def</code> <code role="identifier">apply</code>(amount:<code role="type"> Int</code>)         = <code role="statement">new</code> <code role="special">Money</code>(scaled(<code role="special">BigDecimal</code>(amount)))

  <code role="statement">def</code> <code role="identifier">unapply</code>(m:<code role="type"> Money</code>) = <code role="special">Some</code>(m.amount)

  <code role="statement">protected</code> <code role="statement">def</code> <code role="identifier">scaled</code>(d:<code role="type"> BigDecimal</code>) = d.setScale(scale, roundingMode)

  <code role="statement">val</code> scale = <code role="constant">4</code>
  <code role="statement">val</code> jroundingMode = JRoundingMode.<code role="special">HALF_UP</code>
  <code role="statement">val</code> roundingMode  = BigDecimal.RoundingMode.<code role="special">ROUND_HALF_UP</code>
  <code role="statement">val</code> context = <code role="statement">new</code> <code role="special">JMathContext</code>(scale, jroundingMode)
}

<code role="statement">object</code> <code role="special">Type2Money</code> {
  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">bigDecimal2Money</code>(b:<code role="type"> BigDecimal</code>)   = <code role="special">Money</code>(b)
  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">jBigDecimal2Money</code>(b:<code role="type"> JBigDecimal</code>) = <code role="special">Money</code>(b)
  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">double2Money</code>(d:<code role="type"> Double</code>)           = <code role="special">Money</code>(d)
  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">long2Money</code>(l:<code role="type"> Long</code>)               = <code role="special">Money</code>(l)
  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">int2Money</code>(i:<code role="type"> Int</code>)                 = <code role="special">Money</code>(i)
}
</programlisting><para id="para_note_that_it_uses_scala_bigde">Note that we use
    <literal moreinfo="none">scala.BigDecimal</literal>, which wraps
    <literal moreinfo="none">java.math.BigDecimal</literal>, as the storage type for financial
    figures.<indexterm significance="normal"><primary>BigDecimal class</primary></indexterm></para><para id="para_the_deductions_are_calculated_">Deductions are calculated
    using four helper methods in
    <literal moreinfo="none">payroll.api.DeductionsCal⁠cu⁠lator</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/api/deductions-calc.scala</code>

<code role="preproc">package</code> payroll.api
<code role="preproc">import</code> payroll.Type2Money._

<code role="statement">object</code> <code role="special">DeductionsCalculator</code> {
  <code role="statement">def</code> <code role="identifier">federalIncomeTax</code>(empl:<code role="type"> Employee</code>, gross:<code role="type"> Money</code>) = gross * <code role="constant">.25</code>

  <code role="statement">def</code> <code role="identifier">stateIncomeTax</code>(empl:<code role="type"> Employee</code>, gross:<code role="type"> Money</code>) = gross * <code role="constant">.05</code>

  <code role="statement">def</code> <code role="identifier">insurancePremiums</code>(empl:<code role="type"> Employee</code>, gross:<code role="type"> Money</code>) = <code role="special">Money</code>(<code role="constant">500</code>)

  <code role="statement">def</code> <code role="identifier">retirementFundContributions</code>(empl:<code role="type"> Employee</code>, gross:<code role="type"> Money</code>) = gross * <code role="constant">.10</code>
}
</programlisting><para id="para_each_method_might_use_the_empl">Each method might use the
    employee information and the gross salary for the pay period. In this
    case, we use very simple algorithms based on just the gross salary, except
    for insurance premiums, which we treat as a fixed value.</para><para id="para_running_payroll_api_script_">Running the script for the
    payroll API produces the following output:</para><screen format="linespecific">(665) $ scala -cp ... payroll-api-script.scala
Buck Trends: Paycheck($3076.92,$1346.15,$1730.77)
Jane Doe: Paycheck($3461.54,$1576.92,$1884.62)</screen><sect2 id="APayrollInternalDSL"><title>A Payroll Internal DSL</title><para id="para_this_code_works_well_enough_b">The previous code works
      well enough, but suppose we wanted to show it to the Accounting
      Department to confirm that we’re calculating paychecks correctly. Most
      likely, they would get lost in the Scala idioms. Suppose further that we
      need the ability to customize this algorithm frequently—for example,
      because it needs to be customized for different employee types
      (salaried, hourly, etc.), or to modify the deduction calculations.
      Ideally, we would like to enable the accountants to do these
      customizations themselves, without our help.<indexterm significance="normal"><primary>payroll internal DSL (example)</primary></indexterm><indexterm class="endofrange" startref="ch11_DSLinternalpayrollAPI" significance="normal"/><indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal DSL for payroll application
          (example)</secondary><tertiary>payroll internal DSL</tertiary></indexterm></para><para id="para_we_might_achieve_these_goals_i">We might achieve these
      goals if we can express the logic in a DSL that is sufficiently
      intuitive to an accountant. Can we morph our API example into such a
      DSL?</para><para id="para_look_again_at_payroll_api_sc">Returning to the script for
      the payroll API, what if we hide most of the explicit references to
      context information, like the employee, gross salary, and deduction
      values? Consider the following text:</para><screen format="linespecific">Rules to calculate an employee's paycheck:
  employee's gross salary for 2 weeks
  minus deductions for
    federalIncomeTax, which     is  25%  of gross
    stateIncomeTax, which       is  5%   of gross
    insurancePremiums, which    are 500. in gross's currency
    retirementFundContributions are 10%  of gross</screen><para id="para_this_reads_mostly_like_normal_">This reads like normal
      English, not code. We have included some “bubble” words (see <link linkend="Ford2009" xrefstyle="select:nopage">[Ford2009]</link>) that aid
      readability but don’t necessarily correspond to anything essential, such
      as <literal moreinfo="none">to</literal>, <literal moreinfo="none">an</literal>, <literal moreinfo="none">is</literal>,
      <literal moreinfo="none">for</literal>, <literal moreinfo="none">of</literal>, and
      <literal moreinfo="none">which</literal>. We’ll eliminate some of these unnecessary
      words and keep others in our Scala DSL.</para><para id="para_compared_to_the_version_in_p">Compared to the version in
      the payroll API script, there’s a lot less clutter obscuring the
      essentials of the algorithm. This is because we have minimized explicit
      references to the contextual information. We only mention
      <literal moreinfo="none">employee</literal> twice. We mention <literal moreinfo="none">gross</literal>
      five times, but hopefully in “intuitive” ways.</para><para id="para_there_are_many_possible_intern">There are many possible
      internal Scala DSLs we could construct that resemble this ad hoc DSL.
      Here is one of them, again in a script, which produces the same output
      as before:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/dsl/payroll-dsl-script.scala</code>

<code role="preproc">import</code> payroll._
<code role="preproc">import</code> payroll.dsl._
<code role="preproc">import</code> payroll.dsl.rules_

<code role="statement">val</code> payrollCalculator = rules { employee <code role="statement">=&gt;</code>
  employee salary_for <code role="constant">2.</code>weeks minus_deductions_for { gross <code role="statement">=&gt;</code>
    federalIncomeTax            is  (<code role="constant">25.</code>  percent_of gross)
    stateIncomeTax              is  (<code role="constant">5.</code>   percent_of gross)
    insurancePremiums           are (<code role="constant">500.</code> in gross.currency)
    retirementFundContributions are (<code role="constant">10.</code>  percent_of gross)
  }
}

<code role="statement">val</code> buck = <code role="special">Employee</code>(<code role="special">Name</code>(<code role="constant">"Buck"</code>, <code role="constant">"Trends"</code>), <code role="special">Money</code>(<code role="constant">80000</code>))
<code role="statement">val</code> jane = <code role="special">Employee</code>(<code role="special">Name</code>(<code role="constant">"Jane"</code>, <code role="constant">"Doe"</code>), <code role="special">Money</code>(<code role="constant">90000</code>))

<code role="special">List</code>(buck, jane).foreach { employee <code role="statement">=&gt;</code>
  <code role="statement">val</code> check = payrollCalculator(employee)
  format(<code role="constant">"%s %s: %s</code><code role="special">\n</code><code role="constant">"</code>, employee.name.first, employee.name.last, check)
}
</programlisting><para id="para_we_ll_go_through_the_implement">We’ll go through the
      implementation step by step, but first, let’s summarize the features of
      Scala that allow us to implement this DSL.</para></sect2><sect2 id="InternalDSLs-InfixOperatorNotation"><title>Infix Operator Notation</title><para id="para_definition_of_payrollCalculator">Consider this line in
      the definition of <literal moreinfo="none">payrollCalculator</literal>:<indexterm significance="normal"><primary>operator notation</primary><secondary>infix operator notation</secondary></indexterm><indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal DSL for payroll application
          (example)</secondary><tertiary>infix operator notation</tertiary></indexterm><indexterm significance="normal"><primary>. (dot)</primary><secondary>infix operator notation</secondary></indexterm><indexterm significance="normal"><primary>infix operator notation</primary></indexterm></para><programlisting language="scala" format="linespecific">employee salary_for <code role="constant">2.</code>weeks minus_deductions_for { gross <code role="statement">=&gt;</code>
</programlisting><para id="para_this_infix_notation_is_equival">This infix notation is
      equivalent to the following less-readable form:</para><programlisting language="scala" format="linespecific">employee.salary_for(<code role="constant">2.</code>weeks).minus_deductions_for { gross <code role="statement">=&gt;</code>
</programlisting><para id="para_you_can_see_why_we_wrote_2_we">You can see why we wrote
      <literal moreinfo="none">2.weeks</literal> earlier, because the result of this
      expression is passed to <literal moreinfo="none">salary_for</literal>. Without the
      period, the infix expression would be parsed as
      <literal moreinfo="none">employee.salary_for(2).weeks...</literal>. There is no
      <literal moreinfo="none">weeks</literal> method on <literal moreinfo="none">Int</literal>, of course.
      We’ll revisit this expression in a moment.</para><para id="para_method_chaining_like_this_is_o">Method chaining like this
      is often implemented where each method returns <literal moreinfo="none">this</literal>
      so you can continue calling methods on the same instance. Note that
      returning <literal moreinfo="none">this</literal> allows those method calls to occur in
      any order. If you need to impose a specific ordering, then return an
      instance of a different type. For example, if
      <literal moreinfo="none">minus_deductions_for</literal> must be called after
      <literal moreinfo="none">salary_for</literal>, then <literal moreinfo="none">salary_for</literal> should
      return a new instance.<indexterm significance="normal"><primary>method chaining</primary></indexterm></para><para id="para_because_chaining_is_so_easy_w">Because chaining is so
      easy, we could have created separate methods for
      <literal moreinfo="none">salary</literal>, <literal moreinfo="none">for</literal>,
      <literal moreinfo="none">minus</literal>, and <literal moreinfo="none">deductions</literal>, allowing us
      to write the following expression:</para><programlisting language="scala" format="linespecific">employee salary <code role="statement">for</code> <code role="constant">2.</code>weeks minus deductions <code role="statement">for</code> { gross <code role="statement">=&gt;</code>
</programlisting><para id="para_note_that_calls_to_for_are_p">Note that calls to
      <literal moreinfo="none">for</literal> are preceded by different calls with very
      different meanings. So, if the same instance is used throughout, it
      would have to track the “flow” internally. Chaining different instances
      would eliminate this problem. However, since no computations are
      actually needed between these words, we chose the simpler design where
      words are joined together, separated by <literal moreinfo="none">_</literal>.</para></sect2><sect2 id="InternalDSLs-ImplicitConversions-UserDefinedTypes"><title>Implicit Conversions and User-Defined Types</title><para id="para_int_doesnt_have_weeks_method">Returning to
      <literal moreinfo="none">2.weeks</literal>, since <literal moreinfo="none">Int</literal> doesn’t have a
      <literal moreinfo="none">weeks</literal> method, we use an implicit conversion to a
      <literal moreinfo="none">Duration</literal> instance that wraps an
      <literal moreinfo="none">Int</literal> specifying an amount:<indexterm significance="normal"><primary>implicit conversions</primary><secondary>in internal DSL payroll implementation</secondary></indexterm><indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal DSL for payroll application
          (example)</secondary><tertiary>implicit conversions and user-defined types</tertiary></indexterm></para><?dbfo-need height=”1in”
?><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/dsl/duration.scala</code>

<code role="preproc">package</code> payroll.dsl

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Duration</code>(<code role="statement">val</code> amount:<code role="type"> Int</code>) {
  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> the number of work days in "amount" weeks. */</code>
  <code role="statement">def</code> <code role="identifier">weeks</code> = amount * <code role="constant">5</code>

  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> the number of work days in "amount" years. */</code>
  <code role="statement">def</code> <code role="identifier">years</code> = amount * <code role="constant">260</code>
}
</programlisting><para id="para_the_weeks_method_multiples_t">The
      <literal moreinfo="none">weeks</literal> method multiples that amount by 5 to return the
      corresponding amount of work days. Hence, we designed the payroll
      calculator to work with days as the unit of time. This decision is
      completely hidden behind the DSL. Should we later add support for work
      hours, it would be easy to refactor the design to use hours
      instead.</para><para id="para__duration_is_one_of_the__ad_h"><literal moreinfo="none">Duration</literal> is
      one of the ad hoc types that we designed to encapsulate the implicit
      context, to implement helper methods for the DSL, etc. We’ll discuss the
      implicit conversion method we need in a moment.</para></sect2><sect2 id="InternalDSLs-Apply"><title>Apply Methods</title><para id="para_internal_dsl_objects_use_apply">A number of the
      implementation objects use <literal moreinfo="none">apply</literal> to invoke behavior.
      The <literal moreinfo="none">rules</literal> object encapsulates the process of building
      the rules for payroll calculation. Its <literal moreinfo="none">apply</literal> method
      takes a function literal, <literal moreinfo="none">Employee =&gt;
      Paycheck</literal>.<indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal DSL for payroll application
          (example)</secondary><tertiary>apply methods</tertiary></indexterm></para></sect2><sect2 id="_payroll_rules_dsl_implementation"><title>Payroll Rules DSL Implementation</title><para id="para_now_lets_explore_the_implement">Now let’s explore the
      implementation, starting with the <literal moreinfo="none">rules</literal> object and
      working our way down:<indexterm class="startofrange" id="ch11_DLSinternalpayrollrules" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal DSL for payroll application
          (example)</secondary><tertiary>payroll rules DSL implementation</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/dsl/payroll.scala</code>

<code role="preproc">package</code> payroll.dsl
<code role="preproc">import</code> payroll._

<code role="statement">object</code> <code role="special">rules</code> {

  <code role="statement">def</code> <code role="identifier">apply</code>(rules:<code role="type"> Employee =&gt; Paycheck</code>) = <code role="statement">new</code> <code role="special">PayrollBuilderRules</code>(rules)

  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">int2Duration</code>(i:<code role="type"> Int</code>) = <code role="special">Duration</code>(i)

  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">employee2GrossPayBuilder</code>(e:<code role="type"> Employee</code>) =
      <code role="statement">new</code> <code role="special">GrossPayBuilder</code>(e)

  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">grossPayBuilder2DeductionsBuilder</code>(b:<code role="type"> GrossPayBuilder</code>)
      = <code role="statement">new</code> <code role="special">DeductionsBuilder</code>(b)

  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">double2DeductionsBuilderDeductionHelper</code>(d:<code role="type"> Double</code>) =
      <code role="statement">new</code> <code role="special">DeductionsBuilderDeductionHelper</code>(d)
}

<code role="preproc">import</code> rules._
...
</programlisting><para id="para_the_function_literal_argument_">The function literal
      argument for <literal moreinfo="none">rules.apply</literal> is used to construct a
      <literal moreinfo="none">PayrollBuilderRules</literal> that will process the specified
      rules. It is used at the very beginning of the DSL.</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> payrollCalculator = rules { employee <code role="statement">=&gt;</code> ...
</programlisting><para id="para_the_rules_object_also_define">The
      <literal moreinfo="none">rules</literal> object also defines implicit conversions. The
      first one is used by the <literal moreinfo="none">2.weeks</literal> expression. It
      converts <literal moreinfo="none">2</literal> into a <literal moreinfo="none">Duration</literal>
      instance, which we discussed previously. The other conversions are used
      later in the DSL to enable transparent conversion of
      <literal moreinfo="none">Doubles</literal>, <literal moreinfo="none">Employees</literal>, etc. into
      wrapper instances that we will describe shortly.</para><para id="para_note_that_the_rules_object_i">Note that the
      <literal moreinfo="none">rules</literal> object is imported so these conversions are
      visible in the rest of the current file. It will also need to be
      imported in files that use the DSL.</para><para id="para_the_payrollbuilderrules_is_o">The
      <literal moreinfo="none">PayrollBuilderRules</literal> is our first wrapper instance. It
      evaluates the function literal for the whole rule set, wrapped in a
      <literal moreinfo="none">try/catch</literal> block:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/dsl/payroll.scala</code>
...
<code role="statement">class</code> <code role="special">PayrollException</code>(message:<code role="type"> String</code>, cause:<code role="type"> Throwable</code>)
    <code role="statement">extends</code> <code role="special">RuntimeException</code>(message, cause)

<code role="statement">protected</code>[dsl] <code role="statement">class</code> <code role="special">PayrollBuilderRules</code>(rules:<code role="type"> Employee =&gt; Paycheck</code>) {
  <code role="statement">def</code> <code role="identifier">apply</code>(employee:<code role="type"> Employee</code>) = {
    <code role="statement">try</code> {
      rules(employee)
    } <code role="statement">catch</code> {
      <code role="statement">case</code> th:<code role="type"> Throwable =&gt; new</code> <code role="special">PayrollException</code>(
        <code role="constant">"Failed to process payroll for employee: "</code> + employee, th)
    }
  }
}
...
</programlisting><para id="para_note_that_we_protected_access_">Note that we protect
      access to <literal moreinfo="none">PayrollBuilderRules</literal>, because we don’t want
      clients using it directly. However, we left the exception public for use
      in <literal moreinfo="none">catch</literal> clauses. (You can decide whether or not you
      like wrapping a thrown exception in a “domain-specific” exception, as
      shown.)</para><para id="para_note_that_we_have_to_pass_the_">Note that we have to pass
      the employee as a “context” instance in the function literal. We said
      that it is desirable to make the context as implicit as possible. A
      common theme in our implementation classes, like
      <literal moreinfo="none">PayrollBuilderRules</literal>, is to hold context information
      in wrapper instances and to minimize their visibility in the DSL. An
      alternative approach would be to store context in singleton objects so
      other instances can get to them. This approach raises thread safety
      issues, unfortunately.</para><para id="para_to_see_what_we_mean_concerning">To see what we mean
      concerning the context, consider the part of our script that uses the
      payroll DSL, where the deductions are specified:</para><programlisting language="scala" format="linespecific">... { gross <code role="statement">=&gt;</code>
  federalIncomeTax            is  (<code role="constant">25.</code>  percent_of gross)
  stateIncomeTax              is  (<code role="constant">5.</code>   percent_of gross)
  insurancePremiums           are (<code role="constant">500.</code> in gross.currency)
  retirementFundContributions are (<code role="constant">10.</code>  percent_of gross)
}
</programlisting><para id="para_consider_the_insurance_premium">Consider the insurance
      premiums, for which a flat <literal moreinfo="none">Money(500)</literal> is deducted.
      Why didn’t we just write <literal moreinfo="none">insurancePremiums are 500.</literal>,
      instead? It turns out we have to “sneak” the <literal moreinfo="none">gross</literal>
      instance into the expression somehow. The name <literal moreinfo="none">gross</literal>
      implies that it is a <literal moreinfo="none">Money</literal> representing the
      employee’s salary for the pay period. <emphasis>Tricksey
      DSLses!!</emphasis> It is actually another helper instance,
      <literal moreinfo="none">DeductionsBuilder</literal>, which holds the whole paycheck,
      including the gross pay, and the employee instance. The name
      <literal moreinfo="none">gross</literal> is used merely because it reads well in the
      places where it is used.</para><para id="para_this_block_is_calculating_the_">This block is calculating
      the deductions and deducting them from the gross pay to determine the
      net pay. The <literal moreinfo="none">gross</literal> instance handles this process.
      There is no “communication” between the four lines of the function
      literal. Furthermore, <literal moreinfo="none">federalIncomeTax</literal>,
      <literal moreinfo="none">insurancePremiums</literal>, etc. are objects with no
      connection to <literal moreinfo="none">DeductionsBuilder</literal> (as we’ll see
      shortly). It would be great if they could be members of
      <literal moreinfo="none">DeductionsBuilder</literal> or perhaps some other wrapper
      instance enclosing this scope. Then each line would be a method call on
      one or the other wrapper. Unfortunately, this doesn’t work. Hence, each
      line must specify the <literal moreinfo="none">gross</literal> instance to maintain
      continuity. We jump through various hoops to support the syntax, yet
      allow <literal moreinfo="none">gross</literal> to be available, as needed.</para><para id="para_so_we_contrived_the_conventio">So, we contrived the
      convention that “raw” numbers, like the insurance deduction, have to be
      qualified by the particular currency used for the gross pay. We’ll see
      how the expression <literal moreinfo="none">500. in gross.currency</literal> works in a
      moment. It is something of a hack, but it reads well and it solves our
      design problem.</para><para id="para_here_is_a_possible_alternative">Here is a possible
      alternative design that would have avoided the problem:</para><programlisting language="scala" format="linespecific">... { builder <code role="statement">=&gt;</code>
  builder federalIncomeTax            (<code role="constant">25.</code>  percent_of gross)
  builder stateIncomeTax              (<code role="constant">5.</code>   percent_of gross)
  builder insurancePremiums           <code role="constant">500.</code>
  builder retirementFundContributions (<code role="constant">10.</code>  percent_of gross)
}
</programlisting><para id="para_now_the_fact_that_a_builder_">Now the fact that a
      <literal moreinfo="none">builder</literal> is being used is more explicit, and
      <literal moreinfo="none">federalIncomeTax</literal>, <literal role="keep-together" moreinfo="none">insurancePremiums</literal>, etc. are methods on
      the builder. We opted for a more readable style, with the penalty of a
      harder implementation. You’ll sometimes hear the phrase <emphasis>fluent
      in⁠ter⁠face</emphasis> used to refer to DSLs that emphasize
      readability.<indexterm significance="normal"><primary>fluent interface</primary></indexterm></para><para id="para_here_is_grosspaybuilder_">Here is
      <literal moreinfo="none">GrossPayBuilder</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/dsl/payroll.scala</code>
...
<code role="preproc">import</code> payroll.Type2Money._

<code role="statement">protected</code>[dsl] <code role="statement">class</code> <code role="special">GrossPayBuilder</code>(<code role="statement">val</code> employee:<code role="type"> Employee</code>) {

  <code role="statement">var</code> gross:<code role="type"> Money</code> = <code role="constant">0</code>

  <code role="statement">def</code> <code role="identifier">salary_for</code>(days:<code role="type"> Int</code>) = {
    gross += dailyGrossSalary(employee.annualGrossSalary) * days
    <code role="statement">this</code>
  }

  <code role="comment">// Assume 260 working days: 52 weeks (including vacation) * 5 days/week.</code>
  <code role="statement">def</code> <code role="identifier">weeklyGrossSalary</code>(annual:<code role="type"> Money</code>) = annual / <code role="constant">52.0</code>
  <code role="statement">def</code> <code role="identifier">dailyGrossSalary</code>(annual:<code role="type"> Money</code>)  = annual / <code role="constant">260.0</code>
}
...
</programlisting><para id="para_recall_that_rules_defines_an">Recall that
      <literal moreinfo="none">rules</literal> defines an implicit conversion from
      <literal moreinfo="none">Employee</literal> to this type. It is invoked by the
      expression <literal moreinfo="none">employee salary_for</literal>, so the
      <literal moreinfo="none">GrossPayBuilder.salary_for</literal> method can be called.
      <literal moreinfo="none">GrossPayBuilder</literal> initializes the
      <literal moreinfo="none">gross</literal> and appends new values to it whenever
      <literal moreinfo="none">salary_for</literal> is called, which assumes we’re adding
      gross pay in increments of days. Finally, <literal moreinfo="none">salary_for</literal>
      returns <literal moreinfo="none">this</literal> to support chaining.</para><para id="para_deduction_calculation_is_most_">Deduction calculation is
      the most complex part. When <literal moreinfo="none">minus_deductions_for</literal> is
      used in the DSL, it triggers the implicit conversion defined in
      <literal moreinfo="none">rules</literal> from the <literal moreinfo="none">GrossPayBuilder</literal> to
      a <literal moreinfo="none">DeductionsBuilder</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/dsl/payroll.scala</code>
...
<code role="statement">protected</code>[dsl] <code role="statement">class</code> <code role="special">DeductionsBuilder</code>(gpb:<code role="type"> GrossPayBuilder</code>) {

  <code role="statement">val</code> employee = gpb.employee
  <code role="statement">var</code> paycheck:<code role="type"> Paycheck</code> = <code role="statement">new</code> <code role="special">Paycheck</code>(gpb.gross, gpb.gross, <code role="constant">0</code>)

  <code role="statement">def</code> <code role="identifier">currency</code> = <code role="statement">this</code>

  <code role="statement">def</code> <code role="identifier">minus_deductions_for</code>(deductionRules:<code role="type"> DeductionsBuilder =&gt; Unit</code>) = {
    deductionRules(<code role="statement">this</code>)
    paycheck
  }

  <code role="statement">def</code> <code role="identifier">addDeductions</code>(amount:<code role="type"> Money</code>) = paycheck = paycheck plusDeductions amount

  <code role="statement">def</code> <code role="identifier">addDeductionsPercentageOfGross</code>(percentage:<code role="type"> Double</code>) = {
    <code role="statement">val</code> amount = paycheck.gross * (percentage/<code role="constant">100.</code>)
    addDeductions(amount)
  }
}
...
</programlisting><para id="para__deductionsbuilder_saves_the_"><literal moreinfo="none">DeductionsBuilder</literal>
      saves the <literal moreinfo="none">employee</literal> from the passed-in
      <literal moreinfo="none">GrossPayBuilder</literal>, which it doesn’t save as a field. It
      also initializes the <literal moreinfo="none">paycheck</literal> using the calculated
      gross pay.</para><para id="para_note_that_the_currency_metho">Note that the
      <literal moreinfo="none">currency</literal> method simply returns
      <literal moreinfo="none">this</literal>. We don’t need to do anything with the actual
      currency when this method is invoked. Instead, it is used to support a
      design idiom that we’ll discuss shortly.</para><para id="para_the_minus_deductions_for_doe">The
      <literal moreinfo="none">minus_deductions_for</literal> does the important work. It
      invokes the function literal with the individual rules and then returns
      the completed <literal moreinfo="none">Paycheck</literal> instance, which is ultimately
      what <literal moreinfo="none">rules.apply</literal> returns.</para><para id="para_our_remaining_two_methods_are_">Our remaining two methods
      are used to calculate individual deductions. They are called from
      <literal moreinfo="none">DeductionsBuilderDeductionHelper</literal>, which we show
      now:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/dsl/payroll.scala</code>
...
<code role="statement">class</code> <code role="special">DeductionCalculator</code> {
  <code role="statement">def</code> <code role="identifier">is</code>(builder:<code role="type"> DeductionsBuilder</code>) = apply(builder)
  <code role="statement">def</code> <code role="identifier">are</code>(builder:<code role="type"> DeductionsBuilder</code>) = apply(builder)

  <code role="statement">def</code> <code role="identifier">apply</code>(builder:<code role="type"> DeductionsBuilder</code>) = {}
}

<code role="statement">object</code> <code role="special">federalIncomeTax</code> <code role="statement">extends</code> <code role="special">DeductionCalculator</code>
<code role="statement">object</code> <code role="special">stateIncomeTax</code> <code role="statement">extends</code> <code role="special">DeductionCalculator</code>
<code role="statement">object</code> <code role="special">insurancePremiums</code> <code role="statement">extends</code> <code role="special">DeductionCalculator</code>
<code role="statement">object</code> <code role="special">retirementFundContributions</code> <code role="statement">extends</code> <code role="special">DeductionCalculator</code>

<code role="statement">protected</code>[dsl] <code role="statement">class</code> <code role="special">DeductionsBuilderDeductionHelper</code>(<code role="statement">val</code> factor:<code role="type"> Double</code>) {
  <code role="statement">def</code> <code role="identifier">in</code> (builder:<code role="type"> DeductionsBuilder</code>) = {
    builder addDeductions <code role="special">Money</code>(factor)
    builder
  }
  <code role="statement">def</code> <code role="identifier">percent_of</code> (builder:<code role="type"> DeductionsBuilder</code>) = {
    builder addDeductionsPercentageOfGross factor
    builder
  }
}
</programlisting><para id="para_now_we_see_that_federalincome">Now we see that
      <literal moreinfo="none">federalIncomeTax</literal>, etc. are singleton objects. Note
      the “synonym” methods <literal moreinfo="none">is</literal> and <literal moreinfo="none">are</literal>.
      We used <literal moreinfo="none">are</literal> for the objects with plural names, like
      <literal moreinfo="none">insurancePre⁠miums</literal>, and <literal moreinfo="none">is</literal> for the
      singular objects, like <literal moreinfo="none">federalIncomeTax</literal>. In fact,
      since both methods delegate to <literal moreinfo="none">apply</literal>, they are
      effectively bubble words that the user could omit. That is, the
      following two DSL lines are equivalent:</para><programlisting language="scala" format="linespecific">federalIncomeTax is (<code role="constant">25.</code> percent_of gross)
federalIncomeTax    (<code role="constant">25.</code> percent_of gross)
</programlisting><para id="para_the_apply_method_takes_dedu">The <literal moreinfo="none">apply</literal>
      method takes <literal moreinfo="none">DeductionsBuilder</literal> and does nothing with
      it! In fact, by the time <literal moreinfo="none">apply</literal> is called, the
      deduction has already been calculated and factored into the paycheck. By
      implication, the presence of expressions like <literal moreinfo="none">federalIncomeTax
      is</literal> are effectively syntactic sugar (at least as this DSL is
      currently implemented). They are a fancy form of comments, but at least
      they have the virtue of type checking the “kinds” of deductions that are
      allowed. Of course, as the implementation evolves, these instances might
      do real work.</para><para id="para_to_see_why_deductioncalculato">To see why
      <literal moreinfo="none">DeductionCalculator.apply</literal> is empty, let’s discuss
      <literal moreinfo="none">DeductionsBuilderDe⁠duc⁠tionHelper</literal>. Recall that the
      <literal moreinfo="none">rules</literal> object has an implicit conversion method to
      convert a <literal moreinfo="none">Double</literal> to a
      <literal moreinfo="none">DeductionsBuilderDeductionHelper</literal>. Once we have a
      helper instance, we can call either the <literal moreinfo="none">in</literal> method or
      the <literal moreinfo="none">percent_of</literal> method. Every line in the deductions
      function literal exploits this instance.</para><?dbfo-need height=”1in”
?><para id="para_for_example_25_percent_of_">For example, <literal moreinfo="none">(25.
      percent_of gross)</literal> is roughly equivalent to the following
      steps:</para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>Call to
          <literal moreinfo="none">rules.double2DeductionsBuilderDeductionHelper(25.)</literal>
          to create a new
          <literal moreinfo="none">DeductionsBuilderDeductionHelper(25.)</literal></para></listitem><listitem><para>Call to the helper’s <literal moreinfo="none">percent_of(gross)</literal>
          method, where <literal moreinfo="none">gross</literal> is a
          <literal moreinfo="none">DeductionsBuilder</literal></para></listitem><listitem><para><literal moreinfo="none">gross.addDeductionsPercentageOfGross(factor)</literal></para></listitem></orderedlist><para id="para_in_other_words_we_used_deduc">In other words, we used
      <literal moreinfo="none">DeductionsBuilderDeductionHelper</literal> to convert an
      expression of the form <literal moreinfo="none">Double method
      DeductionsBuilder</literal> into an expression of the form <literal role="keep-together" moreinfo="none">DeductionsBuilder method2 Double</literal>.
      <literal moreinfo="none">DeductionsBuilder</literal> accumulates each deduction into the
      paycheck we’re building.</para><para id="para_the_expression_500_in_gross_">The expression
      <literal moreinfo="none">500. in gross.currency</literal> works almost identically.
      <literal moreinfo="none">DeductionsBuilder.currency</literal> is effectively another
      bubble word; it simply returns <literal moreinfo="none">this</literal>, but gives a
      readable idiom for the DSL. The <literal moreinfo="none">in</literal> method simply
      converts the <literal moreinfo="none">Double</literal> to a <literal moreinfo="none">Money</literal> and
      passes it to <literal moreinfo="none">DeductionsBuilder.addDeductions</literal>.</para><para id="para_so_deductioncalculator_apply_">So
      <literal moreinfo="none">DeductionCalculator.apply</literal> does nothing, because all
      the work is already done by the time <literal moreinfo="none">apply</literal> is
      called.<indexterm class="endofrange" startref="ch11_DLSinternalpayrollrules" significance="normal"/></para></sect2><sect2 id="InternalDSLsFinalThoughts"><title>Internal DSLs: Final Thoughts</title><para id="para_so_which_is_better_the_origi">So which is better, the
      original API implementation or the DSL implementation? The DSL
      implementation is complex. Like any language, testing its robustness can
      be a challenge. Users will try many combinations of expressions. They
      will probably not understand the compiler error messages that refer to
      the internals we’ve hidden behind the DSL.<indexterm significance="normal"><primary>internal DSLs</primary><seealso>DSLs</seealso></indexterm></para><para id="para_also_designing__good__dsls_is">Designing a quality DSL is
      difficult. With an API, you can follow the Scala library conventions for
      types, method names, etc. However, with a DSL, you’re trying to imitate
      the language of a new domain. It’s hard to get it right.</para><para id="para_on_the_other_hand_a_well_desi">It’s worth the effort,
      though. A well-designed DSL minimizes the translation effort between
      requirements and code, thereby improving communications with <phrase role="keep-together">stake</phrase><phrase role="keep-together">holders</phrase> about requirements. DSLs also
      facilitate rapid feature change and hide distracting implementation
      details. As always, there is a cost/benefit analysis you should make
      when deciding whether to use a DSL.</para><para id="para_assuming_you_ve_made_the_go_">Assuming you’ve made the
      “go” decision, a common problem in DSL design is the <emphasis>finishing
      problem</emphasis> (see <link linkend="Ford2009" xrefstyle="select:nopage">[Ford2009]</link>). How do you know when
      you’ve finished building up the state of an instance and it’s ready to
      use?<indexterm significance="normal"><primary>finishing problem (in DSL design)</primary></indexterm></para><para id="para_we_solved_this_problem_in_two_">We solved this problem in
      two ways. First, we nested the calculation steps in a function literal.
      As soon as <literal moreinfo="none">rules(employee)</literal> was invoked, the paycheck
      was built to completion. Also, all the steps were evaluated “eagerly.”
      We didn’t need to put in all the rules, then run them at the end. Our
      only ordering requirement was the need to calculate the gross pay first,
      since the deductions are based on it. We enforced the correct order of
      invocation using instances of different types.</para><para id="para_there_are_cases_where_you_can_">There are cases in which
      you can’t evaluate the build steps eagerly. For example, a DSL that
      builds up a SQL query string can’t run a query after each step of the
      build process. In this case, evaluation has to wait until the query
      string is completely built.</para><para id="para_in_contrast_if_your_dsl_steps">By contrast, if your DSL
      steps are stateless, chained method invocation works just fine. In this
      case, it doesn’t matter when you stop calling chained methods. If you
      chain methods that build up state, you’ll have to add some sort of
      <literal moreinfo="none">done</literal> method and trust the users to always use it at
      the end.<indexterm class="endofrange" startref="ch11_DSLinternal" significance="normal"/></para></sect2></sect1><sect1 id="ExternalDSLsWithCombinatorParsers"><title>External DSLs with Parser Combinators</title><para id="para_when_you_write_a_parser_for_an">When you write a parser for
    an external DSL, you can use a parser generator tool like Antlr (see <link linkend="Antlr" xrefstyle="select:nopage">[Antlr]</link>). However, the
    Scala library includes a powerful parser combinator library that can be
    used for parsing most external DSLs that have a context-free grammar. An
    attractive feature of this library is the way it defines an internal DSL
    that makes parser definitions look very similar to familiar grammar
    notations, like EBNF (Extended Backus-Naur Form—see <link linkend="EBNF" xrefstyle="select:nopage">[BNF]</link>).<indexterm class="startofrange" id="ch11_parsercombinators" significance="normal"><primary>parser combinators, external DSLs with</primary></indexterm><indexterm significance="normal"><primary>external DSLs</primary><seealso>DSLs</seealso></indexterm><indexterm significance="normal"><primary>context-free grammars</primary></indexterm><indexterm significance="normal"><primary>EBNF (Extended Backus-Naur Form) grammar notation</primary></indexterm><indexterm class="startofrange" id="ch11_DSLexternal" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>external DSLs with parser combinators</secondary></indexterm></para><sect2 id="_about_parser_combinators"><title>About Parser Combinators</title><para id="para_parser_combinators_are_buildin">Parser combinators are
      building blocks for parsers. Parsers that handle specific kinds of
      input—floating-point numbers, integers, etc.—can be combined together to
      form other parser combinators for larger expressions. A combinator
      framework makes it easy to combine parsers to handle sequential and
      alternative cases, repetition, optional terms, etc.<indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>external DSLs with parser combinators</secondary><tertiary>parser combinators</tertiary></indexterm></para><para id="para_other_references">We’ll learn more about parsing
      techniques and terminology as we proceed. A complete exposition of
      parsing techniques is beyond our scope, but our example should get you
      started. You can find additional examples of parsers written using
      Scala’s parser combinator library in <link linkend="Spiewak2009b" xrefstyle="select:nopage">[Spiewak2009b]</link>, <link linkend="Ghosh2008a" xrefstyle="select:nopage">[Ghosh2008a]</link>, and
      <link linkend="Odersky2008" xrefstyle="select:nopage">[Odersky2008]</link>.</para></sect2><sect2 id="APayrollExternalDSL"><title>A Payroll External DSL</title><para id="para_comb_parser_example">For our parser combinator example,
      we’ll reuse the example we just discussed for internal DSLs. We’ll
      modify the grammar slightly, since our external DSL does not have to be
      valid Scala syntax. Other changes will make parser construction easier.
      Here’s an example written in the external DSL:<indexterm class="startofrange" id="ch11_parsercombpayrollext" significance="normal"><primary>parser combinators, external DSLs with</primary><secondary>payroll external DSL</secondary></indexterm><indexterm class="startofrange" id="ch11_payrollexternalDSL" significance="normal"><primary>payroll external DSL (example)</primary></indexterm><indexterm class="startofrange" id="ch11_DSLexternalpayroll" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>external DSLs with parser combinators</secondary><tertiary>payroll external DSL</tertiary></indexterm></para><screen format="linespecific">paycheck for employee "Buck Trends" is salary for 2 weeks minus deductions for {
  federal income tax            is  25.  percent of gross,
  state income tax              is  5.   percent of gross,
  insurance premiums            are 500. in gross currency,
  retirement fund contributions are 10.  percent of gross
}</screen><para id="para_compare_this_example_of_our_ex">Compare this example to
      the internal DSL we defined in <xref linkend="APayrollInternalDSL"/>:</para><programlisting language="scala" format="linespecific">... = rules { employee <code role="statement">=&gt;</code>
  employee salary_for <code role="constant">2.</code>weeks minus_deductions_for { gross <code role="statement">=&gt;</code>
    federalIncomeTax            is  (<code role="constant">25.</code>  percent_of gross)
    stateIncomeTax              is  (<code role="constant">5.</code>   percent_of gross)
    insurancePremiums           are (<code role="constant">500.</code> in gross.currency)
    retirementFundContributions are (<code role="constant">10.</code>  percent_of gross)
  }
}
...
</programlisting><para id="para_in_our_new_dsl_we_insert_a_sp">In our new DSL, we insert
      a specific employee in the script. We wouldn’t expect a user to copy and
      paste this script for every employee. A natural extension that we won’t
      pursue would allow the user to loop over all salaried employees in a
      database, for example.</para><para id="para_other_differences_include_remo">Some of the differences
      are “gratuitous”; we could have used the same syntax we used previously.
      These changes include removing underscores between words in some
      expressions and expanding camel-case words into space-separated words.
      That is, we turned some single words into multi-word expressions. We
      made these changes because they will be easy to implement using parser
      combinators, but using the same multi-word expressions would have added
      a lot of complexity to the internal DSL’s implementation.</para><para id="para_we_no_longer_need_local_vari">We no longer need “local
      variables” like <literal moreinfo="none">employee</literal> and
      <literal moreinfo="none">gross</literal>. Those words still appear in the DSL, but our
      parser will keep track of the corresponding instances internally.</para><para id="para_the_remaining_changes_are_punc">The remaining changes are
      punctuation. It is still convenient to surround the list of deductions
      with curly braces. We now use a comma to separate the individual
      deductions, as that will make the parser’s job easier. We can also drop
      the parentheses we used earlier.<indexterm significance="normal"><primary>grammars</primary><secondary>EBNF notation for external payroll DSL
          grammar</secondary></indexterm></para><para id="para_to_see_how_closely_the__intern">To see how closely the
      internal DSL for Scala’s parser combinator library resembles the
      context-free grammar, let’s start with the grammar itself, written in a
      variation of EBNF. We’ll omit commas to separate sequences, for
      clarity:<indexterm significance="normal"><primary>EBNF (Extended Backus-Naur Form) grammar notation</primary><secondary>external payroll DSL grammar</secondary></indexterm></para><screen format="linespecific">paycheck = empl gross deduct;

empl = "paycheck" "for" "employee" employeeName;

gross = "is" "salary" "for" duration;

deduct = "minus" "deductions" "for" "{" deductItems "}";

employeeName = "\"" name " " name "\"";

name = ...

duration = decimalNumber weeksDays;

weeksDays = "week" | "weeks" | "day" | "days";

deductItems = Ɛ | deductItem { "," deductItem };

deductItem = deductKind deductAmount;

deductKind = tax | insurance | retirement;

tax = fedState "income" "tax";

fedState = "federal" | "state";

insurance = "insurance" "premiums";

retirement = "retirement" "fund" "contributions";

deductAmount = percentage | amount;

percentage = toBe doubleNumber "percent" "of" "gross";

amount = toBe doubleNumber "in" "gross" "currency";

toBe = "is" | "are";

decimalNumber = ...

doubleNumber = ...</screen><para id="para_we_ll_see_that_most_of_the_tok">We can see that most of
      the <emphasis>terminals</emphasis> (the literal strings
      <literal moreinfo="none">paycheck</literal>, <literal moreinfo="none">for</literal>,
      <literal moreinfo="none">employee</literal>, the characters <literal moreinfo="none">{</literal> and
      <literal moreinfo="none">}</literal>, etc.) will be bubble words, as defined in the
      previous section. We’ll ignore these after parsing. The Ɛ is used to
      indicate an empty production for <literal moreinfo="none">deductItems</literal>,
      although there will rarely be no deductions!<indexterm significance="normal"><primary>terminals</primary></indexterm></para><para id="para_we_didn_t_spell_out_the_detail">We didn’t spell out the
      details for decimal numbers, double numbers, and allowed letters in the
      employee names. We simply elided those definitions. We’ll handle the
      details later.</para><para id="para_each_line_in_the_grammar_defin">Each line in the grammar
      defines a <emphasis>production rule</emphasis>. The end of the
      definition is marked with a semicolon. A
      <emphasis>nonterminal</emphasis> appears on the lefthand side of the
      equals sign. The righthand side consists of terminals (e.g., the literal
      strings and characters we just mentioned) that require no further
      parsing, other nonterminals (including possibly a <phrase role="keep-together">recursive</phrase> <phrase role="keep-together">reference</phrase> to the lefthand side
      nonterminal), and operators that express relationships between the
      items. Notice that the grammar forms have a hierarchical <phrase role="keep-together">decomposition</phrase>, although not a directed
      acyclic graph, as generally speaking these <phrase role="keep-together">grammars</phrase> can have cycles.<indexterm significance="normal"><primary>; (semicolon)</primary><secondary>ending production rule definitions</secondary></indexterm><indexterm significance="normal"><primary>nonterminals</primary></indexterm><indexterm significance="normal"><primary>production rules</primary></indexterm></para><para id="para_we_have_a_context_free_grammar">We have a context-free
      grammar because every production rule has a single nonterminal on the
      lefthand side of the equals sign, i.e., without any additional context
      information required to specify the production’s applicability and
      meaning.</para><para id="para_productions_like_tobe_is_">Production rules like
      <literal moreinfo="none">toBe = "is" | "are"</literal> mean the <literal moreinfo="none">is</literal>
      production (a terminal in this case) <emphasis>or</emphasis> the
      <literal moreinfo="none">are</literal> production will match. This is an example of an
      <emphasis>alternative composition</emphasis>.<indexterm significance="normal"><primary>alternative composition</primary></indexterm></para><para id="para_when_productions_are_separated">When productions are
      separated by white space on the righthand side of another production,
      e.g., <literal moreinfo="none">prod1 prod2</literal>, both productions are required to
      appear sequentially for a match. (Most EBNF formats actually require a
      comma to separate these items.) Hence, these expressions are more like
      “and” expressions, but <emphasis>sequential composition</emphasis> is so
      common that no <literal moreinfo="none">&amp;</literal> operator is used, the analog of
      <literal moreinfo="none">|</literal> for alternative composition.<indexterm significance="normal"><primary>sequential composition</primary></indexterm></para><para id="para_the_production_deductitem">The production rule with
      <literal moreinfo="none">"{" deductItem { "," deductItem } "}"</literal> demonstrates
      how to specify optional (zero or more) repetitions. This expression
      matches a literal <literal moreinfo="none">{</literal> character, followed by a
      <literal moreinfo="none">deductItem</literal> (another production), followed by zero or
      more expressions consisting of a literal comma <literal moreinfo="none">,</literal> and
      another <literal moreinfo="none">deductItem</literal>, and finally ending with a literal
      <literal moreinfo="none">}</literal> character. Sometimes an asterisk is used to
      indicate repetition zero or more times, e.g., <literal moreinfo="none">prod *</literal>.
      For repetition at least once, <literal moreinfo="none">prod +</literal> is sometimes
      used.<indexterm significance="normal"><primary>+ (plus sign)</primary><secondary>specifying at least one repetition in production
          rule</secondary></indexterm><indexterm significance="normal"><primary>* (asterisk)</primary><secondary>zero or more repetitions in production rule</secondary></indexterm></para><para id="para_finally_if_we_had_optional_te">Finally, if we had
      optional items in our grammar, we would enclose them in square brackets,
      <literal moreinfo="none">[...]</literal>. There are other kinds of composition operators
      possible (and <phrase role="keep-together">supported</phrase> in the
      Scala library), a few of which we’ll discuss. See the <link linkend="ScalaAPI2008" role="keep-together" xrefstyle="select:nopage">[ScalaAPI2008]</link> entry for
      <literal moreinfo="none">Parsers</literal> for more details.<indexterm class="endofrange" startref="ch11_parsercombpayrollext" significance="normal"/><indexterm significance="normal"><primary>Parsers object</primary><secondary>documentation of composition operators</secondary></indexterm><indexterm significance="normal"><primary>[ ] (square brackets)</primary><secondary>enclosing optional items in parser grammar</secondary></indexterm><indexterm class="endofrange" startref="ch11_payrollexternalDSL" significance="normal"/><indexterm class="endofrange" startref="ch11_DSLexternalpayroll" significance="normal"/></para></sect2><sect2 id="AScalaImplementationExternalDSLGrammar"><title>A Scala Implementation of the External DSL Grammar</title><para id="para_here_is_the_parser_written_usi">Here is the parser
      written using Scala’s parser combinators. At this point, we won’t do
      anything to actually calculate an employee’s paycheck, so we’ll append
      <literal moreinfo="none">V1</literal> to the class name:<indexterm class="startofrange" id="ch11_parsercombScala" significance="normal"><primary>parser combinators, external DSLs with</primary><secondary>Scala implementation of external DSL grammar</secondary></indexterm><indexterm class="startofrange" id="ch11_DSLsparser" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>external DSLs with parser combinators</secondary><tertiary>Scala implementation of external DSL grammar</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb-v1.scala</code>

<code role="preproc">package</code> payroll.pcdsl
<code role="preproc">import</code> scala.util.parsing.combinator._
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> payroll._
<code role="preproc">import</code> payroll.Type2Money._

<code role="statement">class</code> <code role="special">PayrollParserCombinatorsV1</code> <code role="statement">extends</code> <code role="special">JavaTokenParsers</code> {

  <code role="statement">def</code> <code role="identifier">paycheck</code> = empl ~ gross ~ deduct

  <code role="statement">def</code> <code role="identifier">empl</code> = <code role="constant">"paycheck"</code> ~&gt; <code role="constant">"for"</code> ~&gt; <code role="constant">"employee"</code> ~&gt; employeeName

  <code role="statement">def</code> <code role="identifier">gross</code> = <code role="constant">"is"</code> ~&gt; <code role="constant">"salary"</code> ~&gt; <code role="constant">"for"</code> ~&gt; duration

  <code role="statement">def</code> <code role="identifier">deduct</code> = <code role="constant">"minus"</code> ~&gt; <code role="constant">"deductions"</code> ~&gt; <code role="constant">"for"</code> ~&gt; <code role="constant">"{"</code> ~&gt; deductItems  &lt;~ <code role="constant">"}"</code>

  <code role="comment">// stringLiteral provided by JavaTokenParsers</code>
  <code role="statement">def</code> <code role="identifier">employeeName</code> = stringLiteral

  <code role="comment">// decimalNumber provided by JavaTokenParsers</code>
  <code role="statement">def</code> <code role="identifier">duration</code> = decimalNumber ~ weeksDays

  <code role="statement">def</code> <code role="identifier">weeksDays</code> = <code role="constant">"weeks"</code> | <code role="constant">"week"</code> | <code role="constant">"days"</code> | <code role="constant">"day"</code>

  <code role="statement">def</code> <code role="identifier">deductItems</code> = repsep(deductItem, <code role="constant">","</code> )

  <code role="statement">def</code> <code role="identifier">deductItem</code> = deductKind ~&gt; deductAmount

  <code role="statement">def</code> <code role="identifier">deductKind</code> = tax | insurance | retirement

  <code role="statement">def</code> <code role="identifier">tax</code> = fedState &lt;~ <code role="constant">"income"</code> &lt;~ <code role="constant">"tax"</code>

  <code role="statement">def</code> <code role="identifier">fedState</code> = <code role="constant">"federal"</code> | <code role="constant">"state"</code>

  <code role="statement">def</code> <code role="identifier">insurance</code> = <code role="constant">"insurance"</code> ~&gt; <code role="constant">"premiums"</code>

  <code role="statement">def</code> <code role="identifier">retirement</code> = <code role="constant">"retirement"</code> ~&gt; <code role="constant">"fund"</code> ~&gt; <code role="constant">"contributions"</code>

  <code role="statement">def</code> <code role="identifier">deductAmount</code> = percentage | amount

  <code role="statement">def</code> <code role="identifier">percentage</code> = toBe ~&gt; doubleNumber &lt;~ <code role="constant">"percent"</code> &lt;~ <code role="constant">"of"</code> &lt;~ <code role="constant">"gross"</code>

  <code role="statement">def</code> <code role="identifier">amount</code> = toBe ~&gt; doubleNumber &lt;~ <code role="constant">"in"</code> &lt;~ <code role="constant">"gross"</code> &lt;~ <code role="constant">"currency"</code>

  <code role="statement">def</code> <code role="identifier">toBe</code> = <code role="constant">"is"</code> | <code role="constant">"are"</code>

  <code role="comment">// floatingPointNumber provided by JavaTokenParsers</code>
  <code role="statement">def</code> <code role="identifier">doubleNumber</code> = floatingPointNumber
}
</programlisting><para id="para_the_body_of_payrollparsercomb">The body of
      <literal moreinfo="none">PayrollParserCombinatorsV1</literal> looks very similar to the
      grammar we defined for the DSL. Each production rule becomes a method.
      The terminating semicolon is dropped, but since the production is a
      method, it would be valid Scala to leave it in.</para><para id="para_where_we_had_whitespace_betwee">Where we had whitespace
      between each production on the righthand side, we now use a combinator
      operator, either <literal moreinfo="none">∼</literal>, <literal moreinfo="none">∼&gt;</literal>, or
      <literal moreinfo="none">&lt;∼</literal>. The combinator for sequential composition is
      <literal moreinfo="none">∼</literal>, used when we want to retain for further processing
      the results produced by both productions on the left and right sides of
      the <literal moreinfo="none">∼</literal>. For example, when processing the
      <literal moreinfo="none">paycheck</literal> production, we want to keep all three
      results from <literal moreinfo="none">empl</literal>, <literal moreinfo="none">gross</literal>, and
      <literal moreinfo="none">deduct</literal>. Hence we use two <literal moreinfo="none">∼</literal>
      operators:<indexterm significance="normal"><primary>sequential composition</primary><secondary>combinator operators</secondary></indexterm><indexterm significance="normal"><primary>~ (tilde)</primary><secondary>~, ~&gt;, and &lt;~ combinator operators</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">paycheck</code> = empl ~ gross ~ deduct
</programlisting><para id="para_we_use_another_sequential_comp">We use another sequential
      composition combinator <literal moreinfo="none">∼&gt;</literal> when we no longer need
      the result of the production to the <emphasis>left</emphasis>. For
      example, when processing the <literal moreinfo="none">empl</literal> production, we only
      want to keep the parse result for the last production,
      <literal moreinfo="none">employeeName</literal>:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">empl</code> = <code role="constant">"paycheck"</code> ~&gt; <code role="constant">"for"</code> ~&gt; <code role="constant">"employee"</code> ~&gt; employeeName
</programlisting><para id="para_similarly_we_use_when_we">Similarly, we use
      <literal moreinfo="none">&lt;∼</literal> when we no longer need the result for the
      production to the <emphasis>right</emphasis>. For example, when
      processing the <literal moreinfo="none">tax</literal> production, we only want to keep
      the result of the first production, <literal moreinfo="none">fedState</literal>:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">tax</code> = fedState &lt;~ <code role="constant">"income"</code> &lt;~ <code role="constant">"tax"</code>
</programlisting><para id="para_our_heavy_use_of_sequenti">Our heavy use of the
      <literal moreinfo="none">&lt;∼</literal> sequential combinator in the various
      productions related to deductions indicates that we aren’t keeping track
      of the source of each deduction, just the amount of the deduction. A
      real paycheck application would print this information, of course. Our
      aim is for simplicity. As an exercise, consider how
      <literal moreinfo="none">PayrollParserCombi⁠natorsV1</literal> and the subsequent
      refinements below would change if we tracked this information. Would you
      necessarily keep the parsed strings or track the information some other
      way?</para><para id="para_the_or_case_is_expressed_w">The “or” case is expressed
      with the <literal moreinfo="none">|</literal> method, just as in the grammar:<indexterm significance="normal"><primary>| (vertical bar)</primary><secondary>or case in parser grammar</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">weeksDays</code> = <code role="constant">"weeks"</code> | <code role="constant">"week"</code> | <code role="constant">"days"</code> | <code role="constant">"day"</code>
</programlisting><para id="para_the_rep_method_can_be_used_f">The <literal moreinfo="none">rep</literal>
      method can be used for zero or more repetitions. We actually use a
      similar method, <literal moreinfo="none">repsep</literal>, which lets us specify a
      separator, in our case a comma (<literal moreinfo="none">,</literal>):</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">deduct</code> = ... ~&gt; <code role="constant">"{"</code> ~&gt; repsep(deductItem, <code role="constant">","</code> ) &lt;~ <code role="constant">"}"</code>
</programlisting><para id="para_note_that_deduct_combines_se">Note that
      <literal moreinfo="none">deduct</literal> combines several features we have just
      described.</para><para id="para_like_repetition_there_is_an_">Like repetition, there is
      an <literal moreinfo="none">opt</literal> method for optional terms, which we aren’t
      using.</para><para id="para__payrollparsercombinatorsv1_i"><literal moreinfo="none">PayrollParserCombinatorsV1</literal>
      inherits from <literal moreinfo="none">JavaTokenParsers</literal>, which inherits from
      <literal moreinfo="none">RegexParsers</literal>, which inherits from the root parser
      trait <literal moreinfo="none">Parsers</literal>. It’s well known that parsing
      non-trivial grammars with just regular expressions tends to break down
      pretty quickly. However, using regular expressions to parse individual
      terms inside a parsing framework can be very effective. In our example,
      we exploit the productions in <literal role="keep-together" moreinfo="none">JavaTokenParsers</literal> to parse quoted strings
      (for the employee’s name), decimal literals, and floating-point
      literals.<indexterm significance="normal"><primary>Parsers object</primary></indexterm><indexterm significance="normal"><primary>JavaTokenParsers</primary></indexterm><indexterm significance="normal"><primary>regular expressions</primary><secondary>use in parsing</secondary></indexterm></para><para id="para_let_s_try_it_out_here_is_a_sp">Let’s try it out! Here is
      a specification that exercises the parser for two cases, without and
      with deductions:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb-v1-spec.scala</code>

<code role="preproc">package</code> payroll.pcdsl
<code role="preproc">import</code> scala.util.parsing.combinator._
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> payroll._
<code role="preproc">import</code> payroll.Type2Money._

<code role="statement">object</code> <code role="special">PayrollParserCombinatorsV1Spec</code>
  <code role="statement">extends</code> <code role="special">Specification</code>(<code role="constant">"PayrollParserCombinatorsV1"</code>) {

  <code role="constant">"PayrollParserCombinatorsV1"</code> should {
    <code role="constant">"parse rules when there are no deductions"</code> in {
      <code role="statement">val</code> input = <code role="constant">"""paycheck for employee "Buck Trends"</code>
<code role="constant">                     is salary for 2 weeks minus deductions for {}"""</code>
      <code role="statement">val</code> p = <code role="statement">new</code> <code role="special">PayrollParserCombinatorsV1</code>
      p.parseAll(p.paycheck, input) <code role="statement">match</code> {
        <code role="statement">case</code> p.<code role="special">Success</code>(r,<code role="statement">_</code>) <code role="statement">=&gt;</code> r.toString mustEqual
                    <code role="constant">"""(("Buck Trends"~(2~weeks))~List())"""</code>
        <code role="statement">case</code> x <code role="statement">=&gt;</code> fail(x.toString)
      }
    }

    <code role="constant">"calculate the gross, net, and deductions for the pay period"</code> in {
      <code role="statement">val</code> input =
          <code role="constant">"""paycheck for employee "Buck Trends"</code>
<code role="constant">             is salary for 2 weeks minus deductions for {</code>
<code role="constant">               federal income tax            is  25.  percent of gross,</code>
<code role="constant">               state income tax              is  5.   percent of gross,</code>
<code role="constant">               insurance premiums            are 500. in gross currency,</code>
<code role="constant">               retirement fund contributions are 10.  percent of gross</code>
<code role="constant">             }"""</code>
      <code role="statement">val</code> p = <code role="statement">new</code> <code role="special">PayrollParserCombinatorsV1</code>
      p.parseAll(p.paycheck, input) <code role="statement">match</code> {
        <code role="statement">case</code> p.<code role="special">Success</code>(r,<code role="statement">_</code>) <code role="statement">=&gt;</code> r.toString mustEqual
            <code role="constant">"""(("Buck Trends"~(2~weeks))~List(25., 5., 500., 10.))"""</code>
        <code role="statement">case</code> x <code role="statement">=&gt;</code> fail(x.toString)
      }
    }
  }
}
</programlisting><para id="para_this_part_of_the_specification">This part of the
      specification shows us how to instantiate and use the parser:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> p = <code role="statement">new</code> <code role="special">PayrollParserCombinatorsV1</code>

p.parseAll(p.paycheck, input) <code role="statement">match</code> {
  <code role="statement">case</code> p.<code role="special">Success</code>(r,<code role="statement">_</code>) <code role="statement">=&gt;</code> r.toString mustEqual <code role="constant">"..."</code>
  <code role="statement">case</code> x <code role="statement">=&gt;</code> fail(x.toString)
}
</programlisting><para id="para_the_parseall_method_is_defin">The
      <literal moreinfo="none">parseAll</literal> method is defined in a parent class. We
      invoke the top-level production method, <literal moreinfo="none">paycheck</literal>, and
      pass its return value as the first argument to
      <literal moreinfo="none">parseAll</literal> and pass the string to parse as the second
      argument.</para><para id="para_if_the_parsing_process_is_succ">If the parsing process is
      successful, the result of the parse is returned as an instance of type
      <literal moreinfo="none">p.Success[+T]</literal>, a case class declared in the
      <literal moreinfo="none">Parsers</literal> trait. Why is there a <literal moreinfo="none">p.</literal>
      prefix? It indicates that <literal moreinfo="none">p.Success</literal> is a
      <emphasis>path-dependent type</emphasis>, which we will discuss in <xref linkend="PathDependentTypes"/>. For now, just know that even though
      <literal moreinfo="none">Success</literal> is defined in the <literal moreinfo="none">Parsers</literal>
      trait, the actual type of the instance is dependent on the
      <literal moreinfo="none">PayrollParserCombinatorsV1</literal> instance we created. In
      other words, if we had another parser, <phrase role="keep-together">say
      <literal moreinfo="none">p2</literal> </phrase>of type <literal moreinfo="none">MyOtherParser</literal>,
      then <literal moreinfo="none">p2.Success[String]</literal> would be different from
      <literal role="keep-together" moreinfo="none">p.Success[String]</literal> and one could
      not be substituted for the other.<indexterm significance="normal"><primary>path-dependent types</primary><secondary>p.Success case class (example)</secondary></indexterm></para><para id="para_the_success_object_contains_">The
      <literal moreinfo="none">Success</literal> instance contains two fields. The first is
      the result of the parse, an instance of type <literal moreinfo="none">T</literal>
      (assigned to <literal moreinfo="none">r</literal> in the <literal moreinfo="none">case</literal>
      clause). The second is the remaining input string to parse, which will
      be empty after a successful parse (we will have parsed the whole string
      at this point). This string is assigned to <literal moreinfo="none">_</literal>.</para><para id="para_if_the_parse_fails_the_return">If the parse fails, the
      returned instance is either a <literal moreinfo="none">p.Failure</literal> or
      <literal moreinfo="none">p.Error</literal>, which our example handles with a generic
      <literal moreinfo="none">case</literal> clause. Both are derived from
      <literal moreinfo="none">p.NoSuccess</literal>, which contains fields for an error
      message and the unconsumed input at the point of failure. A
      <literal moreinfo="none">p.Failure</literal> in a parser will trigger backtracking so
      that a retry with a different parser can be invoked by the parser
      framework, if possible. An <literal moreinfo="none">Error</literal> result does not
      trigger backtracking and is used to signal more serious problems.</para><para id="para_for_completeness_both_p_succ">For completeness, both
      <literal moreinfo="none">p.Success</literal> and <literal moreinfo="none">p.NoSuccess</literal> derive
      from <literal moreinfo="none">p.ParseResult</literal>.</para><para id="para_we_have_left_two_big_unanswere">We have two big
      unanswered questions: what do the production methods actually return,
      and what is the type of the result instance returned in the
      <literal moreinfo="none">p.Success</literal>?</para><para id="para_the_production_methods_themsel">The production methods
      themselves return parsers. Most of them in our example return
      <literal moreinfo="none">p.Parser[String]</literal> (again, a path-dependent type).
      However, because the <literal moreinfo="none">deduct</literal> method handles repetition
      (it invokes the <literal moreinfo="none">repsep</literal> method), it actually returns a
      <literal moreinfo="none">p.Parser[List[String]]</literal>. When this parser is used, it
      will return a <literal moreinfo="none">List[String]</literal>, with one string
      corresponding to each match in the repetition.</para><para id="para_so_our_call_to_p_parseall_p_">So, our call to
      <literal moreinfo="none">p.parseAll(p.paycheck, input)</literal> earlier parses the
      <literal moreinfo="none">input</literal> string using the parser returned by
      <literal moreinfo="none">p.paycheck</literal>. That brings us to the second question:
      what is the result of a successful parse?</para><para id="para_to_see_what_s_returned_compil">To see what’s returned,
      compile the <filename moreinfo="none">PayrollParserCombinatorsV1</filename> file listed
      at the beginning of this section and invoke the <literal moreinfo="none">scala</literal>
      interpreter with the <literal moreinfo="none">-cp</literal> option to include the
      directory where the class files were written (it will be
      <filename moreinfo="none">build</filename> if you used the build process for the code
      example distribution).</para><para id="para_once_in_the_interpreter_enter">Once in the interpreter,
      enter the following expressions after the <literal moreinfo="none">scala&gt;</literal>
      prompt. (You can also find this input the
      <filename moreinfo="none">payroll-parser-comb-script.scala</filename> file in the code
      example distribution.)</para><screen format="linespecific">scala&gt; import scala.util.parsing.combinator._
import scala.util.parsing.combinator._

scala&gt; import payroll.pcdsl._
import payroll.pcdsl._

scala&gt; val p = new PayrollParserCombinatorsV1
p: payroll.pcdsl.PayrollParserCombinatorsV1 = \
    payroll.pcdsl.PayrollParserCombinatorsV1@79e84310

scala&gt; p.empl
res0: p.Parser[String] = Parser (~&gt;)

scala&gt; p.weeksDays
res2: p.Parser[String] = Parser (|)

scala&gt; p.doubleNumber
res3: p.Parser[String] = Parser ()

scala&gt; p.deduct
res1: p.Parser[List[String]] = Parser (&lt;~)

scala&gt; p.paycheck
res4: p.Parser[p.~[p.~[String,p.~[String,String]],List[String]]] = Parser (~)

scala&gt; p.parseAll(p.weeksDays, "weeks")
res5: p.ParseResult[String] = [1.6] parsed: weeks

scala&gt; val input = """paycheck for employee "Buck Trends"
     | is salary for 2 weeks minus deductions for {}"""
input: java.lang.String =
paycheck for employee "Buck Trends"
       is salary for 2 weeks minus deductions for {}

scala&gt; p.parseAll(p.paycheck, input)
res6: p.ParseResult[p.~[p.~[String,p.~[String,String]],List[String]]] = \
    [2.53] parsed: (("Buck Trends"~(2~weeks))~List())

scala&gt;</screen><para id="para_we_import_types_we_need_and_cr">We import the necessary
      types and create a <literal moreinfo="none">PayrollParserCombinatorsV1</literal>
      instance. Then we call several of the production methods to see what
      kind of <literal moreinfo="none">Parser</literal> each returns. The first
      three—<literal moreinfo="none">empl</literal>, <literal moreinfo="none">weeksDays</literal>, and
      <literal moreinfo="none">doubleNumber</literal>—return
      <literal moreinfo="none">p.Parser[String]</literal>.</para><para id="para_note_what_s_written_on_the_rig">Note what’s written on
      the righthand side in the output for the first three parsers:
      <literal moreinfo="none">empl</literal>, <literal moreinfo="none">weeksDays</literal>, and
      <literal moreinfo="none">doubleNumber</literal>. We see <literal moreinfo="none">Parser
      (∼&gt;)</literal>, <literal moreinfo="none">Parser (|)</literal>, and <literal moreinfo="none">Parser
      ()</literal>, respectively. The parsers returned reflect the definitions
      of the production rules, where <literal moreinfo="none">empl</literal> ends with a
      combinator of the form <literal moreinfo="none">prod1 ∼&gt; prod2</literal>,
      <literal moreinfo="none">weeksDays</literal> returns a combinator of the form
      <literal moreinfo="none">prod1 | prod2</literal>, and <literal moreinfo="none">doubleNumber</literal>
      returns a parser for a single production.</para><para id="para_because_deduct_consists_of_c">Because
      <literal moreinfo="none">deduct</literal> consists of combinators that handle
      repetition, the parser returned by <literal moreinfo="none">deduct</literal> is of type
      <literal moreinfo="none">p.Parser[List[String]]</literal>, as we stated previously. The
      righthand side of the output is <literal moreinfo="none">Parser (&lt;∼)</literal>,
      because the definition of <literal moreinfo="none">deduct</literal> ends with
      <literal moreinfo="none">prod1 &lt;∼ prod2</literal>.</para><para id="para_things_get_more_interesting_wh">Things get more
      interesting when we look at the top-level production,
      <literal moreinfo="none">paycheck</literal>. What is
      <literal moreinfo="none">p.Parser[p.∼[p.∼[String,p.∼[String,String]],List[String]]] =
      Parser (∼)</literal> <phrase role="keep-together">supposed</phrase> to
      mean? Well, the righthand side should be easy to understand now; the
      definition of <literal moreinfo="none">paycheck</literal> ends in <literal moreinfo="none">prod1 ∼
      prod2</literal>. What is the type parameter for
      <literal moreinfo="none">p.Parser</literal> on the lefthand side of the equals
      sign?</para><para id="para_the_parser_trait_also_define">The
      <literal moreinfo="none">Parsers</literal> trait also defines a case class named
      <literal moreinfo="none">∼</literal> that represents a pair of sequential
      rules:<indexterm significance="normal"><primary>Parsers object</primary><secondary>~ case class</secondary></indexterm><indexterm significance="normal"><primary>~ (tilde)</primary><secondary>case class defined by Parsers trait</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="statement">class</code> <code role="special">~</code><code role="special">[+a, +b]</code>(_1:<code role="type"> a</code>, _2:<code role="type"> b</code>) {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = <code role="constant">"("</code>+ _1 +<code role="constant">"~"</code>+ _2 +<code role="constant">")"</code>
}
</programlisting><para id="para_the_actual_path_dependent_type">The actual path-dependent
      type in our example is <literal moreinfo="none">p.∼[+a,+b]</literal>. Hence, the type
      parameter <literal moreinfo="none">T</literal> in <literal moreinfo="none">p.Parser[T]</literal> is
      <literal moreinfo="none">p.∼[p.∼[String,p.∼[String,String]],List[String]]</literal>,
      which is a hierarchical tree of types.</para><para id="para_let_s_break_it_down_working_o">Let’s break it down,
      working our way inside out. Note that there are three
      <literal moreinfo="none">p.∼</literal>. We’ll start with the innermost type,
      <literal moreinfo="none">p.∼[String,String]</literal>, and map the type declaration to
      the output we saw in the <literal moreinfo="none">scala</literal> session <literal moreinfo="none">"Buck
      Trends"∼(2∼weeks∼List())</literal>.</para><para id="para_the_p_string_string_corre">The
      <literal moreinfo="none">p.∼[String,String]</literal> corresponds to the parser that
      handles expressions like <literal role="keep-together" moreinfo="none">2
      weeks</literal>. Hence, the instance created when we parsed our example
      string was the instance <literal moreinfo="none">p.∼("2", "weeks")</literal>. Calling
      the <literal moreinfo="none">p.∼.toString</literal> method produces the output
      <literal moreinfo="none">(2~weeks)</literal>.</para><para id="para_working_out_one_level_we_have">Working out one level, we
      have <literal moreinfo="none">p.∼[String,p.∼[String,String]]</literal>. This combination
      parses <literal moreinfo="none">paycheck for employee "Buck Trends" is salary for 2
      weeks</literal>. Recall that we discard <literal moreinfo="none">paycheck for
      employee</literal> and <literal moreinfo="none">is salary for</literal>, keeping only
      the <literal moreinfo="none">Buck Trends</literal> and <literal moreinfo="none">2 weeks</literal>. So we
      create an instance <literal moreinfo="none">p.∼("Buck Trends", p.∼("2",
      "weeks"))</literal>. Calling <literal moreinfo="none">toString</literal> again results
      in the string <literal moreinfo="none">("Buck Trends"∼(2∼weeks))</literal>.</para><para id="para_finally_at_the_outer_level_of">Finally, at the outermost
      level, you can see we have the following:
      <literal moreinfo="none">p.∼[p.∼[String,p.∼[String,String]],List[String]]</literal>.
      We’ve already discussed everything up to the last
      <literal moreinfo="none">List[String]</literal>, which comes from the
      <literal moreinfo="none">deduct</literal> production:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">deduct</code> = <code role="constant">"minus"</code> ~&gt; <code role="constant">"deductions"</code> ~&gt; <code role="constant">"for"</code> ~&gt;
             <code role="constant">"{"</code> ~&gt; repsep(deductItem, <code role="constant">","</code> ) &lt;~ <code role="constant">"}"</code>
</programlisting><para id="para_we_discard_everything_except_f">We discard everything
      except for the list of zero or more <literal moreinfo="none">deductItems</literal>.
      There are none in our example, so we get an empty list for which
      <literal moreinfo="none">toString</literal> returns <literal moreinfo="none">List()</literal>.
      Therefore, calling <literal moreinfo="none">p.∼.toString</literal> on our outermost
      type, the one that parameterizes <literal moreinfo="none">p.Parser</literal>, <phrase role="keep-together">returns</phrase> the string <literal moreinfo="none">"Buck
      Trends"∼(2∼weeks∼List())</literal>. We’re done!</para><para id="para_well_not_quite_we_re_still_n">Well, not quite. We’re
      still not calculating an actual paycheck for ol’ Buck. Let’s <phrase role="keep-together">complete</phrase> our implementation.<indexterm class="endofrange" startref="ch11_parsercombScala" significance="normal"/><indexterm class="endofrange" startref="ch11_DSLsparser" significance="normal"/></para></sect2><sect2 id="_generating_paychecks_with_the_external_dsl"><title>Generating Paychecks with the External DSL</title><para id="para_as_we_parse_the_dsl_we_want_t">As we parse the DSL, we
      want to look up the employee by name, fetch his or her gross salary for
      the specified pay period, and then calculate the deductions as we go.
      When the parser returned by <literal moreinfo="none">paycheck</literal> finishes, we
      want to return a <literal moreinfo="none">Pair</literal> with the
      <literal moreinfo="none">Employee</literal> instance and the completed
      <literal moreinfo="none">Paycheck</literal>.<indexterm class="startofrange" id="ch11_parsersfinal" significance="normal"><primary>parser combinators, external DSLs with</primary><secondary>generating paychecks with
          PayrollParserCombinators</secondary></indexterm><indexterm class="startofrange" id="ch11_DSLexternalpaycheck" significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>external DSLs with parser combinators</secondary><tertiary>generating paychecks with external DSL</tertiary></indexterm></para><para id="para_we_will_reuse_domain_class">We will reuse “domain”
      classes like <literal moreinfo="none">Employee</literal>, <literal moreinfo="none">Money</literal>,
      <literal moreinfo="none">Paycheck</literal>, etc. from earlier in the chapter. To do the
      calculations on demand, we will create a second iteration of <literal role="keep-together" moreinfo="none">PayrollParserCombinatorsV1</literal> that we’ll
      call <literal moreinfo="none">PayrollParserCombinators</literal>. We’ll modify the
      parsers returned by some of the production methods to return new kinds
      of parsers. We’ll also do administrative work like storing running
      context data, as needed. Our implementation won’t be thread-safe. You’ll
      want to ensure that only one thread uses a given
      <literal moreinfo="none">PayrollParserCombinators</literal>. We could make it more
      robust, but doing so isn’t the goal of this exercise.</para><para id="para_here_is_our_final_payrollpars">Here is our final
      <literal moreinfo="none">PayrollParserCombinators</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb.scala</code>

<code role="preproc">package</code> payroll.pcdsl
<code role="preproc">import</code> scala.util.parsing.combinator._
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> payroll._
<code role="preproc">import</code> payroll.Type2Money._

<code role="statement">class</code> <code role="special">UnknownEmployee</code>(name:<code role="type"> Name</code>) <code role="statement">extends</code> <code role="special">RuntimeException</code>(name.toString)

<code role="statement">class</code> <code role="special">PayrollParserCombinators</code>(<code role="statement">val</code> employees:<code role="type"> Map[Name, Employee]</code>)
  <code role="statement">extends</code> <code role="special">JavaTokenParsers</code> {

  <code role="statement">var</code> currentEmployee:<code role="type"> Employee</code> = <code role="statement">null</code>
  <code role="statement">var</code> grossAmount:<code role="type"> Money</code> = <code role="special">Money</code>(<code role="constant">0</code>)

  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[(Employee, Paycheck)] */</code>
  <code role="statement">def</code> <code role="identifier">paycheck</code> = empl ~ gross ~ deduct ^^ {
    <code role="statement">case</code> e ~ g ~ d <code role="statement">=&gt;</code> (e, <code role="special">Paycheck</code>(g, g-d, d))
  }

  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[Employee] */</code>
  <code role="statement">def</code> <code role="identifier">empl</code> = <code role="constant">"paycheck"</code> ~&gt; <code role="constant">"for"</code> ~&gt; <code role="constant">"employee"</code> ~&gt; employeeName ^^ { name <code role="statement">=&gt;</code>
    <code role="statement">val</code> names = name.substring(<code role="constant">1</code>, name.length-<code role="constant">1</code>).split(<code role="constant">" "</code>) <code role="comment">// remove ""</code>
    <code role="statement">val</code> n = <code role="special">Name</code>(names(<code role="constant">0</code>), names(<code role="constant">1</code>));
    <code role="statement">if</code> (! employees.contains(n))
      <code role="statement">throw</code> <code role="statement">new</code> <code role="special">UnknownEmployee</code>(n)
    currentEmployee = employees(n)
    currentEmployee
  }

  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[Money] */</code>
  <code role="statement">def</code> <code role="identifier">gross</code> = <code role="constant">"is"</code> ~&gt; <code role="constant">"salary"</code> ~&gt; <code role="constant">"for"</code> ~&gt; duration ^^ { dur <code role="statement">=&gt;</code>
    grossAmount = salaryForDays(dur)
    grossAmount
  }

  <code role="statement">def</code> <code role="identifier">deduct</code> = <code role="constant">"minus"</code> ~&gt; <code role="constant">"deductions"</code> ~&gt; <code role="constant">"for"</code> ~&gt; <code role="constant">"{"</code> ~&gt; deductItems  &lt;~ <code role="constant">"}"</code>

  <code role="comment">/**</code>
<code role="comment">   * "stringLiteral" provided by JavaTokenParsers</code>
<code role="comment">   * </code><code role="special">@return</code><code role="comment"> Parser[String]</code>
<code role="comment">   */</code>
  <code role="statement">def</code> <code role="identifier">employeeName</code> = stringLiteral

  <code role="comment">/**</code>
<code role="comment">   * "decimalNumber" provided by JavaTokenParsers</code>
<code role="comment">   * </code><code role="special">@return</code><code role="comment"> Parser[Int]</code>
<code role="comment">   */</code>
  <code role="statement">def</code> <code role="identifier">duration</code> = decimalNumber ~ weeksDays ^^ {
    <code role="statement">case</code> n ~ factor <code role="statement">=&gt;</code> n.toInt * factor
  }

  <code role="statement">def</code> <code role="identifier">weeksDays</code> = weeks | days

  <code role="statement">def</code> <code role="identifier">weeks</code> = <code role="constant">"weeks?"</code>.r ^^ { <code role="statement">_</code> <code role="statement">=&gt;</code> <code role="constant">5</code> }

  <code role="statement">def</code> <code role="identifier">days</code> = <code role="constant">"days?"</code>.r ^^ { <code role="statement">_</code> <code role="statement">=&gt;</code> <code role="constant">1</code> }

  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[Money] */</code>
  <code role="statement">def</code> <code role="identifier">deductItems</code> = repsep(deductItem, <code role="constant">","</code>) ^^ { items <code role="statement">=&gt;</code>
    items.foldLeft(<code role="special">Money</code>(<code role="constant">0</code>)) {<code role="statement">_</code> + <code role="statement">_</code>}
  }

  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[Money] */</code>
  <code role="statement">def</code> <code role="identifier">deductItem</code> = deductKind ~&gt; deductAmount

  <code role="statement">def</code> <code role="identifier">deductKind</code> = tax | insurance | retirement

  <code role="statement">def</code> <code role="identifier">tax</code> = fedState &lt;~ <code role="constant">"income"</code> &lt;~ <code role="constant">"tax"</code>

  <code role="statement">def</code> <code role="identifier">fedState</code> = <code role="constant">"federal"</code> | <code role="constant">"state"</code>

  <code role="statement">def</code> <code role="identifier">insurance</code> = <code role="constant">"insurance"</code> ~&gt; <code role="constant">"premiums"</code>

  <code role="statement">def</code> <code role="identifier">retirement</code> = <code role="constant">"retirement"</code> ~&gt; <code role="constant">"fund"</code> ~&gt; <code role="constant">"contributions"</code>

  <code role="statement">def</code> <code role="identifier">deductAmount</code> = percentage | amount

  <code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[Money] */</code>
  <code role="statement">def</code> <code role="identifier">percentage</code> = toBe ~&gt; doubleNumber &lt;~ <code role="constant">"percent"</code> &lt;~ <code role="constant">"of"</code> &lt;~ <code role="constant">"gross"</code>  ^^ {
    percentage <code role="statement">=&gt;</code> grossAmount * (percentage / <code role="constant">100.</code>)
  }

  <code role="statement">def</code> <code role="identifier">amount</code> = toBe ~&gt; doubleNumber &lt;~ <code role="constant">"in"</code> &lt;~ <code role="constant">"gross"</code> &lt;~ <code role="constant">"currency"</code> ^^ {
    <code role="special">Money</code>(<code role="statement">_</code>)
  }

  <code role="statement">def</code> <code role="identifier">toBe</code> = <code role="constant">"is"</code> | <code role="constant">"are"</code>

  <code role="statement">def</code> <code role="identifier">doubleNumber</code> = floatingPointNumber ^^ { <code role="statement">_</code>.toDouble }

  <code role="comment">// Support method. Assume 260 (52 * 5) paid work days/year</code>
  <code role="statement">def</code> <code role="identifier">salaryForDays</code>(days:<code role="type"> Int</code>) =
      (currentEmployee.annualGrossSalary / <code role="constant">260.0</code>) * days
}
</programlisting><para id="para_for_simplicity_we_ll_use_a_ma">For simplicity, we’ll use
      a map of “known” employees, keyed by <literal moreinfo="none">Name</literal> instances,
      that we save as a field in <literal moreinfo="none">PayrollParserCombinators</literal>.
      A real implementation would probably use a data store of some
      kind.</para><para id="para_there_are_two_other_fields_c">There are two other fields:
      <literal moreinfo="none">currentEmployee</literal>, which remembers which employee we
      are processing, and <literal moreinfo="none">grossAmount</literal>, which remembers the
      gross amount of pay for the employee for the pay period. Both fields
      have a slight <emphasis>design smell</emphasis>. They are mutable. They
      are set only once per parse, but not when they are declared, only when
      we parse the input that allows us to calculate them. You might have also
      noticed that if the same <literal moreinfo="none">PayrollParserCombinators</literal>
      instance is used more than once, we don’t reset these fields to their
      default values. No doubt it would be possible to write scripts in the
      DSL that exploit this bug.</para><para id="para_these_weaknesses_are_not_inher">These weaknesses are not
      inherent to parser combinators. They reflect simplifications we used for
      our purposes. As an exercise, you might try improving the implementation
      to eliminate these weaknesses.</para><para id="para_we_have_added_javadoc_style_">We have added Javadoc-style
      <literal moreinfo="none">@return</literal> annotations for most of the productions to
      make it clear what they are now returning. In some cases, the
      productions are unchanged, as the original parser instances are fine as
      is. Most of the changes reflect our desire to calculate the paycheck as
      we go.<indexterm significance="normal"><primary sortas="return annotations">@return annotation</primary></indexterm><indexterm significance="normal"><primary>Javadoc-style @return annotation</primary></indexterm></para><?dbfo-need height=”1in”
?><para id="para_consider_the_new_paycheck_pr">Consider the new
      <literal moreinfo="none">paycheck</literal> production:</para><programlisting language="scala" format="linespecific"><code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[(Employee, Paycheck)] */</code>
<code role="statement">def</code> <code role="identifier">paycheck</code> = empl ~ gross ~ deduct ^^ {
  <code role="statement">case</code> e ~ g ~ d <code role="statement">=&gt;</code> (e, <code role="special">Paycheck</code>(g, g-d, d))
}
</programlisting><para id="para_now_we_return_a_pair_with_th">Now, we return a
      <literal moreinfo="none">Pair</literal> with the <literal moreinfo="none">Employee</literal> and the
      computed <literal moreinfo="none">Paycheck</literal>. The <literal moreinfo="none">empl ∼ gross ∼
      deduct</literal> combination would still return
      <literal moreinfo="none">Parser[String]</literal> (we’ll drop the <phrase role="keep-together">path-</phrase><phrase role="keep-together">dependent</phrase> prefix for now). We have added a
      new combinator <literal moreinfo="none">^^</literal>, e.g., <literal moreinfo="none">prod1 ^^
      func1</literal>, where <literal moreinfo="none">func1</literal> is a function. If
      <literal moreinfo="none">prod1</literal> succeeds, then the result of applying
      <literal moreinfo="none">func1</literal> to the result of <literal moreinfo="none">prod1</literal> is
      returned. That is, we return <literal moreinfo="none">func1(prod1)</literal>.</para><para id="para_for_paycheck_we_give_it_a_f">For
      <literal moreinfo="none">paycheck</literal>, we give it a function literal that does a
      pattern match to extract the three results from <literal moreinfo="none">empl</literal>,
      <literal moreinfo="none">gross</literal>, and <literal moreinfo="none">deduct</literal>, respectively.
      We create a 2-tuple (<literal moreinfo="none">Pair</literal>) with <literal moreinfo="none">e</literal>,
      the <literal moreinfo="none">Employee</literal>, and a <literal moreinfo="none">Paycheck</literal>
      calculated from the gross salary for the pay period (in
      <literal moreinfo="none">g</literal>) and the sum of all the deductions (in
      <literal moreinfo="none">d</literal>).</para><para id="para_it_s_important_to_keep_clear_t">It’s important to keep
      clear that the anonymous function passed as an argument to
      <literal moreinfo="none">^^</literal> returns a tuple <literal moreinfo="none">(Employee,
      Paycheck)</literal>, but the production <literal moreinfo="none">paycheck</literal>
      method itself returns a <literal moreinfo="none">Parser[(Employee, Paycheck)]</literal>.
      This pattern has been true from the beginning, actually, where
      <literal moreinfo="none">Strings</literal> were always involved in our first version. It
      will remain true for all the production rules in
      <literal moreinfo="none">PayrollParserCombinators</literal>.</para><para id="para_the_empl_production_assumes_">The <literal moreinfo="none">empl</literal>
      production assumes the employee’s first name and last name are given.
      (Obviously, this would be inadequate in a real application.)</para><programlisting language="scala" format="linespecific"><code role="comment">/** </code><code role="special">@return</code><code role="comment"> Parser[Employee] */</code>
<code role="statement">def</code> <code role="identifier">empl</code> = <code role="constant">"paycheck"</code> ~&gt; <code role="constant">"for"</code> ~&gt; <code role="constant">"employee"</code> ~&gt; employeeName ^^ { name <code role="statement">=&gt;</code>
   <code role="statement">val</code> names = name.substring(<code role="constant">1</code>, name.length-<code role="constant">1</code>).split(<code role="constant">" "</code>) <code role="comment">// remove ""</code>
   <code role="statement">val</code> n = <code role="special">Name</code>(names(<code role="constant">0</code>), names(<code role="constant">1</code>));
   <code role="statement">if</code> (! employees.contains(n))
     <code role="statement">throw</code> <code role="statement">new</code> <code role="special">UnknownEmployee</code>(n)
   currentEmployee = employees(n)
   currentEmployee
}
</programlisting><para id="para_to_construct_the_name_the_emb">To construct the name, the
      embedded double quotes have to be removed, which is why we start by
      extracting the substring that tosses the first and last characters. The
      name is used to look up the <literal moreinfo="none">Employee</literal> instance in the
      map, saving the value in the <literal moreinfo="none">currentEm⁠ployee</literal> field.
      In general, there is not a lot of “graceful” error handling in
      <literal moreinfo="none">PayrollParserCombinators</literal>. However, the
      <literal moreinfo="none">empl</literal> method handles the case where no employee is
      found with the specified name, throwing an
      <literal moreinfo="none">UnknownEmployee</literal> exception when this <phrase role="keep-together">occurs</phrase>.</para><para id="para_the_rest_of_the_productions_wo">The rest of the
      productions work similarly. Sometimes, a parser converts an input string
      to an <literal moreinfo="none">Int</literal> (e.g., <literal moreinfo="none">duration</literal>) or a
      <literal moreinfo="none">Money</literal> (e.g., <literal moreinfo="none">gross</literal>). An
      interesting case is <literal moreinfo="none">deduct</literal>. It folds the list of
      deductions into a single deduction amount, using addition. The
      <literal moreinfo="none">foldLeft</literal> method takes two argument lists. The first
      has a single argument that specifies the initial value, in this case,
      zero <literal moreinfo="none">Money</literal>. The second argument list has a single
      function literal argument that takes two arguments: the accumulated
      value of the folding operation, and an item from the list. In this case,
      we return the sum of the arguments. So, <literal role="keep-together" moreinfo="none">foldLeft</literal> iterates over the
      <literal moreinfo="none">items</literal> collection, adding them together. See <xref linkend="TraversingMappingFilteringFolding"/> for more information on
      <literal moreinfo="none">foldLeft</literal> and related operations.</para><para id="para_the_weeks_and_days_product">The <literal moreinfo="none">weeks</literal>
      and <literal moreinfo="none">days</literal> productions remind us that we are using
      parser combinators based on regular-expressions. (We’re also using
      <literal moreinfo="none">stringLiteral</literal>, <literal moreinfo="none">decimalNumber</literal>, and
      <literal moreinfo="none">floatingPointNumber</literal> provided by
      <literal moreinfo="none">JavaTokenParsers</literal>.) Note that <literal moreinfo="none">weeks</literal>
      and <literal moreinfo="none">days</literal> ignore the parsed string. They just return a
      multiplication factor used to determine total days in the pay period in
      the <literal moreinfo="none">duration</literal> production rule.</para><para id="para_there_are_other_combinator_met">There are other
      combinator methods for applying functions to parser results in different
      ways. See the <literal moreinfo="none">Parsers</literal> Scaladoc page for
      details.</para><para id="para_the_following_specification_w">The following (somewhat
      incomplete) specification shows the calculation of paychecks when there
      are no deductions and when there are several deductions:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb-spec.scala</code>

<code role="preproc">package</code> payroll.pcdsl
<code role="preproc">import</code> scala.util.parsing.combinator._
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> payroll._
<code role="preproc">import</code> payroll.Type2Money._

<code role="comment">// Doesn't test "sad path" scenarios...</code>
<code role="statement">object</code> <code role="special">PayrollParserCombinatorsSpec</code>
    <code role="statement">extends</code> <code role="special">Specification</code>(<code role="constant">"PayrollParserCombinators"</code>) {

  <code role="statement">val</code> salary = <code role="special">Money</code>(<code role="constant">100000.1</code>)  <code role="comment">// for a full year</code>
  <code role="statement">val</code> gross = salary / <code role="constant">26.</code>      <code role="comment">// for two weeks</code>
  <code role="statement">val</code> buck = <code role="special">Employee</code>(<code role="special">Name</code>(<code role="constant">"Buck"</code>, <code role="constant">"Trends"</code>), salary)
  <code role="statement">val</code> employees = <code role="special">Map</code>(buck.name -&gt; buck)

  <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">money2double</code>(m:<code role="type"> Money</code>) = m.amount.doubleValue

  <code role="constant">"PayrollParserCombinators"</code> should {
    <code role="constant">"calculate the gross == net when there are no deductions"</code> in {
      <code role="statement">val</code> input = <code role="constant">"""paycheck for employee "Buck Trends"</code>
<code role="constant">                     is salary for 2 weeks minus deductions for {}"""</code>
      <code role="statement">val</code> p = <code role="statement">new</code> <code role="special">PayrollParserCombinators</code>(employees)
      p.parseAll(p.paycheck, input) <code role="statement">match</code> {
        <code role="statement">case</code> p.<code role="special">Success</code>(<code role="special">Pair</code>(employee, paycheck),<code role="statement">_</code>) <code role="statement">=&gt;</code>
          employee mustEqual buck
          paycheck.gross must beCloseTo(gross, <code role="special">Money</code>(<code role="constant">.001</code>))
          paycheck.net must beCloseTo(gross, <code role="special">Money</code>(<code role="constant">.001</code>))
          <code role="comment">// zero deductions?</code>
          paycheck.deductions must beCloseTo(<code role="special">Money</code>(<code role="constant">0.</code>), <code role="special">Money</code>(<code role="constant">.001</code>))
        <code role="statement">case</code> x <code role="statement">=&gt;</code> fail(x.toString)
      }
    }

    <code role="constant">"calculate the gross, net, and deductions for the pay period"</code> in {
      <code role="statement">val</code> input =
        <code role="constant">"""paycheck for employee "Buck Trends"</code>
<code role="constant">           is salary for 2 weeks minus deductions for {</code>
<code role="constant">             federal income tax            is  25.  percent of gross,</code>
<code role="constant">             state income tax              is  5.   percent of gross,</code>
<code role="constant">             insurance premiums            are 500. in gross currency,</code>
<code role="constant">             retirement fund contributions are 10.  percent of gross</code>
<code role="constant">           }"""</code>

      <code role="statement">val</code> p = <code role="statement">new</code> <code role="special">PayrollParserCombinators</code>(employees)
      p.parseAll(p.paycheck, input) <code role="statement">match</code> {
        <code role="statement">case</code> p.<code role="special">Success</code>(<code role="special">Pair</code>(employee, paycheck),<code role="statement">_</code>) <code role="statement">=&gt;</code>
          employee mustEqual buck
          <code role="statement">val</code> deductions = (gross * <code role="constant">.4</code>) + <code role="special">Money</code>(<code role="constant">500</code>)
          <code role="statement">val</code> net = gross - deductions
          paycheck.gross must beCloseTo(gross, <code role="special">Money</code>(<code role="constant">.001</code>))
          paycheck.net must beCloseTo(net, <code role="special">Money</code>(<code role="constant">.001</code>))
          paycheck.deductions must beCloseTo(deductions, <code role="special">Money</code>(<code role="constant">.001</code>))
        <code role="statement">case</code> x <code role="statement">=&gt;</code> fail(x.toString)
      }
    }
  }
}
</programlisting><para id="para_if_you_work_out_what_the_resul">If you work out what the
      results should be from the input strings, you’ll see that the
      implementation correctly calculates the paycheck.</para><para id="para_besides_the_many_small_details">Besides the many small
      details that differ between this implementation of the external DSL and
      the previous implementation of the internal DSL, there is one big
      conceptual difference from the two implementations. Here we are
      computing the paycheck as we parse code written in the external DSL. In
      the internal DSL case, we generated a <phrase role="keep-together">paycheck</phrase> calculator when we parsed the
      DSL. Afterward, we used that calculator to <phrase role="keep-together">compute</phrase> paychecks for one employee at a
      time. We could have generated a paycheck calculator like we did before,
      but we chose a simpler approach to focus on the construction of the
      parser itself. Also, as we discussed earlier, we weren’t as careful
      about thread safety and other issues in the implementation.<indexterm class="endofrange" startref="ch11_parsercombinators" significance="normal"/><indexterm class="endofrange" startref="ch11_parsersfinal" significance="normal"/><indexterm class="endofrange" startref="ch11_DSLexternalpaycheck" significance="normal"/><indexterm class="endofrange" startref="ch11_DSLexternal" significance="normal"/></para></sect2><sect2 id="ExternalDSLsFinalThoughts"><title>Internal Versus External DSLs: Final Thoughts</title><para id="para_scala_provides_rich_support_fo">Scala provides rich
      support for creating your own internal and external DSLs. However, a
      non-trivial DSL can be a challenge to implement and debug. For the
      examples in this chapter, the parser combinators implementation was
      easier to design and write than the implementation for the internal DSL.
      However, we found that debugging the <phrase role="keep-together">internal</phrase> DSL was easier.<indexterm significance="normal"><primary>external DSLs</primary><secondary>internal DSLs versus</secondary></indexterm><indexterm significance="normal"><primary>internal DSLs</primary><secondary>external DSLs versus</secondary></indexterm><indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>internal versus external</secondary></indexterm></para><?dbfo-need height=”2in”
?><para id="para_another_problem_you_must_consi">You must also consider
      how robust the parser must be when handling invalid input. Depending on
      the level of sophistication of the users of the DSL, you may need to
      provide very good feedback when errors occur, especially when your users
      are non-programmers. The parser combinator library in Scala version 2.8
      will provide improved support for error recovery and reporting, compared
      to the version 2.7.X library.</para><para id="para_the_version_2_8_library_will_a">The version 2.8 library
      will also provide support for writing <emphasis>packrat
      parsers</emphasis> that can implement unambiguous <emphasis>parsing
      expression grammars</emphasis> (PEGs). The 2.8 implementation of packrat
      parsers also supports <emphasis>memoization</emphasis>, which helps
      improve performance, among other benefits. If you need a fast parser, a
      packrat parser will take you further before you need to consider more
      specialized tools, like parser generators.<indexterm significance="normal"><primary>memoization</primary><secondary>support by packrat parsers</secondary></indexterm><indexterm significance="normal"><primary>PEGs (parsing expression grammars)</primary></indexterm><indexterm significance="normal"><primary>parsing expression grammars (PEGs)</primary></indexterm><indexterm significance="normal"><primary>packrat parsers</primary></indexterm></para></sect2></sect1><sect1 id="_recap_and_what_s_next_3"><title>Recap and What’s Next</title><para id="para_so_it_s_tempting_to_create_ds">It’s tempting to create DSLs
    with abandon. DSLs in Scala can be quite fun to work with, but don’t
    underestimate the effort required to create robust DSLs that meet your
    clients usability needs, nor long-term maintenance and support
    issues.</para><para id="para_if_you_choose_to_write_a_dsl_">If you choose to write a
    DSL, you have rich options in Scala. The syntax is flexible yet powerful
    enough that an internal DSL may be sufficient. A internal DSL is an
    excellent starting point, especially if other programmers will be the
    primary writers of code in the DSL.</para><para id="para_if_you_expect_your_non_program">If you expect your
    non-programming stakeholders to read or even write code written in the
    DSL, it might be worth the extra effort to create an external DSL that
    eliminates as many of the programming-language idioms as possible.
    Consider whether the code written in the DSL will need to be processed for
    other purposes, like generating documentation, spreadsheets, etc. Since
    you will have to write a parser for the DSL anyway, it might be
    straightforward to write others to handle these different purposes.</para><para id="para_so_far_we_have_only_hinted_at">In the next chapter, we’ll
    explore the richness of Scala’s type system. We’ve learned many of its
    features already. Now, we’ll explore the type system in full
    detail.<indexterm class="endofrange" startref="ch11_DSLs" significance="normal"/></para></sect1></chapter><chapter id="ScalasTypeSystem"><title>The Scala Type System</title><para id="para_types_intro">Scala is a statically typed language. Its type
  system is one of the most sophisticated in any programming language, in part
  because it combines comprehensive ideas from functional programming and
  object-oriented programming. The type system tries to be logically
  comprehensive, complete, and consistent. It exceeds limitations in Java’s
  type system while containing innovations that appear in Scala for the first
  time.<indexterm significance="normal"><primary>type system</primary><seealso>data types</seealso></indexterm><indexterm class="startofrange" id="ch12_datatypes" significance="normal"><primary>data types</primary></indexterm></para><para id="para_however_much_of_this_sophisti">However, the type system can
  be intimidating at first, especially if you come from a dynamically typed
  language like Ruby or Python. Fortunately, type inference hides most of the
  complexities away. Most of the time, you don’t need to know the particulars,
  so we encourage you not to worry that you must master the type system in
  order to use Scala effectively. You might choose to skim this chapter if
  you’re new to Scala, so you’ll know where to look when type-related
  questions arise later.<indexterm significance="normal"><primary>types</primary><seealso>data types</seealso></indexterm></para><para id="para_still_the_more_you_know_about">Still, the more you know about
  the type system, the more you will be able to exploit its features in your
  programs. This is especially true for library writers, who will want to
  understand when to use parameterized types versus abstract types, which type
  parameters should be covariant, contravariant, or invariant under subtyping,
  and so forth. Also, some understanding of the type system will help you
  understand and debug the occasional compilation failure related to typing.
  Finally, this understanding will help you make sense of the type information
  shown in the sources and Scaladocs for Scala libraries.</para><para id="para_if_you_didn_t_understand_some_">If you didn’t understand some
  of the terms we used in the preceding paragraphs, don’t worry. We’ll explain
  them and why they are useful. We’re not going to discuss Scala’s type system
  in exhaustive detail. Rather, we want you to come away with a pragmatic
  understanding of the type system. You should develop an awareness of the
  features available, what purposes they serve, and how to read and understand
  type declarations.</para><para id="para_we_ll_also_highlight_similarit">We’ll also highlight
  similarities with Java’s type system, since it may be a familiar point of
  reference for you. Understanding the differences is also useful for
  interoperability with Java libraries. To focus the discussion, we won’t
  cover the .NET type system, except to point out some notable differences
  that .NET programmers will want to know.</para><sect1 id="ReflectingOnTypes"><title>Reflecting on Types</title><para id="para_reflecting_on_types">Scala supports the same reflection
    capabilities that Java and .NET support. The syntax is different in some
    cases.<indexterm significance="normal"><primary>data types</primary><secondary>reflection</secondary></indexterm><indexterm significance="normal"><primary>reflection</primary></indexterm></para><para id="para_java_class_methods">First, you can use the same methods you
    might use in Java or .NET code. The following script shows some of the
    reflection methods available on the JVM, through
    <literal moreinfo="none">java.lang.Object</literal> and
    <literal moreinfo="none">java.lang.Class</literal>:<indexterm significance="normal"><primary>Java</primary><secondary>JVM (Java Virtual Machine)</secondary><tertiary>reflection methods</tertiary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/reflection/jvm-script.scala</code>

<code role="statement">trait</code> <code role="special">T</code><code role="special">[A]</code> {
  <code role="statement">val</code> vT:<code role="type"> A</code>
  <code role="statement">def</code> <code role="identifier">mT</code> = vT
}

<code role="statement">class</code> <code role="special">C</code> <code role="statement">extends</code> <code role="special">T</code><code role="special">[String]</code> {
  <code role="statement">val</code> vT = <code role="constant">"T"</code>
  <code role="statement">val</code> vC = <code role="constant">"C"</code>
  <code role="statement">def</code> <code role="identifier">mC</code> = vC

  <code role="statement">class</code> <code role="special">C2</code>
  <code role="statement">trait</code> <code role="special">T2</code>
}

<code role="statement">val</code> c = <code role="statement">new</code> <code role="special">C</code>
<code role="statement">val</code> clazz = c.getClass              <code role="comment">// method from java.lang.Object</code>
<code role="statement">val</code> clazz2 = classOf[<code role="special">C</code>]             <code role="comment">// Scala method: classOf[C] ~ C.class</code>
<code role="statement">val</code> methods = clazz.getMethods      <code role="comment">// method from java.lang.Class&lt;T&gt;</code>
<code role="statement">val</code> ctors = clazz.getConstructors   <code role="comment">// ...</code>
<code role="statement">val</code> fields = clazz.getFields
<code role="statement">val</code> annos = clazz.getAnnotations
<code role="statement">val</code> name  = clazz.getName
<code role="statement">val</code> parentInterfaces = clazz.getInterfaces
<code role="statement">val</code> superClass = clazz.getSuperclass
<code role="statement">val</code> typeParams = clazz.getTypeParameters
</programlisting><para id="para_note_that_these_methods_are_on">Note that these methods are
    only available on subtypes of <literal moreinfo="none">AnyRef</literal>.<indexterm significance="normal"><primary>AnyRef object</primary><secondary>reflection methods</secondary></indexterm></para><para id="para_the_classof_t_method_return">The
    <literal moreinfo="none">classOf[T]</literal> method returns the runtime representation
    for a Scala type. It is analogous to the Java expression
    <literal moreinfo="none">T.class</literal>. Using <literal moreinfo="none">classOf[T]</literal> is
    convenient when you have a type that you want information about, while
    <literal moreinfo="none">getClass</literal> is convenient for retrieving the same
    information from an instance of the type.</para><para id="para_however_classof_t_and_get">However,
    <literal moreinfo="none">classOf[T]</literal> and <literal moreinfo="none">getClass</literal> return
    slightly different values, reflecting the effect of <emphasis>type
    erasure</emphasis> on the JVM, in the case of
    <literal moreinfo="none">getClass</literal>:<indexterm significance="normal"><primary>type erasure</primary><secondary>getClass method on JVM</secondary></indexterm></para><screen format="linespecific">scala&gt; classOf[C]
res0: java.lang.Class[C] = class C

scala&gt; c.getClass
res1: java.lang.Class[_] = class C</screen><note id="para_note_although_net_does_not_h"><para>Although .NET does not have type erasure, meaning it supports
      <emphasis>reified types</emphasis>, the .NET version of Scala currently
      follows the JVM’s erasure model in order to avoid incompatibilities that
      would require a “forked” implementation.</para></note><para id="para_we_ll_discuss_a_workaround_for">We’ll discuss a workaround
    for erasure, called <literal moreinfo="none">Manifest</literal>s, after we discuss
    <emphasis>parameterized types</emphasis> in the next section.</para><para id="para_scala_also_provides_methods_fo">Scala also provides methods
    for testing whether an object matches a type and also for casting an
    object to a type.</para><para id="para__any_isinstanceof_t_will_ret"><literal moreinfo="none">x.isInstanceOf[T]</literal>
    will return <literal moreinfo="none">true</literal> if the instance <literal moreinfo="none">x</literal>
    is of type <literal moreinfo="none">T</literal>. However, this test is subject to type
    erasure. For example,
    <literal moreinfo="none">List(3.14159).isInstanceOf[List[String]]</literal> will return
    <literal moreinfo="none">true</literal> because the type parameter of
    <literal moreinfo="none">List</literal> is lost at the byte code level. However, you’ll
    get an “unchecked” warning from the compiler.</para><para id="para__any_asinstanceof_t_will_cas"><literal moreinfo="none">x.asInstanceOf[T]</literal>
    will cast <literal moreinfo="none">x</literal> to <literal moreinfo="none">T</literal> or throw a
    <literal moreinfo="none">ClassCastException</literal> if <literal moreinfo="none">T</literal> and the type
    of <literal moreinfo="none">x</literal> are not compatible. Once again, type erasure must
    be considered with parameterized types. The expression
    <literal moreinfo="none">List(3.14159).asInstanceOf[List[String]]</literal> will
    succeed.</para><para id="para_note_that_these_two_operations">Note that these two
    operations are methods and not keywords in the language, and their names
    are deliberately somewhat verbose. Normally, type checks and casts like
    these should be avoided. For type checks, use pattern matching instead.
    For casts, consider why a cast is necessary and determine if a refactoring
    of the design can eliminate the requirement for a cast.</para><note id="para_exper_scala_reflect"><para>At the time of this writing, there are some experimental features
      that might appear in the final version 2.8 release in the
      <literal moreinfo="none">scala.reflect</literal> package. These features are designed to
      make reflective examination and invocation of code easier than using the
      corresponding Java methods.</para></note></sect1><sect1 id="ParameterizedTypes"><title>Understanding Parameterized Types</title><para id="para_we_introduced__parameterized_t">We introduced
    <emphasis>parameterized types</emphasis> and <emphasis>methods</emphasis>
    in <xref linkend="IntroducingScala"/>, and filled in a few more details
    in <xref linkend="AbstractTypesAndParameterizedTypes"/>. If you come from
    a Java or C# background, you probably already have some knowledge of
    parameterized types and methods. Now we explore the details of Scala’s
    sophisticated support for parameterized types.<indexterm significance="normal"><primary>parameterized types</primary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>parameterized types</secondary></indexterm></para><para id="para_scala_s_parameterized_types_ar">Scala’s parameterized types
    are similar to Java and C# generics and C++ templates. They provide the
    same capabilities as Java generics, but with significant differences and
    extensions, reflecting the sophistication of Scala’s type system.</para><para id="para_to_recap_a_declaration_like_">To recap, a declaration like
    <literal moreinfo="none">class List[+A]</literal> means that <literal moreinfo="none">List</literal> is
    parameterized by a single type, represented by <literal moreinfo="none">A</literal>. The
    <literal moreinfo="none">+</literal> is called a <emphasis>variance annotation</emphasis>.
    We’ll come back to it in <xref linkend="VarianceUnderInheritance"/>.<indexterm significance="normal"><primary>variance annotations</primary></indexterm></para><para id="para_a_declaration_like_list_043">Sometimes, a parameterized
    type like <literal moreinfo="none">List</literal> is called a <emphasis>type
    constructor</emphasis>, because it is used to create specific types. For
    example, <literal moreinfo="none">List</literal> is the type constructor for
    <literal moreinfo="none">List[String]</literal> and <literal moreinfo="none">List[Int]</literal>, which
    are different types (although they are actually implemented with the same
    byte code due to <emphasis>type erasure</emphasis>). In fact, it’s more
    accurate to say that all traits and classes are type constructors. Those
    without type parameters are effectively <phrase role="keep-together">zero-</phrase><phrase role="keep-together">argument</phrase>, parameterized types.</para><warning id="para_warning_if_you_write_class_s"><para>If you write <literal moreinfo="none">class StringList[String] extends
      List[String] {...}</literal>, Scala will interpret
      <literal moreinfo="none">String</literal> as the name of the type parameter, not the
      creation of a type based on actual Strings. You want to write
      <literal moreinfo="none">class StringList extends List[String] {...}</literal>.</para></warning><sect2 id="Manifests"><title>Manifests</title><para id="para_there_is_an_experimental_featu">There is an experimental
      feature in Scala (since version 2.7.2), called
      <literal moreinfo="none">Manifest</literal>s, that captures type information that is
      erased in the byte code. This feature is not documented in the
      Scaladocs, but you can examine the source for the
      <literal moreinfo="none">scala.reflect.Manifest</literal> trait. <link linkend="Ortiz2008" xrefstyle="select:nopage">[Ortiz2008]</link>
      discusses <literal moreinfo="none">Manifest</literal>s and provides examples of their
      use.<indexterm significance="normal"><primary>Manifests</primary></indexterm><indexterm significance="normal"><primary>parameterized types</primary><secondary>Manifests</secondary></indexterm></para><para id="para_a_manifest_is_declared_as_an">A
      <literal moreinfo="none">Manifest</literal> is declared as an implicit argument to a
      method or type that wants to capture the erased type information. Unlike
      most implicit arguments, the user does not need to supply an in-scope
      <literal moreinfo="none">Manifest</literal> value or method. Instead, the compiler
      generates one automatically. Here is an example that illustrates some of
      the strengths and weaknesses of <literal moreinfo="none">Manifest</literal>s:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/manifests/manifest-script.scala</code>

<code role="preproc">import</code> scala.reflect.Manifest

<code role="statement">object</code> <code role="special">WhichList</code> {
  <code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[B]</code>(value:<code role="type"> List[B]</code>)(<code role="statement">implicit</code> m:<code role="type"> Manifest[B]</code>) = m.toString <code role="statement">match</code> {
    <code role="statement">case</code> <code role="constant">"int"</code>              <code role="statement">=&gt;</code> println( <code role="constant">"List[Int]"</code> )
    <code role="statement">case</code> <code role="constant">"double"</code>           <code role="statement">=&gt;</code> println( <code role="constant">"List[Double]"</code> )
    <code role="statement">case</code> <code role="constant">"java.lang.String"</code> <code role="statement">=&gt;</code> println( <code role="constant">"List[String]"</code> )
    <code role="statement">case</code> <code role="statement">_</code>                  <code role="statement">=&gt;</code> println( <code role="constant">"List[???]"</code> )
  }
}

<code role="special">WhichList</code>(<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>))
<code role="special">WhichList</code>(<code role="special">List</code>(<code role="constant">1.1</code>, <code role="constant">2.2</code>, <code role="constant">3.3</code>))
<code role="special">WhichList</code>(<code role="special">List</code>(<code role="constant">"one"</code>, <code role="constant">"two"</code>, <code role="constant">"three"</code>))

<code role="special">List</code>(<code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>), <code role="special">List</code>(<code role="constant">1.1</code>, <code role="constant">2.2</code>, <code role="constant">3.3</code>), <code role="special">List</code>(<code role="constant">"one"</code>, <code role="constant">"two"</code>, <code role="constant">"three"</code>)) foreach {
  <code role="special">WhichList</code>(<code role="statement">_</code>)
}
</programlisting><para id="para__whichlist_tries_to_determine"><literal moreinfo="none">WhichList</literal>
      tries to determine the type of list passed in. It uses the value of the
      <literal role="keep-together" moreinfo="none">Manifest</literal>’s
      <literal moreinfo="none">toString</literal> method to determine this information. Notice
      that it works when the list is constructed inside the call to
      <literal moreinfo="none">WhichList.apply</literal>. It does <emphasis>not</emphasis>
      work when a previously constructed list is passed to
      <literal moreinfo="none">WhichList.apply</literal>.</para><para id="para_the_compiler_exploits_the_type">The compiler exploits the
      type information it knows in the first case to construct the implicit
      <literal moreinfo="none">Manifest</literal> with the correct <literal moreinfo="none">B</literal>.
      However, when given previously constructed lists, the crucial type
      information is already lost.</para><para id="para_hence_manifests_can_t_resur">Hence,
      <literal moreinfo="none">Manifest</literal>s can’t “resurrect” type information from
      byte code, but they can be used to capture and exploit type information
      before it is erased.</para></sect2><sect2 id="ParameterizedMethods"><title>Parameterized Methods</title><para id="para_because_the_runtime_system_ins">Individual methods can
      also be parameterized. Good examples are the <literal moreinfo="none">apply</literal>
      methods in companion objects for parameterized classes. Recall that
      companion objects are singleton objects associated with a companion
      class. There is only one instance of a singleton object, as its name
      implies, so type parameters would be meaningless.<indexterm significance="normal"><primary>parameterized methods</primary></indexterm><indexterm significance="normal"><primary>parameterized types</primary><secondary>parameterized methods</secondary></indexterm><indexterm significance="normal"><primary>methods</primary><secondary>parameterized</secondary></indexterm></para><para id="para_often_the_methods_in_these_co">Let’s consider
      <literal moreinfo="none">object List</literal>, the companion object for <literal moreinfo="none">class
      List[+A]</literal>. Here is the definition of the
      <literal moreinfo="none">apply</literal> method in <literal moreinfo="none">object
      List</literal>:<indexterm significance="normal"><primary>List object</primary><secondary>apply method, parameterized</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[A]</code>(xs:<code role="type"> A</code>*):<code role="type"> List[A]</code> = xs.toList
</programlisting><para id="para_so_the_following_declarations">The
      <literal moreinfo="none">apply</literal> methods takes a variable length list of
      arguments of type <literal moreinfo="none">A</literal>, which will be inferred from the
      arguments, and returns a list created from the arguments. Here is an
      example:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> languages = <code role="special">List</code>(<code role="constant">"Scala"</code>, <code role="constant">"Java"</code>, <code role="constant">"Ruby"</code>, <code role="constant">"C#"</code>, <code role="constant">"C++"</code>, <code role="constant">"Python"</code>, ...)
<code role="statement">val</code> positiveInts = <code role="special">List</code>(<code role="constant">1</code>, <code role="constant">2</code>, <code role="constant">3</code>, <code role="constant">4</code>, <code role="constant">5</code>, <code role="constant">6</code>, <code role="constant">7</code>, ...)
</programlisting><para id="para_we_ll_look_at_other_parameteri">We’ll look at other
      parameterized methods shortly.</para></sect2></sect1><sect1 id="VarianceUnderInheritance"><title>Variance Under Inheritance</title><para id="para_parameterized_types_diff_with_java">An important difference
    between Java and Scala generics is how <emphasis>variance</emphasis> under
    inheritance works. For example, if a method has an argument of type
    <literal moreinfo="none">List[AnyRef]</literal>, can you pass a
    <literal moreinfo="none">List[String]</literal> value? In other words, should a
    <literal moreinfo="none">List[String]</literal> be considered a
    <emphasis>subtype</emphasis> of <literal moreinfo="none">List[AnyRef]</literal>? If so,
    this kind of variance is called <emphasis>covariance</emphasis>, because
    the supertype-subtype relationship of the container (the parameterized
    type) “goes in the same direction” as the relationship between the type
    parameters. In other contexts, you might want
    <emphasis>contravariant</emphasis> or <emphasis>invariant</emphasis>
    behavior, which we’ll describe shortly.<indexterm significance="normal"><primary>type variance</primary><seealso>variance under inheritance</seealso></indexterm><indexterm significance="normal"><primary>generics</primary><secondary>variance under inheritance, differences between Java and
        Scala</secondary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>variance under inheritance</secondary></indexterm><indexterm significance="normal"><primary>variance under inheritance</primary></indexterm><indexterm class="startofrange" id="ch12_inheritvariance" significance="normal"><primary>inheritance</primary><secondary>variance under</secondary></indexterm></para><para id="para_in_scala_the_type_designer_sp">In Scala, the variance
    behavior is defined at the <emphasis>declaration site</emphasis> using
    <emphasis>variance annotations</emphasis>: <literal moreinfo="none">+</literal>,
    <literal moreinfo="none">-</literal>, or nothing. In other words, the type designer
    decides how the type should vary under inheritance.<indexterm significance="normal"><primary>declaration site</primary></indexterm><indexterm significance="normal"><primary>- (minus sign)</primary><secondary>variance annotations</secondary></indexterm><indexterm significance="normal"><primary>+ (plus sign)</primary><secondary>variance annotations</secondary></indexterm><indexterm significance="normal"><primary>variance annotations</primary><secondary>summary of</secondary></indexterm></para><para id="para_let_s_examine_the_three_kinds_">Let’s examine the three
    kinds of variance, summarized in <xref linkend="type-variance-annotations-table"/>, and understand how to use
    them effectively. We’ll assume that
    <literal moreinfo="none">T</literal><superscript>sup</superscript> is a
    <emphasis>supertype</emphasis> of <literal moreinfo="none">T</literal> and
    <literal moreinfo="none">T</literal><subscript>sub</subscript> is a
    <emphasis>subtype</emphasis> of <literal moreinfo="none">T</literal>.</para><table id="type-variance-annotations-table"><title>Type variance annotations and their meanings</title><tgroup cols="3"><thead valign="top"><row><entry>Annotation</entry><entry><phrase role="keep-together">Java
            equivalent</phrase></entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para>+</para></entry><entry><para><literal moreinfo="none">? extends T</literal></para></entry><entry><para><emphasis>Covariant</emphasis> subclassing. E.g.,
            <literal moreinfo="none">List[T</literal><subscript>sub</subscript><literal moreinfo="none">]</literal>
            is a subtype of <literal moreinfo="none">List[T]</literal>.</para></entry></row><row><entry><para>-</para></entry><entry><para><literal moreinfo="none">? super T</literal></para></entry><entry><para><emphasis>Contravariant</emphasis> subclassing. E.g.,
            <literal moreinfo="none">X[T</literal><superscript>sup</superscript><literal moreinfo="none">]</literal>
            is a subtype of <literal moreinfo="none">X[T]</literal>.</para></entry></row><row><entry><para><emphasis>none</emphasis></para></entry><entry><para><literal moreinfo="none">T</literal></para></entry><entry><para><emphasis>Invariant</emphasis> subclassing. E.g.,
            Can’t substitute
            <literal moreinfo="none">Y[T</literal><superscript>sup</superscript><literal moreinfo="none">]</literal>
            or
            <literal moreinfo="none">Y[T</literal><subscript>sub</subscript><literal moreinfo="none">]</literal>
            for <literal moreinfo="none">Y[T]</literal>.</para></entry></row></tbody></tgroup></table><para id="para_the_java_equivalent_column">The “Java equivalent” column is
    a bit misleading; we’ll explain why in a moment.<indexterm significance="normal"><primary>invariant subclassing</primary></indexterm><indexterm significance="normal"><primary>covariant subclassing</primary></indexterm><indexterm significance="normal"><primary>contravariant subclassing</primary></indexterm></para><para id="para_class_list_is_declared_list">Class <literal moreinfo="none">List</literal>
    is declared <literal moreinfo="none">List[+A]</literal>, which means that
    <literal moreinfo="none">List[String]</literal> is a subclass of
    <literal moreinfo="none">List[AnyRef]</literal>, so <literal moreinfo="none">Lists</literal> are covariant
    in the type parameter <literal moreinfo="none">A</literal>. (When a type like
    <literal moreinfo="none">List</literal> has only one covariant type parameter, you’ll
    often hear the shorthand expression “Lists are covariant” and similarly
    for types with a single contravariant type parameter.)<indexterm significance="normal"><primary>FunctionN object</primary><secondary>variance under inheritance</secondary></indexterm></para><para id="para_the_declarations_function__n_">The traits
    <literal moreinfo="none">FunctionN</literal>, for <literal moreinfo="none">N</literal> equals 0 to 22, are
    used by Scala to implement function values as true objects. Let’s pick
    <literal moreinfo="none">Function1</literal> as a representative example. It is declared
    <literal moreinfo="none">trait Function1[-T, +R]</literal>.</para><para id="para_the_043_r_is_the_return_ty">The <literal moreinfo="none">+R</literal> is
    the return type and has the covariant annotation <literal moreinfo="none">+</literal>. The
    type for the single argument has the <emphasis>contravariant</emphasis>
    annotation <literal moreinfo="none">-</literal>. For functions with more than one
    argument, all the argument types have the contravariant annotation. So,
    for example, using our <literal moreinfo="none">T</literal>,
    <literal moreinfo="none">T</literal><superscript>sup</superscript>, and
    <literal moreinfo="none">T</literal><subscript>sub</subscript> types, the following
    definition would be legal:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> f:<code role="type"> Function1[T, T]</code> = <code role="statement">new</code> <code role="special">Function1</code><code role="special">[Tsup, Tsub]</code> { ... }
</programlisting><para id="para_hence_the_function_traits_are">Hence, the function traits
    are covariant in the return type parameter <literal moreinfo="none">R</literal> and
    contravariant in the argument parameters
    <literal moreinfo="none">T</literal><subscript>1</subscript><literal moreinfo="none">,
    T</literal><subscript>2</subscript><literal moreinfo="none">, ...,
    T</literal><subscript>N</subscript>.</para><para id="para_so_what_does_this_really_mean_">So, what does this really
    mean? Let’s look at an example to understand the variance behavior. If you
    have prior experience with <emphasis>Design by Contract</emphasis> (see
    <link linkend="DesignByContract" xrefstyle="select:nopage">[DesignByContract]</link>), it might help you to
    recall how it works, which is very similar. (We will discuss Design by
    Contract briefly in <xref linkend="DesignByContractExample"/>.) This
    script demonstrates variance under inheritance:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/variances/func-script.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="statement">class</code> <code role="special">CSuper</code>                { <code role="statement">def</code> <code role="identifier">msuper</code> = println(<code role="constant">"CSuper"</code>) }
<code role="statement">class</code> <code role="special">C</code>      <code role="statement">extends</code> <code role="special">CSuper</code> { <code role="statement">def</code> <code role="identifier">m</code>      = println(<code role="constant">"C"</code>) }
<code role="statement">class</code> <code role="special">CSub</code>   <code role="statement">extends</code> <code role="special">C</code>      { <code role="statement">def</code> <code role="identifier">msub</code>   = println(<code role="constant">"CSub"</code>) }

<code role="statement">var</code> f:<code role="type"> C =&gt; C</code> = (c:<code role="type"> C</code>)      <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">C</code>       <code role="comment">// #1</code>
    f         = (c:<code role="type"> CSuper</code>) <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">CSub</code>    <code role="comment">// #2</code>
    f         = (c:<code role="type"> CSuper</code>) <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">C</code>       <code role="comment">// #3</code>
    f         = (c:<code role="type"> C</code>)      <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">CSub</code>    <code role="comment">// #4</code>
    f         = (c:<code role="type"> CSub</code>)   <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">CSuper</code>  <code role="comment">// #5: ERROR!</code>
</programlisting><para id="para_this_script_doesn_t_produce_an">This script doesn’t produce
    any output. If you run it, it will fail to compile on the last
    line.</para><para id="para_start_with_simple_hierarchy_of_3_classes">We start by
    defining a very simple hierarchy of three classes, <literal moreinfo="none">C</literal>
    and its superclass <literal moreinfo="none">CSuper</literal> and its subtype
    <literal moreinfo="none">CSub</literal>. Each one defines a method, which we’ll exploit
    shortly.</para><para id="para_next_we_define_a_var_named_">Next we define a
    <literal moreinfo="none">var</literal> named <literal moreinfo="none">f</literal> on the line with the #1
    comment. It is a function with the signature <literal moreinfo="none">C =&gt; C</literal>.
    More precisely, it is of type <literal moreinfo="none">Function1(-C,+C)</literal>. To be
    clear, the value assigned to <literal moreinfo="none">f</literal> is after the equals
    sign, <literal moreinfo="none">(c: C) =&gt; new C</literal>. We actually ignore the input
    <literal moreinfo="none">c</literal> value and just create a new
    <literal moreinfo="none">C</literal>.</para><para id="para_now_we_call_applyfunc_passi">Now we assign different
    anonymous function values to <literal moreinfo="none">f</literal>. We use whitespace to
    make the similarities and differences stand out when comparing the
    original declaration of <literal moreinfo="none">f</literal> and the subsequent
    reassignments. We keep reassigning to <literal moreinfo="none">f</literal> because we are
    just testing what will and won’t compile at this point. Specifically, we
    want to know what function values we can legally assign to <literal moreinfo="none">f: (C)
    =&gt; C</literal>.</para><para id="para_the_second_invocation_2_pas">The second assignment on line
    #2 assigns <literal moreinfo="none">(x:CSuper) =&gt; new CSub</literal> as the function
    value. This also works, because the argument to
    <literal moreinfo="none">Function1</literal> is <emphasis>contravariant</emphasis>, so we
    can substitute the <emphasis>supertype</emphasis>, while the return type
    of <literal moreinfo="none">Function1</literal> is <emphasis>covariant</emphasis>, so our
    function value can return an instance of the
    <emphasis>subtype</emphasis>.</para><para id="para_the_next_two_lines_also_work_">The next two lines also
    work. On line #3, we use a <literal moreinfo="none">CSuper</literal> for the argument,
    which works as it did in line #2. We return a <literal moreinfo="none">C</literal>, which
    also works as expected. Similarly, on line #4, we use <literal moreinfo="none">C</literal>
    as the argument and <literal moreinfo="none">CSub</literal> as the return type, both of
    which worked fine in the previous lines.</para><para id="para_the_last_line_does_not_compile">The last line, #5, does not
    compile because we are attempting to use a covariant argument in a
    contravariant position. We’re also attempting to use a contravariant
    return value where only covariant values are allowed.<indexterm significance="normal"><primary>Design by Contract</primary></indexterm></para><para id="para_okay_but__why__is_all_this_co">Why is the behavior correct
    in these cases? Here’s where Design by Contract thinking comes in handy.
    Let’s see how a client might use some of these definitions of
    <literal moreinfo="none">f</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/variances/func2-script.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="statement">class</code> <code role="special">CSuper</code>                { <code role="statement">def</code> <code role="identifier">msuper</code> = println(<code role="constant">"CSuper"</code>) }
<code role="statement">class</code> <code role="special">C</code>      <code role="statement">extends</code> <code role="special">CSuper</code> { <code role="statement">def</code> <code role="identifier">m</code>      = println(<code role="constant">"C"</code>) }
<code role="statement">class</code> <code role="special">CSub</code>   <code role="statement">extends</code> <code role="special">C</code>      { <code role="statement">def</code> <code role="identifier">msub</code>   = println(<code role="constant">"CSub"</code>) }

<code role="statement">def</code> <code role="identifier">useF</code>(f:<code role="type"> C =&gt; C</code>) = {
  <code role="statement">val</code> c1 = <code role="statement">new</code> <code role="special">C</code>     <code role="comment">// #1</code>
  <code role="statement">val</code> c2:<code role="type"> C</code> = f(c1)  <code role="comment">// #2</code>
  c2.msuper          <code role="comment">// #3</code>
  c2.m               <code role="comment">// #4</code>
}

useF((c:<code role="type"> C</code>)      <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">C</code>)        <code role="comment">// #5</code>
useF((c:<code role="type"> CSuper</code>) <code role="statement">=&gt;</code> <code role="statement">new</code> <code role="special">CSub</code>)     <code role="comment">// #6</code>
useF((c:<code role="type"> CSub</code>)   <code role="statement">=&gt;</code> {println(c.msub); <code role="statement">new</code> <code role="special">CSuper</code>})   <code role="comment">// #7: ERROR!</code>
</programlisting><para id="para_the_usef_method_takes_a_func">The <literal moreinfo="none">useF</literal>
    method takes a function <literal moreinfo="none">C =&gt; C</literal> as an argument.
    (We’re just passing function literals now, rather than assigning them to
    <literal moreinfo="none">f</literal>.) It creates a <literal moreinfo="none">C</literal> (line #1) and
    passes it to the input function to create a new <literal moreinfo="none">C</literal> (line
    #2). Then it uses the features of <literal moreinfo="none">C</literal>; namely, it calls
    the <literal moreinfo="none">msuper</literal> and <literal moreinfo="none">m</literal> methods (lines #3
    and #4, respectively).</para><para id="para_in_invocation_2_we_passed_">You could say that the
    <literal moreinfo="none">useF</literal> method specifies a <emphasis>contract</emphasis>
    of behavior. It expects to be passed a function that can take a
    <literal moreinfo="none">C</literal> and return a <literal moreinfo="none">C</literal>. It will call the
    passed-in function, passing a <literal moreinfo="none">C</literal> instance to it, and it
    will expect to receive a <literal moreinfo="none">C</literal> back.<indexterm significance="normal"><primary>contract</primary></indexterm></para><para id="para_in_line_5_we_pass_usef_a_f">In line #5, we pass
    <literal moreinfo="none">useF</literal> a function that takes a <literal moreinfo="none">C</literal> and
    returns a <literal moreinfo="none">C</literal>. The returned <literal moreinfo="none">C</literal> will
    work with lines #3 and #4, by definition. All is good.</para><para id="para_in_line_6_we_pass_in_a_fun">Finally, we come to the point
    of this example. In line #6, we pass in a function that is “willing” to
    accept a <literal moreinfo="none">CSuper</literal> and “promises” to return a
    <literal moreinfo="none">CSub</literal>. That is, this function is type inferred to be
    <literal moreinfo="none">Function1[CSuper,CSub]</literal>. In effect, it widens the
    allowed instances by accepting a supertype. Keep in mind that it will
    never actually be passed a <literal moreinfo="none">CSuper</literal> by
    <literal moreinfo="none">useF</literal>, only a <literal moreinfo="none">C</literal>. However, since it
    can accept a wider set of instances, it will work fine if it only gets
    <literal moreinfo="none">C</literal> instances.</para><para id="para_return_promise">Similarly, by “promising” to return a
    <literal moreinfo="none">CSub</literal>, this anonymous function narrows the possible
    values returned to <literal moreinfo="none">useF</literal>. That’s OK, too, because
    <literal moreinfo="none">useF</literal> will accept any <literal moreinfo="none">C</literal> in return, so
    if it only gets <literal moreinfo="none">CSubs</literal>, it will be happy. Lines #3 and
    #4 will still work.</para><para id="para_applying_the_same_arguments_w">Applying the same arguments,
    we can see why the last line in the script, line #7, fails to compile. Now
    the anonymous function can only accept a <literal moreinfo="none">CSub</literal>, but
    <literal moreinfo="none">useF</literal> will pass it a <literal moreinfo="none">C</literal>. The body of
    the anonymous function would now break, because it calls
    <literal moreinfo="none">c.msub</literal>, which doesn’t exist in <literal moreinfo="none">C</literal>.
    Similarly, returning a <literal moreinfo="none">CSuper</literal> when a
    <literal moreinfo="none">C</literal> is expected breaks line #4 in
    <literal moreinfo="none">useF</literal>, because <literal moreinfo="none">CSuper</literal> doesn’t have
    the <literal moreinfo="none">m</literal> method.</para><para id="para_the_same_arguments_explain_how">The same arguments are used
    to explain how contracts can change under inheritance in Design by
    Contract.</para><para id="para_note_that_variance_annotations">Note that variance
    annotations only make sense on the type parameters for parameterized
    types, not parameterized methods, because the annotations affect the
    behavior of subtyping. Methods aren’t subtyped, but the types that contain
    them might be <phrase role="keep-together">subtyped</phrase>.<indexterm significance="normal"><primary>- (minus sign)</primary><secondary>variance annotations</secondary></indexterm><indexterm significance="normal"><primary>+ (plus sign)</primary><secondary>variance annotations</secondary></indexterm></para><note id="para_note_the_8216_043_8217_"><para>The <literal moreinfo="none">+</literal> <emphasis>variance annotation</emphasis>
      means the parameterized type is <emphasis>covariant</emphasis> in the
      type parameter. The <literal moreinfo="none">-</literal> variance annotation means the
      parameterized type is <emphasis>contravariant</emphasis> in the type
      parameter. No variance annotation means the parameterized type is
      <emphasis>invariant</emphasis> in the type parameter.</para></note><para id="para_finally_the_compiler_checks_y">Finally, the compiler checks
    your use of variance annotations for problems like the one we just
    described in the last lines of the examples. Suppose you attempted to
    define your own function type this way:</para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">MyFunction2</code><code role="special">[+T1, +T2, -R]</code> {
  <code role="statement">def</code> <code role="identifier">apply</code>(v1:<code role="type">T1</code>, v2:<code role="type">T2</code>):<code role="type"> R</code> = { ... }
  ...
}
</programlisting><para id="para_variance_errors_compile_checks">The compiler would throw
    the following errors for the <literal moreinfo="none">apply</literal> method:</para><screen format="linespecific">... error: contravariant type R occurs in covariant position in type (T1,T2)R
       def apply(v1:T1, v2:T2):R
           ^
... error: covariant type T1 occurs in contravariant position in type T1 ...
       def apply(v1:T1, v2:T2):R
                 ^
... error: covariant type T2 occurs in contravariant position in type T2 ...
       def apply(v1:T1, v2:T2):R
                        ^</screen><sect2 id="VarianceOfMutableTypes"><title>Variance of Mutable Types</title><para id="para_all_the_parameterized_types_we">All the parameterized
      types we’ve discussed so far have been immutable types. What about the
      variance behavior of mutable types? The short answer is that only
      <emphasis>invariance</emphasis> is allowed. Consider this
      example:<indexterm significance="normal"><primary>data types</primary><secondary>variance under inheritance</secondary><tertiary>variance of mutable types</tertiary></indexterm><indexterm significance="normal"><primary>variance under inheritance</primary><secondary>variance of mutable types</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/variances/mutable-type-variance-script.scala</code>
<code role="comment">// WON'T COMPILE: Mutable parameterized types can't have variance annotations</code>

<code role="statement">class</code> <code role="special">ContainerPlus</code><code role="special">[+A]</code>(<code role="statement">var</code> value:<code role="type"> A</code>)      <code role="comment">// ERROR</code>
<code role="statement">class</code> <code role="special">ContainerMinus</code><code role="special">[-A]</code>(<code role="statement">var</code> value:<code role="type"> A</code>)     <code role="comment">// ERROR</code>

println( <code role="statement">new</code> <code role="special">ContainerPlus</code>(<code role="constant">"Hello World!"</code>) )
println( <code role="statement">new</code> <code role="special">ContainerMinus</code>(<code role="constant">"Hello World!"</code>) )
</programlisting><para id="para_mutable_type_script_errors">Running this script throws
      the following errors:</para><screen format="linespecific">... 4: error: covariant type A occurs in contravariant position in type A \
    of parameter of setter value_=
class ContainerPlus[+A](var value: A)      // ERROR
                             ^
... 5: error: contravariant type A occurs in covariant position in type =&gt; A \
    of method value
class ContainerMinus[-A](var value: A)     // ERROR
                              ^
two errors found</screen><para id="para_we_can_make_sense_of_these_err">We can make sense of
      these errors by remembering our discussion of
      <literal moreinfo="none">FunctionN</literal> type variance under inheritance, where the
      types of the function arguments are <emphasis>contravariant</emphasis>
      (i.e., <literal moreinfo="none">-T1</literal>) and the return type is
      <emphasis>covariant</emphasis> (i.e., <literal moreinfo="none">+R</literal>).</para><para id="para_the_problem_with_a_mutable_typ">The problem with a
      mutable type is that at least one of its fields has the equivalent of
      read <emphasis>and</emphasis> write operations, either through direct
      access or through accessor methods.</para><para id="para_in_the_first_error_we_are_try">In the first error, we are
      trying to use a covariant type as an argument to a setter (write)
      method, but we saw from our discussion of function types that argument
      types to a method must be contravariant. A covariant type is fine for
      the getter (read) method.</para><para id="para_similarly_for_the_second_erro">Similarly, for the second
      error, we are trying to use a contravariant type as the return value of
      a read method, which must be covariant. For the write method, the
      contravariant type is fine.</para><para id="para_hence_the_compiler_won_t_let_">Hence, the compiler won’t
      let us use a variance annotation on a type that is used for a mutable
      field. For this reason, all the mutable parameterized types in the Scala
      library are <emphasis>invariant</emphasis> in their type parameters.
      Some of them have corresponding immutable types that have covariant or
      contravariant parameters.</para></sect2><sect2 id="VarianceInScalaVsJava"><title>Variance In Scala Versus Java</title><para id="para_in_scala_the_variance_behavio">As we said, the variance
      behavior is defined at the <emphasis>declaration site</emphasis> in
      Scala. In Java, it is defined at the <emphasis>call site</emphasis>. The
      <emphasis>client</emphasis> of a type defines the variance behavior
      desired (see <link linkend="Naftalin2006" xrefstyle="select:nopage">[Naftalin2006]</link>). In other words, when
      you use a Java generic and specify the type parameter, you also specify
      the variance behavior (including invariance, which is the default). You
      can’t specify variance behavior at the definition site in Java, although
      you can use expressions that look similar. Those expressions define
      <emphasis>type bounds</emphasis>, which we’ll discuss shortly.<indexterm class="startofrange" id="ch12_datatypesvarianceSvJ" significance="normal"><primary>data types</primary><secondary>variance under inheritance</secondary><tertiary>variance in Scala versus Java</tertiary></indexterm><indexterm significance="normal"><primary>type bounds</primary></indexterm><indexterm class="startofrange" id="ch12_Javavariance" significance="normal"><primary>Java</primary><secondary>variance</secondary></indexterm><indexterm class="startofrange" id="ch12_varianceSvJ" significance="normal"><primary>variance under inheritance</primary><secondary>variance in Scala versus Java</secondary></indexterm></para><para id="para_in_java_variance_specification">In Java variance
      specifications, a wildcard <literal moreinfo="none">?</literal> always appears before
      the <literal moreinfo="none">super</literal> or <literal moreinfo="none">extends</literal> keyword, as
      shown earlier in <xref linkend="type-variance-annotations-table"/>.
      When we said after the table that the “Java Equivalent” column is a bit
      misleading, we were referring to the differences between declaration
      versus call site specifications. There is another way in which the Scala
      and Java behaviors differ, which we’ll cover in <xref linkend="ExistentialTypes"/>.</para><para id="para_because_variances_in_java_are_">A drawback of call-site
      variance specifications is that they force the users of Java generics to
      understand the type system more thoroughly than is necessary for users
      of Scala parameterized types, who don’t need to specify this behavior
      when using parameterized types. (Scala users also benefit greatly from
      type inference.)</para><para id="para_let_s_look_at_a_java_example_">Let’s look at a Java
      example, a simplified Java version of Scala’s <literal moreinfo="none">Option</literal>,
      <literal moreinfo="none">Some</literal>, and <literal moreinfo="none">None</literal> types:</para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/TypeSystem/variances/Option.java</code>

<code role="preproc">package</code> variances;

<code role="type">abstract</code> <code role="type">public</code> <code role="type">class</code> Option&lt;T&gt; {
  <code role="type">abstract</code> <code role="type">public</code> <code role="type">boolean</code> isEmpty();

  <code role="type">abstract</code> <code role="type">public</code> T get();

  <code role="type">public</code> T getOrElse(T t) {
    <code role="statement">return</code> isEmpty() ? t : get();
  }
}
</programlisting><programlisting language="java" format="linespecific"><code role="comment">// code-examples/TypeSystem/variances/Some.java</code>

<code role="preproc">package</code> variances;

<code role="type">public</code> <code role="type">class</code> Some&lt;T&gt; <code role="type">extends</code> Option&lt;T&gt; {

  <code role="type">public</code> Some(T value) {
    <code role="type">this</code>.value = value;
  }

  <code role="type">public</code> <code role="type">boolean</code> isEmpty() { <code role="statement">return</code> <code role="constant">false</code>; }

  <code role="type">private</code> T value;

  <code role="type">public</code> T get() { <code role="statement">return</code> value; }

  <code role="type">public</code> String toString() {
    <code role="statement">return</code> <code role="constant">"Option("</code> + value + <code role="constant">")"</code>;
  }
}
</programlisting><programlisting language="java" format="linespecific"><code role="comment">// code-examples/TypeSystem/variances/None.java</code>

<code role="preproc">package</code> variances;

<code role="type">public</code> <code role="type">class</code> None&lt;T&gt; <code role="type">extends</code> Option&lt;T&gt; {

  <code role="type">public</code> <code role="type">boolean</code> isEmpty() { <code role="statement">return</code> <code role="constant">true</code>; }

  <code role="type">public</code> T get() { <code role="statement">throw</code> <code role="statement">new</code> java.util.NoSuchElementException(); }

  <code role="type">public</code> String toString() {
    <code role="statement">return</code> <code role="constant">"None"</code>;
  }
}
</programlisting><para id="para_here_is_an_example_that_uses_t">Here is an example that
      uses this Java <literal moreinfo="none">Option</literal> hierarchy:</para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/TypeSystem/variances/OptionExample.java</code>

<code role="preproc">package</code> variances;
<code role="preproc">import</code> java.io.*;
<code role="preproc">import</code> shapes.*;  <code role="comment">// From "Introducing Scala" chapter</code>

<code role="type">public</code> <code role="type">class</code> OptionExample {
  <code role="type">static</code> String[] shapeNames = {<code role="constant">"Rectangle"</code>, <code role="constant">"Circle"</code>, <code role="constant">"Triangle"</code>, <code role="constant">"Unknown"</code>};
  <code role="type">static</code> <code role="type">public</code> <code role="type">void</code> main(String[] args) {

    Option&lt;? <code role="type">extends</code> Shape&gt; shapeOption =
      makeShape(shapeNames[<code role="constant">0</code>], <code role="statement">new</code> Point(<code role="constant">0.</code>,<code role="constant">0.</code>), <code role="constant">2.</code>, <code role="constant">5.</code>);
    print(shapeNames[<code role="constant">0</code>], shapeOption);

    shapeOption = makeShape(shapeNames[<code role="constant">1</code>], <code role="statement">new</code> Point(<code role="constant">0.</code>,<code role="constant">0.</code>), <code role="constant">2.</code>);
    print(shapeNames[<code role="constant">1</code>], shapeOption);

    shapeOption = makeShape(shapeNames[<code role="constant">2</code>],
      <code role="statement">new</code> Point(<code role="constant">0.</code>,<code role="constant">0.</code>), <code role="statement">new</code> Point(<code role="constant">2.</code>,<code role="constant">0.</code>), <code role="statement">new</code> Point(<code role="constant">0.</code>,<code role="constant">2.</code>));
    print(shapeNames[<code role="constant">2</code>], shapeOption);

    shapeOption = makeShape(shapeNames[<code role="constant">3</code>]);
    print(shapeNames[<code role="constant">3</code>], shapeOption);
  }

  <code role="type">static</code> <code role="type">public</code> Option&lt;? <code role="type">extends</code> Shape&gt; makeShape(String shapeName,
      Object<code role="identifier">...</code> args) {
    <code role="statement">if</code> (shapeName == shapeNames[<code role="constant">0</code>])
      <code role="statement">return</code> <code role="statement">new</code> Some&lt;Rectangle&gt;(<code role="statement">new</code> Rectangle((Point) args[<code role="constant">0</code>],
        (Double) args[<code role="constant">1</code>], (Double) args[<code role="constant">2</code>]));
    <code role="statement">else</code> <code role="statement">if</code> (shapeName == shapeNames[<code role="constant">1</code>])
      <code role="statement">return</code> <code role="statement">new</code> Some&lt;Circle&gt;(<code role="statement">new</code> Circle((Point) args[<code role="constant">0</code>], (Double) args[<code role="constant">1</code>]));
    <code role="statement">else</code> <code role="statement">if</code> (shapeName == shapeNames[<code role="constant">2</code>])
      <code role="statement">return</code> <code role="statement">new</code> Some&lt;Triangle&gt;(<code role="statement">new</code> Triangle((Point) args[<code role="constant">0</code>],
        (Point) args[<code role="constant">1</code>], (Point) args[<code role="constant">2</code>]));
    <code role="statement">else</code>
      <code role="statement">return</code> <code role="statement">new</code> None&lt;Shape&gt;();
  }

  <code role="type">static</code> <code role="type">void</code> print(String name, Option&lt;? <code role="type">extends</code> Shape&gt; shapeOption) {
    System.out.println(name + <code role="constant">"? "</code> + shapeOption);
  }
}
</programlisting><para id="para__optionexample_main_uses_the_"><literal moreinfo="none">OptionExample.main</literal>
      uses the <literal moreinfo="none">Shape</literal> hierarchy from <xref linkend="IntroducingScala"/>, but we have updated it slightly to
      exploit features that we’ve learned since then, such as
      <literal moreinfo="none">case</literal> classes:<indexterm class="endofrange" startref="ch12_Javavariance" significance="normal"/></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/shapes/shapes.scala</code>

<code role="preproc">package</code> shapes {
  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Point</code>(x:<code role="type"> Double</code>, y:<code role="type"> Double</code>) {
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"Point("</code> + x + <code role="constant">","</code> + y + <code role="constant">")"</code>
  }

  <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Circle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Rectangle</code>(lowerLeft:<code role="type"> Point</code>, height:<code role="type"> Double</code>, width:<code role="type"> Double</code>)
        <code role="statement">extends</code> <code role="special">Shape</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Rectangle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Triangle</code>(point1:<code role="type"> Point</code>, point2:<code role="type"> Point</code>, point3:<code role="type"> Point</code>)
        <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Triangle.draw: "</code> + <code role="statement">this</code>)
  }
}
</programlisting><para id="para_running_optionexample_with_">Running
      <literal moreinfo="none">OptionExample</literal> with <literal moreinfo="none">scala -cp ...
      variances.OptionExample</literal> produces the following output:</para><screen format="linespecific">Rectangle? Option(Rectangle(Point(0.0,0.0),2.0,5.0))
Circle? Option(Circle(Point(0.0,0.0),2.0))
Triangle? Option(Triangle(Point(0.0,0.0),Point(2.0,0.0),Point(0.0,2.0)))
Unknown? None</screen><para id="para_note_that_we_are_also_demonstr">By the way, we are also
      demonstrating Scala-Java interoperability, which we’ll revisit in <xref linkend="JavaInterop"/>.</para><para id="para__optionexample_main_calls_the"><literal moreinfo="none">OptionExample.main</literal>
      calls the static factory method <literal moreinfo="none">makeShape</literal>, whose
      arguments are the name of a geometric shape and a variable length list
      of parameters to pass to the <literal moreinfo="none">Shape</literal>
      constructors.</para><para id="para_note_that_the_makeshape_retu">Note that
      <literal moreinfo="none">makeShape</literal> returns <literal moreinfo="none">Option&lt;? extends
      Shape&gt;</literal>, and when we instantiate a <literal moreinfo="none">Shape</literal>,
      we return a <literal moreinfo="none">Some</literal> parameterized with the
      <literal moreinfo="none">Shape</literal> subtype it wraps. If an unknown shape name is
      passed in, then we return a <literal moreinfo="none">None&lt;Shape&gt;</literal>. We
      must parameterize a <literal moreinfo="none">None</literal> instance with
      <literal moreinfo="none">Shape</literal>. Because Scala defines a subtype of
      <emphasis>all</emphasis> types, <literal moreinfo="none">Nothing</literal>, Scala can
      define <literal moreinfo="none">None</literal> as <literal moreinfo="none">case object None extends
      Option[Nothing]</literal>.<indexterm significance="normal"><primary>Nothing type</primary></indexterm></para><para id="para_the_java_type_system_provides_">The Java type system
      provides no way to implement our Java <literal moreinfo="none">None</literal> in a
      similar way. Having a singleton object <literal moreinfo="none">None</literal> has a
      number of advantages, including greater efficiency, because we aren’t
      creating lots of little objects, and unambiguous behavior of
      <literal moreinfo="none">equals</literal>, because we don’t need to define the semantics
      of equality between different type instantiations of our Java
      <literal moreinfo="none">None&lt;?&gt;</literal> type—for example,
      <literal moreinfo="none">None&lt;String&gt;</literal> versus
      <literal moreinfo="none">None&lt;Shape&gt;</literal>.</para><para id="para_finally_note_that_main_a_c">Finally, note that
      <literal moreinfo="none">OptionExample</literal>, a client of <literal moreinfo="none">Option</literal>,
      has to specify type variance, <literal moreinfo="none">Option&lt;? extends
      Shape&gt;</literal> in several places. In Scala, the client doesn’t
      carry this burden.<indexterm class="endofrange" startref="ch12_varianceSvJ" significance="normal"/><indexterm class="endofrange" startref="ch12_datatypesvarianceSvJ" significance="normal"/></para></sect2><sect2 id="ImplementationNotes"><title>Implementation Notes</title><para id="para_it_s_worth_noting_how_paramete">The implementation of
      parameterized types and methods is worth noting. The implementations are
      generated when the defining source file is compiled. For each type
      parameter, the implementation assumes that <literal moreinfo="none">Any</literal>
      subtype could be specified (<literal moreinfo="none">Object</literal> is used in Java
      generics). These aspects have performance implications that we will
      revisit when we discuss the <literal moreinfo="none">@specialized</literal> annotation
      in <xref linkend="Annotations"/>.<indexterm class="endofrange" startref="ch12_inheritvariance" significance="normal"/></para></sect2></sect1><sect1 id="TypeBounds"><title>Type Bounds</title><para id="para_when_defining_a_parameterized_">When defining a
    parameterized type or method, it may be necessary to specify
    <emphasis>bounds</emphasis> on the type. For example, a parameterized type
    might assume that a particular type parameter contains certain
    methods.<indexterm class="startofrange" id="ch12_typebounds" significance="normal"><primary>type bounds</primary></indexterm><indexterm class="startofrange" id="ch12_datatypestypebounds" significance="normal"><primary>data types</primary><secondary>type bounds</secondary></indexterm></para><sect2 id="UpperTypeBounds"><title>Upper Type Bounds</title><para id="para_for_example_there_are_several">Consider the overloaded
      <literal moreinfo="none">apply</literal> methods in <literal moreinfo="none">object
      scala.Array</literal> that create new arrays. There are optimized
      implementations for each of the <literal moreinfo="none">AnyVal</literal> types. There
      is another implementation of <literal moreinfo="none">apply</literal> that is
      parameterized for any type that is a subtype of <literal role="keep-together" moreinfo="none">AnyRef</literal>. Here is the implementation in
      Scala version 2.7.5:<indexterm significance="normal"><primary>Array object, apply method overloaded for AnyVal and AnyRef
          types</primary></indexterm><indexterm significance="normal"><primary>upper type bounds</primary></indexterm><indexterm significance="normal"><primary>type bounds</primary><secondary>upper</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">object</code> <code role="special">Array</code> {
  ...
  <code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[A &lt;: AnyRef]</code>(xs:<code role="type"> A</code>*):<code role="type"> Array[A]</code> = {
    <code role="statement">val</code> array = <code role="statement">new</code> <code role="special">Array</code><code role="special">[A]</code>(xs.length)
    <code role="statement">var</code> i = <code role="constant">0</code>
    <code role="statement">for</code> (x <code role="statement">&lt;-</code> xs.elements) { array(i) = x; i += <code role="constant">1</code> }
    array
  }
  ...
}
</programlisting><para id="para_the_type_parameter_a_anyre">The type parameter <literal moreinfo="none">A
      &lt;: AnyRef</literal> means “any type <literal moreinfo="none">A</literal> that is a
      <emphasis>subtype</emphasis> of <literal moreinfo="none">AnyRef</literal>.” Note that a
      type is always a subtype and a supertype of itself, so
      <literal moreinfo="none">A</literal> could also equal <literal moreinfo="none">AnyRef</literal>. So the
      <literal moreinfo="none">&lt;:</literal> operator indicates that the type to the left
      must be derived from the type to the right, or that they must be the
      same type. As we said in <xref linkend="ReservedWords"/>, this operator
      is actually a reserved word in the <phrase role="keep-together">language</phrase>.</para><para id="para_these_bounds_are_called__upper">These bounds are called
      <emphasis>upper type bounds</emphasis>, following the de facto
      convention that diagrams of type hierarchies put subtypes below their
      supertypes. We followed this convention in the diagram shown in <xref linkend="ScalaTypeHierarchy"/>.</para><para id="para_without_the_bound_in_this_case">Without the bound in this
      case, i.e., if the signature were <literal moreinfo="none">def apply[A](xs: A*):
      Array[A]</literal>, the declaration would be ambiguous with the other
      <literal moreinfo="none">apply</literal> methods for each of the
      <literal moreinfo="none">AnyVal</literal> types.</para><note id="para_note_the_type_signature_a_"><para>The type signature <literal moreinfo="none">A &lt;: B</literal> says that
        <literal moreinfo="none">A</literal> must be a <emphasis>subtype</emphasis> of
        <literal moreinfo="none">B</literal>. In Java, this would be expressed as <literal moreinfo="none">A
        extends B</literal> in a type declaration. This is different from
        <emphasis>instantiating</emphasis> a type at a call site, where the
        syntax <literal moreinfo="none">? extends B</literal> is used in Java, indicating the
        <emphasis>variance</emphasis> behavior.</para></note><para id="para_keep_in_mind_the_distinction_b">Keep in mind the
      distinction between type variance and type bounds. For a type like
      <literal moreinfo="none">List</literal>, the <emphasis>variance</emphasis> behavior
      describes how actual types instantiated from it, like
      <literal moreinfo="none">List[AnyRef]</literal> and <literal moreinfo="none">List[String]</literal>, are
      related. In this case, <literal moreinfo="none">List[String]</literal> is a subtype of
      <literal moreinfo="none">List[AnyRef]</literal>, since <literal moreinfo="none">String</literal> is a
      subtype of <literal moreinfo="none">AnyRef</literal>.</para><para id="para_in_contrast_a__type_bound__li">In contrast, lower and
      upper type bounds limit the allowed types that can be used for a type
      parameter when instantiating a type from a parameterized type. For
      example, <literal moreinfo="none">def apply[A &lt;: AnyRef]...</literal> says that any
      type used for <literal moreinfo="none">A</literal> must be a subtype of
      <literal moreinfo="none">AnyRef</literal>.</para></sect2><sect2 id="LowerTypeBounds"><title>Lower Type Bounds</title><para id="para_similarly_there_are_circumsta">Similarly, there are
      circumstances when we might want to express that only
      <literal moreinfo="none">supertypes</literal> of a particular type are allowed. (Recall
      that a type is also a supertype of itself.) We call these
      <emphasis>lower type bounds</emphasis>, again because the allowed type
      would be above the boundary in a typical type hierarchy
      diagram.<indexterm significance="normal"><primary>lower type bounds</primary></indexterm><indexterm significance="normal"><primary>type bounds</primary><secondary>lower</secondary></indexterm></para><para id="para_in_fact_any_method_can_be_par">A particularly interesting
      example is the <literal moreinfo="none">::</literal> (“cons”) method in class
      <literal moreinfo="none">List[+A]</literal>. Recall that this operator is used to create
      a new list by prepending an element to a list:</para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">List</code><code role="special">[+A]</code> {
  ...
  <code role="statement">def</code> ::[<code role="special">B</code> &gt;:<code role="type"> A</code>](x :<code role="type"> B</code>) :<code role="type"> List[B]</code> = <code role="statement">new</code> scala.::(x, <code role="statement">this</code>)
  ...
}
</programlisting><para id="para_the_new_list_is_of_type_scala">The new list will be of
      type <literal moreinfo="none">List[B]</literal>, specifically a
      <literal moreinfo="none">scala.::</literal>. The <literal moreinfo="none">::</literal>
      <emphasis>class</emphasis> (as opposed to the <literal moreinfo="none">::</literal>
      <emphasis>method</emphasis>) is derived from <literal moreinfo="none">List</literal>.
      We’ll come back to it in a moment.</para><para id="para_the_operator_can_prepend_">The <literal moreinfo="none">::</literal>
      method can prepend an object of a different type from
      <literal moreinfo="none">A</literal>, the type of the elements in the original list. The
      compiler will infer the closest common supertype for
      <literal moreinfo="none">A</literal> and the parameter <literal moreinfo="none">x</literal>. It will use
      that supertype as <literal moreinfo="none">B</literal>. Here’s an example that prepends
      a different type of object on a list:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/bounds/list-ab-script.scala</code>

<code role="statement">val</code> languages = <code role="special">List</code>(<code role="constant">"Scala"</code>, <code role="constant">"Java"</code>, <code role="constant">"Ruby"</code>, <code role="constant">"C#"</code>, <code role="constant">"C++"</code>, <code role="constant">"Python"</code>)
<code role="statement">val</code> list = <code role="constant">3.14</code> :: languages
println(list)
</programlisting><para id="para_the_script_prints_the_followin">The script prints the
      following output:</para><screen format="linespecific">List(3.14, Scala, Java, Ruby, C#, C++, Python)</screen><para id="para_the_new_list_of_type_list_any">The new list of type
      <literal moreinfo="none">List[Any]</literal>, since <literal moreinfo="none">Any</literal> is the
      closest common supertype of <literal moreinfo="none">String</literal> and
      <literal moreinfo="none">Double</literal>. We started with a list of
      <literal moreinfo="none">Strings</literal>, so <literal moreinfo="none">A</literal> was
      <literal moreinfo="none">String</literal>. Then we prepended a
      <literal moreinfo="none">Double</literal>, so the compiler inferred <literal moreinfo="none">B</literal>
      to be <literal moreinfo="none">Any</literal>, the closest (and only) common
      supertype.</para><note id="para_note_the_type_signature_b_"><para>The type signature <literal moreinfo="none">B &gt;: A</literal> says that
        <literal moreinfo="none">B</literal> must be a <emphasis>supertype</emphasis> of
        <literal moreinfo="none">A</literal>. There is no analog in Java; <literal moreinfo="none">B super
        A</literal> is not supported.</para></note></sect2><sect2 id="ACloserLookAtLists"><title>A Closer Look at Lists</title><para id="para_putting_these_features_togethe">Putting these features
      together, it’s worth looking at the implementation of the
      <literal moreinfo="none">List</literal> class in the Scala library. It illustrates
      several useful idioms for functional-style, immutable data structures
      that are fully type-safe, yet flexible. We won’t show the entire
      implementation, and we’ll omit the <literal moreinfo="none">object List</literal>, many
      methods in the <literal moreinfo="none">List</literal> class, and the comments that are
      used to generate the Scaladocs. We encourage you to look at the complete
      implementation of <literal moreinfo="none">List</literal>, either by downloading the
      source distribution from the <ulink url="http://www.scala-lang.org/">Scala website</ulink> or by browsing to
      the implementation through the Scaladocs page for
      <literal moreinfo="none">List</literal>. To avoid confusion with
      <literal moreinfo="none">scala.List</literal>, we’ll use our own package and name,
      <literal moreinfo="none">AbbrevList</literal>:<indexterm class="startofrange" id="ch12_typeboundsList" significance="normal"><primary>type bounds</primary><secondary>List class, Scala implementation</secondary></indexterm><indexterm class="startofrange" id="ch12_Listclass" significance="normal"><primary>List class</primary><secondary>Scala implementation</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/bounds/abbrev-list.scala</code>
<code role="comment">// Adapted from scala/List.scala in the Scala version 2.7.5 distribution.</code>

<code role="preproc">package</code> bounds.abbrevlist

<code role="statement">sealed</code> <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">AbbrevList</code><code role="special">[+A]</code> {

  <code role="statement">def</code> <code role="identifier">isEmpty</code>:<code role="type"> Boolean</code>
  <code role="statement">def</code> <code role="identifier">head</code>:<code role="type"> A</code>
  <code role="statement">def</code> <code role="identifier">tail</code>:<code role="type"> AbbrevList[A]</code>

  <code role="statement">def</code> ::[<code role="special">B</code> &gt;:<code role="type"> A</code>] (x:<code role="type"> B</code>):<code role="type"> AbbrevList[B]</code> = <code role="statement">new</code> bounds.abbrevlist.::(x, <code role="statement">this</code>)

  <code role="statement">final</code> <code role="statement">def</code> <code role="identifier">foreach</code>(f:<code role="type"> A =&gt; Unit</code>) = {
    <code role="statement">var</code> these = <code role="statement">this</code>
    <code role="statement">while</code> (!these.isEmpty) {
      f(these.head)
      these = these.tail
    }
  }
}

<code role="comment">// The empty AbbrevList.</code>

<code role="statement">case</code> <code role="statement">object</code> <code role="special">AbbrevNil</code> <code role="statement">extends</code> <code role="special">AbbrevList</code><code role="special">[Nothing]</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">isEmpty</code> = <code role="constant">true</code>

  <code role="statement">def</code> <code role="identifier">head</code>:<code role="type"> Nothing</code> =
    <code role="statement">throw</code> <code role="statement">new</code> <code role="special">NoSuchElementException</code>(<code role="constant">"head of empty AbbrevList"</code>)

  <code role="statement">def</code> <code role="identifier">tail</code>:<code role="type"> AbbrevList[Nothing]</code> =
    <code role="statement">throw</code> <code role="statement">new</code> <code role="special">NoSuchElementException</code>(<code role="constant">"tail of empty AbbrevList"</code>)
}

<code role="comment">// A non-empty AbbrevList characterized by a head and a tail.</code>

<code role="statement">final</code> <code role="statement">case</code> <code role="statement">class</code> ::[<code role="special">B</code>](<code role="statement">private</code> <code role="statement">var</code> hd:<code role="type"> B</code>,
    <code role="statement">private</code>[abbrevlist] <code role="statement">var</code> tl:<code role="type"> AbbrevList[B]</code>) <code role="statement">extends</code> <code role="special">AbbrevList</code><code role="special">[B]</code> {

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">isEmpty</code>:<code role="type"> Boolean</code> = <code role="constant">false</code>
  <code role="statement">def</code> <code role="identifier">head</code> :<code role="type"> B</code> = hd
  <code role="statement">def</code> <code role="identifier">tail</code> :<code role="type"> AbbrevList[B]</code> = tl
}
</programlisting><para id="para_notice_that_while_abbrevlist_">Notice that while
      <literal moreinfo="none">AbbrevList</literal> is immutable, the internal implementation
      uses mutable variables, e.g., in <literal moreinfo="none">forEach</literal>.</para><para id="para_there_are_three_types_defined_">There are three types
      defined, forming a sealed hierarchy. <literal moreinfo="none">AbbrevList</literal> (the
      analog of <literal moreinfo="none">List</literal>) is an abstract trait that declares
      three abstract methods: <literal moreinfo="none">isEmpty</literal>,
      <literal moreinfo="none">head</literal>, and <literal moreinfo="none">tail</literal>. It defines the
      “cons” operator (<literal moreinfo="none">::</literal>) and a <literal moreinfo="none">foreach</literal>
      method. All the other methods found in <literal moreinfo="none">List</literal> could be
      implemented with these methods, although some methods (like
      <literal moreinfo="none">List.length</literal>) use different implementation options for
      efficiency.</para><para id="para__abbrevnil_is_the_analog_of_"><literal moreinfo="none">AbbrevNil</literal> is
      the analog of <literal moreinfo="none">Nil</literal>. It is a case object that extends
      <literal moreinfo="none">AbbrevList[Nothing]</literal>. It returns
      <literal moreinfo="none">true</literal> from <literal moreinfo="none">isEmpty</literal>, and it throws
      an exception from <literal moreinfo="none">head</literal> and <literal moreinfo="none">tail</literal>.
      Because <literal moreinfo="none">AbbrevNil</literal> (and <literal moreinfo="none">Nil</literal>) have
      essentially no state and behavior, having an object rather than a class
      eliminates unnecessary copies, makes <literal moreinfo="none">equals</literal> fast and
      simple, etc.</para><para id="para_the_class_is_final_its_a">The <literal moreinfo="none">::</literal> class
      is the analog of <literal moreinfo="none">scala.::</literal> derived from
      <literal moreinfo="none">List</literal>. It is declared final. Its arguments are the
      element to become the <literal moreinfo="none">head</literal> of the new list and an
      existing list, which will be the <literal moreinfo="none">tail</literal> of the new
      list. Note that these values are stored directly as fields. The
      <literal moreinfo="none">head</literal> and <literal moreinfo="none">tail</literal> methods defined in
      <literal moreinfo="none">AbbrevList</literal> are just reader methods for these fields.
      There is no other data structure required to represent the
      list.<indexterm significance="normal"><primary>: (colon)</primary><secondary>:: class</secondary></indexterm></para><para id="para_this_is_why_prepending_a_new_e">This is why prepending a
      new element to create a new list is an O(1) operation. The
      <literal moreinfo="none">List</literal> class also has a deprecated method
      <literal moreinfo="none">+</literal> for creating a new list by appending an element to
      the end of an existing list. That operation is O(N), where N is the
      length of the list.</para><para id="para_as_you_build_up_new_lists_by_p">As you build up new lists
      by prepending elements to other lists, a nested hierarchy of
      <literal moreinfo="none">::</literal> instances is created. Because the lists are
      immutable, there are no concerns about corruption if one of the
      <literal moreinfo="none">::</literal> is changed in some way.</para><para id="para_you_can_see_this_nesting_if_yo">You can see this nesting
      if you print out a list, exploiting the <literal moreinfo="none">toString</literal>
      method generated because of the <literal moreinfo="none">case</literal> keyword. Here is
      an example <literal moreinfo="none">scala</literal> session:</para><screen format="linespecific">$ scala -cp ...
Welcome to Scala version 2.7.5.final ...
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import bounds.abbrevlist._
import bounds.abbrevlist._

scala&gt; 1 :: 2 :: 3 :: AbbrevNil
res1: bounds.abbrevlist.AbbrevList[Int] = ::(1,::(2,::(3,AbbrevNil)))</screen><para id="para_abbrevnil_to_string_output">Note the output on the last
      line, which shows the nesting of <literal moreinfo="none">(head,tail)</literal>
      elements.</para><para id="para_for_another_example_of_a_simil">For another example using
      similar approaches, this time for defining a stack, refer to <ulink url="http://www.scala-lang.org/node/129"/>.<indexterm class="endofrange" startref="ch12_Listclass" significance="normal"/><indexterm class="endofrange" startref="ch12_typeboundsList" significance="normal"/></para></sect2><sect2 id="ViewsAndViewBounds"><title>Views and View Bounds</title><para id="para_we_ve_seen_many_examples_where">We’ve seen many examples
      where an <literal moreinfo="none">implicit</literal> method was used to convert one type
      to another—for example, to give the appearance of adding new methods to
      an existing type, the so-called Pimp My Library pattern. We used this
      pattern extensively in <xref linkend="DomainSpecificLanguages"/>. You
      can also use function values that have the <literal moreinfo="none">implicit</literal>
      keyword. We’ll see examples of both shortly.<indexterm class="startofrange" id="ch12_views" significance="normal"><primary>views</primary></indexterm><indexterm significance="normal"><primary>type bounds</primary><secondary>views and view bounds</secondary></indexterm></para><para id="para_a__view__is_a_value_of_functio">A
      <emphasis>view</emphasis> is an implicit value of function type that
      converts a type <literal moreinfo="none">A</literal> to <literal moreinfo="none">B</literal>. The
      function has the type <literal moreinfo="none">A =&gt; B</literal> or <literal moreinfo="none">(=&gt; A)
      =&gt; B</literal> (recall that <literal moreinfo="none">(=&gt; A)</literal> is a
      <emphasis>by-name parameter</emphasis>). An in-scope implicit method
      with the same signature can also be used as a view, e.g., an implicit
      method imported from an <literal moreinfo="none">object</literal>. The term
      <emphasis>view</emphasis> conveys the sense of having a view from one
      type (<literal moreinfo="none">A</literal>) to another type
      (<literal moreinfo="none">B</literal>).<indexterm significance="normal"><primary>by-name parameters</primary></indexterm></para><para id="para_a_view_is_applied_in_two_circu">A view is applied in two
      circumstances.</para><orderedlist id="para_1_when_a_type_a_is_used_in_" numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>When a type <literal moreinfo="none">A</literal> is used in a context where
          another type <literal moreinfo="none">B</literal> is expected and there is a view in
          scope that can convert <literal moreinfo="none">A</literal> to
          <literal moreinfo="none">B</literal>.</para></listitem><listitem><para>When a non-existent member <literal moreinfo="none">m</literal> of a type
          <literal moreinfo="none">A</literal> is referenced, but there is an in-scope view
          that can convert <literal moreinfo="none">A</literal> to a <literal moreinfo="none">B</literal> that
          has the <literal moreinfo="none">m</literal> member.</para></listitem></orderedlist><para id="para_a_common_example_of_the_second">A common example of the
      second circumstance is the <literal moreinfo="none">x -&gt; y</literal> initialization
      syntax for <literal moreinfo="none">Maps</literal>, which triggers invocation of
      <literal moreinfo="none">Predef.anyToArrowAssoc(x)</literal>, as we discussed in <xref linkend="PredefObject"/>.</para><para id="para_for_the_first_case_predef_a">For an example of the first
      circumstance, <literal moreinfo="none">Predef</literal> also defines many views for
      converting between <literal moreinfo="none">AnyVal</literal> types and for converting an
      <literal moreinfo="none">AnyVal</literal> type to its corresponding
      <literal moreinfo="none">java.lang</literal> type. For example,
      <literal moreinfo="none">double2Double</literal> converts a
      <literal moreinfo="none">scala.Double</literal> to a
      <literal moreinfo="none">java.lang.Dou⁠ble</literal>.</para><para id="para_a__view_bound__a_b_is_i">A <emphasis>view
      bound</emphasis> in a type declaration is indicated with the
      <literal moreinfo="none">&lt;%</literal> keyword, e.g., <literal moreinfo="none">A &lt;% B</literal>. It
      allows any type to be used for <literal moreinfo="none">A</literal> if it can be
      converted to <literal moreinfo="none">B</literal> using a view.<indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt;% indicating view bound in type
          declaration</secondary></indexterm><indexterm class="startofrange" id="ch12_viewbounds" significance="normal"><primary>view bounds</primary></indexterm></para><para id="para_a_method_or_class_containing_s">A method or class
      containing such a type parameter is treated as being equivalent to a
      corresponding method or class with an extra argument list with one
      element, a view. For example, consider the following method definition
      with a view bound:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">m</code> <code role="identifier">[A &lt;% B]</code>(arglist):<code role="type"> R</code> = ...
</programlisting><para id="para_it_is_effectively_this_method_">It is effectively the
      same as this method definition:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">m</code> <code role="identifier">[A]</code>(arglist)(<code role="statement">implicit</code> viewAB:<code role="type"> A =&gt; B</code>):<code role="type"> R</code> = ...
</programlisting><para id="para_the_implicit_parameter_view_">(The implicit parameter
      <literal moreinfo="none">viewAB</literal> would be given a unique name by the compiler.)
      Note that we have an additional argument list, as opposed to an
      additional argument in the existing argument list.</para><para id="para_why_does_view_bounds_trans_work">Why does this
      transformation work? We said that a valid <literal moreinfo="none">A</literal> must have
      a view in scope that transforms it to a <literal moreinfo="none">B</literal>. The
      implicit <literal moreinfo="none">viewAB</literal> argument will get invoked inside
      <literal moreinfo="none">m</literal> to convert all <literal moreinfo="none">A</literal> instances to
      <literal moreinfo="none">B</literal> instances where needed.</para><para id="para_for_this_to_work_there_must_b">For this to work, there
      must be a view of the correct type in scope to satisfy the implicit
      argument. You could also pass a function with the correct signature
      explicitly as the second argument list when you call
      <literal moreinfo="none">m</literal>. However, there is one situation where this won’t
      work, which we’ll describe after our upcoming example.</para><para id="para_for_view_bounds_on_types_the_">For view bounds on types,
      the implicit view argument list would be added to the primary
      constructor.</para><note id="para_note_traits_can_t_have_view_b"><para>Traits can’t have view bounds for their type parameters, because
        they can’t have constructor argument lists.</para></note><para id="para_to_make_this_more_concrete_le">To make this more
      concrete, let’s use view bounds to implement a
      <literal moreinfo="none">LinkedList</literal> class that uses <literal moreinfo="none">Nodes</literal>,
      where each <literal moreinfo="none">Node</literal> has a <literal moreinfo="none">payload</literal> and
      a reference to the next <literal moreinfo="none">Node</literal> in the list. First, here
      is a hierarchy of <literal moreinfo="none">Nodes</literal>:<indexterm significance="normal"><primary>LinkedList class that uses Nodes (example)</primary></indexterm><indexterm significance="normal"><primary>view bounds</primary><secondary>implementing LinkedList class that uses Nodes</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/bounds/node.scala</code>

<code role="preproc">package</code> bounds

<code role="statement">abstract</code> <code role="statement">trait</code> <code role="special">Node</code><code role="special">[+A]</code> {
  <code role="statement">def</code> <code role="identifier">payload</code>:<code role="type"> A</code>
  <code role="statement">def</code> <code role="identifier">next</code>:<code role="type"> Node[A]</code>
}

<code role="statement">case</code> <code role="statement">class</code> ::[+<code role="special">A</code>](<code role="statement">val</code> payload:<code role="type"> A</code>, <code role="statement">val</code> next:<code role="type"> Node[A]</code>) <code role="statement">extends</code> <code role="special">Node</code><code role="special">[A]</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> =
    String.format(<code role="constant">"(%s :: %s)"</code>, payload.toString, next.toString)
}

<code role="statement">object</code> <code role="special">NilNode</code> <code role="statement">extends</code> <code role="special">Node</code><code role="special">[Nothing]</code> {
  <code role="statement">def</code> <code role="identifier">payload</code> = <code role="statement">throw</code> <code role="statement">new</code> <code role="special">NoSuchElementException</code>(<code role="constant">"No payload in NilNode"</code>)
  <code role="statement">def</code> <code role="identifier">next</code>    = <code role="statement">throw</code> <code role="statement">new</code> <code role="special">NoSuchElementException</code>(<code role="constant">"No next in NilNode"</code>)

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = <code role="constant">"*"</code>
}
</programlisting><para id="para_this_type_hierarchy_looks_a_lo">This type hierarchy is
      modeled after <literal moreinfo="none">List</literal> and <literal moreinfo="none">AbbrevList</literal>
      earlier. The <literal moreinfo="none">::</literal> type represents intermediate nodes,
      and <literal moreinfo="none">NilNode</literal> is analogous to <literal moreinfo="none">Nil</literal>
      for <literal moreinfo="none">Lists</literal>. We also override
      <literal moreinfo="none">toString</literal> to give us convenient output, which we’ll
      examine shortly.</para><para id="para_the_following_script_defines_t">The following script
      defines a <literal moreinfo="none">LinkedList</literal> type that uses
      <literal moreinfo="none">Nodes</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/bounds/view-bounds-script.scala</code>

<code role="preproc">import</code> bounds._

<code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">any2Node</code><code role="identifier">[A]</code>(x:<code role="type"> A</code>):<code role="type"> Node[A]</code> = bounds.::[<code role="special">A</code>](x, <code role="special">NilNode</code>)

<code role="statement">case</code> <code role="statement">class</code> <code role="special">LinkedList</code><code role="special">[A &lt;% Node[A]]</code>(<code role="statement">val</code> head:<code role="type"> Node[A]</code>) {

  <code role="statement">def</code> ::[<code role="special">B</code> &gt;:<code role="type"> A</code> &lt;% <code role="special">Node</code><code role="special">[B]</code>](x:<code role="type"> Node[B]</code>) =
    <code role="special">LinkedList</code>(bounds.::(x.payload, head))

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = head.toString
}

<code role="statement">val</code> list1 = <code role="special">LinkedList</code>(<code role="constant">1</code>)
<code role="statement">val</code> list2 = <code role="constant">2</code> :: list1
<code role="statement">val</code> list3 = <code role="constant">3</code> :: list2
<code role="statement">val</code> list4 = <code role="constant">"FOUR!"</code> :: list3

println(list1)
println(list2)
println(list3)
println(list4)
</programlisting><para id="para_it_starts_with_a_definition_of">It starts with a
      definition of a parameterized implicit method,
      <literal moreinfo="none">any2Node</literal>, that converts <literal moreinfo="none">A</literal> to
      <literal moreinfo="none">Node[A]</literal>. It will be used as the implicit view
      argument when we work with <literal moreinfo="none">LinkedLists</literal>. It creates a
      “leaf” node using a <literal moreinfo="none">bounds.::</literal> node with a reference
      to <literal moreinfo="none">NilNode</literal> as the “next” element in the list.</para><para id="para_an_alternative_would_be_a_func">An alternative would be a
      function value that converts <literal moreinfo="none">Any</literal> to
      <literal moreinfo="none">Node[Any]</literal>:</para><programlisting language="scala" format="linespecific"><code role="statement">implicit</code> <code role="statement">val</code> any2Node = (a:<code role="type"> Any</code>) <code role="statement">=&gt;</code> bounds.::[<code role="special">Any</code>](a, <code role="special">NilNode</code>)
</programlisting><para id="para_otherwise_the_script_would_ru">Otherwise, the script
      would run the same, except that some of the temporary lists would be
      using <literal moreinfo="none">Node[Any]</literal> rather than
      <literal moreinfo="none">Node[Int]</literal>.</para><para id="para_look_at_the_declaration_of_li">Look at the declaration of
      <literal moreinfo="none">LinkedList</literal>:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="statement">class</code> <code role="special">LinkedList</code><code role="special">[A &lt;% Node[A]]</code>(<code role="statement">val</code> head:<code role="type"> Node[A]</code>) { ... }
</programlisting><para id="para_it_defines_a_view_bound_on_a_">It defines a view bound on
      <literal moreinfo="none">A</literal> and takes a single argument, the head
      <literal moreinfo="none">Node</literal> of the list (which may be the head of a chain of
      <literal moreinfo="none">Nodes</literal>). As we see later in the script, even though
      the constructor expects a <literal moreinfo="none">Node[A]</literal> argument, we can
      pass it an <literal moreinfo="none">A</literal> and the implicit view
      <literal moreinfo="none">any2Node</literal> will get invoked. The beauty of this
      approach is that a client never has to worry about proper construction
      of <literal moreinfo="none">Nodes</literal>. The machinery handles that process
      automatically.</para><para id="para_the_class_also_has_a_cons_">The class also has a “cons”
      operator:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> ::[<code role="special">B</code> &gt;:<code role="type"> A</code> &lt;% <code role="special">Node</code><code role="special">[B]</code>](x:<code role="type"> Node[B]</code>) = ...
</programlisting><para id="para_the_type_parameter_means_b_">The type parameter means
      ``<literal moreinfo="none">B</literal> is lower bounded by (i.e., is a supertype of)
      <literal moreinfo="none">A</literal>, and <literal moreinfo="none">B</literal> also has a view bound of
      <literal moreinfo="none">B &lt;% Node[B]</literal>. As we saw for
      <literal moreinfo="none">List</literal> and <literal moreinfo="none">AbbrevList</literal>, the lower
      bound allows us to prepend items of different types from the original
      <literal moreinfo="none">A</literal> type. This method will have its own implicit view
      argument, but our parameterized, implicit method,
      <literal moreinfo="none">any2Node</literal>, will be used for this argument, too.</para><para id="para_we_mentioned_previously_that_i">We mentioned previously
      that if you don’t have a view in scope, you could pass a “non-implicit”
      converter as the second argument list explicitly. This actually won’t
      work in our example, because the constructor and <literal moreinfo="none">::</literal>
      method in <literal moreinfo="none">LinkedList</literal> take <literal moreinfo="none">Node[A]</literal>
      arguments, but we call them with <literal moreinfo="none">Ints</literal> and
      <literal moreinfo="none">Strings</literal>. We would have to call them with
      <literal moreinfo="none">Node[Int]</literal> and <literal moreinfo="none">Node[String]</literal>
      arguments explicitly. We would also have to invoke <literal moreinfo="none">::</literal>
      in an ugly way—<literal moreinfo="none">val list2 = list1.::(2)(converter)</literal>,
      for example.</para><para id="para_even_though_it_looks_like_the_">Let’s clarify the syntax
      a bit. When you see <literal moreinfo="none">B &gt;: A &lt;% Node[B]</literal>, it’s
      tempting to assume that the <literal moreinfo="none">&lt;%</literal> should apply to
      <literal moreinfo="none">A</literal> in this expression. It actually applies to
      <literal moreinfo="none">B</literal>. The grammar for type parameters, including view
      bounds, is the following (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>):</para><programlisting language="scala" format="linespecific"><code role="special">TypeParam</code> ::= (id | â~@~X<code role="statement">_</code>â~@~Y) [<code role="special">TypeParamClause</code>] [â~@~X&gt;:â~@~Y <code role="special">Type</code>] [â~@~X&lt;:â~@~Y <code role="special">Type</code>] [â~@~X&lt;%â~@~Y <code role="special">Type</code>]
<code role="special">TypeParamClause</code> ::= â~@~X[â~@~Y <code role="special">VariantTypeParam</code> {â~@~X,â~@~Y <code role="special">VariantTypeParam</code>} â~@~X]â~@~Y
<code role="special">VariantTypeParam</code> ::= [â~@~X+â~@~Y | â~@~Xâ~@~Y] <code role="special">TypeParam</code>
</programlisting><para id="para_so_yes_you_can_have_some_ver">So, yes, you can have some
      very complex, hierarchical types! In our <literal moreinfo="none">::</literal> method,
      the <literal moreinfo="none">id</literal> is <literal moreinfo="none">B</literal>, the
      <literal moreinfo="none">TypeParamClause</literal> is empty, and we have the
      <literal moreinfo="none">&gt;: A</literal> and <literal moreinfo="none">&lt;% Node[B]</literal>
      expressions on the right. Again, all the bounds expressions apply to the
      first <literal moreinfo="none">id</literal> (<literal moreinfo="none">B</literal>) or the underscore
      ( <literal moreinfo="none">_</literal> ).</para><para id="para_you_would_use_the_underscore_">The underscore is used for
      <emphasis>existential types</emphasis>, which we’ll cover in <xref linkend="ExistentialTypes"/>.<indexterm significance="normal"><primary>existential types</primary></indexterm></para><para id="para_finally_we_create_a_linkedli">Finally, we create a
      <literal moreinfo="none">LinkedList</literal> in the script, prepend some values to
      create new lists, and then print them out:</para><screen format="linespecific">1 :: *
2 :: 1 :: *
3 :: 2 :: 1 :: *
FOUR! :: 3 :: 2 :: 1 :: *</screen><para id="para_again_the_view_bounds_let_us_">To recap, the view bounds
      let us work with “payloads” of <literal moreinfo="none">Ints</literal> and
      <literal moreinfo="none">Strings</literal> while the implementation handled the
      necessary conversions to <literal moreinfo="none">Nodes</literal>.</para><para id="para_view_bounds_are_not_used_as_of">View bounds are not used
      as often as upper and lower bounds, but they provide an elegant
      mechanism for those times when automatic coercion from one type into
      another is useful. As always, use implicits with caution; implicit
      conversions are far from obvious when reading code and debugging
      mysterious behavior.<indexterm class="endofrange" startref="ch12_viewbounds" significance="normal"/><indexterm class="endofrange" startref="ch12_views" significance="normal"/><indexterm class="endofrange" startref="ch12_typebounds" significance="normal"/><indexterm class="endofrange" startref="ch12_datatypestypebounds" significance="normal"/></para></sect2></sect1><sect1 id="NothingAndNull"><title>Nothing and Null</title><para id="para_nothing_and_null">In <xref linkend="ScalaTypeHierarchy"/>,
    we mentioned that <literal moreinfo="none">Null</literal> is a subtype of all
    <literal moreinfo="none">AnyRef</literal> types and <literal moreinfo="none">Nothing</literal> is a
    subtype of all types, including <literal moreinfo="none">Null</literal>.<indexterm significance="normal"><primary>data types</primary><secondary>Nothing and Null</secondary></indexterm></para><para id="para__null_is_declared_as_a_final"><literal moreinfo="none">Null</literal> is
    declared as a <literal moreinfo="none">final trait</literal> (so it can’t be subtyped),
    and it has only one instance, <literal moreinfo="none">null</literal>. Since
    <literal moreinfo="none">Null</literal> is a subtype of all <literal moreinfo="none">AnyRef</literal>
    types, you can always assign <literal moreinfo="none">null</literal> as an instance of any
    of those types. Java, in contrast, simply treats <literal moreinfo="none">null</literal>
    as a keyword with special handling by the compiler. However, Java’s
    <literal moreinfo="none">null</literal> actually behaves as if it were a subtype of all
    reference types, just like Scala’s <literal moreinfo="none">Null</literal>.<indexterm significance="normal"><primary>Null object</primary></indexterm></para><para id="para_null_not_subtype_of_anyval">On the other hand, since
    <literal moreinfo="none">Null</literal> is not a subtype of <literal moreinfo="none">AnyVal</literal>, it
    is not possible to assign <literal moreinfo="none">null</literal> to an
    <literal moreinfo="none">Int</literal>, for example, which is also consistent with the
    primitive semantics in Java.</para><para id="para_for_example_nil_is_of_type_"><literal moreinfo="none">Nothing</literal> is
    also a <literal moreinfo="none">final trait</literal>, but it has no instances. However,
    it is still useful for defining types. The best example is
    <literal moreinfo="none">Nil</literal>, the empty list, which is a <literal moreinfo="none">case
    object</literal>. It is of type <literal moreinfo="none">List[Nothing]</literal>. Because
    lists are covariant in Scala, as we saw earlier, this makes
    <literal moreinfo="none">Nil</literal> an instance of <literal moreinfo="none">List[T]</literal>, for any
    type T. We also exploited this feature in our
    <literal moreinfo="none">AbbrevList</literal> and <literal moreinfo="none">LinkedList</literal>
    implementations.<indexterm significance="normal"><primary>List class</primary><secondary>Nil case object</secondary></indexterm><indexterm significance="normal"><primary>Nil case object</primary></indexterm><indexterm significance="normal"><primary>Nothing type</primary></indexterm></para></sect1><sect1 id="_understanding_abstract_types"><title>Understanding Abstract Types</title><para id="para_what_are_abstract_types">Besides parameterized types, which
    are common in statically typed, object-oriented <phrase role="keep-together">languages</phrase>, Scala also supports abstract
    types, which are common in functional <phrase role="keep-together">languages</phrase>. We introduced abstract types in
    <xref linkend="AbstractTypesAndParameterizedTypes"/>.<indexterm class="startofrange" id="ch12_abstracttypes" significance="normal"><primary>abstract types</primary></indexterm><indexterm class="startofrange" id="ch12_datatypesabstract" significance="normal"><primary>data types</primary><secondary>abstract</secondary></indexterm></para><para id="para_these_two_features_overlap_som">These two features overlap
    somewhat. Technically, you could implement almost all the idioms that
    parameterized types support using abstract types and vice versa. However,
    in practice, each feature is a natural fit for different design
    problems.</para><para id="para_recall_our_version_of_observe">Recall our version of
    <literal moreinfo="none">Observer</literal> that uses abstract types in <xref linkend="AdvancedObjectOrientedProgramming"/>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/observer/observer2.scala</code>

<code role="preproc">package</code> observer

<code role="statement">trait</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code>

  <code role="statement">private</code> <code role="statement">var</code> observers = <code role="special">List</code><code role="special">[Observer]</code>()
  <code role="statement">def</code> <code role="identifier">addObserver</code>(observer:<code role="type">Observer</code>) = observers ::= observer
  <code role="statement">def</code> <code role="identifier">notifyObservers</code> = observers foreach (notify(<code role="statement">_</code>))

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code>
}

<code role="statement">trait</code> <code role="special">SubjectForReceiveUpdateObservers</code> <code role="statement">extends</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = { <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> Any</code>) }

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code> = observer.receiveUpdate(<code role="statement">this</code>)
}

<code role="statement">trait</code> <code role="special">SubjectForFunctionalObservers</code> <code role="statement">extends</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = (<code role="special">AbstractSubject</code>) <code role="statement">=&gt;</code> <code role="special">Unit</code>

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code> = observer(<code role="statement">this</code>)
}
</programlisting><para id="para__abstractsubject_declares_a_t"><literal moreinfo="none">AbstractSubject</literal>
    declares a type <literal moreinfo="none">Observer</literal> with no type bounds. It is
    defined in the two derived traits. In
    <literal moreinfo="none">SubjectForReceiveUpdateObservers</literal>, it is defined to be a
    <emphasis>structural type</emphasis>. In
    <literal moreinfo="none">SubjectForFunctionalObservers</literal>, it is defined to be a
    <emphasis>function type</emphasis>. We’ll have more to say about
    structural and function types later in this chapter.</para><para id="para_we_can_also_use_type_bounds_wh">We can also use type bounds
    when we declare or refine the declaration of abstract types. We saw a
    simple example previously in <xref linkend="TypeProjections"/> where we
    had a declaration <literal moreinfo="none">type t &lt;: AnyRef</literal>. That is,
    <literal moreinfo="none">t</literal> had an upper type bound (superclass) of
    <literal moreinfo="none">AnyRef</literal>. <literal moreinfo="none">AnyVal</literal> types weren’t
    allowed.<indexterm significance="normal"><primary>upper type bounds</primary></indexterm><indexterm significance="normal"><primary>type bounds</primary><secondary>using in abstract type declarations</secondary></indexterm></para><para id="para_we_can_also_have__lower_bounds">We can also have lower type
    bounds (subclasses), and we can use most of the <emphasis>value
    type</emphasis>s (see <xref linkend="ValueTypes"/>) in the bounds
    expressions. Here is an example illustrating the most common
    options:<indexterm significance="normal"><primary>value types</primary><secondary>use in type bounds expressions</secondary></indexterm><indexterm significance="normal"><primary>lower type bounds</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/abstracttypes/abs-type-examples-script.scala</code>

<code role="statement">trait</code> <code role="special">exampleTrait</code> {
  <code role="statement">type</code> t1               <code role="comment">// Unconstrained</code>
  <code role="statement">type</code> t2 &gt;:<code role="type"> t3 &lt;: t1</code>   <code role="comment">// t2 must be a supertype of t3 and a subtype of t1</code>
  <code role="statement">type</code> t3 &lt;:<code role="type"> t1</code>         <code role="comment">// t3 must be a subtype of t1</code>
  <code role="statement">type</code> t4               <code role="comment">// Unconstrained</code>
  <code role="statement">type</code> t5 = <code role="special">List</code><code role="special">[t4]</code>    <code role="comment">// List of t4, whatever t4 will eventually be...</code>

  <code role="statement">val</code> v1:<code role="type"> t1</code>            <code role="comment">// Can't initialize until t1 defined.</code>
  <code role="statement">val</code> v3:<code role="type"> t3</code>            <code role="comment">// etc.</code>
  <code role="statement">val</code> v2:<code role="type"> t2</code>            <code role="comment">// ...</code>
  <code role="statement">val</code> v4:<code role="type"> t4</code>            <code role="comment">// ...</code>
  <code role="statement">val</code> v5:<code role="type"> t5</code>            <code role="comment">// ...</code>
}

<code role="statement">trait</code> <code role="special">T1</code> { <code role="statement">val</code> name1:<code role="type"> String</code> }
<code role="statement">trait</code> <code role="special">T2</code> <code role="statement">extends</code> <code role="special">T1</code> { <code role="statement">val</code> name2:<code role="type"> String</code> }
<code role="statement">class</code> <code role="special">C</code>(<code role="statement">val</code> name1:<code role="type"> String</code>, <code role="statement">val</code> name2:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">T2</code>

<code role="statement">object</code> <code role="special">example</code> <code role="statement">extends</code> exampleTrait {
  <code role="statement">type</code> t1 = <code role="special">T1</code>
  <code role="statement">type</code> t2 = <code role="special">T2</code>
  <code role="statement">type</code> t3 = <code role="special">C</code>
  <code role="statement">type</code> t4 = <code role="special">Int</code>

  <code role="statement">val</code> v1 = <code role="statement">new</code> <code role="special">T1</code> { <code role="statement">val</code> name1 = <code role="constant">"T1"</code>}
  <code role="statement">val</code> v3 = <code role="statement">new</code> <code role="special">C</code>(<code role="constant">"C1"</code>, <code role="constant">"C2"</code>)
  <code role="statement">val</code> v2 = <code role="statement">new</code> <code role="special">T2</code> { <code role="statement">val</code> name1 = <code role="constant">"T1"</code>; <code role="statement">val</code> name2 = <code role="constant">"T2"</code> }
  <code role="statement">val</code> v4 = <code role="constant">10</code>
  <code role="statement">val</code> v5 = <code role="special">List</code>(<code role="constant">1</code>,<code role="constant">2</code>,<code role="constant">3</code>,<code role="constant">4</code>,<code role="constant">5</code>)
}
</programlisting><para id="para_the_comments_explain_most_of_t">The comments explain most
    of the details. The relationships between <literal moreinfo="none">t1</literal>,
    <literal moreinfo="none">t2</literal>, and <literal moreinfo="none">t3</literal> have some interesting
    points. First, the declaration of <literal moreinfo="none">t2</literal> says that it must
    be “between” <literal moreinfo="none">t1</literal> and <literal moreinfo="none">t3</literal>. Whatever
    <literal moreinfo="none">t1</literal> becomes, it must be a super class of
    <literal moreinfo="none">t2</literal> (or equal to it), and <literal moreinfo="none">t3</literal> must be
    a subclass of <literal moreinfo="none">t2</literal> (or equal to it).</para><para id="para_remember_from_typebounds">Remember from <xref linkend="TypeBounds"/> that we are making a declaration of the
    <emphasis>first</emphasis> type after the <literal moreinfo="none">type</literal> keyword,
    <literal moreinfo="none">t2</literal>, not the type in the middle, <literal moreinfo="none">t3</literal>.
    The rest of <phrase role="keep-together">the expression</phrase> is
    telling us the bounds of <literal moreinfo="none">t2</literal>.</para><para id="para_consider_the_next_line_that_de">Consider the next line that
    declares <literal moreinfo="none">t3</literal> to be a subtype of <literal moreinfo="none">t1</literal>.
    If you were to omit the type bound, the compiler would throw an error,
    because <literal moreinfo="none">t3 &lt;: t1</literal> is implied by the previous
    declaration of <literal moreinfo="none">t2</literal>. That doesn’t mean that you can leave
    out the declaration of <literal moreinfo="none">t3</literal>. It has to be there, but it
    also has to show a consistent type bound with the one implied in the
    <literal moreinfo="none">t2</literal> declaration.</para><para id="para_when_we_revisit_the_observer_p">When we revisit the
    Observer Pattern in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>, we’ll see another
    example of type bounds used on abstract types. We’ll see a problem they
    can cause, along with an elegant solution.</para><para id="para_finally_abstract_types_don_t_">Finally, abstract types
    don’t have variance annotations:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/abstracttypes/abs-type-variances-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="statement">trait</code> <code role="special">T1</code> { <code role="statement">val</code> name1:<code role="type"> String</code> }
<code role="statement">trait</code> <code role="special">T2</code> <code role="statement">extends</code> <code role="special">T1</code> { <code role="statement">val</code> name2:<code role="type"> String</code> }
<code role="statement">class</code> <code role="special">C</code>(<code role="statement">val</code> name1:<code role="type"> String</code>, <code role="statement">val</code> name2:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">T2</code>

<code role="statement">trait</code> <code role="special">T</code> {
  <code role="statement">type</code> t: +<code role="special">T1</code>   <code role="comment">// ERROR, no +/- type variance annotations</code>
  <code role="statement">val</code> v
}
</programlisting><para id="para_remember_that_the_types_are__m">Remember that the abstract
    types are <emphasis>members</emphasis> of the enclosing type, not type
    parameters, as for parameterized types. The enclosing type may have an
    inheritance relationship with other types, but member types behave just
    like member methods and <phrase role="keep-together">variables</phrase>.
    They don’t affect the inheritance relationships of their enclosing type.
    Like other members, abstract types can be declared abstract or concrete.
    However, they can also be refined in subtypes without being fully defined,
    unlike variables and methods. Of course, instances can only be created
    when the abstract types are given concrete <phrase role="keep-together">definitions</phrase>.</para><sect2 id="_parameterized_types_vs_abstract_types"><title>Parameterized Types Versus Abstract Types</title><para id="para_when_to_use_one__vs___the_othe">When should you use
      parameterized types versus abstract types? Parameterized types are the
      most natural fit for parameterized container types like
      <literal moreinfo="none">List</literal> and <literal moreinfo="none">Option</literal>. Consider the
      declaration of <literal moreinfo="none">Some</literal> from the standard
      library:<indexterm significance="normal"><primary>data types</primary><secondary>abstract</secondary><tertiary>parameterized types versus</tertiary></indexterm><indexterm significance="normal"><primary>parameterized types</primary><secondary>abstract types versus</secondary></indexterm><indexterm significance="normal"><primary>abstract types</primary><secondary>parameterized types versus</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="statement">final</code> <code role="statement">class</code> <code role="special">Some</code><code role="special">[+A]</code>(<code role="statement">val</code> x :<code role="type"> A</code>) { ... }
</programlisting><para id="para_if_we_tried_to_convert_this_to">If we tried to convert
      this to use abstract types, we might start with the following:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> <code role="statement">final</code> <code role="statement">class</code> <code role="special">Some</code>(<code role="statement">val</code> x : ???) {
  <code role="statement">type</code> <code role="special">A</code>
  ...
}
</programlisting><para id="para_what_should_be_the_type_of_the">What should be the type
      of the field <literal moreinfo="none">x</literal>? We can’t use <literal moreinfo="none">A</literal>
      because it’s not in scope at the point of the constructor argument. We
      could use <literal moreinfo="none">Any</literal>, but that defeats the value of having
      appropriately typed declarations.</para><para id="para_if_a_type_will_have_constructo">If a type will have
      constructor arguments declared using a “placeholder” type that has not
      yet been defined, then parameterized types are the only good solution
      (short of using <literal moreinfo="none">Any</literal> or
      <literal moreinfo="none">AnyRef</literal>).</para><para id="para_you_can_use_abstract_types_as_">You can use abstract
      types as method arguments and return values within a function. However,
      two problems can arise. First, you can run into problems with <phrase role="keep-together">path-</phrase><phrase role="keep-together">dependent</phrase> types (discussed in <xref linkend="PathDependentTypes"/>), where the compiler thinks you are
      trying to use an incompatible type in a particular context, when in fact
      they are paths to compatible types. Second, it’s awkward to express
      methods like <literal moreinfo="none">List.::</literal> (“cons”) using abstract types
      where type changes (expansion in this case) can occur:<indexterm significance="normal"><primary>methods</primary><secondary>abstract types as arguments</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">List</code><code role="special">[+A]</code> {
  ...
  <code role="statement">def</code> ::[<code role="special">B</code> &gt;:<code role="type"> A</code>](x :<code role="type"> B</code>) :<code role="type"> List[B]</code> = <code role="statement">new</code> scala.::(x, <code role="statement">this</code>)
  ...
}
</programlisting><para id="para_also_if_you_want_to_express_v">Also, if you want to
      express variance under inheritance that is tied to the type
      abstractions, then parameterized types with variance annotations make
      these behaviors obvious and explicit.<indexterm significance="normal"><primary>variance under inheritance</primary><secondary>abstract versus parameterized types</secondary></indexterm></para><para id="para_these_limitations_of_abstract_">These limitations of
      abstract types really reflect the tension between object-oriented
      inheritance and the origin of abstract types in pure functional
      programming type <phrase role="keep-together">systems</phrase>, which
      don’t have inheritance. Parameterized types are more popular in
      object-oriented languages because they handle inheritance more naturally
      in most <phrase role="keep-together">circumstances</phrase>.</para><para id="para_on_the_other_hand_when_you_wa">On the other hand,
      sometimes it’s useful to refer to a type abstraction as a member of
      another type, as opposed to a parameter used to construct new types from
      a parameterized type. Refining an abstract type declaration through a
      series of enclosing type refinements can be quite elegant:</para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">T1</code> {
  <code role="statement">type</code> t
  <code role="statement">val</code> v:<code role="type"> t</code>
}
<code role="statement">trait</code> <code role="special">T2</code> <code role="statement">extends</code> <code role="special">T1</code> {
  <code role="statement">type</code> t &lt;:<code role="type"> SomeType1</code>
}
<code role="statement">trait</code> <code role="special">T3</code> <code role="statement">extends</code> <code role="special">T2</code> {
  <code role="statement">type</code> t &lt;:<code role="type"> SomeType2</code>  <code role="comment">// where SomeType2 &lt;: SomeType1</code>
}
<code role="statement">class</code> <code role="special">C</code> <code role="statement">extends</code> <code role="special">T3</code> {
  <code role="statement">type</code> t = <code role="special">Concrete</code>    <code role="comment">// where Concrete &lt;: SomeType2</code>
  <code role="statement">val</code> v = <code role="statement">new</code> <code role="special">Concrete</code>(...)
}
...
</programlisting><para id="para_abstract_types_are_often_used_">This example also shows
      that abstract types are often used to declare abstract variables of the
      same type. Less frequently, they are used for method
      declarations.</para><para id="para_when_the_abstract_variables_ar">When the abstract
      variables are eventually made concrete, they can either be defined
      inside the type body, much as they were originally declared, or they can
      be initialized through constructor arguments. Using constructor
      arguments lets the user decide on the actual values, while initializing
      them in the body lets the type designer decide on the appropriate
      value.</para><para id="para_we_used_constructor_arguments_">We used constructor
      arguments in the brief <literal moreinfo="none">BulkReader</literal> example we
      presented in <xref linkend="AbstractTypesAndParameterizedTypes"/>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/abstract-types-script.scala</code>

<code role="preproc">import</code> java.io._

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code>
  <code role="statement">val</code> source:<code role="type"> In</code>
  <code role="statement">def</code> <code role="identifier">read</code>:<code role="type"> String</code>
}

<code role="statement">class</code> <code role="special">StringBulkReader</code>(<code role="statement">val</code> source:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code> = <code role="special">String</code>
  <code role="statement">def</code> <code role="identifier">read</code> = source
}

<code role="statement">class</code> <code role="special">FileBulkReader</code>(<code role="statement">val</code> source:<code role="type"> File</code>) <code role="statement">extends</code> <code role="special">BulkReader</code> {
  <code role="statement">type</code> <code role="special">In</code> = <code role="special">File</code>
  <code role="statement">def</code> <code role="identifier">read</code> = {
    <code role="statement">val</code> in = <code role="statement">new</code> <code role="special">BufferedInputStream</code>(<code role="statement">new</code> <code role="special">FileInputStream</code>(source))
    <code role="statement">val</code> numBytes = in.available()
    <code role="statement">val</code> bytes = <code role="statement">new</code> <code role="special">Array</code><code role="special">[Byte]</code>(numBytes)
    in.read(bytes, <code role="constant">0</code>, numBytes)
    <code role="statement">new</code> <code role="special">String</code>(bytes)
  }
}

println( <code role="statement">new</code> <code role="special">StringBulkReader</code>(<code role="constant">"Hello Scala!"</code>).read )
println( <code role="statement">new</code> <code role="special">FileBulkReader</code>(<code role="statement">new</code> <code role="special">File</code>(<code role="constant">"abstract-types-script.scala"</code>)).read )
</programlisting><para id="para_if_you_come_from_an_object_ori">If you come from an
      object-oriented background, you will naturally tend to use parameterized
      types more often than abstract types. The Scala standard library tends
      to emphasize parameterized types, too. Still, you should learn the
      merits of abstract types and use them when they make sense.<indexterm class="endofrange" startref="ch12_abstracttypes" significance="normal"/><indexterm class="endofrange" significance="normal"/></para></sect2></sect1><sect1 id="PathDependentTypes"><title>Path-Dependent Types</title><para id="para_languages_that_let_you_nest_ty">Languages that let you nest
    types provide ways to refer to those type <emphasis>paths</emphasis>.
    Scala provides a rich syntax for path-dependent types. Although you will
    probably use them rarely, it’s useful to understand the basics, as
    compiler errors often contain type paths.<indexterm significance="normal"><primary>data types</primary><secondary>path-dependent types</secondary></indexterm><indexterm significance="normal"><primary>path-dependent types</primary></indexterm></para><para id="para_path_dependent_types">Consider the following
    example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/typepaths/type-path-wont-compile.scala</code>
<code role="comment">// ERROR: Won't compile</code>

<code role="statement">trait</code> <code role="special">Service</code> {
  <code role="statement">trait</code> <code role="special">Logger</code> {
    <code role="statement">def</code> <code role="identifier">log</code>(message:<code role="type"> String</code>):<code role="type"> Unit</code>
  }
  <code role="statement">val</code> logger:<code role="type"> Logger</code>

  <code role="statement">def</code> <code role="identifier">run</code> = {
    logger.log(<code role="constant">"Starting "</code> + getClass.getSimpleName + <code role="constant">":"</code>)
    doRun
  }

  <code role="statement">protected</code> <code role="statement">def</code> <code role="identifier">doRun</code>:<code role="type"> Boolean</code>
}

<code role="statement">object</code> <code role="special">MyService1</code> <code role="statement">extends</code> <code role="special">Service</code> {
  <code role="statement">class</code> <code role="special">MyService1Logger</code> <code role="statement">extends</code> <code role="special">Logger</code> {
    <code role="statement">def</code> <code role="identifier">log</code>(message:<code role="type"> String</code>) = println(<code role="constant">"1: "</code>+message)
  }
  <code role="statement">override</code> <code role="statement">val</code> logger = <code role="statement">new</code> <code role="special">MyService1Logger</code>
  <code role="statement">def</code> <code role="identifier">doRun</code> = <code role="constant">true</code>  <code role="comment">// do some real work...</code>
}

<code role="statement">object</code> <code role="special">MyService2</code> <code role="statement">extends</code> <code role="special">Service</code> {
  <code role="statement">override</code> <code role="statement">val</code> logger = MyService1.logger  <code role="comment">// ERROR</code>
  <code role="statement">def</code> <code role="identifier">doRun</code> = <code role="constant">true</code>  <code role="comment">// do some real work...</code>
}
</programlisting><?dbfo-need height=”1in”
?><para id="para_if_you_compile_this_file_you_g">If you compile this file,
    you get the following error:</para><screen format="linespecific">...:27: error: error overriding value logger in trait Service of type \
    MyService2.Logger;
 value logger has incompatible type MyService1.MyService1Logger
  override val logger = MyService1.logger  // ERROR
               ^
one error found</screen><para id="para_the_error_says_that_the_logge">The error says that the
    <literal moreinfo="none">logger</literal> value in <literal role="keep-together" moreinfo="none">MyService2</literal> on line 25 has type
    <literal moreinfo="none">MyService2.Log⁠ger</literal>, even though it’s declared to be of
    type <literal moreinfo="none">Logger</literal> in the parent <literal moreinfo="none">Service</literal>
    trait. Also, we’re trying to assign it a value of type
    <literal moreinfo="none">MyService1.MyService1Logger</literal>.</para><para id="para_these_three_types_are_differen">These three types are
    different in Scala. <literal moreinfo="none">Logger</literal> is nested in
    <literal moreinfo="none">Service</literal>, which is the parent of
    <literal moreinfo="none">MyService1</literal> and <literal moreinfo="none">MyService2</literal>. In Scala,
    that means that the nested <literal moreinfo="none">Logger</literal> type is unique for
    each of the service types. The actual type is
    <emphasis>path-dependent</emphasis>.</para><para id="para_in_this_case_the_easiest_solu">In this case, the easiest
    solution is to move the declaration of <literal moreinfo="none">Logger</literal> outside
    of <literal role="keep-together" moreinfo="none">Service</literal>, thereby removing the
    path dependency. In other cases, it’s possible to qualify the type so that
    it resolves to what you want.</para><para id="para_there_are_several_kinds_of_typ">There are several kinds of
    type paths.</para><sect2 id="_c_this"><title>C.this</title><para id="para_for_a_class_c_you_can_use_c_">For a class
      <literal moreinfo="none">C</literal>, you can use <literal moreinfo="none">C.this</literal> or
      <literal moreinfo="none">this</literal> inside the body to refer to the current
      instance:<indexterm significance="normal"><primary>C.this type</primary></indexterm><indexterm significance="normal"><primary>path-dependent types</primary><secondary>C.this</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">C1</code> {
  <code role="statement">var</code> x = <code role="constant">"1"</code>
  <code role="statement">def</code> <code role="identifier">setX1</code>(x:<code role="type">String</code>) = <code role="statement">this</code>.x = x
  <code role="statement">def</code> <code role="identifier">setX2</code>(x:<code role="type">String</code>) = C1.<code role="statement">this</code>.x = x
}
</programlisting><para id="para_both_setx1_and_setx2_have_">Both <literal moreinfo="none">setX1</literal>
      and <literal moreinfo="none">setX2</literal> have the same effect, because
      <literal moreinfo="none">C1.this</literal> is equivalent to
      <literal moreinfo="none">this</literal>.</para><para id="para_inside_a_type_body_and_outside">Inside a type body and
      outside a method definition, <literal moreinfo="none">this</literal> refers to the type
      itself:</para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">T1</code> {
  <code role="statement">class</code> <code role="special">C</code>
  <code role="statement">val</code> c1 = <code role="statement">new</code> <code role="special">C</code>
  <code role="statement">val</code> c2 = <code role="statement">new</code> <code role="statement">this</code>.<code role="special">C</code>
}
</programlisting><para id="para_the_values_c1_and_c2_have_">The values
      <literal moreinfo="none">c1</literal> and <literal moreinfo="none">c2</literal> have the same type. The
      <literal moreinfo="none">this</literal> in the expression <literal moreinfo="none">this.C</literal>
      refers to the trait <literal moreinfo="none">T1</literal>.</para></sect2><sect2 id="_c_super"><title>C.super</title><para id="para_you_can_refer_specifically_to_">You can refer
      specifically to the parent of a type with
      <literal moreinfo="none">super</literal>:<indexterm significance="normal"><primary>path-dependent types</primary><secondary>C.super</secondary></indexterm><indexterm significance="normal"><primary>C.super type</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">C2</code> <code role="statement">extends</code> <code role="special">C1</code>
<code role="statement">class</code> <code role="special">C3</code> <code role="statement">extends</code> <code role="special">C2</code> {
  <code role="statement">def</code> <code role="identifier">setX3</code>(x:<code role="type">String</code>) = <code role="statement">super</code>.setX1(x)
  <code role="statement">def</code> <code role="identifier">setX4</code>(x:<code role="type">String</code>) = C3.<code role="statement">super</code>.setX1(x)
  <code role="statement">def</code> <code role="identifier">setX5</code>(x:<code role="type">String</code>) = C3.<code role="statement">super</code>[<code role="special">C2</code>].setX1(x)
}
</programlisting><para id="para__c3_super_is_equivalent_to_s"><literal moreinfo="none">C3.super</literal>
      is equivalent to <literal moreinfo="none">super</literal> in this example. If you want
      to refer specifically to one of the parents of a type, you can qualify
      <literal moreinfo="none">super</literal> with the type, as shown in
      <literal moreinfo="none">setX5</literal>. This is particularly useful for the case where
      a type mixes in several traits, each of which overrides the same method.
      If you need access to one of the methods in a specific trait, you can
      qualify <literal moreinfo="none">super</literal>. However, this qualification can’t
      refer to “grandparent” types.</para><para id="para_super_and_linearization">What if you are calling
      <literal moreinfo="none">super</literal> in a class with several mixins and it extends
      another type? To which type does <literal moreinfo="none">super</literal> bind? Without
      the qualification, the rules of <emphasis>linearization</emphasis>
      determine the target of <literal moreinfo="none">super</literal> (see <xref linkend="Linearization"/>).<indexterm significance="normal"><primary>linearization of object hierarchy</primary></indexterm></para><para id="para_just_as_for_this_you_can_us">Just as for
      <literal moreinfo="none">this</literal>, you can use <literal moreinfo="none">super</literal> to refer
      to the parent type in a type body outside a method:</para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">C4</code> {
  <code role="statement">class</code> <code role="special">C5</code>
}
<code role="statement">class</code> <code role="special">C6</code> <code role="statement">extends</code> <code role="special">C4</code> {
  <code role="statement">val</code> c5a = <code role="statement">new</code> <code role="special">C5</code>
  <code role="statement">val</code> c5b = <code role="statement">new</code> <code role="statement">super</code>.<code role="special">C5</code>
}
</programlisting><para id="para_both_c5a_and_c5b_have_the_">Both <literal moreinfo="none">c5a</literal>
      and <literal moreinfo="none">c5b</literal> have the same type.</para></sect2><sect2 id="_path_x"><title>path.x</title><para id="para_you_can_reach_a_nested_type_">You can reach a nested type
      with a period-delimited path expression:<indexterm significance="normal"><primary>. (dot)</primary><secondary>period-delimited path expressions</secondary></indexterm><indexterm significance="normal"><primary>path-dependent types</primary><secondary>period-delimited path expressions</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="preproc">package</code> P1 {
  <code role="statement">object</code> <code role="special">O1</code> {
    <code role="statement">object</code> <code role="special">O2</code> {
      <code role="statement">val</code> name = <code role="constant">"name"</code>
    }
  }
}
<code role="statement">class</code> <code role="special">C7</code> {
  <code role="statement">val</code> name = P1.O1.O2.name
}
</programlisting><para id="para_the_elements_of_a_type_path_mu"><literal moreinfo="none">C7.name</literal> uses
      a path to the <literal moreinfo="none">name</literal> value in <literal moreinfo="none">O2</literal>.
      The elements of a type path must be <emphasis>stable</emphasis>, which
      roughly means that all elements in the path must be packages, singleton
      objects, or type declarations that alias the same. The last element in
      the path can be a class or trait. See <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link> for the details:</para><programlisting language="scala" format="linespecific"><code role="statement">object</code> <code role="special">O3</code> {
  <code role="statement">object</code> <code role="special">O4</code> {
    <code role="statement">type</code> t = java.io.<code role="special">File</code>
    <code role="statement">class</code> <code role="special">C</code>
    <code role="statement">trait</code> <code role="special">T</code>
  }
  <code role="statement">class</code> <code role="special">C2</code> {
    <code role="statement">type</code> t = <code role="special">Int</code>
  }
}
<code role="statement">class</code> <code role="special">C8</code> {
  <code role="statement">type</code> t1 = O3.O4.t
  <code role="statement">type</code> t2 = O3.O4.<code role="special">C</code>
  <code role="statement">type</code> t3 = O3.O4.<code role="special">T</code>
<code role="comment">//  type t4 = O3.C2.t   // ERROR: C2 is not a "value" in O3</code>
}
</programlisting></sect2></sect1><sect1 id="ValueTypes"><title>Value Types</title><para id="para_because_scala_is_a_strongly_an">Because Scala is strongly
    and statically typed, every value has a type. The term <emphasis>value
    types</emphasis> refers to all the different forms these types take, so it
    encompasses many forms that are now familiar to us, plus a few new ones we
    haven’t encountered until now.<indexterm class="startofrange" id="ch12_datatypesvalue" significance="normal"><primary>data types</primary><secondary>value types</secondary></indexterm><indexterm significance="normal"><primary>value types</primary></indexterm></para><warning id="para_warning_we_are_using_the_term"><para>We are using the term <emphasis>value type</emphasis> here in the
      same way the term is used by <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>. However, elsewhere in
      the book we also follow the specification’s overloaded use of the term
      to refer to all subtypes of <literal moreinfo="none">AnyVal</literal>.</para></warning><sect2 id="_type_designators"><title>Type Designators</title><para id="para_the_conventional_type_ids_we_c">The conventional type IDs
      we commonly use are called <emphasis>type
      designators</emphasis>:<indexterm significance="normal"><primary>value types</primary><secondary>type designators</secondary></indexterm><indexterm significance="normal"><primary>type designators</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">Person</code>              <code role="comment">// "Person" is a type designator</code>
<code role="statement">object</code> <code role="special">O</code> { <code role="statement">type</code> t }       <code role="comment">// "O" and "t" are type designators</code>
...
</programlisting><para id="para_they_are_actually_a_short_hand">They are actually a
      shorthand syntax for <emphasis>type projections</emphasis>, which we
      cover later.</para></sect2><sect2 id="_tuples"><title>Tuples</title><para id="para_a_value_of_the_form_x_1_">A value of the form
      <literal moreinfo="none">(x</literal><subscript>1</subscript><literal moreinfo="none">, ...
      x</literal><subscript>N</subscript><literal moreinfo="none">)</literal> is a tuple value
      type.<indexterm significance="normal"><primary>tuples</primary><secondary>value type, syntax for</secondary></indexterm><indexterm significance="normal"><primary>value types</primary><secondary>tuples</secondary></indexterm></para></sect2><sect2 id="_parameterized_types"><title>Parameterized Types</title><para id="para_when_we_create_a_type_from_a_t">When we create a type
      from a parameterized type, e.g., <literal moreinfo="none">List[Int]</literal> and
      <literal moreinfo="none">List[String]</literal> from <literal moreinfo="none">List[A]</literal>, the
      types <literal moreinfo="none">List[Int]</literal> and <literal moreinfo="none">List[String]</literal>
      are value types, because they are associated with declared values, e.g.,
      <literal moreinfo="none">val names = List[String]()</literal>.<indexterm significance="normal"><primary>parameterized types</primary><secondary>value types created from</secondary></indexterm><indexterm significance="normal"><primary>value types</primary><secondary>parameterized types</secondary></indexterm></para></sect2><sect2 id="_annotated_types"><title>Annotated Types</title><para id="para_when_we_annotate_a_type__e_g_">When we annotate a type,
      e.g., <literal moreinfo="none">@serializable @cloneable class C(val x:String)</literal>,
      the actual type includes the annotations.<indexterm significance="normal"><primary>annotated types</primary></indexterm><indexterm significance="normal"><primary>annotated types</primary></indexterm></para></sect2><sect2 id="_compound_types"><title>Compound Types</title><para id="para_a_declaration_of_the_form_t_">A declaration of the form
      <literal moreinfo="none">T</literal><subscript>1</subscript><literal moreinfo="none"> extends
      T</literal><subscript>2</subscript><literal moreinfo="none"> with
      T</literal><subscript>3</subscript><literal moreinfo="none"> { R }</literal>, where
      <literal moreinfo="none">R</literal> is the <emphasis>refinement</emphasis> (body),
      declares a compound type. Any declarations in the refinement are part of
      the compound type definition. The notion of compound types accounts for
      the fact that not all types are named, since we can have anonymous
      types, such as this example <literal moreinfo="none">scala</literal> session:<indexterm significance="normal"><primary>refinement in compound type declarations</primary></indexterm><indexterm significance="normal"><primary>compound types</primary></indexterm></para><screen format="linespecific">scala&gt; val x = new T1 with T2 {
        type z = String
        val v: z = "Z"
}
x: java.lang.Object with T1 with T2{type z = String; def zv: this.z} = \
    $anon$1@9d9347d</screen><para id="para_note_that_path_dependent_type_">Note that path-dependent
      type <literal moreinfo="none">this.z</literal> in the output.</para><para id="para_a_particularly_interesting_cas">A particularly
      interesting case is a declaration of the form <literal moreinfo="none">val x = new { R
      }</literal>, i.e., without any type IDs. This is equivalent to
      <literal moreinfo="none">val x = new AnyRef { R }</literal>.</para></sect2><sect2 id="_infix_types"><title>Infix Types</title><para id="para_some_parameterized_types_take_">Some parameterized types
      take two type arguments, e.g., <literal moreinfo="none">scala.Either[+A,+B]</literal>.
      Scala allows you to declare instances of these types using an infix
      notation, e.g., <literal moreinfo="none">a Either b</literal>. Consider the following
      script that uses <literal moreinfo="none">Either</literal>:<indexterm significance="normal"><primary>value types</primary><secondary>infix types</secondary></indexterm><indexterm significance="normal"><primary>infix types</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/valuetypes/infix-types-script.scala</code>

<code role="statement">def</code> <code role="identifier">attempt</code>(operation:<code role="type"> =&gt; Boolean</code>):<code role="type"> Throwable</code> <code role="special">Either</code> <code role="special">Boolean</code> = <code role="statement">try</code> {
  <code role="special">Right</code>(operation)
} <code role="statement">catch</code> {
  <code role="statement">case</code> t:<code role="type"> Throwable =&gt; Left</code>(t)
}

println(attempt { <code role="statement">throw</code> <code role="statement">new</code> <code role="special">RuntimeException</code>(<code role="constant">"Boo!"</code>) })
println(attempt { <code role="constant">true</code> })
println(attempt { <code role="constant">false</code> })
</programlisting><para id="para_the_attempt_method_will_eval">The
      <literal moreinfo="none">attempt</literal> method will evaluate the
      <emphasis>call-by-name</emphasis> parameter <literal moreinfo="none">operation</literal>
      and return its <literal moreinfo="none">Boolean</literal> result, wrapped in a
      <literal moreinfo="none">Right</literal>, <emphasis>or</emphasis> any
      <literal moreinfo="none">Throwable</literal> that is caught, wrapped in a
      <literal moreinfo="none">Left</literal>. The script produces this output:</para><screen format="linespecific">Left(java.lang.RuntimeException: Boo!)
Right(true)
Right(false)</screen><para id="para_notice_the_return_value_thro">Notice the declared return
      value, <literal moreinfo="none">Throwable Either Boolean</literal>. It is identical to
      <literal moreinfo="none">Either[Throwable, Boolean]</literal>. Recall from <xref linkend="ScalaTypeHierarchy"/> that when using this exception-handling
      idiom with <literal moreinfo="none">Either</literal>, it is conventional to use
      <literal moreinfo="none">Left</literal> for the exception and <literal moreinfo="none">Right</literal>
      for the normal return value.</para></sect2><sect2 id="FunctionTypes"><title>Function Types</title><para id="para_about_function_types">The functions we have been writing
      are also typed. <literal moreinfo="none">(T</literal><subscript>1</subscript><literal moreinfo="none">,
      T</literal><subscript>2</subscript><literal moreinfo="none">, ...
      T</literal><subscript>N</subscript><literal moreinfo="none">) =&gt; R</literal> is the
      type for all functions that take <literal moreinfo="none">N</literal> arguments and
      return a value of type <literal moreinfo="none">R</literal>.<indexterm significance="normal"><primary>value types</primary><secondary>function types</secondary></indexterm><indexterm significance="normal"><primary>function types</primary></indexterm></para><para id="para_when_there_is_only_one_argumen">When there is only one
      argument, you can drop the parentheses: <literal moreinfo="none">T =&gt; R</literal>. A
      function that takes a <emphasis>call-by-name</emphasis> parameter (as
      discussed in <xref linkend="FunctionalProgramming"/>) has the type
      <literal moreinfo="none">(=&gt;T) =&gt; R</literal>. We used a call-by-name argument in
      our <literal moreinfo="none">attempt</literal> example in the previous
      section.<indexterm significance="normal"><primary>call-by-name parameters</primary></indexterm></para><para id="para_recall_that_everything_in_scal">Recall that everything in
      Scala is an object, even functions. The Scala library defines traits for
      each <literal moreinfo="none">FunctionN</literal>, for <literal moreinfo="none">N</literal> from
      <literal moreinfo="none">0</literal> to <literal moreinfo="none">22</literal>, inclusive. Here, for
      example, is the version 2.7.5 source for
      <literal moreinfo="none">scala.Function3</literal>, omitting most comments and a few
      other details that don’t concern us now:<indexterm significance="normal"><primary>FunctionN object</primary><secondary>defining traits for</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// From Scala version 2.7.5: scala.Function3 (excerpt).</code>
<code role="preproc">package</code> scala

<code role="statement">trait</code> <code role="special">Function3</code><code role="special">[-T1, -T2, -T3, +R]</code> <code role="statement">extends</code> <code role="special">AnyRef</code> {
  <code role="statement">def</code> <code role="identifier">apply</code>(v1:<code role="type">T1</code>, v2:<code role="type">T2</code>, v3:<code role="type">T3</code>):<code role="type"> R</code>
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code>() = <code role="constant">"&lt;function&gt;"</code>

  <code role="comment">/** f(x1,x2,x3)  == (f.curry)(x1)(x2)(x3)</code>
<code role="comment">   */</code>
  <code role="statement">def</code> <code role="identifier">curry</code>:<code role="type"> T1 =&gt; T2 =&gt; T3 =&gt; R</code> = {
    (x1:<code role="type"> T1</code>) <code role="statement">=&gt;</code> (x2:<code role="type"> T2</code>) <code role="statement">=&gt;</code> (x3:<code role="type"> T3</code>) <code role="statement">=&gt;</code> apply(x1,x2,x3)
  }
}
</programlisting><para id="para_as_we_discussed_in_varianceu">As we discussed in <xref linkend="VarianceUnderInheritance"/>, the <literal moreinfo="none">FunctionN</literal>
      traits are <emphasis>contravariant</emphasis> in the type parameters for
      the arguments and <emphasis>covariant</emphasis> in the return type
      parameter.</para><para id="para_recall_that_when_you_reference">Recall that when you
      reference any object followed by an argument list, Scala calls the
      <literal moreinfo="none">apply</literal> method on the object. In this way, any object
      with an <literal moreinfo="none">apply</literal> method can also be considered a
      function, providing a nice symmetry with the object-oriented nature of
      Scala.<indexterm significance="normal"><primary>apply method</primary><secondary>objects with, considered as functions</secondary></indexterm></para><para id="para_when_you_define_a_function_val">When you define a
      function value, the compiler instantiates the appropriate <literal role="keep-together" moreinfo="none">FunctionN</literal> object and uses your definition
      of the function as the body of <literal moreinfo="none">apply</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/valuetypes/function-types-script.scala</code>

<code role="statement">val</code> capitalizer = (s:<code role="type"> String</code>) <code role="statement">=&gt;</code> s.toUpperCase

<code role="statement">val</code> capitalizer2 = <code role="statement">new</code> <code role="special">Function1</code><code role="special">[String,String]</code> {
  <code role="statement">def</code> <code role="identifier">apply</code>(s:<code role="type"> String</code>) = s.toUpperCase
}

println( <code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>) map capitalizer)
println( <code role="special">List</code>(<code role="constant">"Programming"</code>, <code role="constant">"Scala"</code>) map capitalizer2)
</programlisting><para id="para_the_capitalizer_and_capital">The
      <literal moreinfo="none">capitalizer</literal> and <literal moreinfo="none">capitalizer2</literal>
      function values are effectively the same, where the latter mimics the
      compiler’s output.</para><para id="para_the_curry_method_returns_a_n">We discussed the
      <literal moreinfo="none">curry</literal> method previously in <xref linkend="Currying"/>. It returns a new function with
      <literal moreinfo="none">N</literal> argument lists, each of which has a single argument
      taken from the original argument list of <literal moreinfo="none">N</literal> arguments.
      Note that the same <literal moreinfo="none">apply</literal> method is invoked:<indexterm significance="normal"><primary>curried functions</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/valuetypes/curried-function-script.scala</code>

<code role="statement">val</code> f  = (x:<code role="type"> Double</code>, y:<code role="type"> Double</code>, z:<code role="type"> Double</code>) <code role="statement">=&gt;</code> x * y / z
<code role="statement">val</code> fc = f.curry

<code role="statement">val</code> answer1 = f(<code role="constant">2.</code>, <code role="constant">5.</code>, <code role="constant">4.</code>)
<code role="statement">val</code> answer2 = fc(<code role="constant">2.</code>)(<code role="constant">5.</code>)(<code role="constant">4.</code>)
println( answer1 + <code role="constant">" == "</code> + answer2 + <code role="constant">"? "</code> + (answer1 == answer2))

<code role="statement">val</code> fc1 = fc(<code role="constant">2.</code>)
<code role="statement">val</code> fc2 = fc1(<code role="constant">5.</code>)
<code role="statement">val</code> answer3 = fc2(<code role="constant">4.</code>)
println( answer3 + <code role="constant">" == "</code> + answer2 + <code role="constant">"? "</code> + (answer3 == answer2))
</programlisting><para id="para_curried_function_script_output">This script produces the
      following output:</para><screen format="linespecific">2.5 == 2.5? true
2.5 == 2.5? true</screen><para id="para_in_the_first_part_of_the_scrip">In the first part of the
      script, we define a <literal moreinfo="none">Function3</literal> value
      <literal moreinfo="none">f</literal> that does <literal moreinfo="none">Double</literal> arithmetic. We
      create a new function value <literal moreinfo="none">fc</literal> by currying
      <literal moreinfo="none">f</literal>. Then we call both functions with the same
      arguments and print out the results. As expected, they both produce the
      same output. (There are no concerns about rounding errors in the
      comparison here; recall that both functions call the same
      <literal moreinfo="none">apply</literal> method, so they must return the same
      value.)</para><para id="para_in_the_second_part_of_the_scri">In the second part of the
      script, we exploit the feature of curried functions that we can
      <emphasis>partially apply</emphasis> arguments, creating new functions,
      until we apply all the arguments. The example also helps us make sense
      of the declaration of <literal moreinfo="none">curry</literal> in
      <literal moreinfo="none">Function3</literal>.</para><para id="para_functions_are_right_associativ">Functions are
      right-associative, so a type <literal moreinfo="none">T1 =&gt; T2 =&gt; T3 =&gt;
      R</literal> is equivalent to <literal moreinfo="none">T1 =&gt; (T2 =&gt; (T3 =&gt;
      R))</literal>. We see this in the script. In the statement <literal moreinfo="none">val
      fc1 = fc(2.)</literal>, we call <literal moreinfo="none">fc</literal> with just the
      first argument list (corresponding to <literal moreinfo="none">T1</literal> equals
      <literal moreinfo="none">Double</literal>). It returns a <emphasis>new</emphasis>
      function of type <literal moreinfo="none">T2 =&gt; (T3 =&gt; R)</literal> or
      <literal moreinfo="none">Double =&gt; (Double =&gt; Double)</literal>, in our
      case.</para><para id="para_next_in_val_fc2_fc1_5_">Next, in <literal moreinfo="none">val fc2 =
      fc1(5.)</literal>, we supply the second (<literal moreinfo="none">T2</literal>)
      argument, returning a new function of type <literal moreinfo="none">T3 =&gt;
      R</literal>, that is, <literal moreinfo="none">Double =&gt; Double</literal>. Finally,
      in <literal moreinfo="none">val answer3 = fc2(4.)</literal> we supply the last argument
      to compute the value of type <literal moreinfo="none">R</literal>, that is
      <literal moreinfo="none">Double</literal>.</para><note id="para_note_a_type_t1_062_t2_"><para>A type <literal moreinfo="none">T1 =&gt; T2 =&gt; T3 =&gt; R</literal> is
        equivalent to <literal moreinfo="none">T1 =&gt; (T2 =&gt; (T3 =&gt; R))</literal>.
        When we call a function of this type with a value for
        <literal moreinfo="none">T1</literal>, it returns a new function of type <literal moreinfo="none">T2
        =&gt; (T3 =&gt; R)</literal>, and so forth.</para></note><para id="para_finally_since_functions_are_i">Finally, since functions
      are instances of traits, you can use the traits as parents of other
      types. In the Scala library, <literal moreinfo="none">Seq[+A]</literal> is a subclass of
      <literal moreinfo="none">PartialFunction[Int,A]</literal>, which is a subclass of
      <literal moreinfo="none">(Int) =&gt; A</literal>, i.e.,
      <literal moreinfo="none">Function1[Int,A]</literal>.<indexterm significance="normal"><primary>traits</primary><secondary>functions as instances of</secondary></indexterm></para></sect2><sect2 id="TypeProjections"><title>Type Projections</title><para id="para_about_type_projections"><emphasis>Type
      projections</emphasis> are a way to refer to a type declaration nested
      in another type:<indexterm significance="normal"><primary>type projections</primary></indexterm><indexterm significance="normal"><primary>value types</primary><secondary>type projections</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/valuetypes/type-projection-script.scala</code>

<code role="statement">trait</code> <code role="special">T</code> {
  <code role="statement">type</code> t &lt;:<code role="type"> AnyRef</code>
}
<code role="statement">class</code> <code role="special">C1</code> <code role="statement">extends</code> <code role="special">T</code> {
  <code role="statement">type</code> t = <code role="special">String</code>
}
<code role="statement">class</code> <code role="special">C2</code> <code role="statement">extends</code> <code role="special">C1</code>

<code role="statement">val</code> ic1:<code role="type"> C1#t</code> = <code role="constant">"C1"</code>
<code role="statement">val</code> ic2:<code role="type"> C2#t</code> = <code role="constant">"C2"</code>
println(ic1)
println(ic2)
</programlisting><para id="para_type_proj_output">Both <literal moreinfo="none">C1#t</literal> and
      <literal moreinfo="none">C2#t</literal> are <literal moreinfo="none">String</literal>. You can also
      reference the abstract type <literal moreinfo="none">T#t</literal>, but you can’t use it
      in a declaration because it is abstract.</para></sect2><sect2 id="_singleton_types"><title>Singleton Types</title><para id="para_about_singleton_types">If you have a value
      <literal moreinfo="none">v</literal> of a subtype of <literal moreinfo="none">AnyRef</literal>,
      including <literal moreinfo="none">null</literal>, you can get its <emphasis>singleton
      type</emphasis> using the expression <literal moreinfo="none">v.type</literal>. These
      expressions can be used as types in declarations. This feature is useful
      on rare occasions to work around the fact that types are path dependent,
      which we discussed in <xref linkend="PathDependentTypes"/>. In these
      cases an object may have a path-dependent type that appears to be
      incompatible with another path-dependent type, when in fact they are
      compatible. Using the <literal moreinfo="none">v.type</literal> expression retrieves the
      singleton type, a “unique” type that eliminates the path dependency. Two
      values <literal moreinfo="none">v1</literal> and <literal moreinfo="none">v2</literal> may have
      different path-dependent types, but they could have the same singleton
      type.<indexterm significance="normal"><primary>singleton types</primary></indexterm><indexterm significance="normal"><primary>value types</primary><secondary>singleton types</secondary></indexterm></para><para id="para_this_example_uses_the_singleto">This example uses the
      singleton type for one value in a declaration of another:</para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">C</code> {
  <code role="statement">val</code> x = <code role="constant">"Cx"</code>
}
<code role="statement">val</code> c = <code role="statement">new</code> <code role="special">C</code>
<code role="statement">val</code> x:<code role="type"> c.x.type</code> = c.x
</programlisting></sect2></sect1><sect1 id="SelfTypeAnnotations"><title>Self-Type Annotations</title><para id="para_self_types">You can use <literal moreinfo="none">this</literal> in a method
    to refer to the enclosing type, which is useful for referencing a member
    of the type. Using <literal moreinfo="none">this</literal> is not usually necessary for
    this purpose, but it’s useful occasionally for disambiguating a reference
    when several values are in scope with the same name. By default, the type
    of <literal moreinfo="none">this</literal> is the same as the enclosing type, but this is
    not really essential.<indexterm significance="normal"><primary>this keyword</primary><secondary>self-type annotations</secondary></indexterm><indexterm class="startofrange" id="ch12_typeself" significance="normal"><primary>type annotations</primary><secondary>self-type annotations</secondary></indexterm><indexterm class="startofrange" id="ch12_selftype" significance="normal"><primary>self-type annotations</primary></indexterm><indexterm class="startofrange" id="ch12_datatypesself" significance="normal"><primary>data types</primary><secondary>self-type annotations</secondary></indexterm><indexterm class="endofrange" startref="ch12_datatypesvalue" significance="normal"/></para><para id="para__self_type_annotations__let_yo"><emphasis>Self-type
    annotations</emphasis> let you specify additional type expectations for
    <literal moreinfo="none">this</literal>, and they can be used to create aliases for
    <literal moreinfo="none">this</literal>. Let’s consider the latter case first:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/selftype/this-alias-script.scala</code>

<code role="statement">class</code> <code role="special">C1</code> { self <code role="statement">=&gt;</code>
  <code role="statement">def</code> <code role="identifier">talk</code>(message:<code role="type"> String</code>) = println(<code role="constant">"C1.talk: "</code> + message)
  <code role="statement">class</code> <code role="special">C2</code> {
    <code role="statement">class</code> <code role="special">C3</code> {
      <code role="statement">def</code> <code role="identifier">talk</code>(message:<code role="type"> String</code>) = self.talk(<code role="constant">"C3.talk: "</code> + message)
    }
    <code role="statement">val</code> c3 = <code role="statement">new</code> <code role="special">C3</code>
  }
  <code role="statement">val</code> c2 = <code role="statement">new</code> <code role="special">C2</code>
}
<code role="statement">val</code> c1 = <code role="statement">new</code> <code role="special">C1</code>
c1.talk(<code role="constant">"Hello"</code>)
c1.c2.c3.talk(<code role="constant">"World"</code>)
</programlisting><para id="para_this_alias_script_output">It prints the following:</para><screen format="linespecific">C1.talk: Hello
C1.talk: C3.talk: World</screen><para id="para_we_give_the_outer_scope_c1_">We give the outer scope
    (<literal moreinfo="none">C1</literal>) <literal moreinfo="none">this</literal> the alias
    <literal moreinfo="none">self</literal>, so we can easily refer to it in
    <literal moreinfo="none">C3</literal>. We could use <literal moreinfo="none">self</literal> within any
    method inside the body of <literal moreinfo="none">C1</literal> or its nested types. Note
    that the name <literal moreinfo="none">self</literal> is arbitrary, but it is somewhat
    conventional. In fact, you could say <literal moreinfo="none">this =&gt;</literal>, but it
    would be completely redundant.</para><para id="para_if_the_self_type_annotation_ha">If the self-type annotation
    has types in the annotation, we get some very different <phrase role="keep-together">benefits</phrase>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/selftype/selftype-script.scala</code>

<code role="statement">trait</code> <code role="special">Persistence</code> {
  <code role="statement">def</code> <code role="identifier">startPersistence</code>:<code role="type"> Unit</code>
}

<code role="statement">trait</code> <code role="special">Midtier</code> {
  <code role="statement">def</code> <code role="identifier">startMidtier</code>:<code role="type"> Unit</code>
}

<code role="statement">trait</code> <code role="special">UI</code> {
  <code role="statement">def</code> <code role="identifier">startUI</code>:<code role="type"> Unit</code>
}

<code role="statement">trait</code> <code role="special">Database</code> <code role="statement">extends</code> <code role="special">Persistence</code> {
  <code role="statement">def</code> <code role="identifier">startPersistence</code> = println(<code role="constant">"Starting Database"</code>)
}

<code role="statement">trait</code> <code role="special">ComputeCluster</code> <code role="statement">extends</code> <code role="special">Midtier</code> {
  <code role="statement">def</code> <code role="identifier">startMidtier</code> = println(<code role="constant">"Starting ComputeCluster"</code>)
}

<code role="statement">trait</code> <code role="special">WebUI</code> <code role="statement">extends</code> <code role="special">UI</code> {
  <code role="statement">def</code> <code role="identifier">startUI</code> = println(<code role="constant">"Starting WebUI"</code>)
}

<code role="statement">trait</code> <code role="special">App</code> {
  self:<code role="type"> Persistence</code> <code role="statement">with</code> <code role="special">Midtier</code> <code role="statement">with</code> <code role="special">UI</code> <code role="statement">=&gt;</code>

  <code role="statement">def</code> <code role="identifier">run</code> = {
    startPersistence
    startMidtier
    startUI
  }
}

<code role="statement">object</code> <code role="special">MyApp</code> <code role="statement">extends</code> <code role="special">App</code> <code role="statement">with</code> <code role="special">Database</code> <code role="statement">with</code> <code role="special">ComputeCluster</code> <code role="statement">with</code> <code role="special">WebUI</code>

MyApp.run
</programlisting><para id="para_this_script_shows_a_schematic_">This script shows a
    schematic layout for an <literal moreinfo="none">App</literal> (application)
    infrastructure supporting several tiers/components, persistent storage,
    midtier, and UI. We’ll explore this approach to component design in more
    detail in <xref linkend="ApplicationDesign"/>.</para><para id="para_for_now_we_just_care_about_th">For now, we just care about
    the role of self types. Each abstract trait declares a “start” method that
    does the work of initializing the tier. (We’re ignoring issues like
    success versus failure of startup, etc.) Each abstract tier is implemented
    by a corresponding concrete trait (not a class, so we can use them as
    mixins). We have traits for database persistence, some sort of computation
    cluster to do the heavy lifting for the business logic, and a web-based
    UI.</para><para id="para_the_app_traits_wires_the_tie">The <literal moreinfo="none">App</literal>
    trait wires the tiers together. For example, it does the work of starting
    the tiers in the <literal moreinfo="none">run</literal> method.</para><para id="para_note_the_self_type_annotation_">Note the self-type
    annotation, <literal moreinfo="none">self: Persistence with Midtier with UI
    =&gt;</literal>. It has two practical effects:</para><orderedlist numeration="arabic" inheritnum="ignore" continuation="restarts"><listitem><para>The body of the trait can assume it is an instance of
        <literal moreinfo="none">Persistence</literal>, <literal moreinfo="none">Midtier</literal>, and
        <literal moreinfo="none">UI</literal>, so it can call methods defined in those types,
        whether or not they are actually defined at this point. We’re doing
        just that in <literal moreinfo="none">run</literal>.</para></listitem><listitem><para>The concrete type that mixes in this trait must also mix in
        these three other traits or descendants of them.</para></listitem></orderedlist><para id="para_in_other_words_the_self_type_">In other words, the self
    type in <literal moreinfo="none">App</literal> specifies dependencies on other components.
    These dependencies are satisfied in <literal moreinfo="none">MyApp</literal>, which mixes
    in the concrete traits for the three tiers.</para><para id="para_if_you_think_about_it_we_coul">We could have declared
    <literal moreinfo="none">App</literal> using inheritance instead:</para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">App</code> <code role="statement">with</code> <code role="special">Persistence</code> <code role="statement">with</code> <code role="special">Midtier</code> <code role="statement">with</code> <code role="special">UI</code> {

  <code role="statement">def</code> <code role="identifier">run</code> = { ... }
}
</programlisting><para id="para_it_is_effectively_the_same_thi">This is effectively the
    same. As we said, the self-type annotation lets the <literal moreinfo="none">App</literal>
    assume it is of type <literal moreinfo="none">Persistence</literal>, etc. That’s exactly
    what happens when you mix in a trait, too.</para><para id="para_so_why_are_self_types_useful_">Why, then, are self types
    useful if they appear to be equivalent to inheritance? There are some
    theoretical reasons and a few special cases where self-type annotations
    offer unique benefits. In practice, you could use inheritance for almost
    all cases. By convention, people use inheritance when they want to imply
    that a type <emphasis>behaves as</emphasis> (inherits from) another type,
    and they use self-type annotations when they want to express a dependency
    between a type and other types (see <link linkend="McIver2009" xrefstyle="select:nopage">[McIver2009]</link>).</para><para id="para_in_our_case_we_don_t_really_t">In our case, we don’t really
    think of an <literal moreinfo="none">App</literal> as <emphasis>being</emphasis> a UI,
    database, etc. We think of an <literal moreinfo="none">App</literal> as being composed of
    those things. Note that in most object-oriented languages, you would
    express this compositional dependency with member fields, especially if
    your language doesn’t support mixin composition, like Java. For example,
    you might write <literal moreinfo="none">App</literal> in Java this way:</para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/TypeSystem/selftype/JavaApp.java</code>

<code role="preproc">package</code> selftype;

<code role="type">public</code> <code role="type">abstract</code> <code role="type">class</code> JavaApp {
  <code role="type">public</code> <code role="type">interface</code> Persistence {
    <code role="type">public</code> <code role="type">void</code> startPersistence();
  }

  <code role="type">public</code> <code role="type">interface</code> Midtier {
    <code role="type">public</code> <code role="type">void</code> startMidtier();
  }

  <code role="type">public</code> <code role="type">interface</code> UI {
    <code role="type">public</code> <code role="type">void</code> startUI();
  }

  <code role="type">private</code> Persistence persistence;
  <code role="type">private</code> Midtier midtier;
  <code role="type">private</code> UI ui;

  <code role="type">public</code> JavaApp(Persistence persistence, Midtier midtier, UI ui) {
    <code role="type">this</code>.persistence = persistence;
    <code role="type">this</code>.midtier = midtier;
    <code role="type">this</code>.ui = ui;
  }

  <code role="type">public</code> <code role="type">void</code> run() {
    persistence.startPersistence();
    midtier.startMidtier();
    ui.startUI();
  }
}
</programlisting><para id="para_you_can_certainly_write_applic">(We nested the component
    interfaces inside <literal moreinfo="none">JavaApp</literal> to avoid creating separate
    files for each one!) You can certainly write applications this way in
    Scala. However, the self-type approach turns programmatic dependency
    resolution, i.e., passing dependencies to constructors or setter methods
    at runtime, into declarative dependency resolution at compile time, which
    catches errors earlier. Declarative programming, which is a hallmark of
    functional programming, is generally more robust, succinct, and clear,
    compared to imperative programming.</para><para id="para_in_selftypeannotationsandabs">We will return to self-type
    annotations as a component composition model in <xref linkend="ApplicationDesign"/>. See <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/> and <xref linkend="DependencyInjectionInScala"/>.<indexterm class="endofrange" startref="ch12_datatypesself" significance="normal"/><indexterm class="endofrange" startref="ch12_selftype" significance="normal"/><indexterm class="endofrange" startref="ch12_typeself" significance="normal"/></para></sect1><sect1 id="StructuralTypes"><title>Structural Types</title><para id="para_structural_types">You can think of <emphasis>structural
    types</emphasis> as a type-safe approach to <emphasis>duck
    typing</emphasis>, the popular name for the way method resolution works in
    dynamically typed languages. In Ruby, for example, when you write
    <literal moreinfo="none">starFighter.shootWeapons</literal>, the runtime looks for a
    <literal role="keep-together" moreinfo="none">shootWeapons</literal> method on the object
    referenced by <literal moreinfo="none">starFighter</literal>. That method, if found, might
    have been defined in the class used to instantiate
    <literal moreinfo="none">starFighter</literal> or one of its parents or “included”
    modules. The method might also have been added to the object using the
    metaprogramming facility of Ruby. Finally, the object might override the
    catch-all <literal moreinfo="none">method_missing</literal> method and do something
    reasonable when the object receives the <literal moreinfo="none">shootWeapons</literal>
    “message.”<indexterm significance="normal"><primary>Ruby</primary><secondary>method resolution in</secondary></indexterm><indexterm significance="normal"><primary>duck typing</primary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>structural types</secondary></indexterm><indexterm significance="normal"><primary>structural types</primary></indexterm></para><para id="para_what_scala_allows_you_do_inste">Scala doesn’t support this
    kind of method resolution, Instead, Scala allows you to specify that an
    object must adhere to a certain <emphasis>structure</emphasis>: that it
    contains certain types, fields, or methods, without concern for the actual
    type of the object. We first encountered structural types near the
    beginning of <xref linkend="Traits"/>. Here is the example we saw then, a
    variation of the Observer Pattern:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/Traits/observer/observer.scala</code>

<code role="preproc">package</code> observer

<code role="statement">trait</code> <code role="special">Subject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = { <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> Any</code>) }

  <code role="statement">private</code> <code role="statement">var</code> observers = <code role="special">List</code><code role="special">[Observer]</code>()
  <code role="statement">def</code> <code role="identifier">addObserver</code>(observer:<code role="type">Observer</code>) = observers ::= observer
  <code role="statement">def</code> <code role="identifier">notifyObservers</code> = observers foreach (<code role="statement">_</code>.receiveUpdate(<code role="statement">this</code>))
}
</programlisting><para id="para_the_declaration_type_observer">The declaration
    <literal moreinfo="none">type Observer = { def receiveUpdate(subject: Any) }</literal>
    says that any valid observer must have the
    <literal moreinfo="none">receiveUpdate</literal> method. It doesn’t matter what the actual
    type is for a particular observer.</para><para id="para_structural_types_have_the_virt">Structural types have the
    virtue of minimizing the interface between two things. In this case, the
    coupling consists of only a single method signature, rather than a type,
    such as a shared trait. A drawback of a structural type is that we still
    couple to a particular <emphasis>name</emphasis>. If a name is arbitrary,
    we don’t really care about its name so much as its intent. In our example
    of a single method, we can avoid coupling to the name using a function
    object instead. In fact, we did this in <xref linkend="OverridingAbstractTypes"/>.</para><para id="para_structural_types_when_names_are_good">On the other hand, if
    the name is a universal convention in some sense, then coupling to it has
    more merit. For example, <literal moreinfo="none">foreach</literal> is very common name in
    the Scala library with a particular meaning, so defining a structural type
    based on <literal moreinfo="none">foreach</literal> might be better for conveying intent
    to the user, rather than using an anonymous function of some kind.</para></sect1><sect1 id="ExistentialTypes"><title>Existential Types</title><para id="para_existential_types"><emphasis>Existential types</emphasis>
    are a way of abstracting over types. They let you “acknowledge” that there
    is a type involved without specifying exactly what it is, usually because
    you don’t know what it is and you don’t need that knowledge in the current
    context.<indexterm significance="normal"><primary>data types</primary><secondary>existential types</secondary></indexterm><indexterm significance="normal"><primary>existential types</primary></indexterm></para><para id="para_existential_types_are_particul">Existential types are
    particularly useful for interfacing to Java’s type system for three
    cases:<indexterm significance="normal"><primary>Java</primary><secondary>interfacing with type system, using existential
        types</secondary></indexterm></para><itemizedlist><listitem><para>The type parameters of generics are “erased” at the byte code
        level (called <emphasis>type erasure</emphasis>). For example, when a
        <literal moreinfo="none">List[Int]</literal> is created, the <literal moreinfo="none">Int</literal>
        type is not available in the byte code.</para></listitem><listitem><para>You might encounter “raw” types, such as pre-Java 5 libraries
        where collections had no type parameters. (All type parameters are
        effectively <literal moreinfo="none">Object</literal>.)</para></listitem><listitem><para>When Java uses wildcards in generics to express variance
        behavior when the generics are <emphasis>used</emphasis>, the actual
        type is unknown. (We discussed this earlier in <xref linkend="VarianceUnderInheritance"/>.)</para></listitem></itemizedlist><para id="para_consider_the_case_of_pattern_m">Consider the case of
    pattern matching on <literal moreinfo="none">List[A]</literal> objects. You might like to
    write code like the following:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/existentials/type-erasure-wont-work.scala</code>
<code role="comment">// WARNINGS: Does not work as you might expect.</code>

<code role="statement">object</code> <code role="special">ProcessList</code> {
  <code role="statement">def</code> <code role="identifier">apply</code><code role="identifier">[B]</code>(list:<code role="type"> List[B]</code>) = list <code role="statement">match</code> {
    <code role="statement">case</code> lInt:<code role="type">    List[Int]</code>    <code role="statement">=&gt;</code> <code role="comment">// do something</code>
    <code role="statement">case</code> lDouble:<code role="type"> List[Double]</code> <code role="statement">=&gt;</code> <code role="comment">// do something</code>
    <code role="statement">case</code> lString:<code role="type"> List[String]</code> <code role="statement">=&gt;</code> <code role="comment">// do something</code>
    <code role="statement">case</code> <code role="statement">_</code>                     <code role="statement">=&gt;</code> <code role="comment">// default behavior</code>
  }
}
</programlisting><para id="para_if_you_compile_this_with_the_">If you compile this with the
    <literal moreinfo="none">-unchecked</literal> flag on the JVM, you’ll get warnings that
    the type parameters like <literal moreinfo="none">Int</literal> are unchecked, because of
    type erasure. Hence, we can’t distinguish between any of the list types
    shown.</para><para id="para_the_manifests_that_we_discus">The
    <literal moreinfo="none">Manifest</literal>s that we discussed previously won’t work
    either, because they can’t recover the erased type of
    <literal moreinfo="none">B</literal>.</para><para id="para_we_ve_already_learned_that_the">We’ve already learned that
    the best we can do in pattern matching is to focus on the fact that we
    have a list and not try to determine the “lost” type parameter for the
    list instance. For type safety, we have to specify that a list has a
    parameter, but since we don’t know what it is, we use the wildcard
    <literal moreinfo="none">_</literal> character for the type parameter, e.g.:</para><programlisting language="scala" format="linespecific"><code role="statement">case</code> l:<code role="type"> List[_]</code> <code role="statement">=&gt;</code> <code role="comment">// do something "generic" with the list</code>
</programlisting><para id="para_when_used_in_a_type_context_li">When used in a type context
    like this, the <literal moreinfo="none">List[_]</literal> is actually shorthand for the
    <emphasis>existential type</emphasis>, <literal moreinfo="none">List[T] forSome { type T
    }</literal>. This is the most general case. We’re saying the type
    parameter for the list could be any type. <xref linkend="existential-type-examples-table"/> lists some other examples
    that demonstrate the use of type bounds.<indexterm significance="normal"><primary>existential types</primary><secondary>examples of</secondary></indexterm></para><table id="existential-type-examples-table"><title>Existential type examples</title><tgroup cols="3"><thead valign="top"><row><entry>Shorthand</entry><entry>Full</entry><entry>Description</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">List[_]</literal></para></entry><entry><para><literal moreinfo="none">List[T] forSome { type T
            }</literal></para></entry><entry><para>T can be any subtype of
            <literal moreinfo="none">Any</literal>.</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">List[_ &lt;:</literal>
            <literal role="keep-together" moreinfo="none">scala.actors.AbstractActor]</literal></para></entry><entry><para><literal role="keep-together" moreinfo="none">List[T] forSome { type
            T &lt;:</literal> <literal role="keep-together" moreinfo="none">scala.actors.AbstractActor
            }</literal></para></entry><entry><para>T can be any subtype of <literal role="keep-together" moreinfo="none">AbstractActor</literal>.</para></entry></row><row><entry><para><literal moreinfo="none">List[_ &gt;: MyFancyActor &lt;:</literal>
            <literal role="keep-together" moreinfo="none">scala.actors.AbstractActor]</literal></para></entry><entry><para><literal moreinfo="none">List[T] forSome { type T &gt;: MyFancyActor
            &lt;: scala.actors.AbstractActor }</literal></para></entry><entry><para>T can be any subtype of <literal role="keep-together" moreinfo="none">AbstractActor</literal> up to and including
            the subtype <literal role="keep-together" moreinfo="none">MyFancyActor</literal>.</para></entry></row></tbody></tgroup></table><para id="para_if_you_think_about_how_scala_s">If you think about how
    Scala syntax for generics is mapped to Java syntax, you might have noticed
    that an expression like <literal moreinfo="none">java.util.List[_ &lt;:
    scala.actors.AbstractAc⁠tor]</literal> is structurally similar to the Java
    variance expression <literal moreinfo="none">java.util.List&lt;? extends
    scala.actors.AbstractActor&gt;</literal>. In fact, they are the same
    declarations. Although we said that variance behavior in Scala is defined
    at the declaration site, you can use existential type expressions in Scala
    to define call-site variance behavior. It is not recommended, for the
    reasons discussed previously, but you have that option.</para><para id="para_you_won_t_see_the_forsome_ex">You won’t see the
    <literal moreinfo="none">forSome</literal> existential type syntax very often in Scala
    code, because existential types exist primarily to support Java generics
    while preserving correctness in Scala’s type system. Type inference hides
    the details from us in most contexts. When working with Scala types, the
    other type constructs we have discussed in this chapter are preferred to
    existential types.</para></sect1><sect1 id="InfiniteDataStructuresAndLaziness"><title>Infinite Data Structures and Laziness</title><para id="para_infinite_data_structures">We described lazy values in <xref linkend="FunctionalProgramming"/>. In functional languages that are lazy
    by default, like Haskell, laziness makes it easy to support
    <emphasis>infinite</emphasis> data structures.<indexterm significance="normal"><primary>lazy evaluation, infinite data structures and</primary></indexterm><indexterm significance="normal"><primary>infinite data structures</primary><secondary>laziness and</secondary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>infinite data structures and lazy vals</secondary></indexterm></para><para id="para_for_example_consider_the_foll">For example, consider the
    following Scala method <literal moreinfo="none">fib</literal> that calculates the
    Fibonacci number for <literal moreinfo="none">n</literal> in the infinite Fibonacci
    sequence:<indexterm significance="normal"><primary>Fibonacci sequence, calculating</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">fib</code>(n:<code role="type"> Int</code>):<code role="type"> Int</code> = n <code role="statement">match</code> {
  <code role="statement">case</code> <code role="constant">0</code> | <code role="constant">1</code> <code role="statement">=&gt;</code> n
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fib(n-<code role="constant">1</code>) + fib(n-<code role="constant">2</code>)
}
</programlisting><para id="para_if_scala_were_purely_lazy_we_">If Scala were purely lazy,
    we could imagine a definition of the Fibonacci sequence like the following
    and it wouldn’t create an infinite loop:</para><programlisting language="scala" format="linespecific">fibonacci_sequence = <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">0</code> to infinity) <code role="statement">yield</code> fib(i)
</programlisting><para id="para_scala_isn_t_lazy_by_default_b">Scala isn’t lazy by default
    (and there is no <literal moreinfo="none">infinity</literal> value or keyword…), but the
    library contains a <literal moreinfo="none">Stream</literal> class that supports lazy
    evaluation and hence it can support infinite data structures. We’ll show
    an implementation of the Fibonacci sequence in a moment. First, here is a
    simpler example that uses streams to represent all positive integers, all
    positive odd integers, and all positive even integers:<indexterm significance="normal"><primary>Stream class</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/lazy/lazy-ints-script.scala</code>

<code role="statement">def</code> <code role="identifier">from</code>(n:<code role="type"> Int</code>):<code role="type"> Stream[Int]</code> = Stream.cons(n, from(n+<code role="constant">1</code>))

<code role="statement">lazy</code> <code role="statement">val</code> ints = from(<code role="constant">0</code>)
<code role="statement">lazy</code> <code role="statement">val</code> odds = ints.filter(<code role="statement">_</code> % <code role="constant">2</code> == <code role="constant">1</code>)
<code role="statement">lazy</code> <code role="statement">val</code> evens = ints.filter(<code role="statement">_</code> % <code role="constant">2</code> == <code role="constant">0</code>)

odds.take(<code role="constant">10</code>).print
evens.take(<code role="constant">10</code>).print
</programlisting><para id="para_lazy_ints_output">It produces this output:</para><screen format="linespecific">1, 3, 5, 7, 9, 11, 13, 15, 17, 19, Stream.empty
0, 2, 4, 6, 8, 10, 12, 14, 16, 18, Stream.empty</screen><para id="para_the_from_method_is_recursive">The <literal moreinfo="none">from</literal>
    method is recursive and never terminates! We use it to define the
    <literal moreinfo="none">ints</literal> by calling <literal moreinfo="none">from(0)</literal>.
    <literal moreinfo="none">Streams.cons</literal> is an object with an
    <literal moreinfo="none">apply</literal> method that is analogous to the
    <literal moreinfo="none">::</literal> (“cons”) method on <literal moreinfo="none">List</literal>. It
    returns a new stream with the first argument as the head and the second
    argument, another stream, as the tail. The <literal moreinfo="none">odds</literal> and
    <literal moreinfo="none">evens</literal> infinite streams are computed by filtering
    <literal moreinfo="none">ints</literal>.</para><para id="para_once_we_have_defined_the_strea">Once we have defined the
    streams, the <literal moreinfo="none">take</literal> method returns a new stream of the
    fixed size specified, 10 in this case. When we print this stream with the
    <literal moreinfo="none">print</literal> method, it prints the 10 elements followed by
    <literal moreinfo="none">Stream.empty</literal> when it hits the end of the stream.</para><para id="para_returning_to_the_fibonacci_seq">Returning to the Fibonacci
    sequence, there is a famous definition using infinite, lazy sequences that
    exploits the <literal moreinfo="none">zip</literal> operation (see, e.g., <link linkend="Abelson1996" xrefstyle="select:nopage">[Abelson1996]</link>). Our
    discussion for Scala is adapted from <link linkend="Ortiz2007" xrefstyle="select:nopage">[Ortiz2007]</link>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/lazy/lazy-fibonacci-script.scala</code>

<code role="statement">lazy</code> <code role="statement">val</code> fib:<code role="type"> Stream[Int]</code> =
  Stream.cons(<code role="constant">0</code>, Stream.cons(<code role="constant">1</code>, fib.zip(fib.tail).map(p <code role="statement">=&gt;</code> p._1 + p._2)))

fib.take(<code role="constant">10</code>).print
</programlisting><para id="para_lazy_fibonacci_output">It produces this output:</para><screen format="linespecific">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, Stream.empty</screen><para id="para_how_does_this_work_like_our_i">How does this work? Like our
    iterative definition at the start of this section, we explicitly specify
    the first two values, 0 and 1. The rest of the numbers are computed using
    <literal moreinfo="none">zip</literal>, exploiting the fact that <literal moreinfo="none">fib(n) =
    fib(n-1) + fib(n-2)</literal>, for <literal moreinfo="none">n &gt; 1</literal>.</para><para id="para_the_call_fib_zip_fib_tail_c">The call
    <literal moreinfo="none">fib.zip(fib.tail)</literal> creates a new stream of tuples with
    the elements of <literal moreinfo="none">fib</literal> in the first position of the tuple,
    and the elements of <literal moreinfo="none">fib.tail</literal> in the second position of
    the tuple. To get back to a single integer for each position in the
    stream, we map the stream of tuples to a stream of <literal moreinfo="none">Ints</literal>
    by adding the tuple elements. Here are the tuples calculated:</para><screen format="linespecific">(0,1), (1,1), (1,2), (2,3), (3,5), (5,8), (8,13), (13, 21), (21, 34), ...</screen><para id="para_note_that_each_second_element_">Note that each second
    element is the next number in the Fibonacci sequence after the first
    element in the tuple. Adding them we get the following:</para><screen format="linespecific">1, 2, 3, 5, 8, 13, 21, 34, 55, ...</screen><para id="para_since_we_concatenate_this_stre">Since we concatenate this
    stream after 0 and 1, we get the Fibonacci sequence:</para><screen format="linespecific">0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...</screen><para id="para_another_scala_type_that_is_laz">Another lazy Scala type,
    albeit a finite one, is <literal moreinfo="none">Range</literal>. Typically, you write
    literal ranges such as <literal moreinfo="none">1 to 1000</literal>.
    <literal moreinfo="none">Range</literal> is lazy, so very large ranges don’t consume too
    many resources. However, this feature can lead to subtle problems unless
    you are careful, as documented by <link linkend="Smith2009b" xrefstyle="select:nopage">[Smith2009b]</link> and commenters. Using the
    example described there, consider this function for returning a
    <literal moreinfo="none">Seq</literal> of three random integers:<indexterm significance="normal"><primary>Range object</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeSystem/lazy/lazy-range-danger-script.scala</code>

<code role="statement">def</code> <code role="identifier">mkRandomInts</code>() = {
  <code role="statement">val</code> randInts = <code role="statement">for</code> {
    i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>
    <code role="statement">val</code> rand = i + (<code role="statement">new</code> scala.util.<code role="special">Random</code>).nextInt
  } <code role="statement">yield</code> rand
  randInts
}
<code role="statement">val</code> ints1 = mkRandomInts

println(<code role="constant">"Calling first on ints1 Seq:"</code>)
<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) {
  println( ints1.first)
}

<code role="statement">val</code> ints2 = ints1.toList
println(<code role="constant">"Calling first on List created from ints1 Seq:"</code>)
<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code>) {
  println( ints2.first)
}
</programlisting><para id="para_here_is_the_output_from_one_ru">Here is the output from one
    run. The actual values will vary from run to run:</para><screen format="linespecific">Calling first on ints1 Seq:
-1532554511
-1532939260
-1532939260
Calling first on List created from ints1 Seq:
-1537171498
-1537171498
-1537171498</screen><para id="para_calling_first_on_the_sequenc">Calling
    <literal moreinfo="none">first</literal> on the sequence does not always return the same
    value! The reason is that the range at the beginning of the
    <literal moreinfo="none">for</literal> comprehension effectively forces the whole sequence
    to be lazy. Hence, it is reevaluated with <emphasis>each</emphasis> call
    to <literal moreinfo="none">first</literal>, and the first value in the sequence actually
    changes, since <literal moreinfo="none">Random</literal> returns a different number each
    time (at least, it will if there is a sufficient time delta between
    calls).</para><para id="para_however_calling_tolist_on_t">However, calling
    <literal moreinfo="none">toList</literal> on the sequence forces it to evaluate the whole
    range and create a <emphasis>strict</emphasis> list.</para><warning id="para_warning_avoid_using_ranges_in"><para>Avoid using ranges in <literal moreinfo="none">for (...) yield x</literal>
      constructs, while <literal moreinfo="none">for (...) {...}</literal> alternatives are
      fine.</para></warning><para id="para_finally_scala_version_2_8_wil">Finally, Scala version 2.8
    will include a <literal moreinfo="none">force</literal> method on all collections that
    will force them to be strict.</para></sect1><sect1 id="_recap_and_what_8217_s_next_5"><title>Recap and What’s Next</title><para id="para_it_s_important_to_remember_tha">It’s important to remember
    that you don’t have to master the intricacies of Scala’s rich type system
    to use Scala effectively. As you use Scala more and more, mastering the
    type system will help you create powerful, sophisticated libraries that
    accelerate your productivity.</para><para id="para_the_scalaspec2009_describe">The <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>
    describes the type system in formal detail. Like any specification, it can
    be difficult reading. The effort is worthwhile if you want a deep
    understanding of the type system. There are also a multitude of papers on
    Scala’s type system. You can find links to many of them on the official
    <ulink url="http://scala-lang.org"/> website.<indexterm significance="normal"><primary>documentation</primary><secondary>Scala type system</secondary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>documentation for Scala type system</secondary></indexterm></para><para id="para_we_have_completed_the_heavy_">The next two chapters cover
    the pragmatics of application design and Scala’s development tools and
    libraries.<indexterm class="endofrange" startref="ch12_datatypes" significance="normal"/></para></sect1></chapter><chapter id="ApplicationDesign"><title>Application Design</title><para id="para_in_this_chapter_we_take_a_pra">In this chapter, we take a
  pragmatic look at developing applications in Scala. We discuss a few
  language and API features that we haven’t covered before, examine common
  design patterns and idioms, and revisit <emphasis>traits</emphasis> with an
  eye toward structuring our code effectively.<indexterm class="startofrange" id="ch13_appdesign" significance="normal"><primary>application design</primary></indexterm></para><sect1 id="Annotations"><title>Annotations</title><para id="para_like_java_and_net_scala_supp">Like Java and .NET, Scala
    supports <emphasis>annotations</emphasis> for adding
    <emphasis>metadata</emphasis> to declarations. Annotations are used by a
    variety of tools in typical enterprise and Internet applications. For
    example, there are annotations that provide directives to the compiler,
    and some Object-Relational Mapping (ORM) frameworks use annotations on
    types and type members to indicate persistence mapping information. While
    some uses for annotations in the Java and .NET worlds can be accomplished
    through other means in Scala, annotations can be essential for
    interoperating with Java and .NET libraries that rely heavily on them.
    Fortunately, Java and .NET annotations can be used in Scala
    code.<indexterm class="startofrange" id="ch13_declarationsannotations" significance="normal"><primary>declarations</primary><secondary>annotations in</secondary></indexterm><indexterm class="startofrange" id="ch13_appdesignannotations" significance="normal"><primary>application design</primary><secondary>annotations</secondary></indexterm><indexterm significance="normal"><primary>metadata</primary><secondary>adding to declarations</secondary></indexterm><indexterm class="startofrange" id="ch13_annotations" significance="normal"><primary>annotations</primary></indexterm></para><para id="para_the_interpretation_of_scala_an">The interpretation of Scala
    annotations depends on the runtime environment. In this section, we will
    focus on the JDK environment.</para><para id="para_in_java_annotations_are_decla">In Java, annotations are
    declared using special conventions, e.g., declaring annotations with the
    <literal moreinfo="none">@interface</literal> keyword instead of the
    <literal moreinfo="none">class</literal> or <literal moreinfo="none">interface</literal> keyword. Here is
    the declaration of an annotation taken from a toolkit called Contract4J
    (see <link linkend="Contract4J" xrefstyle="select:nopage">[Contract4J]</link>) that uses annotations to
    support <emphasis>Design by Contract</emphasis> programming in Java (see
    also <xref linkend="DesignByContractExample"/>). Some of the comments
    have been removed for clarity:<indexterm significance="normal"><primary sortas="interface keyword">@interface keyword
        (Java)</primary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>annotations</secondary></indexterm></para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/AppDesign/annotations/Pre.java</code>

<code role="preproc">package</code> org.contract4j5.contract;
<code role="preproc">import</code> java.lang.annotation.Documented;
<code role="preproc">import</code> java.lang.annotation.ElementType;
<code role="preproc">import</code> java.lang.annotation.Retention;
<code role="preproc">import</code> java.lang.annotation.RetentionPolicy;
<code role="preproc">import</code> java.lang.annotation.Target;

<code role="preproc">@Documented</code>
<code role="preproc">@Retention</code>(RetentionPolicy.RUNTIME)
<code role="preproc">@Target</code>({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
<code role="type">public</code> <code role="type">@interface</code> Pre {
  <code role="comment">/**</code>
<code role="comment">   *</code><code role="special"> The "value" is the test expression, which must evaluate to true or false.</code>
<code role="comment">   * It must be a valid expression in the scripting language you are using.</code>
<code role="comment">   */</code>
  String value() <code role="statement">default</code> <code role="constant">""</code>;

  <code role="comment">/**</code>
<code role="comment">   *</code><code role="special"> An optional message to print with the standard message when the contract</code>
<code role="comment">   *</code><code role="special"> fails.</code>
<code role="comment">   */</code>
  String message() <code role="statement">default</code> <code role="constant">""</code>;
}
</programlisting><para id="para_the_pre_annotation_is_used_">The <literal moreinfo="none">@Pre</literal>
    annotation is used to specify “preconditions” that must be satisfied when
    <emphasis>entering</emphasis> a method or constructor, or
    <emphasis>before</emphasis> using a parameter passed to a method or
    constructor. The conditions are specified as a string that is actually a
    snippet of source code that evaluates to <literal moreinfo="none">true</literal> or
    <literal moreinfo="none">false</literal>. The source <emphasis>languages</emphasis>
    supported for these snippets are scripting languages like Groovy and
    JRuby. The name of the variable for this string, <literal moreinfo="none">value</literal>,
    is a conventional name for the most important field in the
    annotation.<indexterm significance="normal"><primary>metadata</primary><seealso>annotations</seealso></indexterm><indexterm significance="normal"><primary sortas="Pre annotation">@Pre annotation</primary></indexterm></para><para id="para_the_other_field_is_an_optional">The other field is an
    optional <literal moreinfo="none">message</literal> to use when reporting failures.</para><para id="para_the_declaration_has_other_anno">The declaration has other
    annotations applied to it—for example, the <literal moreinfo="none">@Retention</literal>
    annotation with the value <literal moreinfo="none">RetentionPolicy.RUNTIME</literal> means
    that when <literal moreinfo="none">@Pre</literal> is used, its information will be
    retained in the class file for runtime use.<indexterm significance="normal"><primary sortas="Retention annotation">@Retention annotation</primary></indexterm></para><para id="para_here_is_a_scala_example_that_u">Here is a Scala example
    that uses <literal moreinfo="none">@Pre</literal> and shows several ways to specify the
    <literal moreinfo="none">value</literal> and <literal moreinfo="none">message</literal> parameters:</para><screen format="linespecific">// code-examples/AppDesign/annotations/pre-example.scala

import org.contract4j5.contract._

class Person(
  @Pre( "name != null &amp;&amp; name.length() &gt; 0" )
  val name: String,
  @Pre{ val value = "age &gt; 0", val message = "You're too young!" }
  val age: Int,
  @Pre( "ssn != null" )
  val ssn: SSN)

class SSN(
  @Pre( "valid(ssn)" ) { val message = "Format must be NNN-NN-NNNN." }
  val ssn: String) {

  private def valid(value: String) =
    value.matches("""^\s*\d{3}-\d{2}-\d{4}\s*$""")
}</screen><para id="para_in_the_person_class_the_p">In the <literal moreinfo="none">Person</literal>
    class, the <literal moreinfo="none">@Pre</literal> annotation on <literal moreinfo="none">name</literal>
    has a simple string argument: the “precondition” that users must satisfy
    when passing in a name. This value can’t be <literal moreinfo="none">null</literal>, and
    it can’t be of zero length. As in Java, if a single argument is given to
    the annotation, it is assigned to the <literal moreinfo="none">value</literal>
    field.</para><para id="para_a_similar_pre_annotation_is">A similar
    <literal moreinfo="none">@Pre</literal> annotation is used for the third argument, the
    <literal moreinfo="none">ssn</literal> (Social Security number). In both cases, the
    <literal moreinfo="none">message</literal> defaults to the empty string specified in the
    definition of <literal moreinfo="none">Pre</literal>.</para><para id="para_the_pre_annotation_for_the_">The <literal moreinfo="none">@Pre</literal>
    annotation for the age shows one way to specify values for more than one
    field. Instead of parentheses, curly braces are used. The syntax for each
    field looks like a <literal moreinfo="none">val</literal> declaration, without any type
    information, since the types can always be inferred! This syntax allows
    you to use the shorthand syntax for the <literal moreinfo="none">value</literal> and still
    specify values for other fields.</para><note id="para_note_if_person_were_a_java_"><para>If <literal moreinfo="none">Person</literal> were a Java class, this annotation
      expression would look identical, except there would be no
      <literal moreinfo="none">val</literal> keywords and parentheses would be used.</para></note><para id="para_the_pre_annotation_on_the_c">The <literal moreinfo="none">@Pre</literal>
    annotation on the constructor parameter for the <literal moreinfo="none">SSN</literal>
    class shows the alterna<phrase role="keep-together">tive syntax</phrase>
    for specifying values for more than one field. The
    <literal moreinfo="none">value</literal> field is specified as before with a one-element
    parameter list. The <literal moreinfo="none">message</literal> is initialized in a
    follow-on block in curly braces.</para><para id="para_testing_this_code_would_requir">Testing this code would
    require the Contract4J library, build setup, etc. We won’t cover those
    steps here. Refer to <link linkend="Contract4J" xrefstyle="select:nopage">[Contract4J]</link> for more information.</para><para id="para_scala_annotations_don_t_use_a_">Scala annotations don’t use
    a special declaration syntax. They are declared as normal classes. This
    approach eliminates a “special case” in the language, but it also means
    that some of the features provided by Java annotations aren’t supported,
    as we will see. Here is an example annotation from the Scala library,
    <literal moreinfo="none">SerialVersionUID</literal> (again with the comments removed for
    clarity):</para><programlisting language="scala" format="linespecific"><code role="preproc">package</code> scala

<code role="statement">class</code> <code role="special">SerialVersionUID</code>(uid:<code role="type"> Long</code>) <code role="statement">extends</code> <code role="special">StaticAnnotation</code>
</programlisting><para id="para_the_serialversionuid_annota">The
    <literal moreinfo="none">@SerialVersionUID</literal> annotation is applied to a class to
    define a globally unique ID as a <literal moreinfo="none">Long</literal>. When the
    annotation is used, the ID is specified as a constructor argument. This
    annotation serves the same purpose as a <literal moreinfo="none">static</literal> field
    named <literal moreinfo="none">serialVersionUID</literal> in a Java class. This is one
    example of a Scala annotation that maps to a “non-annotation” construct in
    Java.<indexterm significance="normal"><primary sortas="serialVersionUID">@serialVersionUID
        annotation</primary></indexterm></para><para id="para_the_parent_of_serialversionui">The parent of
    <literal moreinfo="none">SerialVersionUID</literal> is the trait
    <literal moreinfo="none">scala.StaticAnnotation</literal>, which is used as the parent for
    all annotations that should be visible to the type checker, even across
    compilation units. The parent class of
    <literal moreinfo="none">scala.StaticAnnotation</literal> is
    <literal moreinfo="none">scala.Annotation</literal>, which is the parent of all Scala
    annotations.<indexterm significance="normal"><primary>Annotation class</primary></indexterm><indexterm significance="normal"><primary>StaticAnnotation class</primary></indexterm></para><para id="para_did_you_notice_that_there_is_n">Did you notice that there
    is no <literal moreinfo="none">val</literal> on <literal moreinfo="none">uid</literal>? Why isn’t
    <literal moreinfo="none">uid</literal> a field? The reason is that the annotation’s data
    is not intended for use by the program. Recall that it is metadata
    designed for external tools to use, such as <literal moreinfo="none">scalac</literal>.
    This also means that Scala annotations have no way to define default
    values in version 2.7.X, as implicit arguments don’t work. However, the
    new default arguments feature in version 2.8.0 may work. (It is not yet
    implemented at the time of this writing.)<indexterm significance="normal"><primary>metadata</primary><secondary>default values and</secondary></indexterm></para><para id="para_like_java_and_net_annotatio">Like Java (and .NET)
    annotations, a Scala annotation clause applies to the definition it
    precedes. You can have as many annotation clauses as you want, and the
    order in which they appear is not significant.</para><para id="para_like_java_annotations_scala_a">Like Java annotations, Scala
    annotation clauses are written using the syntax <literal role="keep-together" moreinfo="none">@MyAnnotation</literal> if the annotation constructor
    takes no parameters, or <literal moreinfo="none">@MyAnnotation(arg1, .., argN)</literal>
    if the constructor takes parameters. The annotation must be a subclass of
    <literal moreinfo="none">scala.Annotation</literal>.</para><para id="para_all_the_constructor_parameters">All the constructor
    parameters must be constant expressions, including strings, class
    literals, Java enumerations, numerical expressions and one-dimensional
    arrays of the same. However, the compiler also allows annotation clauses
    with other arguments, such as boolean values and maps, as shown in this
    example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/annotations/anno-example.scala</code>

<code role="preproc">import</code> scala.StaticAnnotation

<code role="statement">class</code> <code role="special">Persist</code>(tableName:<code role="type"> String</code>, params:<code role="type"> Map[String,Any]</code>)
  <code role="statement">extends</code> <code role="special">StaticAnnotation</code>

<code role="comment">// Doesn't compile:</code>
<code role="comment">//@Persist("ACCOUNTS", Map("dbms" -&gt; "MySql", "writeAutomatically" -&gt; true))</code>
@<code role="special">Persist</code>(<code role="constant">"ACCOUNTS"</code>, <code role="special">Map</code>((<code role="constant">"dbms"</code>, <code role="constant">"MySql"</code>), (<code role="constant">"writeAutomatically"</code>, <code role="constant">true</code>)))
<code role="statement">class</code> <code role="special">Account</code>(<code role="statement">val</code> balance:<code role="type"> Double</code>)
</programlisting><para id="para_curiously_if_you_attempt_to_u">Curiously, if you attempt to
    use the standard <literal moreinfo="none">Map</literal> literal syntax that is shown in
    the comments, you get a compilation error that the
    <literal moreinfo="none">-&gt;</literal> method doesn’t exist for
    <literal moreinfo="none">String</literal>. The implicit conversion to
    <literal moreinfo="none">ArrowAssoc</literal> that we discussed in <xref linkend="PredefObject"/> isn’t invoked. Instead, you have to use a list
    of <literal moreinfo="none">Tuples</literal>, which <literal moreinfo="none">Map.apply</literal> actually
    expects.<indexterm significance="normal"><primary>ClassfileAnnotation class</primary></indexterm></para><para id="para_another_child_of_scala_annota">Another child of
    <literal moreinfo="none">scala.Annotation</literal> that is intended to be a parent of
    other annotations is the trait
    <literal moreinfo="none">scala.ClassfileAnnotation</literal>. It is supposed to be used
    for annotations that should have runtime retention, i.e., the annotations
    should be visible in the class file so they are available at runtime.
    However, actually using it with the JDK version of Scala results in
    compiler errors like the following:</para><screen format="linespecific">...: warning: implementation restriction: subclassing Classfile does not
make your annotation visible at runtime.  If that is what
you want, you must write the annotation class in Java.
...</screen><para id="para_hence_if_you_want_runtime_vis">Hence, if you want runtime
    visibility, you have to implement the annotation in Java. This works fine,
    since you can use any Java annotation in Scala code. The Scala library
    currently defines no annotations derived from
    <literal moreinfo="none">ClassfileAnnotation</literal>, perhaps for obvious
    reasons.</para><warning id="para_warning_avoid_classfileannot"><para>Avoid <literal moreinfo="none">ClassfileAnnotation</literal>. Implement
      annotations that require runtime retention in Java instead.</para></warning><para id="para_for_scala_version_2_7_x_anoth">For Scala version 2.7.X,
    another important limitation to keep in mind is that annotations can’t be
    nested. This causes problems when using JPA annotations in Scala code, for
    example, as discussed in <link linkend="JPAScala" xrefstyle="select:nopage">[JPAScala]</link>. However, Scala version 2.8
    removes this <phrase role="keep-together">limitation</phrase>.<indexterm significance="normal"><primary>annotations</primary><secondary>nesting</secondary></indexterm></para><warning id="para_warning_annotations_can_only_"><para>Annotations can only be nested in Scala version 2.8.</para></warning><para id="para_the_following_tables_describe_">Tables <xref linkend="scala-annotations" xrefstyle="select: labelnumber"/> and <xref linkend="scala-static-annotations" xrefstyle="select: labelnumber"/>
    describe all the annotations defined in the Scala library (adapted and
    expanded from <ulink url="http://www.scala-lang.org/node/106"/>).
    We start with the direct children of <literal moreinfo="none">Annotation</literal>,
    followed by the children of <literal moreinfo="none">StaticAnnotation</literal>.<indexterm significance="normal"><primary>Annotation class</primary><secondary>Scala annotations derived from</secondary></indexterm><indexterm significance="normal"><primary>annotations</primary><secondary>Scala annotations derived from Annotation</secondary></indexterm></para><table id="scala-annotations"><title>Scala annotations derived from Annotation</title><tgroup cols="3"><thead valign="top"><row><entry>Name</entry><entry>Java equivalent</entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para><literal role="keep-together" moreinfo="none">ClassfileAnnotation</literal></para></entry><entry><para>Annotate with <literal moreinfo="none">@Retention<?lb?>(RetentionPolicy.RUNTIME)</literal></para></entry><entry><para>The parent trait for annotations that should be
            retained in the class file for runtime access, but it doesn’t
            actually work on the JDK!</para></entry></row><row><entry><para><literal moreinfo="none">BeanDescription</literal></para></entry><entry><para><literal role="keep-together" moreinfo="none">BeanDescriptor</literal>
            (class)</para></entry><entry><para>An annotation for <emphasis>JavaBean</emphasis> types
            or members that associates a short description (provided as the
            annotation argument) that will be included when generating bean
            information.</para></entry></row><row><entry><para><literal moreinfo="none">BeanDisplayName</literal></para></entry><entry><para><literal moreinfo="none">BeanDescriptor</literal>
            (class)</para></entry><entry><para>An annotation for <emphasis>JavaBean</emphasis> types
            or members that associates a name (provided as the annotation
            argument) that will be included when generating bean
            information.</para></entry></row><row><entry><para><literal moreinfo="none">BeanInfo</literal></para></entry><entry><para><literal moreinfo="none">BeanInfo</literal> (class)</para></entry><entry><para>A marker that indicates that a <literal role="keep-together" moreinfo="none">BeanInfo</literal> class should be generated
            for the marked Scala class. A <literal moreinfo="none">val</literal> <phrase role="keep-together">becomes</phrase> a read-only property. A
            <literal moreinfo="none">var</literal> <phrase role="keep-together">becomes</phrase> a read-write property. A
            <literal moreinfo="none">def</literal> becomes a method.</para></entry></row><row><entry><para><literal moreinfo="none">BeanInfoSkip</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>A marker that indicates that bean information should
            not be generated for the annotated member.</para></entry></row><row><entry><para><literal moreinfo="none">StaticAnnotation</literal></para></entry><entry><para>Static fields, <?lb?><literal role="keep-together" moreinfo="none">@Target(ElementType.TYPE)</literal></para></entry><entry><para>The parent trait of annotations that should be
            visible across compilation units and define “static”
            metadata.</para></entry></row><row><entry><para><literal moreinfo="none">TypeConstraint</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>An annotation trait that can be applied to other
            annotations that define constraints on a type, relying only on
            information defined within the type itself, as opposed to external
            context information where the type is defined or used. The
            compiler can exploit this restriction to rewrite the constraint.
            There are currently no library annotations that use this
            trait.</para></entry></row><row><entry><para><literal moreinfo="none">unchecked</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>A marker annotation for the selector in a match
            statement (e.g., the <literal moreinfo="none">x</literal> in <literal moreinfo="none">x match
            {...}</literal>) that suppresses a compiler warning if the
            <literal moreinfo="none">case</literal> clauses are not “exhaustive.” You can
            still have a runtime <literal moreinfo="none">MatchError</literal> occur if a
            value of <literal moreinfo="none">x</literal> fails to match any of the
            <literal moreinfo="none">case</literal> clauses. See the upcoming
            example.</para></entry></row><row><entry><para><literal moreinfo="none">unsealed</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>Deprecated, use <literal moreinfo="none">@unchecked</literal> <phrase role="keep-together">instead</phrase>.</para></entry></row></tbody></tgroup></table><table id="scala-static-annotations"><title>Scala annotations derived from StaticAnnotation</title><tgroup cols="3"><thead valign="top"><row><entry>Name</entry><entry><phrase role="keep-together">Java
            equivalent</phrase></entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">BeanProperty<indexterm significance="normal"><primary>StaticAnnotation class</primary><secondary>annotations derived from</secondary></indexterm><indexterm significance="normal"><primary>annotations</primary><secondary>Scala annotations derived from
                StaticAnnotation</secondary></indexterm></literal></para></entry><entry><para><emphasis>JavaBean</emphasis>
            convention</para></entry><entry><para>A marker for a field (including a constructor
            argument with the <literal moreinfo="none">val</literal> or <literal moreinfo="none">var</literal>
            keyword) that tells the compiler to generate a JavaBean-style
            “getter” and “setter” method. The setter is only generated for
            <literal moreinfo="none">var</literal> declarations. See the discussion in <xref linkend="JavaBeanProperties"/>.</para></entry></row><row><entry><para><literal moreinfo="none">cloneable</literal></para></entry><entry><para><literal role="keep-together" moreinfo="none">java.lang.Cloneable</literal> (<phrase role="keep-together">interface</phrase>)</para></entry><entry><para>A class marker indicating that a class can be
            cloned.</para></entry></row><row><entry><para><literal moreinfo="none">cps</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>(version 2.8) Generate byte code using continuation
            passing style.</para></entry></row><row><entry><para><literal moreinfo="none">deprecated</literal></para></entry><entry><para><literal role="keep-together" moreinfo="none">java.lang.Deprecated</literal></para></entry><entry><para>A marker for any definition indicating that the
            defined “item” is obsolete. The compiler will issue a warning when
            the item is used.</para></entry></row><row><entry><para><literal moreinfo="none">inline</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>A method marker telling the compiler that it should
            try “<phrase role="keep-together">especially</phrase> hard” to
            inline the method.</para></entry></row><row><entry><para><literal moreinfo="none">native</literal></para></entry><entry><para><literal moreinfo="none">native</literal> (keyword)</para></entry><entry><para>A method marker indicating the method is implemented
            as “native” code. The method body will not be generated by the
            compiler, but usage of the method will be type
            checked.</para></entry></row><row><entry><para><literal moreinfo="none">noinline</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>A method marker that prevents the compiler from
            inlining the method, even when it appears to be safe to do
            so.</para></entry></row><row><entry><para><literal moreinfo="none">remote</literal></para></entry><entry><para><literal moreinfo="none">java.rmi.Remote</literal> (<phrase role="keep-together">interface</phrase>)</para></entry><entry><para>A class marker indicating that the class can be
            invoked from a remote JVM.</para></entry></row><row><entry><para><literal moreinfo="none">serializable</literal></para></entry><entry><para><literal role="keep-together" moreinfo="none">java.io.Serializable</literal> (<phrase role="keep-together">interface</phrase>)</para></entry><entry><para>A class marker indicating that the class can be
            serialized.</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">SerialVersionUID</literal></para></entry><entry><para><literal moreinfo="none">serialVersionUID</literal>
            <emphasis>static</emphasis> <phrase role="keep-together">field in
            a class</phrase></para></entry><entry><para>Defines a globally unique ID for serialization
            purposes. The annotation’s constructor takes a
            <literal moreinfo="none">Long</literal> argument for the UID.</para></entry></row><row><entry><para><literal moreinfo="none">switch</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>(version 2.8) An annotation to be applied to a match
            expression, e.g., <literal moreinfo="none">(x: @switch) match {...}</literal>.
            When present, the compiler will verify that the match has been
            compiled to a table-based or lookup-based
            <literal moreinfo="none">switch</literal> statement. If not, it will issue an
            error if it instead compiles into a series of conditional
            expressions, which are less efficient.</para></entry></row><row><entry><para><literal moreinfo="none">specialized</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>(version 2.8) An annotation applied to type
            parameters in parameterized types and methods. It tells the
            compiler to generate optimized versions of the type or method for
            the <literal moreinfo="none">AnyVal</literal> types corresponding to platform
            primitive types. Optionally, you can limit the
            <literal moreinfo="none">AnyVal</literal> types for which specialized
            implementations will be generated. See the upcoming
            discussion.</para></entry></row><row><entry><para><literal moreinfo="none">tailRec</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>(version 2.8) A method annotation that tells the
            compiler to verify that the method will be compiled with
            <emphasis>tail-call optimization</emphasis>. If it is present, the
            compiler will issue an error if the method cannot be optimized
            into a loop. This happens, for example, when the method is not
            <literal moreinfo="none">private</literal> or <literal moreinfo="none">final</literal>, when it
            could be overridden, and when recursive invocations are not true
            tail calls.</para></entry></row><row><entry><para><literal moreinfo="none">throws</literal></para></entry><entry><para><literal moreinfo="none">throws</literal> (keyword)</para></entry><entry><para>Indicates which exceptions are thrown by the
            annotated method. See the upcoming discussion.</para></entry></row><row><entry><para><literal moreinfo="none">transient</literal></para></entry><entry><para><literal moreinfo="none">transient</literal> (keyword)</para></entry><entry><para>Marks a method as “transient.”</para></entry></row><row><entry><para><literal moreinfo="none">uncheckedStable</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>A marker for a value that is assumed to be stable
            even though its type is volatile (i.e., annotated with
            <literal moreinfo="none">@volatile</literal>).</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">uncheckedVariance</literal></para></entry><entry><para><emphasis>N.A.</emphasis></para></entry><entry><para>A marker for a type argument that is volatile, when
            it is used in a parameterized type, to suppress variance
            checking.</para></entry></row><row><entry><para><literal moreinfo="none">volatile</literal></para></entry><entry><para><literal moreinfo="none">volatile</literal> (keyword, <phrase role="keep-together">for fields only</phrase>)</para></entry><entry><para>A marker for an individual field or a whole type,
            which affects all fields, indicating that the field may be
            modified by a separate thread.</para></entry></row></tbody></tgroup></table><para id="para_28_annotations">The annotations marked with “(version 2.8)”
    are only available in Scala version 2.8 or later. Consider
    <literal moreinfo="none">@tailrec</literal>, as used in the following example:<indexterm significance="normal"><primary>annotations</primary><secondary>available only in Scala version 2.8 or later</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="preproc">import</code> scala.annotation.tailrec

@tailrec
<code role="statement">def</code> <code role="identifier">fib</code>(i:<code role="type"> Int</code>):<code role="type"> Int</code> = i <code role="statement">match</code> {
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">if</code> i &lt;= <code role="constant">1</code> <code role="statement">=&gt;</code> i
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fib(i-<code role="constant">1</code>) + fib(i-<code role="constant">2</code>)
}
println(fib(<code role="constant">5</code>))
</programlisting><para id="para_fib_tailrec_annotation">Note that <literal moreinfo="none">fib</literal>,
    which calculates Fibonacci numbers, is recursive, but it isn’t tail-call
    recursive, because the call to itself is not the very last thing that
    happens in the second case clause. Rather, after calling itself twice, it
    does an addition. Hence, a tail-call optimization can’t be performed on
    this method. When the compiler sees the <literal moreinfo="none">@tailrec</literal>
    annotation, it throws an error if it can’t apply the tail-call
    optimization. Attempting to run this script produces the following
    error:<indexterm significance="normal"><primary>tail calls</primary><secondary>@tailRec annotation and</secondary></indexterm><indexterm significance="normal"><primary sortas="tailRec annotation">@tailRec annotation</primary></indexterm></para><screen format="linespecific">... 4: error: could not optimize @tailrec annotated method
def fib(i: Int): Int = i match {
     ^
one error found</screen><para id="para_switch_annotation">We can also use the same method to
    demonstrate the new <literal moreinfo="none">@switch</literal> annotation available in
    version 2.8:<indexterm significance="normal"><primary sortas="switch annotation">@switch annotation</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="preproc">import</code> scala.annotation.switch

<code role="statement">def</code> <code role="identifier">fib</code>(i:<code role="type"> Int</code>):<code role="type"> Int</code> = (i: @switch) <code role="statement">match</code> {
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">if</code> i &lt;= <code role="constant">1</code> <code role="statement">=&gt;</code> i
  <code role="statement">case</code> <code role="statement">_</code> <code role="statement">=&gt;</code> fib(i-<code role="constant">1</code>) + fib(i-<code role="constant">2</code>)
}
println(fib(<code role="constant">5</code>))
</programlisting><para id="para_fib_switch_annotation">This time we annotate the
    <literal moreinfo="none">i</literal> in the <literal moreinfo="none">match</literal> statement. This
    annotation causes the compiler to raise an error if it can’t generate a
    switch construct in byte code from the cases in the match statement.
    Switches are generally more efficient than conditional logic. Running this
    script produces this output:</para><screen format="linespecific">... 3: error: could not emit switch for @switch annotated match
def fib(i: Int): Int = (i: @switch) match {
                                     ^
one error found</screen><para id="para_fib_switch_annotation2">Conditional blocks have to be
    generated instead. The reason a switch can’t be generated is because of
    the condition guard clause we put in the first case clause, <literal moreinfo="none">if i
    &lt;= 1</literal>.</para><para id="para_let_s_look_at_an_example_of_">Let’s look at an example of
    <literal moreinfo="none">@unchecked</literal> in use (adapted from the Scaladoc entry for
    <literal moreinfo="none">@unchecked</literal>). Consider the following code
    fragment:<indexterm significance="normal"><primary>exceptions</primary><secondary>@unchecked annotation and</secondary></indexterm><indexterm significance="normal"><primary sortas="unchecked annotation">@unchecked annotation</primary></indexterm></para><programlisting language="scala" format="linespecific">...
<code role="statement">def</code> <code role="identifier">process</code>(x:<code role="type"> Option[int]</code>) = x <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Some</code>(value) <code role="statement">=&gt;</code> ...
}
...
</programlisting><para id="para_if_you_compile_it_you_will_ge">If you compile it, you will
    get the following warning:</para><screen format="linespecific">...: warning: does not cover case {object None}
  def f(x: Option[int]) = x match {
                          ^
one warning found</screen><para id="para_normally_you_would_want_to_ad">Normally, you would want to
    add a case for <literal moreinfo="none">None</literal>. However, if you want to suppress
    the warning message in situations like this, change the method as
    follows:</para><programlisting language="scala" format="linespecific">...
<code role="statement">def</code> <code role="identifier">process</code>(x:<code role="type"> Option[int]</code>) = (x: @unchecked) <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Some</code>(value) <code role="statement">=&gt;</code> ...
}
...
</programlisting><para id="para_with_the_unchecked_annotati">With the
    <literal moreinfo="none">@unchecked</literal> annotation applied to <literal moreinfo="none">x</literal>
    as shown, the warning will be suppressed. However, if <literal moreinfo="none">x</literal>
    is ever <literal moreinfo="none">None</literal>, then a <literal moreinfo="none">MatchError</literal> will
    be thrown.</para><para id="para_the_specialized_annotation_">The
    <literal moreinfo="none">@specialized</literal> annotation is another optimization-related
    annotation added in <phrase role="keep-together">version</phrase> 2.8. It
    is a pragmatic solution to a tradeoff between space efficiency and
    performance. In Java and Scala, the implementation of a parameterized type
    or method is generated at the point of the declaration (as we discussed in
    <xref linkend="ParameterizedTypes"/>). In contrast, in C++, a
    <emphasis>template</emphasis> is used to generate an implementation for
    the actual type parameters where the template is used. The <phrase role="keep-together">C++</phrase> approach has the advantage of allowing
    optimized implementations to be generated for primitive types, while it
    has the disadvantage of resulting in code bloat from all the
    instantiations of templates.<indexterm significance="normal"><primary sortas="specialized annotation">@specialized
        annotation</primary></indexterm><indexterm significance="normal"><primary>C++</primary><secondary>templates</secondary></indexterm></para><para id="para_in_jvm_related_languages_the_">In JVM-related languages,
    the “on-demand” generation of implementations isn’t suitable, primarily
    because there is no “link” step as in compiled languages, where every
    required instantiation of a template can be determined. This creates a
    dilemma. By default, a Scala parameterized type or method will be
    translated to a single implementation assuming <literal moreinfo="none">Any</literal> for
    the type parameters (in part due to type erasure at the byte code level).
    Java generics work the same way. However, if a particular use of the type
    or method uses one of the <literal moreinfo="none">AnyVal</literal> types, say
    <literal moreinfo="none">Int</literal>, then we get inefficient boxing and unboxing
    operations in the implementation.</para><para id="para_the_alternative_would_be_to_ge">The alternative would be to
    generate a separate implementation for every <literal moreinfo="none">AnyVal</literal>
    corresponding to a primitive type, but this would lead to code bloat,
    especially since it would be rare that an application would use all those
    implementations. So, we are faced with a dilemma.</para><para id="para_the_specialized_annotation_is_pragmatic">The
    <literal moreinfo="none">@specialized</literal> annotation is a pragmatic compromise. It
    lets the user tell the compiler that runtime efficiency is more important
    than space efficiency, so the compiler will generate the separate
    implementations for each primitive corresponding to an
    <literal moreinfo="none">AnyVal</literal>. Here is an example of how the annotation is
    used:</para><programlisting language="scala" format="linespecific"><code role="statement">class</code> <code role="special">SpecialCollection</code><code role="special">[@specialized +T]</code>(...) {
  ...
}
</programlisting><para id="para_at_the_time_of_this_writing_t">At the time of this writing,
    the implementation in the version 2.8 “nightly” build only supports
    generation of specialized implementations for <literal moreinfo="none">Int</literal> and
    <literal moreinfo="none">Double</literal>. For the final version 2.8 library, it is
    planned that the other <literal moreinfo="none">AnyVal</literal> types will be supported.
    There are also plans to allow the user to specify the types for which
    optimized implementations are generated so that unused implementations for
    the other <literal moreinfo="none">AnyVals</literal> are avoided. See the final 2.8
    Scaladocs for details on the final feature set.</para><para id="para_another_planned_version_2_8_an">Another planned version 2.8
    annotation is <literal moreinfo="none">@cps</literal>, which stands for
    <emphasis>continuation passing style</emphasis>. It will be a directive
    interpreted by a compiler plugin that will trigger generation of
    continuation-based byte code for method invocation, rather than the
    default stack frame byte code. The annotation will have no effect unless
    the corresponding <literal moreinfo="none">scalac</literal> plugin is used. Consult the
    release documentation for more information on this feature, when it
    becomes available.<indexterm significance="normal"><primary sortas="cps">@cps (continual passing style)
        annotation</primary></indexterm></para><para id="para_to_understand_the_throws_an">To understand the
    <literal moreinfo="none">@throws</literal> annotation, it’s important to remember that
    Scala does not have checked exceptions, in contrast with Java. There is
    also no <literal moreinfo="none">throws</literal> clause available for Scala method
    declarations. This is not a problem if a Scala method calls a Java method
    that is declared to throw a checked exception. The exception is treated as
    unchecked in Scala. However, suppose the Scala method in question doesn’t
    catch the exception, but lets it pass through. What if this Scala method
    is called by other Java code?<indexterm significance="normal"><primary>exceptions</primary><secondary>@throws annotation and</secondary></indexterm><indexterm significance="normal"><primary sortas="throws annotation">@throws annotation</primary></indexterm></para><para id="para_let_s_look_at_an_example_invol">Let’s look at an example
    involving <literal moreinfo="none">java.io.IOException</literal>, which is a checked
    exception. The following Scala class prints out the contents of a
    <literal moreinfo="none">java.io.File</literal>:<indexterm significance="normal"><primary>java.io.IOException class</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/annotations/file-printer.scala</code>

<code role="preproc">import</code> java.io._

<code role="statement">class</code> <code role="special">FilePrinter</code>(<code role="statement">val</code> file:<code role="type"> File</code>) {

  @throws(classOf[<code role="special">IOException</code>])
  <code role="statement">def</code> <code role="identifier">print</code>() = {
    <code role="statement">var</code> reader:<code role="type"> LineNumberReader</code> = <code role="statement">null</code>
    <code role="statement">try</code> {
      reader = <code role="statement">new</code> <code role="special">LineNumberReader</code>(<code role="statement">new</code> <code role="special">FileReader</code>(file))
      loop(reader)
    } <code role="statement">finally</code> {
      <code role="statement">if</code> (reader != <code role="statement">null</code>)
        reader.close
    }
  }

  <code role="statement">private</code> <code role="statement">def</code> <code role="identifier">loop</code>(reader:<code role="type"> LineNumberReader</code>):<code role="type"> Unit</code> = {
    <code role="statement">val</code> line = reader.readLine()
    <code role="statement">if</code> (line != <code role="statement">null</code>) {
      format(<code role="constant">"%3d: %s</code><code role="special">\n</code><code role="constant">"</code>, reader.getLineNumber, line)
      loop(reader)
    }
  }
}
</programlisting><para id="para_note_the_throws_annotation_">Note the
    <literal moreinfo="none">@throws</literal> annotation applied to the
    <literal moreinfo="none">print</literal> method. The argument to the annotation
    constructor is a single <literal moreinfo="none">java.lang.Class[Any]</literal> object, in
    this case, <literal moreinfo="none">classOf[IO⁠Exception]</literal>. The Java IO API
    methods used by <literal moreinfo="none">print</literal> and the private method
    <literal moreinfo="none">loop</literal> might throw this exception.</para><para id="para_by_the_way_notice_that_loop_">By the way, notice that
    <literal moreinfo="none">loop</literal> uses functional-style tail recursion, rather than
    a loop. No variables were mutated during the production of this output!
    (Well, we don’t actually know what’s happening inside the Java IO
    classes....)</para><?dbfo-need height=”1in”
?><para id="para_here_is_a_java_class_that_uses">Here is a Java class that
    uses <literal moreinfo="none">FilePrinter</literal>. It provides the
    <literal moreinfo="none">main</literal> routine:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/annotations/FilePrinterMain.java</code>

<code role="preproc">import</code> java.io.*;

public <code role="statement">class</code> <code role="special">FilePrinterMain</code> {
  public static void main(<code role="special">String</code><code role="special">[]</code> args) {
    <code role="statement">for</code> (<code role="special">String</code> fileName:<code role="type"> args</code>) {
      <code role="statement">try</code> {
        <code role="special">File</code> file = <code role="statement">new</code> <code role="special">File</code>(fileName);
        <code role="statement">new</code> <code role="special">FilePrinter</code>(file).print();
      } <code role="statement">catch</code> (<code role="special">IOException</code> ioe) {
        System.err.println(<code role="constant">"IOException for file "</code> + fileName);
        System.err.println(ioe.getMessage());
      }
    }
  }
}
</programlisting><para id="para_these_classes_compile_without_">These classes compile
    without error. You can try them out with the following command (which
    assumes that <literal moreinfo="none">FilePrinterMain.java</literal> is in the
    <filename moreinfo="none">annotations</filename> directory, as in the example code
    distribution):</para><screen format="linespecific">scala -cp build FilePrinterMain annotations/FilePrinterMain.java</screen><para id="para_you_should_get_the_following_o">You should get the
    following output:</para><screen format="linespecific"> 1: import java.io.*;
 2:
 3: public class FilePrinterMain {
 4:   public static void main(String[] args) {
 5:     for (String fileName: args) {
 6:       try {
 7:         File file = new File(fileName);
 8:         new FilePrinter(file).print();
 9:       } catch (IOException ioe) {
10:         System.err.println("IOException for file " + fileName);
11:         System.err.println(ioe.getMessage());
12:       }
13:     }
14:   }
15: }</screen><para id="para_now_returning_to_file_print">Now, returning to the
    <literal moreinfo="none">FilePrinter</literal> class, suppose you comment out the
    <literal moreinfo="none">@throws</literal> line. This file will continue to compile, but
    when you compile <literal moreinfo="none">FilePrinterMain.java</literal>, you will get the
    following error:</para><screen format="linespecific">annotations/FilePrinterMain.java:9: exception java.io.IOException is never
thrown in body of corresponding try statement
      } catch (IOException ioe) {
        ^
1 error</screen><para id="para_even_though_java_io_ioexcepti">Even though
    <literal moreinfo="none">java.io.IOException</literal> may get thrown by
    <literal moreinfo="none">FilePrinter</literal>, that information isn’t in the byte code
    generated by <literal moreinfo="none">scalac</literal>, so the analysis done by
    <literal moreinfo="none">javac</literal> mistakenly concludes that
    <literal moreinfo="none">IOException</literal> is never thrown.</para><para id="para_so_the_purpose_of_throws_i">So, the purpose of
    <literal moreinfo="none">@throws</literal> is to insert the information on thrown checked
    exceptions into the byte code that <literal moreinfo="none">javac</literal> will
    read.<indexterm class="endofrange" startref="ch13_declarationsannotations" significance="normal"/><indexterm class="endofrange" startref="ch13_appdesignannotations" significance="normal"/><indexterm class="endofrange" startref="ch13_annotations" significance="normal"/></para><tip id="para_tip_in_a_mixed_java_scala_env"><para>In a mixed Java-Scala environment, consider adding the
      <literal moreinfo="none">@throws</literal> <phrase role="keep-together">annotation</phrase> for all your Scala methods that
      can throw Java checked exceptions. Eventually, some Java code will
      probably call one of those <phrase role="keep-together">methods</phrase>.</para></tip></sect1><sect1 id="EnumerationsVsPatternMatching"><title>Enumerations Versus Pattern Matching</title><para id="para_enumerations_are_a_way_of_defi">Enumerations are a way of
    defining a finite set of constant values. They are a lightweight
    alternative to case classes. You can reference the values directly,
    iterate through them, index into them with integer indices, etc.<indexterm significance="normal"><primary>case classes</primary><secondary>enumerations as alternative to</secondary></indexterm><indexterm class="startofrange" id="ch13_enumerations" significance="normal"><primary>enumerations</primary></indexterm><indexterm class="startofrange" id="ch13_appdesignenumvpm" significance="normal"><primary>application design</primary><secondary>enumerations versus pattern matching</secondary></indexterm></para><para id="para_just_as_for_annotations_scala">Just as for annotations,
    Scala’s form of enumerations are class-based, with a particular set of
    idioms, rather than relying on special keywords for defining them, as is
    used for enumerations in Java and .NET. However, you can also use
    enumerations defined in those languages.</para><para id="para_scala_enumerations_are_defined">Scala enumerations are
    defined by subclassing the abstract <literal moreinfo="none">scala.Enumeration</literal>
    class. There are several ways to construct and use an enumeration. We’ll
    demonstrate one idiom that most closely matches the Java and .NET forms
    you may already know.<indexterm significance="normal"><primary>enumerations</primary><secondary>scala.Enumeration class</secondary></indexterm></para><para id="para_recall_http_methods_script_">Recall the HTTP methods
    scripts that we wrote in <xref linkend="SealedClassHierarchies"/>. We
    defined the set of HTTP 1.1 methods using a sealed case class
    hierarchy:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ObjectSystem/sealed/http-script.scala</code>

<code role="statement">sealed</code> <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">HttpMethod</code>()
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Connect</code>(body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Delete</code> (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Get</code>    (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Head</code>   (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Options</code>(body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Post</code>   (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Put</code>    (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>
<code role="statement">case</code> <code role="statement">class</code> <code role="special">Trace</code>  (body:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">HttpMethod</code>

<code role="statement">def</code> <code role="identifier">handle</code> (method:<code role="type"> HttpMethod</code>) = method <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Connect</code> (body) <code role="statement">=&gt;</code> println(<code role="constant">"connect: "</code> + body)
  <code role="statement">case</code> <code role="special">Delete</code>  (body) <code role="statement">=&gt;</code> println(<code role="constant">"delete: "</code>  + body)
  <code role="statement">case</code> <code role="special">Get</code>     (body) <code role="statement">=&gt;</code> println(<code role="constant">"get: "</code>     + body)
  <code role="statement">case</code> <code role="special">Head</code>    (body) <code role="statement">=&gt;</code> println(<code role="constant">"head: "</code>    + body)
  <code role="statement">case</code> <code role="special">Options</code> (body) <code role="statement">=&gt;</code> println(<code role="constant">"options: "</code> + body)
  <code role="statement">case</code> <code role="special">Post</code>    (body) <code role="statement">=&gt;</code> println(<code role="constant">"post: "</code>    + body)
  <code role="statement">case</code> <code role="special">Put</code>     (body) <code role="statement">=&gt;</code> println(<code role="constant">"put: "</code>     + body)
  <code role="statement">case</code> <code role="special">Trace</code>   (body) <code role="statement">=&gt;</code> println(<code role="constant">"trace: "</code>   + body)
}

<code role="statement">val</code> methods = <code role="special">List</code>(
  <code role="special">Connect</code>(<code role="constant">"connect body..."</code>),
  <code role="special">Delete</code> (<code role="constant">"delete body..."</code>),
  <code role="special">Get</code>    (<code role="constant">"get body..."</code>),
  <code role="special">Head</code>   (<code role="constant">"head body..."</code>),
  <code role="special">Options</code>(<code role="constant">"options body..."</code>),
  <code role="special">Post</code>   (<code role="constant">"post body..."</code>),
  <code role="special">Put</code>    (<code role="constant">"put body..."</code>),
  <code role="special">Trace</code>  (<code role="constant">"trace body..."</code>))

methods.foreach { method <code role="statement">=&gt;</code> handle(method) }
</programlisting><para id="para_in_that_example_each_method_h">In that example, each method
    had a <literal moreinfo="none">body</literal> attribute for the message body. We’ll assume
    here that the body is handled through other means and we only care about
    identifying the kind of HTTP method. So, here is a Scala
    <literal moreinfo="none">Enumeration</literal> class for the HTTP 1.1 <phrase role="keep-together">methods</phrase>:<indexterm class="startofrange" id="ch13_enumsHttpMethod" significance="normal"><primary>enumerations</primary><secondary>HttpMethod object (example)</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/enumerations/http-enum-script.scala</code>

<code role="statement">object</code> <code role="special">HttpMethod</code> <code role="statement">extends</code> <code role="special">Enumeration</code> {
  <code role="statement">type</code> <code role="special">Method</code> = <code role="special">Value</code>
  <code role="statement">val</code> Connect, <code role="special">Delete</code>, <code role="special">Get</code>, <code role="special">Head</code>, <code role="special">Options</code>, <code role="special">Post</code>, <code role="special">Put</code>, <code role="special">Trace</code> = <code role="special">Value</code>
}

<code role="preproc">import</code> HttpMethod._

<code role="statement">def</code> <code role="identifier">handle</code> (method:<code role="type"> HttpMethod.Method</code>) = method <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Connect</code> <code role="statement">=&gt;</code> println(<code role="constant">"Connect: "</code> + method.id)
  <code role="statement">case</code> <code role="special">Delete</code>  <code role="statement">=&gt;</code> println(<code role="constant">"Delete: "</code>  + method.id)
  <code role="statement">case</code> <code role="special">Get</code>     <code role="statement">=&gt;</code> println(<code role="constant">"Get: "</code>     + method.id)
  <code role="statement">case</code> <code role="special">Head</code>    <code role="statement">=&gt;</code> println(<code role="constant">"Head: "</code>    + method.id)
  <code role="statement">case</code> <code role="special">Options</code> <code role="statement">=&gt;</code> println(<code role="constant">"Options: "</code> + method.id)
  <code role="statement">case</code> <code role="special">Post</code>    <code role="statement">=&gt;</code> println(<code role="constant">"Post: "</code>    + method.id)
  <code role="statement">case</code> <code role="special">Put</code>     <code role="statement">=&gt;</code> println(<code role="constant">"Put: "</code>     + method.id)
  <code role="statement">case</code> <code role="special">Trace</code>   <code role="statement">=&gt;</code> println(<code role="constant">"Trace: "</code>   + method.id)
}

<code role="special">HttpMethod</code> foreach { method <code role="statement">=&gt;</code> handle(method) }
println( <code role="special">HttpMethod</code> )
</programlisting><para id="para_this_script_produces_the_follo">This script produces the
    following output:</para><screen format="linespecific">Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Main$$anon$1$HttpMethod(0), Main$$anon$1$HttpMethod(1),
Main$$anon$1$HttpMethod(2), Main$$anon$1$HttpMethod(3),
Main$$anon$1$HttpMethod(4), Main$$anon$1$HttpMethod(5),
Main$$anon$1$HttpMethod(6), Main$$anon$1$HttpMethod(7)}</screen><para>(We wrapped the lines for the output between the
    <literal moreinfo="none">{...}</literal>.) There are two uses of <literal moreinfo="none">Value</literal>
    in the definition of <literal moreinfo="none">HttpMethod</literal>. The first usage is
    actually a reference to an abstract class,
    <literal moreinfo="none">Enumeration.Value</literal>, which encapsulates some useful
    operations for the “values” in the enumeration. We define a new
    <literal moreinfo="none">type</literal>, <literal moreinfo="none">Method</literal>, that functions as an
    alias for <literal moreinfo="none">Value</literal>. We see it used in the type of the
    argument passed to the <literal moreinfo="none">handle</literal> method, which
    demonstrates <literal moreinfo="none">HttpMethod</literal> in use.
    <literal moreinfo="none">HttpMethod.Method</literal> is a more meaningful name to the
    reader than the generic <literal moreinfo="none">HttpMethod.Value</literal>. Note that one
    of the fields in <literal moreinfo="none">Enumeration.Value</literal> is
    <literal moreinfo="none">id</literal>, which we also use in
    <literal moreinfo="none">handle</literal>.<indexterm significance="normal"><primary>Value class</primary></indexterm><indexterm significance="normal"><primary>Enumeration.Value class</primary></indexterm></para><para id="para_the_second_use_of_value_is_a">The second use of
    <literal moreinfo="none">Value</literal> is actually a call to a method. There is no
    namespace collision between these two names. The line <literal moreinfo="none">val
    Connect, Delete, Get, Head, Options, Post, Put, Trace = Value</literal>
    defines the set of values for the enumeration. The
    <literal moreinfo="none">Value</literal> method is called for each one. It creates a new
    <literal moreinfo="none">Enumeration.Value</literal> for each one and adds it to the
    managed set of values.</para><para id="para_in_the_code_below_the_definiti">In the code below the
    definition, we import the definitions in <literal moreinfo="none">HttpMethod</literal> and
    we define a <literal moreinfo="none">handle</literal> method that pattern matches on
    <literal moreinfo="none">HttpMethod.Method</literal> objects. It simply prints a message
    for each value along with its <literal moreinfo="none">id</literal>. Note that while the
    example has no “default” case clause (e.g. <literal moreinfo="none">case _ ⇒
    ...</literal>), none is required in this case. However, the compiler
    doesn’t actually know that all the possible values are covered, in
    contrast to a sealed case class hierarchy. If you comment out one of the
    case statements in <literal moreinfo="none">handle</literal>, you will get no warnings,
    but you will get a <literal moreinfo="none">MatchError</literal>.<indexterm significance="normal"><primary>pattern matching</primary><secondary sortas="enumerations">on enumerations</secondary></indexterm></para><warning id="para_warning_when_pattern_matching"><para>When pattern matching on enumeration values, the compiler can’t
      tell if the match is “exhaustive.”</para></warning><para id="para_you_might_wonder_why_we_hard_c">You might wonder why we
    hardcoded strings like “Connect” in the <literal moreinfo="none">println</literal>
    statements in the case clauses. Can’t we get the name from the
    <literal moreinfo="none">HttpMethod.Method</literal> object itself? And why didn’t the
    output of <literal moreinfo="none">println(HttpMethod)</literal> include those names,
    instead of the ugly internal object names?</para><para id="para_you_are_probably_accustomed_to">You are probably accustomed
    to using such names with Java or .NET enumerations. Unfortunately, we
    can’t get those names from the values in the Scala enumeration, at least
    given the way that we declared <literal moreinfo="none">HttpMethod</literal>. However,
    there are two ways we can change the implementation to get name strings.
    In the first approach, we pass the name to <literal moreinfo="none">Value</literal> when
    creating the fields:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/enumerations/http-enum2-script.scala</code>

<code role="statement">object</code> <code role="special">HttpMethod</code> <code role="statement">extends</code> <code role="special">Enumeration</code> {
  <code role="statement">type</code> <code role="special">Method</code> = <code role="special">Value</code>
  <code role="statement">val</code> Connect = <code role="special">Value</code>(<code role="constant">"Connect"</code>)
  <code role="statement">val</code> Delete  = <code role="special">Value</code>(<code role="constant">"Delete"</code>)
  <code role="statement">val</code> Get     = <code role="special">Value</code>(<code role="constant">"Get"</code>)
  <code role="statement">val</code> Head    = <code role="special">Value</code>(<code role="constant">"Head"</code>)
  <code role="statement">val</code> Options = <code role="special">Value</code>(<code role="constant">"Options"</code>)
  <code role="statement">val</code> Post    = <code role="special">Value</code>(<code role="constant">"Post"</code>)
  <code role="statement">val</code> Put     = <code role="special">Value</code>(<code role="constant">"Put"</code>)
  <code role="statement">val</code> Trace   = <code role="special">Value</code>(<code role="constant">"Trace"</code>)
}

<code role="preproc">import</code> HttpMethod._

<code role="statement">def</code> <code role="identifier">handle</code> (method:<code role="type"> HttpMethod.Method</code>) = method <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Connect</code> <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Delete</code>  <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Get</code>     <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Head</code>    <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Options</code> <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Post</code>    <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Put</code>     <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Trace</code>   <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
}

<code role="special">HttpMethod</code> foreach { method <code role="statement">=&gt;</code> handle(method) }
println( <code role="special">HttpMethod</code> )
</programlisting><para id="para_redundant_connect">It is a bit redundant to have to use the
    same word twice in declarations like <literal moreinfo="none">val Connect =
    Value("Connect")</literal>.</para><para id="para_http-enum2-script_output">Running this script produces the
    following nicer output:</para><screen format="linespecific">Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Connect, Delete, Get, Head, Options, Post, Put, Trace}</screen><para id="para_in_the_second_approach_we_pas">In the second approach, we
    pass the list of names to the <literal moreinfo="none">Enumeration</literal>
    constructor:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/enumerations/http-enum3-script.scala</code>

<code role="statement">object</code> <code role="special">HttpMethod</code> <code role="statement">extends</code> <code role="special">Enumeration</code>(
    <code role="constant">"Connect"</code>, <code role="constant">"Delete"</code>, <code role="constant">"Get"</code>, <code role="constant">"Head"</code>, <code role="constant">"Options"</code>, <code role="constant">"Post"</code>, <code role="constant">"Put"</code>, <code role="constant">"Trace"</code>) {
  <code role="statement">type</code> <code role="special">Method</code> = <code role="special">Value</code>
  <code role="statement">val</code> Connect, <code role="special">Delete</code>, <code role="special">Get</code>, <code role="special">Head</code>, <code role="special">Options</code>, <code role="special">Post</code>, <code role="special">Put</code>, <code role="special">Trace</code> = <code role="special">Value</code>
}

<code role="preproc">import</code> HttpMethod._

<code role="statement">def</code> <code role="identifier">handle</code> (method:<code role="type"> HttpMethod.Method</code>) = method <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Connect</code> <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Delete</code>  <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Get</code>     <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Head</code>    <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Options</code> <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Post</code>    <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Put</code>     <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Trace</code>   <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
}

<code role="special">HttpMethod</code> foreach { method <code role="statement">=&gt;</code> handle(method) }
println( <code role="special">HttpMethod</code> )
</programlisting><para id="para_note_that_we_have_a__redundant">This script produces
    identical output. Note that we have a <emphasis>redundant</emphasis> list
    of name strings and names of the <literal moreinfo="none">vals</literal>. <emphasis>It is
    up to you to keep the items in the list and their order consistent with
    the declared values!</emphasis> This version has fewer characters, but it
    is more error-prone. Internally, <literal moreinfo="none">Enumeration</literal> pairs the
    strings with the corresponding <literal moreinfo="none">Value</literal> instances as they
    are created.</para><para id="para_on_the_plus_side_the_output_i">The output when printing the
    whole <literal moreinfo="none">HttpMethod</literal> object is better for either
    alternative implementation. When the values have names, their
    <literal moreinfo="none">toString</literal> returns the name. In fact, our final two
    examples have become quite artificial because we now have identical
    statements for each case clause! Of course, in a real implementation, you
    would handle the different HTTP methods differently.<indexterm class="endofrange" startref="ch13_enumerations" significance="normal"/><indexterm class="endofrange" startref="ch13_enumsHttpMethod" significance="normal"/><indexterm class="endofrange" startref="ch13_appdesignenumvpm" significance="normal"/></para></sect1><sect1 id="ThoughtsOnAnnotationsAndEnumerations"><title>Thoughts On Annotations and Enumerations</title><para id="para_for_both_annotations_and_enume">For both annotations and
    enumerations, there are advantages and disadvantages to the Scala
    approach, where we use regular class-based mechanisms, rather than
    inventing custom keywords and syntax. The advantages include fewer special
    cases in the language. Classes and traits are used in more or less the
    same ways they are used for “normal” code. The disadvantages include the
    need to understand and use ad hoc conventions that are not always as
    convenient to use as the custom syntax mechanisms required in Java and
    .NET. Also, Scala’s implementations are not as full-featured.<indexterm significance="normal"><primary>enumerations</primary><secondary>advantages and disadvantages of</secondary></indexterm><indexterm significance="normal"><primary>annotations</primary><secondary>advantages and disadvantages of</secondary></indexterm></para><para id="para_so_should_the_scala_community">So, should the Scala
    community relent and implement ad hoc, but more full-featured mechanisms
    for annotations and enumerations? Maybe not. Scala is a more flexible
    language than most languages. Many of the features provided by Java and
    .NET annotations and enumerations can be implemented in Scala by other
    means.</para><para id="para_some_use_cases_for_the_mor">Some use cases for the more
    advanced features of Java annotations can be implemented more elegantly
    with “normal” Scala code, as we will discuss in <xref linkend="DesignPatterns"/>. For enumerations, sealed case classes and
    pattern matching provide a more flexible solution, in many
    cases.<indexterm significance="normal"><primary>pattern matching</primary><secondary>using with case classes, enumerations versus</secondary></indexterm><indexterm significance="normal"><primary>case classes</primary><secondary>enumerations versus</secondary></indexterm><indexterm significance="normal"><primary>application design</primary><secondary>enumerations versus case classes and pattern
        matching</secondary></indexterm><indexterm significance="normal"><primary>enumerations</primary><secondary>case classes and pattern matching versus</secondary></indexterm></para><sect2 id="EnumerationsVsCaseClassesAndPatternMatching"><title>Enumerations Versus Case Classes and Pattern Matching</title><para id="para_let_s_revisit_http_methods_s">Let’s revisit the HTTP
      method script, which uses a sealed case class hierarchy versus the
      version we wrote previously that uses an <literal moreinfo="none">Enumeration</literal>.
      Since the enumeration version doesn’t handle the message body, let’s
      write a modified version of the sealed case class version that is closer
      to the enumeration version, i.e., it also doesn’t hold the message body
      and it has <literal moreinfo="none">name</literal> and <literal moreinfo="none">id</literal>
      methods:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/enumerations/http-case-script.scala</code>

<code role="statement">sealed</code> <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">HttpMethod</code>(<code role="statement">val</code> id:<code role="type"> Int</code>) {
  <code role="statement">def</code> <code role="identifier">name</code> = getClass getSimpleName
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = name
}

<code role="statement">case</code> <code role="statement">object</code> <code role="special">Connect</code> <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">0</code>)
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Delete</code>  <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">1</code>)
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Get</code>     <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">2</code>)
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Head</code>    <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">3</code>)
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Options</code> <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">4</code>)
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Post</code>    <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">5</code>)
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Put</code>     <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">6</code>)
<code role="statement">case</code> <code role="statement">object</code> <code role="special">Trace</code>   <code role="statement">extends</code> <code role="special">HttpMethod</code>(<code role="constant">7</code>)

<code role="statement">def</code> <code role="identifier">handle</code> (method:<code role="type"> HttpMethod</code>) = method <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">Connect</code> <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Delete</code>  <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Get</code>     <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Head</code>    <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Options</code> <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Post</code>    <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Put</code>     <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
  <code role="statement">case</code> <code role="special">Trace</code>   <code role="statement">=&gt;</code> println(method + <code role="constant">": "</code> + method.id)
}

<code role="special">List</code>(<code role="special">Connect</code>, <code role="special">Delete</code>, <code role="special">Get</code>, <code role="special">Head</code>, <code role="special">Options</code>, <code role="special">Post</code>, <code role="special">Put</code>, <code role="special">Trace</code>) foreach {
  method <code role="statement">=&gt;</code> handle(method)
}
</programlisting><para id="para_note_that_we_used_case_object">Note that we used
      <literal moreinfo="none">case object</literal> for all the concrete subclasses, to have
      a true set of constants. To mimic the enumeration <literal moreinfo="none">id</literal>,
      we added a field explicitly, but now it’s up to us to pass in valid,
      unique values! The <literal moreinfo="none">handle</literal> methods in the two
      implementations are nearly identical.</para><para id="para_this_script_outputs_the_follow">This script outputs the
      following:</para><screen format="linespecific">Main$$anon$1$Connect$: 0
Main$$anon$1$Delete$: 1
Main$$anon$1$Get$: 2
Main$$anon$1$Head$: 3
Main$$anon$1$Options$: 4
Main$$anon$1$Post$: 5
Main$$anon$1$Put$: 6
Main$$anon$1$Trace$: 7</screen><para id="para_the_object_names_are_ugly_but">The object names are ugly,
      but we could parse the string and remove the substring we really care
      about.</para><para id="para_both_approaches_support_the_co">Both approaches support
      the concept of a finite and fixed set of values, as long as the case
      class hierarchy is sealed. An additional advantage of a sealed case
      class hierarchy is the fact that the compiler will warn you if pattern
      matching statements aren’t <phrase role="keep-together">exhaustive</phrase>. Try removing one of the case
      clauses and you’ll get the usual warning. The compiler can’t do this
      with enumerations, as we saw.</para><para id="para_the_enumeration_format_is_more">The enumeration format is
      more succinct, despite the name duplication we had to use, and it also
      supports the ability to iterate through the values. We had to do that
      manually in the case clause implementation.</para><para id="para_the_case_class_implementation_">The case class
      implementation naturally accommodates other fields, e.g., the
      <literal moreinfo="none">body</literal>, as in the original implementation, while
      enumerations can only accommodate constant <literal moreinfo="none">Values</literal>
      with associated names and IDs.</para><tip id="para_tip_for_cases_where_you_need_"><para>For cases where you need only a simple list of constants by name
        or ID number, use enumerations. Be careful to follow the usage idioms.
        For fixed sets of more complex, constant objects, use sealed case
        objects.</para></tip></sect2></sect1><sect1 id="UsingNullsVsOptions"><title>Using Nulls Versus Options</title><para id="para_when_we_introduced_option_in">When we introduced
    <literal moreinfo="none">Option</literal> in <xref linkend="OptionSomeNone"/>, we briefly
    discussed how it encourages avoiding <literal moreinfo="none">null</literal> references in
    your code, which Tony Hoare, who introduced the concept of
    <literal moreinfo="none">null</literal> in 1965, called his “billion dollar mistake” (see
    <link linkend="Hoare2009" xrefstyle="select:nopage">[Hoare2009]</link>).<indexterm significance="normal"><primary>Option class</primary><secondary>nulls versus</secondary></indexterm><indexterm significance="normal"><primary>nulls</primary><secondary>Options versus</secondary></indexterm><indexterm significance="normal"><primary>application design</primary><secondary>nulls versus Options</secondary></indexterm></para><para id="para_scala_has_to_support_null_b">Scala has to support
    <literal moreinfo="none">null</literal>, because <literal moreinfo="none">null</literal> is supported on
    both the JVM and .NET and other libraries use <literal moreinfo="none">null</literal>. In
    fact, <literal moreinfo="none">null</literal> is used by some Scala libraries.</para><para id="para_what_if_null_were_not_availa">What if
    <literal moreinfo="none">null</literal> were not available? How would that change your
    designs? The <literal moreinfo="none">Map</literal> API offers some useful examples.
    Consider these two <literal moreinfo="none">Map</literal> methods:</para><programlisting language="scala" format="linespecific"><code role="statement">trait</code> <code role="special">Map</code><code role="special">[A,+B]</code> {
  ...
  <code role="statement">def</code> <code role="identifier">get</code>(key:<code role="type"> A</code>) :<code role="type"> Option[B]</code>
  <code role="statement">def</code> <code role="identifier">getOrElse</code> <code role="identifier">[B2 &gt;: B]</code>(key :<code role="type"> A</code>, default :<code role="type"> =&gt; B2</code>) :<code role="type"> B2</code> = ...
  ...
}
</programlisting><para id="para_a_map_may_not_have_a_value_for">A map may not have a value
    for a particular key. Both of these methods avoid returning
    <literal moreinfo="none">null</literal> in that case. Concrete implementations of
    <literal moreinfo="none">get</literal> in subclasses return a <literal moreinfo="none">None</literal> if
    no value exists for the key. Otherwise, they return a
    <literal moreinfo="none">Some</literal> wrapping the value. The method signature tells you
    that a value might not exist, and it forces you to handle that situation
    gracefully:</para><programlisting language="scala" format="linespecific"><code role="statement">val</code> stateCapitals = <code role="special">Map</code>(<code role="constant">"Alabama"</code> -&gt; <code role="constant">"Montgomery"</code>, ...)
...

stateCapitals.get(<code role="constant">"North Hinterlandia"</code>) <code role="statement">match</code> {
  <code role="statement">case</code> <code role="special">None</code> <code role="statement">=&gt;</code> println (<code role="constant">"No such state!"</code>)
  <code role="statement">case</code> <code role="special">Some</code>(x) <code role="statement">=&gt;</code> println(x)
}
</programlisting><para id="para_similarly_getorelse_forces_">Similarly,
    <literal moreinfo="none">getOrElse</literal> forces you to design defensively. You have to
    specify a default value for when a key isn’t in the map. Note that the
    default value can actually be an instance of a supertype relative to the
    map’s value type:</para><programlisting language="scala" format="linespecific">println(stateCapitals.getOrElse(<code role="constant">"North Hinterlandia"</code>, <code role="constant">"No such state!"</code>))
</programlisting><para id="para_a_lot_of_java_and_net_apis_al">A lot of Java and .NET APIs
    allow <literal moreinfo="none">null</literal> method arguments and can return
    <literal moreinfo="none">null</literal> values. You can write Scala wrappers around them
    to implement an appropriate strategy for handling
    <literal moreinfo="none">nulls</literal>.</para><para id="para_for_example_let_s_revisit_our">For example, let’s revisit
    our previous file printing example from <xref linkend="Annotations"/>.
    We’ll refactor our <literal moreinfo="none">FilePrinter</literal> class and the Java
    driver into a combined script. We’ll address two issues: 1) wrap
    <literal moreinfo="none">LineNumberReader.readLine</literal> with a method that returns an
    <literal moreinfo="none">Option</literal> instead of <literal moreinfo="none">null</literal>, and 2) wrap
    checked <literal moreinfo="none">IOExceptions</literal> in our own unchecked exception,
    called <literal moreinfo="none">ScalaIOException</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/options-nulls/file-printer-refactored-script.scala</code>

<code role="preproc">import</code> java.io._

<code role="statement">class</code> <code role="special">ScalaIOException</code>(cause:<code role="type"> Throwable</code>) <code role="statement">extends</code> <code role="special">RuntimeException</code>(cause)

<code role="statement">class</code> <code role="special">ScalaLineNumberReader</code>(in:<code role="type"> Reader</code>) <code role="statement">extends</code> <code role="special">LineNumberReader</code>(in) {
  <code role="statement">def</code> <code role="identifier">inputLine</code>() = readLine() <code role="statement">match</code> {
    <code role="statement">case</code> <code role="statement">null</code> <code role="statement">=&gt;</code> <code role="special">None</code>
    <code role="statement">case</code> line <code role="statement">=&gt;</code> <code role="special">Some</code>(line)
  }
}

<code role="statement">object</code> <code role="special">ScalaLineNumberReader</code> {
  <code role="statement">def</code> <code role="identifier">apply</code>(file:<code role="type"> File</code>) = <code role="statement">try</code> {
     <code role="statement">new</code> <code role="special">ScalaLineNumberReader</code>(<code role="statement">new</code> <code role="special">FileReader</code>(file))
  } <code role="statement">catch</code> {
    <code role="statement">case</code> ex:<code role="type"> IOException =&gt; throw</code> <code role="statement">new</code> <code role="special">ScalaIOException</code>(ex)
  }
}

<code role="statement">class</code> <code role="special">FilePrinter</code>(<code role="statement">val</code> file:<code role="type"> File</code>) {
  <code role="statement">def</code> <code role="identifier">print</code>() = {
    <code role="statement">val</code> reader = <code role="special">ScalaLineNumberReader</code>(file)
    <code role="statement">try</code> {
      loop(reader)
    } <code role="statement">finally</code> {
      <code role="statement">if</code> (reader != <code role="statement">null</code>)
        reader.close
    }
  }

  <code role="statement">private</code> <code role="statement">def</code> <code role="identifier">loop</code>(reader:<code role="type"> ScalaLineNumberReader</code>):<code role="type"> Unit</code> = {
    reader.inputLine() <code role="statement">match</code> {
      <code role="statement">case</code> <code role="special">None</code> <code role="statement">=&gt;</code>
      <code role="statement">case</code> <code role="special">Some</code>(line) <code role="statement">=&gt;</code> {
        format(<code role="constant">"%3d: %s</code><code role="special">\n</code><code role="constant">"</code>, reader.getLineNumber, line)
        loop(reader)
      }
    }
  }
}

<code role="comment">// Process the command-line arguments (file names):</code>
args.foreach { fileName <code role="statement">=&gt;</code>
  <code role="statement">new</code> <code role="special">FilePrinter</code>(<code role="statement">new</code> <code role="special">File</code>(fileName)).print();
}
</programlisting><para id="para_the_scalabufferedreader_clas">The
    <literal moreinfo="none">ScalaLineNumberReader</literal> class defines a new method
    <literal moreinfo="none">inputLine</literal> that calls <literal role="keep-together" moreinfo="none">LineNumberReader.readLine</literal> and pattern
    matches the result. If <literal moreinfo="none">null</literal>, then
    <literal moreinfo="none">None</literal> is returned. <phrase role="keep-together">Otherwise</phrase>, the line is returned wrapped in a
    <literal moreinfo="none">Some[String]</literal>.</para><para id="para__scalaioexception_is_a_subcla"><literal moreinfo="none">ScalaIOException</literal>
    is a subclass of <literal moreinfo="none">RuntimeException</literal>, so it is unchecked.
    We use it to wrap any <literal moreinfo="none">IOExceptions</literal> thrown in
    <literal moreinfo="none">ScalaLineNumberReader.apply</literal>.</para><para id="para_the_refactored_fileprinter_c">The refactored
    <literal moreinfo="none">FilePrinter</literal> class uses
    <literal moreinfo="none">ScalaLineNumberReader.apply</literal> in its
    <literal moreinfo="none">print</literal> method. It uses
    <literal moreinfo="none">ScalaLineNumberReader.inputLine</literal> in its
    <literal moreinfo="none">loop</literal> method. While the original version properly
    handled the case of <literal moreinfo="none">LineNumberReader.readLine</literal> returning
    <literal moreinfo="none">null</literal>, now the user of
    <literal moreinfo="none">ScalaLineNumberReader</literal> has no choice but to handle a
    <literal moreinfo="none">None</literal> return value.</para><para id="para_the_script_ends_with_a_loop_ov">The script ends with a loop
    over the input arguments, which are stored automatically in the
    <literal moreinfo="none">args</literal> variable. Each argument is treated as a file name
    to be printed. The script will print itself with the following
    command:</para><screen format="linespecific">scala file-printer-refactored-script.scala file-printer-refactored-script.scala</screen><sect2 id="OptionsAndForComprehensions"><title>Options and for Comprehensions</title><para id="para_one_other_benefit_of_option_with_for_comps">There is one
      other benefit of using <literal moreinfo="none">Options</literal> with
      <literal moreinfo="none">for</literal> comprehensions, automatic <phrase role="keep-together">removal</phrase> of <literal moreinfo="none">None</literal>
      elements from comprehensions, under most conditions (refer to <link linkend="Pollak2007" xrefstyle="select:nopage">[Pollak2007]</link> and
      <link linkend="Spiewak2009c" xrefstyle="select:nopage">[Spiewak2009c]</link>). Consider this first
      version of a script that uses <literal moreinfo="none">Options</literal> in a
      <literal moreinfo="none">for</literal> <phrase role="keep-together">comprehension</phrase>:<indexterm significance="normal"><primary>for comprehensions</primary><secondary>using Options with</secondary></indexterm><indexterm significance="normal"><primary>Option class</primary><secondary>using with for comprehensions</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/options-nulls/option-for-comp-v1-script.scala</code>

<code role="statement">case</code> <code role="statement">class</code> <code role="special">User</code>(userName:<code role="type"> String</code>, name:<code role="type"> String</code>, email:<code role="type"> String</code>, bio:<code role="type"> String</code>)

<code role="statement">val</code> newUserProfiles = <code role="special">List</code>(
  <code role="special">Map</code>(<code role="constant">"userName"</code> -&gt; <code role="constant">"twitspam"</code>, <code role="constant">"name"</code> -&gt; <code role="constant">"Twit Spam"</code>),
  <code role="special">Map</code>(<code role="constant">"userName"</code> -&gt; <code role="constant">"bucktrends"</code>, <code role="constant">"name"</code> -&gt; <code role="constant">"Buck Trends"</code>,
      <code role="constant">"email"</code> -&gt; <code role="constant">"thebuck@stops.he.re"</code>, <code role="constant">"bio"</code> -&gt; <code role="constant">"World's greatest bloviator"</code>),
  <code role="special">Map</code>(<code role="constant">"userName"</code> -&gt; <code role="constant">"lonelygurl"</code>, <code role="constant">"name"</code> -&gt; <code role="constant">"Lonely Gurl"</code>,
      <code role="constant">"bio"</code> -&gt; <code role="constant">"Obviously fake..."</code>),
  <code role="special">Map</code>(<code role="constant">"userName"</code> -&gt; <code role="constant">"deanwampler"</code>, <code role="constant">"name"</code> -&gt; <code role="constant">"Dean Wampler"</code>,
      <code role="constant">"email"</code> -&gt; <code role="constant">"dean@....com"</code>, <code role="constant">"bio"</code> -&gt; <code role="constant">"Scala passionista"</code>),
  <code role="special">Map</code>(<code role="constant">"userName"</code> -&gt; <code role="constant">"al3x"</code>, <code role="constant">"name"</code> -&gt; <code role="constant">"Alex Payne"</code>,
      <code role="constant">"email"</code> -&gt; <code role="constant">"al3x@....com"</code>, <code role="constant">"bio"</code> -&gt; <code role="constant">"Twitter API genius"</code>))

<code role="comment">// Version #1</code>

<code role="statement">var</code> validUsers = <code role="statement">for</code> {
  user     <code role="statement">&lt;-</code> newUserProfiles
  <code role="statement">if</code> (user.contains(<code role="constant">"userName"</code>) &amp;&amp; user.contains(<code role="constant">"name"</code>) &amp;&amp;   <code role="comment">// #1</code>
      user.contains(<code role="constant">"email"</code>) &amp;&amp; user.contains(<code role="constant">"bio"</code>))         <code role="comment">// #1</code>
  userName <code role="statement">&lt;-</code> user get <code role="constant">"userName"</code>
  name     <code role="statement">&lt;-</code> user get <code role="constant">"name"</code>
  email    <code role="statement">&lt;-</code> user get <code role="constant">"email"</code>
  bio      <code role="statement">&lt;-</code> user get <code role="constant">"bio"</code> }
    <code role="statement">yield</code> <code role="special">User</code>(userName, name, email, bio)

validUsers.foreach (user <code role="statement">=&gt;</code> println(user))
</programlisting><para id="para_imagine_this_code_is_used_in_s">Imagine this code is used
      in some sort of social networking site. New users submit profile data,
      which is passed to this service in bulk for processing. For example, we
      hardcoded a list of submitted profiles, where each profile data set is a
      map. The map might have been copied from an HTTP session.</para><para id="para_the_service_filters_out_incomp">The service filters out
      incomplete profiles (missing fields), shown with the #1 comments, and
      creates new user objects from the complete profiles.</para><para id="para_3_of_5_users_printed">Running the script prints out three
      new users from the five submitted profiles:</para><screen format="linespecific">User(bucktrends,Buck Trends,thebuck@stops.he.re,World's greatest bloviator)
User(deanwampler,Dean Wampler,dean@....com,Scala passionista)
User(al3x,Alex Payne,al3x@....com,Twitter API genius)</screen><para id="para_now_comment_out_the_two_lines">Now, delete the two lines
      with the #1 comment:</para><programlisting language="scala" format="linespecific">...
<code role="statement">var</code> validUsers = <code role="statement">for</code> {
  user     <code role="statement">&lt;-</code> newUserProfiles
  userName <code role="statement">&lt;-</code> user get <code role="constant">"userName"</code>
  name     <code role="statement">&lt;-</code> user get <code role="constant">"name"</code>
  email    <code role="statement">&lt;-</code> user get <code role="constant">"email"</code>
  bio      <code role="statement">&lt;-</code> user get <code role="constant">"bio"</code> }
    <code role="statement">yield</code> <code role="special">User</code>(userName, name, email, bio)

validUsers.foreach (user <code role="statement">=&gt;</code> println(user))
</programlisting><para id="para_before_you_rerun_the_script_w">Before you rerun the
      script, what do you expect to happen? Will it print five lines with some
      fields empty (or containing other kinds of values)?</para><para id="para_same_3_of_5_users_printed">It prints the same thing! How
      did it do the filtering we wanted without the explicit
      conditional?</para><para id="para_the_answer_lies_in_the_way_tha">The answer lies in the
      way that <literal moreinfo="none">for</literal> comprehensions are implemented. Here are
      a couple of simple for comprehensions followed by their translations
      (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). First, we’ll look at
      a single <emphasis>generator</emphasis> with a
      <literal moreinfo="none">yield</literal>:<indexterm significance="normal"><primary>generators</primary><secondary sortas="for comprehensions">in for
          comprehensions</secondary></indexterm></para><programlisting language="scala" format="linespecific"><code role="statement">for</code> (p1 <code role="statement">&lt;-</code> e1) <code role="statement">yield</code> e2          <code role="comment">// for comprehension</code>

e1 map ( <code role="statement">case</code> p1 <code role="statement">=&gt;</code> e2 )         <code role="comment">// translation</code>
</programlisting><para id="para_here_s_the_translation_a_singl">Here’s the translation of
      a single generator followed by an arbitrary expression (which could be
      several expressions in braces, etc.):</para><programlisting language="scala" format="linespecific"><code role="statement">for</code> (p1 <code role="statement">&lt;-</code> e1) e2                <code role="comment">// for comprehension</code>

e1 foreach ( <code role="statement">case</code> p1 <code role="statement">=&gt;</code> e2 )     <code role="comment">// translation</code>
</programlisting><para id="para_with_more_than_one__generator_">With more than one
      generator, <literal moreinfo="none">map</literal> is replaced with
      <literal moreinfo="none">flatMap</literal> in the <literal moreinfo="none">yield</literal> expressions,
      but <literal moreinfo="none">foreach</literal> is unchanged:</para><programlisting language="scala" format="linespecific"><code role="statement">for</code> (p1 <code role="statement">&lt;-</code> e1; p2 <code role="statement">&lt;-</code> e2 ...) <code role="statement">yield</code> eN       <code role="comment">// for comprehension</code>

e1 flatMap ( <code role="statement">case</code> p1 <code role="statement">=&gt;</code> <code role="statement">for</code> (p2 <code role="statement">&lt;-</code> e2 ...) <code role="statement">yield</code> eN )  <code role="comment">// translation</code>
</programlisting><programlisting language="scala" format="linespecific"><code role="statement">for</code> (p1 <code role="statement">&lt;-</code> e1; p2 <code role="statement">&lt;-</code> e2 ...) eN             <code role="comment">// for comprehension</code>

e1 foreach ( <code role="statement">case</code> p1 <code role="statement">=&gt;</code> <code role="statement">for</code> (p2 <code role="statement">&lt;-</code> e2 ...) eN )       <code role="comment">// translation</code>
</programlisting><para id="para_note_that_the_second_through_t">Note that the second
      through the N<superscript>th</superscript> generators become nested for
      comprehensions that need translating.</para><para id="para_there_are_similar_translations">There are similar
      translations for conditional statements (which become calls to <literal role="keep-together" moreinfo="none">filter</literal>) and <literal moreinfo="none">val</literal>
      assignments. We won’t show them here, since our primary purpose is to
      describe just enough of the implementation details so you can understand
      how <literal moreinfo="none">Options</literal> and <literal moreinfo="none">for</literal> comprehensions
      work together. The additional details are described in <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>, with examples.</para><para id="para_if_you_follow_this_translation">If you follow this
      translation process on our example, you get the following
      expansion:</para><programlisting language="scala" format="linespecific"><code role="statement">var</code> validUsers = newUserProfiles flatMap {
  <code role="statement">case</code> user <code role="statement">=&gt;</code> user.get(<code role="constant">"userName"</code>) flatMap {
    <code role="statement">case</code> userName <code role="statement">=&gt;</code> user.get(<code role="constant">"name"</code>) flatMap {
      <code role="statement">case</code> name <code role="statement">=&gt;</code> user.get(<code role="constant">"email"</code>) flatMap {
        <code role="statement">case</code> email <code role="statement">=&gt;</code> user.get(<code role="constant">"bio"</code>) map {
          <code role="statement">case</code> bio <code role="statement">=&gt;</code> <code role="special">User</code>(name, userName, email, bio)    <code role="comment">// #1</code>
        }
      }
    }
  }
}
</programlisting><para id="para_note_that_we_have_flatmap_ca">Note that we have
      <literal moreinfo="none">flatMap</literal> calls until the most nested case, where
      <literal moreinfo="none">map</literal> is used (<literal role="keep-together" moreinfo="none">flatMap</literal> and <literal moreinfo="none">map</literal> behave
      equivalently in this case).</para><para id="para_now_we_can_understand_why_the_">Now we can understand why
      the big conditional was unnecessary. Recall that <literal moreinfo="none">user</literal>
      is a <literal moreinfo="none">Map</literal> and <literal moreinfo="none">user.get("...")</literal>
      returns an <literal moreinfo="none">Option</literal>, either <literal moreinfo="none">None</literal> or
      <literal moreinfo="none">Some(value)</literal>. The key is the behavior of
      <literal moreinfo="none">flatMap</literal> defined on <literal moreinfo="none">Option</literal>, which
      lets us treat <literal moreinfo="none">Options</literal> like other collections. Here is
      the definition of <literal moreinfo="none">flatMap</literal>:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">flatMap</code><code role="identifier">[B]</code>(f:<code role="type"> A =&gt; Option[B]</code>):<code role="type"> Option[B]</code> =
  <code role="statement">if</code> (isEmpty) <code role="special">None</code> <code role="statement">else</code> f(<code role="statement">this</code>.get)
</programlisting><para id="para_if_user_get_returns_">If
      <literal moreinfo="none">user.get("...")</literal> returns <literal moreinfo="none">None</literal>, then
      <literal moreinfo="none">flatMap</literal> simply returns <literal moreinfo="none">None</literal> and
      never evaluates the function literal. Hence, the nested iterations
      simply stop and never get to the line marked with the comment #1, where
      the <literal moreinfo="none">User</literal> is created.</para><para id="para_the_outer_most_flatmap_is_on">The outermost
      <literal moreinfo="none">flatMap</literal> is on the input <literal moreinfo="none">List</literal>,
      <literal moreinfo="none">newUserProfiles</literal>. On a multi-element <phrase role="keep-together">collection</phrase> like this, the behavior of
      <literal moreinfo="none">flatMap</literal> is similar to <literal moreinfo="none">map</literal>, but it
      flattens the new <phrase role="keep-together">collection</phrase> and
      doesn’t require the resulting map to have the same number of elements as
      the original collection, like <literal moreinfo="none">map</literal> does.</para><para id="para_finally_recall_from_partial">Finally, recall from <xref linkend="PartialFunctions"/> that the <literal moreinfo="none">case user =&gt;
      ...</literal> <phrase role="keep-together">statements</phrase>, for
      example, cause the compiler to generate a
      <literal moreinfo="none">PartialFunction</literal> to pass to <literal role="keep-together" moreinfo="none">flatMap</literal> and <literal moreinfo="none">map</literal>, so no
      corresponding <literal moreinfo="none">foo match {...}</literal> style wrappers are
      necessary.</para><tip id="para_tip_using_options_with_for"><para>Using <literal moreinfo="none">Options</literal> with <literal moreinfo="none">for</literal>
        comprehensions eliminate the need for most “null/empty” checks.</para></tip></sect2></sect1><sect1 id="ExceptionsAndTheAlternatives"><title>Exceptions and the Alternatives</title><para id="para_if_nulls_are_the_billion_d">If <literal moreinfo="none">nulls</literal> are
    the “billion dollar mistake” as we discussed in <xref linkend="OptionSomeNone"/>, then what about exceptions? You can argue
    that <literal moreinfo="none">nulls</literal> should never occur and you can design a
    language and libraries that never use them. However, exceptions have a
    legitimate place because they <emphasis>separate the con⁠cerns</emphasis>
    of normal program flow from “exceptional” program flow. The divide isn’t
    always clear-cut. For example, if a user mistypes his username, is that
    normal or exceptional?<indexterm significance="normal"><primary>application design</primary><secondary>exceptions and alternatives</secondary></indexterm><indexterm significance="normal"><primary>exceptions</primary><secondary>and alternatives to</secondary></indexterm></para><para id="para_another_question_is_where_shou">Another question is where
    should the exception be caught and handled? Java’s checked exceptions were
    designed to document for the API user what exceptions might be thrown by a
    method. The flaw was that it encouraged handling of the exception in ways
    that are often suboptimal. If one method calls another method that might
    throw a checked exception, the calling method is forced to either handle
    the exception or declare that it also throws the exception. More often
    than not, the calling method is the wrong place to handle the exception.
    It is too common for methods to simply “eat” an exception that should
    really be passed up the stack and handled in a more appropriate context.
    Otherwise, <literal moreinfo="none">throws</literal> declarations are required up the
    stack of method calls. This is not only tedious, but it pollutes the
    intermediate contexts with exception names that often have no connection
    to the local context.</para><para id="para_as_we_have_seen_scala_doesn_t_">As we have seen, Scala
    doesn’t have checked exceptions. Any exception can propagate to the point
    where it is most appropriate to handle it. However, design discipline is
    required to implement handlers in the appropriate places for all
    exceptions for which recovery is possible!</para><para id="para_every_now_and_then_an_argumen">Every now and then, an
    argument erupts among developers in a particular language community about
    whether or not it’s OK to use exceptions as a control-flow mechanism for
    normal processing. Sometimes this use of exceptions is seen as a useful
    <literal role="keep-together" moreinfo="none">longjump</literal> or non-local
    <literal moreinfo="none">goto</literal> mechanism for exiting out of a deeply nested
    scope. One reason this debate pops up is that this use of exceptions is
    sometimes more efficient than a more “conventional” implementation.</para><para id="para_for_example_you_might_impleme">For example, you might
    implement <literal moreinfo="none">Iterable.foreach</literal> to blindly traverse a
    collection and stop when it catches whatever exception indicates it went
    past the end of the <phrase role="keep-together">collection</phrase>.</para><para id="para_when_it_comes_to_application_d">When it comes to
    application design, communicating <emphasis>intent</emphasis> is very
    important. Using exceptions as a <literal moreinfo="none">goto</literal> mechanism breaks
    the <emphasis>principle of least surprise</emphasis>. It will be rare that
    the performance gain will justify the loss of clarity, so we encourage you
    to use exceptions only for truly “exceptional” conditions. Note that Ruby
    actually provides a non-local <literal moreinfo="none">goto</literal>-like mechanism. In
    Ruby the keywords <literal moreinfo="none">throw</literal> and <literal moreinfo="none">catch</literal>
    are actually reserved for this purpose, while <literal moreinfo="none">raise</literal> and
    <literal moreinfo="none">rescue</literal> are the keywords for raising an exception and
    handling it.<indexterm significance="normal"><primary>Ruby</primary><secondary>exceptions</secondary></indexterm></para><para id="para_whatever_your_view_on_the_prop">Whatever your view on the
    proper use of exceptions, when you design APIs, minimizing the possibility
    of raising an exception will benefit your users. This is the flip side of
    an exception handling strategy, preventing them in the first place.
    <literal moreinfo="none">Option</literal> can help.<indexterm significance="normal"><primary>Option class</primary><secondary>alternatives to exceptions</secondary></indexterm></para><para id="para_consider_two_methods_on_seq_">Consider two methods on
    <literal moreinfo="none">Seq</literal>, <literal moreinfo="none">first</literal> and
    <literal moreinfo="none">firstOption</literal>:<indexterm significance="normal"><primary>Seq class, first and firstOption methods</primary></indexterm></para><screen format="linespecific">trait Seq[+A] {
  ...
  def first : A = ...
  def firstOption : Option[A] = ...
  ...
}</screen><para id="para_the_first_method_throws_a_p">The <literal moreinfo="none">first</literal>
    method throws a <literal moreinfo="none">Predef.UnsupportedOperationException</literal> if
    the sequence is empty. Returning <literal moreinfo="none">null</literal> in this case
    isn’t an option, because the sequence could have <literal moreinfo="none">null</literal>
    elements! In contrast, the <literal moreinfo="none">firstOption</literal> method returns
    an <literal moreinfo="none">Option</literal>, so it returns <literal moreinfo="none">None</literal> if the
    sequence is empty, which is unambiguous.</para><para id="para_you_could_argue_that_the_seq_">You could argue that the
    <literal moreinfo="none">Seq</literal> API would be more robust if it only had a “first”
    method that returned an <literal moreinfo="none">Option</literal>. It’s useful to ask
    yourself, “How can I prevent the user from ever failing?” When “failure”
    can’t be prevented, use <literal moreinfo="none">Option</literal> or a similar construct
    to document for the user that a failure mode is possible. Thinking in
    terms of valid state transformations, the <literal moreinfo="none">first</literal> method,
    while convenient, isn’t really valid for a sequence in an empty state.
    Should the “first” methods not exist for this reason? This choice is
    probably too draconian, but by returning <literal moreinfo="none">Option</literal> from
    <literal moreinfo="none">firstOption</literal>, the API communicates to the user that
    there are circumstances when the method can’t satisfy the request and it’s
    up to the user to recover gracefully. In this sense,
    <literal moreinfo="none">firstOption</literal> treats an empty sequence as a
    non-exceptional situation.</para><para id="para_recall_that_we_saw_another_exa">Recall that we saw another
    example of this decision tradeoff in <xref linkend="OptionSomeNone"/>. We
    discussed two methods on <literal moreinfo="none">Option</literal> for retrieving the
    value an instance wraps (when the instance is actually a
    <literal moreinfo="none">Some</literal>). The <literal moreinfo="none">get</literal> method throws an
    exception if there is no value, i.e., the <literal moreinfo="none">Option</literal>
    instance is actually <literal moreinfo="none">None</literal>. The other method,
    <literal moreinfo="none">getOrElse</literal>, takes a second argument, a default value to
    return if the <literal moreinfo="none">Option</literal> is actually
    <literal moreinfo="none">None</literal>. In this case, no exception is thrown.</para><para id="para_of_course_it_is_impossible_to">Of course, it is impossible
    to avoid all exceptions. Part of the original intent of checked versus
    unchecked exceptions was to distinguish between potentially recoverable
    problems and catastrophic failures, like out-of-memory errors.</para><para id="para_however_the_alternative_metho">However, the alternative
    methods in <literal moreinfo="none">Seq</literal> and <literal moreinfo="none">Option</literal> show a way
    to “encourage” the user of an API to consider the consequences of a
    possible failure, like asking for the first element in an empty sequence.
    The user can specify the contingency in the event that a failure occurs.
    Minimizing the possibility of exceptions will improve the robustness of
    your Scala libraries and the applications that use them.</para></sect1><sect1 id="ScalableAbstractions"><title>Scalable Abstractions</title><para id="para_it_has_been_a_goal_for_some_ti">It has been a goal for some
    time in our industry to create reusable <emphasis>components</emphasis>.
    Unfortunately, there is little agreement on the meaning of the term
    <emphasis>component</emphasis>, nor on a related term,
    <emphasis>module</emphasis> (which some people consider synonymous with
    <emphasis>component</emphasis>). Proposed definitions usually start with
    assumptions about the platform, granularity, deployment and configuration
    scenarios, versioning issues, etc. (see <link linkend="Szyperski1998" xrefstyle="select:nopage">[Szyperski1998]</link>).<indexterm class="startofrange" id="ch13_components" significance="normal"/><indexterm significance="normal"><primary>modules</primary><secondary>components and</secondary></indexterm><indexterm significance="normal"><primary>components</primary><secondary>defined</secondary></indexterm><indexterm significance="normal"><primary>application design</primary><secondary>scalable abstractions</secondary></indexterm></para><para id="para_we_ll_avoid_that_discussion_an">We’ll avoid that discussion
    and use the term <emphasis>component</emphasis> informally to refer to a
    grouping of types and packages that exposes coherent abstractions
    (preferably just one) for the services it offers, that has minimal
    coupling to other components, and that is internally cohesive.<indexterm significance="normal"><primary>scalable abstractions</primary><see>components</see></indexterm></para><para id="para_all_languages_offer_mechanisms">All languages offer
    mechanisms for defining components, at least to some degree. Objects are
    the primary encapsulation mechanism in object-oriented languages. However,
    objects alone aren’t enough, because we quickly find that objects
    naturally cluster together into more coarse-grained aggregates, especially
    as our applications grow. Generally speaking, an object isn’t necessarily
    a component, and a component may contain many objects. Scala and Java
    offer packages for aggregating types. Ruby modules serve a similar
    purpose, as do C# and C++ namespaces.</para><para id="para_however_these_packaging_mecha">However, these packaging
    mechanisms still have limitations. A common problem is that they don’t
    clearly define what is publicly visible outside the component boundary and
    what is internal to the component. For example, in Java, any public type
    or public method on a public type is visible outside the package boundary
    to every other component. You can make types and methods “package
    private,” but then they are invisible to other packages encapsulated in
    the component. Java doesn’t have a clear sense of component
    boundaries.</para><para id="para_scala_provides_several_mechani">Scala provides a number of
    mechanisms that improve this situation. We have seen many of them
    already.</para><sect2 id="FineGrainedVisibilityRules"><title>Fine-Grained Visibility Rules</title><para id="para_we_saw_in_visibilityrules_">We saw in <xref linkend="VisibilityRules"/> that Scala provides more fine-grained
      visibility rules than most other languages. You can control the
      visibility of types and methods outside type and package
      boundaries.<indexterm significance="normal"><primary>components</primary><secondary>fine-grained visibility rules in Scala</secondary></indexterm><indexterm significance="normal"><primary>visibility</primary><secondary>fine-grained visibility rules in Scala</secondary></indexterm></para><para id="para_consider_the_following_encodedstring_component">Consider
      the following example of a component in package
      <literal moreinfo="none">encodedstring</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/encoded-string.scala</code>

<code role="preproc">package</code> encodedstring {

  <code role="statement">trait</code> <code role="special">EncodedString</code> {
    <code role="statement">protected</code>[encodedstring] <code role="statement">val</code> string:<code role="type"> String</code>
    <code role="statement">val</code> separator:<code role="type"> EncodedString.Separator.Delimiter</code>

    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = string

    <code role="statement">def</code> <code role="identifier">toTokens</code> = string.split(separator.toString).toList
  }

  <code role="statement">object</code> <code role="special">EncodedString</code> {
    <code role="statement">object</code> <code role="special">Separator</code> <code role="statement">extends</code> <code role="special">Enumeration</code> {
      <code role="statement">type</code> <code role="special">Delimiter</code> = <code role="special">Value</code>
      <code role="statement">val</code> COMMA = <code role="special">Value</code>(<code role="constant">","</code>)
      <code role="statement">val</code> TAB   = <code role="special">Value</code>(<code role="constant">"\t"</code>)
    }

    <code role="statement">def</code> <code role="identifier">apply</code>(s:<code role="type"> String</code>, sep:<code role="type"> Separator.Delimiter</code>) = sep <code role="statement">match</code> {
      <code role="statement">case</code> Separator.<code role="special">COMMA</code> <code role="statement">=&gt;</code> impl.<code role="special">CSV</code>(s)
      <code role="statement">case</code> Separator.<code role="special">TAB</code>   <code role="statement">=&gt;</code> impl.<code role="special">TSV</code>(s)
    }

    <code role="statement">def</code> <code role="identifier">unapply</code>(es:<code role="type"> EncodedString</code>) = <code role="special">Some</code>(<code role="special">Pair</code>(es.string, es.separator))
  }

  <code role="preproc">package</code> impl {
    <code role="statement">private</code>[encodedstring] <code role="statement">case</code> <code role="statement">class</code> <code role="special">CSV</code>(<code role="statement">override</code> <code role="statement">val</code> string:<code role="type"> String</code>)
        <code role="statement">extends</code> <code role="special">EncodedString</code> {
      <code role="statement">override</code> <code role="statement">val</code> separator = EncodedString.Separator.<code role="special">COMMA</code>
    }

    <code role="statement">private</code>[encodedstring] <code role="statement">case</code> <code role="statement">class</code> <code role="special">TSV</code>(<code role="statement">override</code> <code role="statement">val</code> string:<code role="type"> String</code>)
        <code role="statement">extends</code> <code role="special">EncodedString</code> {
      <code role="statement">override</code> <code role="statement">val</code> separator = EncodedString.Separator.<code role="special">TAB</code>
    }
  }
}
</programlisting><para id="para_encapsulates_encoded_strings">This example encapsulates
      handling of strings encoding comma-separated values (CSVs) or
      tab-separated values (TSVs). The <literal moreinfo="none">encodedstring</literal>
      package exposes a trait <literal moreinfo="none">EncodedString</literal> that is visible
      to clients. The concrete classes implementing CSVs and TSVs are declared
      <literal moreinfo="none">private[encodedstring]</literal> in the
      <literal moreinfo="none">encodedstring.impl</literal> package. The trait defines two
      abstract <literal moreinfo="none">val</literal> fields: one to hold the encoded
      <literal moreinfo="none">string</literal>, which is protected from client access, and
      the other to hold the <literal moreinfo="none">separator</literal> (e.g., a comma).
      Recall from <xref linkend="AdvancedObjectOrientedProgramming"/> that
      abstract fields, like abstract types and methods, must be initialized in
      concrete instances. In this case, <literal moreinfo="none">string</literal> will be
      defined through a concrete constructor, and the
      <literal moreinfo="none">separator</literal> is defined explicitly in the concrete
      classes, <literal moreinfo="none">CSV</literal> and <literal moreinfo="none">TSV</literal>.</para><para id="para_the_tostring_method_on_enco">The
      <literal moreinfo="none">toString</literal> method on <literal moreinfo="none">EncodedString</literal>
      prints the string as a “normal” string. By hiding the
      <literal moreinfo="none">string</literal> value and the concrete classes, we have
      complete freedom in how the string is actually stored. For example, for
      extremely large strings, we might want to split them on the delimiter
      and store the tokens in a data structure. This could save space if the
      strings are large enough and we can share tokens between strings. Also,
      we might find this storage useful for various searching, sorting, and
      other manipulation tasks. All these implementation issues are
      transparent to the client.</para><para id="para_exposes_encoded_strings_abstractions">The package also
      exposes an object with an <literal moreinfo="none">Enumeration</literal> for the known
      separators, an <literal moreinfo="none">apply</literal> factory method to construct new
      encoded strings, and an <literal moreinfo="none">unapply</literal> extractor method to
      decompose the encoded string into its enclosed string and the delimiter.
      In this case, the <literal moreinfo="none">unapply</literal> method looks trivial, but
      if we stored the strings in a different way, this method could
      transparently reconstitute the original string.</para><para id="para_clients_of_encoded_strings">So, clients of this component
      only know about the <literal moreinfo="none">EncodedString</literal> abstraction and the
      enumeration representing the supported types of encoded strings. All the
      actual implementation types and details are private to the
      <literal moreinfo="none">encodedstring</literal> package. (We put them in the same file
      for convenience, but normally you would kept them separate.) Hence, the
      boundary is clear between the exposed abstractions and the internal
      implementation details.</para><para id="para_encoded_strings_script">The following script demonstrates
      the component in use:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/encoded-string-script.scala</code>

<code role="preproc">import</code> encodedstring._
<code role="preproc">import</code> encodedstring.EncodedString._

<code role="statement">def</code> <code role="identifier">p</code>(s:<code role="type"> EncodedString</code>) = {
  println(<code role="constant">"EncodedString: "</code> + s)
  s.toTokens foreach (x <code role="statement">=&gt;</code> println(<code role="constant">"token: "</code> + x))
}

<code role="statement">val</code> csv = <code role="special">EncodedString</code>(<code role="constant">"Scala,is,great!"</code>, Separator.<code role="special">COMMA</code>)
<code role="statement">val</code> tsv = <code role="special">EncodedString</code>(<code role="constant">"Scala\tis\tgreat!"</code>, Separator.<code role="special">TAB</code>)

p(csv)
p(tsv)

println( <code role="constant">"</code><code role="special">\n</code><code role="constant">Extraction:"</code> )
<code role="special">List</code>(csv, <code role="constant">"ProgrammingScala"</code>, tsv, <code role="constant">3.14159</code>) foreach {
  <code role="statement">case</code> <code role="special">EncodedString</code>(str, delim) <code role="statement">=&gt;</code>
    println( <code role="constant">"EncodedString: </code><code role="special">\"</code><code role="constant">"</code> + str + <code role="constant">"</code><code role="special">\"</code><code role="constant">, delimiter: </code><code role="special">\"</code><code role="constant">"</code> + delim + <code role="constant">"</code><code role="special">\"</code><code role="constant">"</code> )
  <code role="statement">case</code> s:<code role="type"> String =&gt; println</code>( <code role="constant">"String: "</code> + s )
  <code role="statement">case</code> x <code role="statement">=&gt;</code> println( <code role="constant">"Unknown Value: "</code> + x )
}
</programlisting><para id="para_encoded_strings_script_output">It produces the following
      output:</para><screen format="linespecific">EncodedString: Scala,is,great!
token: Scala
token: is
token: great!
EncodedString: Scala    is      great!
token: Scala
token: is
token: great!

Extraction:
EncodedString: "Scala,is,great!", delimiter: ","
String: ProgrammingScala
EncodedString: "Scala   is      great!", delimiter: "   "
Unknown Value: 3.14159</screen><para id="para_cant_access_CSV">However, if we try to use the
      <literal moreinfo="none">CSV</literal> class directly, for example, we get the following
      error:</para><screen format="linespecific">scala&gt; import encodedstring._
import encodedstring._

scala&gt; val csv = impl.CSV("comma,separated,values")
&lt;console&gt;:6: error: object CSV cannot be accessed in package encodedstring.impl
       val csv = impl.CSV("comma,separated,values")
                      ^

scala&gt;</screen><para id="para_was_it_necessary_to_make_the_c">In this simple example,
      it wasn’t essential to make the concrete types private to the component.
      However, we have a very minimal interface to clients of the component,
      and we are free to modify the implementation as we see fit with little
      risk of forcing client code modifications. A common cause of maintenance
      paralysis in mature applications is the presence of too many
      dependencies between concrete types, which become difficult to modify
      since they force changes to client code. So, for larger, more
      sophisticated components, this clear separation of abstraction from
      implementation can keep the code maintainable and reusable for a long
      time.</para></sect2><sect2 id="MixinComposition"><title>Mixin Composition</title><para id="para_we_saw_in_traits_in_obje">We saw in <xref linkend="Traits"/> how traits promote mixin composition. A class can
      focus on its <emphasis>primary domain</emphasis>, and other
      responsibilities can be implemented separately in traits. When instances
      are constructed, classes and traits can be combined to compose the full
      range of required behaviors.<indexterm significance="normal"><primary>traits</primary><secondary>promotion of mixin composition</secondary></indexterm><indexterm significance="normal"><primary>mixin composition</primary></indexterm></para><para id="para_in_overridingabstracttypes_">For example, in <xref linkend="OverridingAbstractTypes"/>, we discussed our second version of
      the Observer Pattern:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/observer/observer2.scala</code>

<code role="preproc">package</code> observer

<code role="statement">trait</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code>

  <code role="statement">private</code> <code role="statement">var</code> observers = <code role="special">List</code><code role="special">[Observer]</code>()
  <code role="statement">def</code> <code role="identifier">addObserver</code>(observer:<code role="type">Observer</code>) = observers ::= observer
  <code role="statement">def</code> <code role="identifier">notifyObservers</code> = observers foreach (notify(<code role="statement">_</code>))

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code>
}

<code role="statement">trait</code> <code role="special">SubjectForReceiveUpdateObservers</code> <code role="statement">extends</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = { <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> Any</code>) }

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code> = observer.receiveUpdate(<code role="statement">this</code>)
}

<code role="statement">trait</code> <code role="special">SubjectForFunctionalObservers</code> <code role="statement">extends</code> <code role="special">AbstractSubject</code> {
  <code role="statement">type</code> <code role="special">Observer</code> = (<code role="special">AbstractSubject</code>) <code role="statement">=&gt;</code> <code role="special">Unit</code>

  <code role="statement">def</code> <code role="identifier">notify</code>(observer:<code role="type"> Observer</code>):<code role="type"> Unit</code> = observer(<code role="statement">this</code>)
}
</programlisting><para id="para_we_used_this_version_to_observ">We used this version to
      observe button “clicks” in a UI. Let’s revisit this implementation and
      resolve a few limitations, using our next tool for scalable
      abstractions, <emphasis>self-type annotations</emphasis> combined with
      abstract type members.<indexterm significance="normal"><primary>abstract types</primary><secondary>combined with self-type annotations</secondary></indexterm><indexterm significance="normal"><primary>self-type annotations</primary><secondary>and abstract type members</secondary></indexterm></para></sect2><sect2 id="SelfTypeAnnotationsAndAbstractTypeMembers"><title>Self-Type Annotations and Abstract Type Members</title><para id="para_there_are_a_few_things_that_are_unsatisfying1">There are
      a few things that are unsatisfying about the implementation of
      <literal moreinfo="none">AbstractSub⁠ject</literal> in our second version of the
      Observer Pattern. The first occurs in
      <literal moreinfo="none">SubjectForRe⁠ceiveUpdateObservers</literal>, where the
      <literal moreinfo="none">Observer</literal> type is defined to be the structural type
      <literal moreinfo="none">{ def receiveUpdate(subject: Any) }</literal>. It would be nice
      to narrow the type of <literal role="keep-together" moreinfo="none">subject</literal> to
      something more specific than <literal moreinfo="none">Any</literal>.</para><para id="para_there_are_a_few_things_that_are_unsatisfying2">The second
      issue, which is really the same problem in a different form, occurs in
      <literal moreinfo="none">SubjectForFunctionalObservers</literal>, where the
      <literal moreinfo="none">Observer</literal> type is defined to be the type
      <literal moreinfo="none">(AbstractSubject) =&gt; Unit</literal>. We would like the
      argument to the function to be something more specific than
      <literal moreinfo="none">AbstractSubject</literal>. Perhaps this drawback wasn’t so
      evident before, because our simple examples never needed to access
      <literal moreinfo="none">Button</literal> state information or methods.<indexterm significance="normal"><primary>polymorphism</primary><secondary>family polymorphism</secondary></indexterm><indexterm significance="normal"><primary>family polymorphism</primary></indexterm><indexterm significance="normal"><primary>covariant specialization</primary></indexterm></para><para id="para_in_fact_we_expect_the_actual_">In fact, we expect the
      actual types of the subject and observer to be specialized <emphasis role="keep-together">covariantly</emphasis>. For example, when we’re
      observing <literal moreinfo="none">Buttons</literal>, we expect our observers to be
      specialized for <literal moreinfo="none">Buttons</literal>, so they can access
      <literal moreinfo="none">Button</literal> state and methods. This
      <emphasis>covariant</emphasis> specialization is sometimes called
      <emphasis>family polymorphism</emphasis> (see <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>).
      Let’s fix our design to support this covariance.</para><para id="para_to_simplify_the_example_let_s">To simplify the example,
      let’s focus on just the <literal moreinfo="none">receiveUpdate</literal> form of the
      <literal moreinfo="none">Observer</literal>, which we implemented with
      <literal moreinfo="none">SubjectForReceiveUpdateObservers</literal> before. Here is a
      reworking of our pattern, loosely following an example in <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>.
      (Note that the Scala syntax has changed somewhat since that paper was
      written.)</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/observer3-wont-compile.scala</code>
<code role="comment">// WON'T COMPILE</code>

<code role="preproc">package</code> observer

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">SubjectObserver</code> {
  <code role="statement">type</code> <code role="special">S</code> &lt;:<code role="type"> Subject</code>
  <code role="statement">type</code> <code role="special">O</code> &lt;:<code role="type"> Observer</code>

  <code role="statement">trait</code> <code role="special">Subject</code> {
    <code role="statement">private</code> <code role="statement">var</code> observers = <code role="special">List</code><code role="special">[O]</code>()
    <code role="statement">def</code> <code role="identifier">addObserver</code>(observer:<code role="type"> O</code>) = observers ::= observer
    <code role="statement">def</code> <code role="identifier">notifyObservers</code> = observers foreach (<code role="statement">_</code>.receiveUpdate(<code role="statement">this</code>)) <code role="comment">// ERROR</code>
  }

  <code role="statement">trait</code> <code role="special">Observer</code> {
    <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> S</code>)
  }
}
</programlisting><para id="para_type_and_parents">We’ll explain the error in a minute.
      Note how the types <literal moreinfo="none">S</literal> and <literal moreinfo="none">O</literal> are
      declared. As we saw in <xref linkend="ParameterizedTypes"/>, the
      expression <literal moreinfo="none">type S &lt;: Subject</literal> defines an abstract
      type <literal moreinfo="none">S</literal> where the only allowed concrete types will be
      subtypes of <literal moreinfo="none">Subject</literal>. The declaration of
      <literal moreinfo="none">O</literal> is similar. To be clear, <literal moreinfo="none">S</literal> and
      <literal moreinfo="none">O</literal> are “placeholders” at this point, while
      <literal moreinfo="none">Subject</literal> and <literal moreinfo="none">Observer</literal> are abstract
      traits defined in <literal moreinfo="none">SubjectObserver</literal>.</para><para id="para_subjectobserver_as_abstract_class_or_trait">By the way,
      declaring <literal moreinfo="none">SubjectObserver</literal> as an abstract class versus
      a trait is somewhat arbitrary. We’ll derive concrete objects from it
      shortly. We need <literal moreinfo="none">SubjectObserver</literal> primarily so we have
      a type to “hold” our abstract type members <literal moreinfo="none">S</literal> and
      <literal moreinfo="none">O</literal>.</para><para id="para_if_you_attempt_to_compile_this">However, if you attempt
      to compile this code as currently written, you get the following
      error:</para><screen format="linespecific">... 10: error: type mismatch;
 found   : SubjectObserver.this.Subject
 required: SubjectObserver.this.S
      def notifyObservers = observers foreach (_.receiveUpdate(this))
                                                               ^
one error found</screen><para id="para_in_the_nested_observer_trait">In the nested
      <literal moreinfo="none">Observer</literal> trait, <literal moreinfo="none">receiveUpdate</literal> is
      expecting an instance of type <literal moreinfo="none">S</literal>, but we are passing
      it <literal moreinfo="none">this</literal>, which is of type <literal moreinfo="none">Subject</literal>.
      In other words, we are passing an instance of a parent type of the type
      expected. One solution would be to change the signature to just expect
      the parent type, <literal moreinfo="none">Subject</literal>. That’s undesirable. We just
      mentioned that our concrete observers need the more specific type, the
      actual concrete type we’ll eventually define for <literal moreinfo="none">S</literal>,
      so they can call methods on it. For example, when observing UI <literal role="keep-together" moreinfo="none">CheckBoxes</literal>, the observers will want to
      read whether or not a box is checked. We don’t want to force the
      observers to use unsafe casts.</para><para id="para_a__self_type_annotation__ode">We looked at composition
      using <emphasis>self-type annotations</emphasis> in <xref linkend="SelfTypeAnnotations"/>. Let’s use this feature now to solve
      our current compilation problem. Here is the same code again with a
      self-type annotation:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/observer3.scala</code>

<code role="preproc">package</code> observer

<code role="statement">abstract</code> <code role="statement">class</code> <code role="special">SubjectObserver</code> {
  <code role="statement">type</code> <code role="special">S</code> &lt;:<code role="type"> Subject</code>
  <code role="statement">type</code> <code role="special">O</code> &lt;:<code role="type"> Observer</code>

  <code role="statement">trait</code> <code role="special">Subject</code> {
    self:<code role="type"> S</code> <code role="statement">=&gt;</code>    <code role="comment">// #1</code>
    <code role="statement">private</code> <code role="statement">var</code> observers = <code role="special">List</code><code role="special">[O]</code>()
    <code role="statement">def</code> <code role="identifier">addObserver</code>(observer:<code role="type"> O</code>) = observers ::= observer
    <code role="statement">def</code> <code role="identifier">notifyObservers</code> = observers foreach (<code role="statement">_</code>.receiveUpdate(self))  <code role="comment">// #2</code>
  }

  <code role="statement">trait</code> <code role="special">Observer</code> {
    <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(subject:<code role="type"> S</code>)
  }
}
</programlisting><para id="para_comment_1_shows_the_self_type">Comment #1 shows the
      self-type annotation, <literal moreinfo="none">self: S =&gt;</literal>. We can now use
      <literal moreinfo="none">self</literal> as an alias for <literal moreinfo="none">this</literal>, but
      whenever it appears, the type will be assumed to be
      <literal moreinfo="none">S</literal>, not <literal moreinfo="none">Subject</literal>. It is as if we’re
      telling <literal moreinfo="none">Subject</literal> to impersonate another type, but in a
      type-safe way, as we’ll see.<indexterm significance="normal"><primary>this keyword</primary><secondary>self versus, in self-type annotations</secondary></indexterm></para><para id="para_actually_we_could_have_used_">Actually, we could have
      used <literal moreinfo="none">this</literal> instead of <literal moreinfo="none">self</literal> in the
      annotation, but <literal moreinfo="none">self</literal> is somewhat conventional. A
      different name also reminds us that we’re working with a different
      type.</para><para id="para_when_an_actual_concrete_subje">Are self-type annotations
      a safe thing to use? When an actual concrete <literal role="keep-together" moreinfo="none">SubjectOb⁠server</literal> is defined,
      <literal moreinfo="none">S</literal> and <literal moreinfo="none">O</literal> will be specified and type
      checking will be performed to ensure that the concrete
      <literal moreinfo="none">S</literal> and <literal moreinfo="none">O</literal> are compatible with
      <literal moreinfo="none">Subject</literal> and <literal moreinfo="none">Observer</literal>. In this
      case, because we also defined <literal moreinfo="none">S</literal> to be a subtype of
      <literal moreinfo="none">Subject</literal> and <literal moreinfo="none">O</literal> to be a subtype of
      <literal moreinfo="none">Observer</literal>, any concrete types derived from
      <literal moreinfo="none">Subject</literal> and <literal moreinfo="none">Observer</literal>,
      respectively, will work.</para><para id="para_comment_2_shows_that_we_now_p">Comment #2 shows that we
      pass <literal moreinfo="none">self</literal> instead of <literal moreinfo="none">this</literal> to
      <literal moreinfo="none">receiveUpdate</literal>.</para><para id="para_to_be_continued_">Now that we have a generic
      implementation of the pattern, let’s specialize it for observing button
      clicks:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/button-observer3.scala</code>

<code role="preproc">package</code> ui
<code role="preproc">import</code> observer._

<code role="statement">object</code> <code role="special">ButtonSubjectObserver</code> <code role="statement">extends</code> <code role="special">SubjectObserver</code> {
  <code role="statement">type</code> <code role="special">S</code> = <code role="special">ObservableButton</code>
  <code role="statement">type</code> <code role="special">O</code> = <code role="special">ButtonObserver</code>

  <code role="statement">class</code> <code role="special">ObservableButton</code>(name:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Button</code>(name) <code role="statement">with</code> <code role="special">Subject</code> {
    <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
      <code role="statement">super</code>.click()
      notifyObservers
    }
  }

  <code role="statement">trait</code> <code role="special">ButtonObserver</code> <code role="statement">extends</code> <code role="special">Observer</code> {
    <code role="statement">def</code> <code role="identifier">receiveUpdate</code>(button:<code role="type"> ObservableButton</code>)
  }
}
</programlisting><para id="para_we_declare_an_object_buttonsubjectobserver">We declare an
      object <literal moreinfo="none">ButtonSubjectObserver</literal> where we define
      <literal moreinfo="none">S</literal> and <literal moreinfo="none">O</literal> to be
      <literal moreinfo="none">ObservableButton</literal> and
      <literal moreinfo="none">ButtonObserver</literal>, respectively, both of which are
      defined in the object. We use an <literal moreinfo="none">object</literal> now so that
      we can refer to the nested types easily, as we’ll see shortly.</para><para id="para_observablebutton_is_a_concrete_class"><literal moreinfo="none">ObservableButton</literal>
      is a concrete class that overrides <literal moreinfo="none">click</literal> to notify
      observers, similar to our previous implementations in <xref linkend="Traits"/>. However, <literal moreinfo="none">ButtonObserver</literal> is still
      an abstract trait, because <literal moreinfo="none">receiveUpdate</literal> is not
      defined. Notice that the argument to <literal role="keep-together" moreinfo="none">receiveUpdate</literal> is now an
      <literal moreinfo="none">ObservableButton</literal>, the value assigned to
      <literal moreinfo="none">S</literal>.</para><para id="para_the_final_piece_of_the_puzzle_">The final piece of the
      puzzle is to define a concrete observer. As before, we’ll count button
      clicks. However, to emphasize the value of having the specific type of
      instance passed to the observer, a <literal moreinfo="none">Button</literal> in this
      case, we’ll enhance the observer to track clicks for multiple buttons
      using a hash map with the button labels as the keys. No type casts are
      required!</para><screen format="linespecific">// code-examples/AppDesign/abstractions/button-click-observer3.scala

package ui
import observer._

class ButtonClickObserver extends ButtonSubjectObserver.ButtonObserver {
  val clicks = new scala.collection.mutable.HashMap[String,Int]()

  def receiveUpdate(button: ButtonSubjectObserver.ObservableButton) = {
    val count = clicks.getOrElse(button.label, 0) + 1
    clicks.update(button.label, count)
  }
}</screen><para id="para_every_time_buttonclickobserve">Every time
      <literal moreinfo="none">ButtonClickObserver.receiveUpdate</literal> is called, it
      fetches the current count for the button, if any, and updates the map
      with an incremented count. Note that it is now impossible to call
      <literal moreinfo="none">receiveUpdate</literal> with a normal
      <literal moreinfo="none">Button</literal>. We have to use an <literal role="keep-together" moreinfo="none">ObservableButton</literal>. This restriction
      eliminates bugs where we don’t get the notifications we expected. We
      also have access to any “enhanced” features that
      <literal moreinfo="none">ObservableButton</literal> may have.</para><para id="para_finally_here_is_a_specificati">Finally, here is a
      specification that exercises the code:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/button-observer3-spec.scala</code>

<code role="preproc">package</code> ui
<code role="preproc">import</code> org.specs._
<code role="preproc">import</code> observer._

<code role="statement">object</code> <code role="special">ButtonObserver3Spec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"An Observer counting button clicks"</code> should {
    <code role="constant">"see all clicks"</code> in {
      <code role="statement">val</code> button1 = <code role="statement">new</code> ButtonSubjectObserver.<code role="special">ObservableButton</code>(<code role="constant">"button1"</code>)
      <code role="statement">val</code> button2 = <code role="statement">new</code> ButtonSubjectObserver.<code role="special">ObservableButton</code>(<code role="constant">"button2"</code>)
      <code role="statement">val</code> button3 = <code role="statement">new</code> ButtonSubjectObserver.<code role="special">ObservableButton</code>(<code role="constant">"button3"</code>)
      <code role="statement">val</code> buttonObserver = <code role="statement">new</code> <code role="special">ButtonClickObserver</code>
      button1.addObserver(buttonObserver)
      button2.addObserver(buttonObserver)
      button3.addObserver(buttonObserver)
      clickButton(button1, <code role="constant">1</code>)
      clickButton(button2, <code role="constant">2</code>)
      clickButton(button3, <code role="constant">3</code>)
      buttonObserver.clicks(<code role="constant">"button1"</code>) mustEqual <code role="constant">1</code>
      buttonObserver.clicks(<code role="constant">"button2"</code>) mustEqual <code role="constant">2</code>
      buttonObserver.clicks(<code role="constant">"button3"</code>) mustEqual <code role="constant">3</code>
    }
  }

  <code role="statement">def</code> <code role="identifier">clickButton</code>(button:<code role="type"> Button</code>, nClicks:<code role="type"> Int</code>) =
    <code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to nClicks)
      button.click()
}
</programlisting><para id="para_we_create_three_buttons_and_on">We create three buttons
      and one observer for all of them. We then click the buttons different
      numbers of times. Finally, we confirm that the clicks were properly
      counted for each button.</para><para id="para_abstract_types_and_self_types_conclusion_">We see again
      how abstract types combined with self-type annotations provide a
      reusable abstraction that is easy to extend in a type-safe way for
      particular needs. Even though we defined a general protocol for
      observing an “event” after it happened, we were able to define subtypes
      specific to <literal moreinfo="none">Buttons</literal> without resorting to unsafe casts
      from <literal moreinfo="none">Subject</literal> abstractions.</para><para id="para_modular_scala_compiler">The Scala compiler itself is
      implemented using these mechanisms (see <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>) to make it modular in
      useful ways. For example, it is relatively straightforward to implement
      compiler plugins.</para><para id="para_revisit_in_di">We’ll revisit these idioms in <xref linkend="DependencyInjectionInScala"/>.<indexterm class="endofrange" startref="ch13_components" significance="normal"/></para></sect2></sect1><sect1 id="EffectiveTraitsDesign"><title>Effective Design of Traits</title><para id="para_one_of_the_reasons_that_java_d">One of the reasons that
    many languages (like Java) do not implement multiple inheritance is
    because of the problems observed with multiple inheritance in C++. One of
    those problems is the so-called <emphasis>diamond of death</emphasis>,
    which is illustrated in <xref linkend="diamond-of-death"/>.<indexterm significance="normal"><primary>C++</primary><secondary>multiple inheritance</secondary></indexterm><indexterm significance="normal"><primary>inheritance</primary><secondary>multiple, problems with</secondary></indexterm><indexterm significance="normal"><primary>diamond of death (problem with multiple
        inheritance)</primary></indexterm><indexterm class="startofrange" id="ch13_appdesigntraits" significance="normal"><primary>application design</primary><secondary>effective trait design</secondary></indexterm><indexterm class="startofrange" id="ch13_traitseffective" significance="normal"><primary>traits</primary><secondary>effective design of</secondary></indexterm></para><figure float="none" id="diamond-of-death"><title>Diamond of death in languages with multiple inheritance</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1301.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1301.png" format="PNG"/></imageobject></mediaobject></figure><para id="para_in_c_each_constructor_for_">In C++, each constructor for
    <literal moreinfo="none">C</literal> will invoke a constructor for <literal moreinfo="none">B1</literal>
    and a constructor for <literal moreinfo="none">B2</literal> (explicitly or implicitly).
    Each constructor for <literal moreinfo="none">B1</literal> and <literal moreinfo="none">B2</literal> will
    invoke a constructor for <literal moreinfo="none">A</literal>. Hence, in a
    <emphasis>naïve</emphasis> implementation of multiple inheritance, the
    fields of <literal moreinfo="none">A</literal>, <literal moreinfo="none">a1</literal> and
    <literal moreinfo="none">a2</literal>, could be initialized <emphasis>twice</emphasis> and
    possibly initialized in an inconsistent way or there might be two
    different <literal moreinfo="none">A</literal> “pieces” in the <literal moreinfo="none">C</literal>
    instance, one for <literal moreinfo="none">B1</literal> and one for <literal moreinfo="none">B2</literal>!
    C++ has mechanisms to clarify what should happen, but it’s up to the
    developer to understand the details and to do the correct thing.</para><para id="para_scala_s_single_inheritance_wit">Scala’s single inheritance
    and support for traits avoid these problems, while providing the most
    important benefit of multiple inheritance: <emphasis>mixin</emphasis>
    composition. The order of construction is unambiguous (see <xref linkend="Linearization"/>). Traits can’t have constructor argument lists,
    but Scala ensures that their fields are properly initialized when
    instances are created, as we saw in <xref linkend="ConstructingTraits"/>
    and <xref linkend="OverridingFieldsInTraits"/>. We saw another example of
    initializing <literal moreinfo="none">vals</literal> in a trait in <xref linkend="FineGrainedVisibilityRules"/>. There we defined concrete classes
    that overrode the definitions of the two abstract fields in the
    <literal moreinfo="none">EncodedString</literal> trait.<indexterm significance="normal"><primary>inheritance</primary><secondary>single inheritance plus traits in Scala</secondary></indexterm><indexterm significance="normal"><primary>mixin composition</primary></indexterm></para><para id="para_however_since_a_trait_can_con">So, Scala handles many
    potential issues that arise when mixing the contributions of different
    traits into the set of possible states of an instance. Still, it’s
    important to consider how the contributions of different traits interact
    with each other.</para><para id="para_when_considering_the_state_of_">When considering the state
    of an instance, it is useful to consider the instance as possessing a
    <emphasis>state machine</emphasis>, where <emphasis>events</emphasis>
    (e.g., method calls and field writes) cause transitions from one state to
    another. The set of all possible states form a <emphasis>space</emphasis>.
    You can think of each <emphasis>field</emphasis> as contributing one
    <emphasis>dimension</emphasis> to this space.</para><para id="para_for_example_recall_our_vetoa">For example, recall our
    <literal moreinfo="none">VetoableClicks</literal> trait in <xref linkend="StackableTraits"/>, where button clicks were counted and
    additional clicks were vetoed after a certain number of clicks occurred.
    Our simple <literal moreinfo="none">Button</literal> class contributed only a
    <literal moreinfo="none">label</literal> dimension, while
    <literal moreinfo="none">VetoableClicks</literal> contributed a <literal moreinfo="none">count</literal>
    dimension and a <literal moreinfo="none">maxAllowed</literal> constant. Here is a recap of
    these types, collected together into a single script that also exercises
    the code:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/vetoable-clicks1-script.scala</code>

<code role="statement">trait</code> <code role="special">Clickable</code> {
  <code role="statement">def</code> <code role="identifier">click</code>()
}

<code role="statement">class</code> <code role="special">Widget</code>
<code role="statement">class</code> <code role="special">Button</code>(<code role="statement">val</code> label:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Widget</code> <code role="statement">with</code> <code role="special">Clickable</code> {
  <code role="statement">def</code> <code role="identifier">click</code>() = println(<code role="constant">"click!"</code>)
}

<code role="statement">trait</code> <code role="special">VetoableClicks</code> <code role="statement">extends</code> <code role="special">Clickable</code> {
  <code role="statement">val</code> maxAllowed = <code role="constant">1</code>
  <code role="statement">private</code> <code role="statement">var</code> count = <code role="constant">0</code>
  <code role="statement">abstract</code> <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="statement">if</code> (count &lt; maxAllowed) {
      count += <code role="constant">1</code>
      <code role="statement">super</code>.click()
    }
  }
}

<code role="statement">val</code> button1 = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"click me!"</code>)
println(<code role="constant">"new Button(...)"</code>)
<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code> ) button1.click()

<code role="statement">val</code> button2 = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"click me!"</code>) <code role="statement">with</code> <code role="special">VetoableClicks</code>
println(<code role="constant">"new Button(...) with VetoableClicks"</code>)
<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code> ) button2.click()
</programlisting><para id="ui2-vetoable-clicks-recap-output">This script prints the
    following output:</para><screen format="linespecific">new Button(...)
click!
click!
click!
new Button(...) with VetoableClicks
click!</screen><para id="para_maxallowed_is_a_constant">Note that
    <literal moreinfo="none">maxAllowed</literal> is a constant, but it can be overridden when
    instantiating each instance. So, two instances could differ only by the
    value of <literal moreinfo="none">maxAllowed</literal>. Therefore,
    <literal moreinfo="none">maxAllowed</literal> also contributes a dimension to the state,
    but with only one value per <phrase role="keep-together">instance</phrase>!</para><para id="para_so_for_a_button_labeled_sub">So, for a button labeled
    “Submit,” with <literal moreinfo="none">maxAllowed</literal> set to 3, and which has been
    clicked twice (so <literal moreinfo="none">count</literal> equals 2), its state can be
    represented by the tuple <literal moreinfo="none">("Submit", 2, 3)</literal>.</para><para id="para_in_general_a_single_trait_can">In general, a single trait
    can either be stateless, i.e., it contributes no new dimensions of state
    to the instance, or it can contribute <emphasis>orthogonal</emphasis>
    state dimensions to the instance, i.e., dimensions that are independent of
    the state contributions from other traits and the parent class. In the
    script, <literal moreinfo="none">Clickable</literal> is trivially stateless (ignoring the
    button’s label), while <literal moreinfo="none">VetoableClicks</literal> contributes
    <literal moreinfo="none">maxAllowed</literal> and <literal moreinfo="none">count</literal>. Traits with
    orthogonal state often have orthogonal methods, too. For example, the
    Observer Pattern traits we used in <xref linkend="Traits"/> contained
    methods for managing their lists of observers.</para><para id="para_independent_of_these_two_possi">Independent of whether a
    trait contributes state dimensions, a trait can also modify the possible
    values for a dimension contributed by a different trait or the parent
    class. To see an example, let’s refactor the script to move the click
    <literal moreinfo="none">count</literal> to the <literal role="keep-together" moreinfo="none">Clickable</literal> trait:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/abstractions/vetoable-clicks2-script.scala</code>

<code role="statement">trait</code> <code role="special">Clickable</code> {
  <code role="statement">private</code> <code role="statement">var</code> clicks = <code role="constant">0</code>
  <code role="statement">def</code> <code role="identifier">count</code> = clicks

  <code role="statement">def</code> <code role="identifier">click</code>() = { clicks += <code role="constant">1</code> }
}

<code role="statement">class</code> <code role="special">Widget</code>
<code role="statement">class</code> <code role="special">Button</code>(<code role="statement">val</code> label:<code role="type"> String</code>) <code role="statement">extends</code> <code role="special">Widget</code> <code role="statement">with</code> <code role="special">Clickable</code> {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="statement">super</code>.click()
    println(<code role="constant">"click!"</code>)
  }
}

<code role="statement">trait</code> <code role="special">VetoableClicks</code> <code role="statement">extends</code> <code role="special">Clickable</code> {
  <code role="statement">val</code> maxAllowed = <code role="constant">1</code>
  <code role="statement">abstract</code> <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">click</code>() = {
    <code role="statement">if</code> (count &lt; maxAllowed)
      <code role="statement">super</code>.click()
  }
}

<code role="statement">val</code> button1 = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"click me!"</code>)
println(<code role="constant">"new Button(...)"</code>)
<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code> ) button1.click()

<code role="statement">val</code> button2 = <code role="statement">new</code> <code role="special">Button</code>(<code role="constant">"click me!"</code>) <code role="statement">with</code> <code role="special">VetoableClicks</code>
println(<code role="constant">"new Button(...) with VetoableClicks"</code>)
<code role="statement">for</code> (i <code role="statement">&lt;-</code> <code role="constant">1</code> to <code role="constant">3</code> ) button2.click()
</programlisting><para id="para_now_clickable_contributes_th">This script prints the same
    output as before. Now <literal moreinfo="none">Clickable</literal> contributes one state
    dimension for <literal moreinfo="none">count</literal> (which is now a method that returns
    the value of the private <literal moreinfo="none">clicks</literal> field).
    <literal moreinfo="none">VetoableClicks</literal> <emphasis>modifies</emphasis> this
    dimension by reducing the number of possible values for
    <literal moreinfo="none">count</literal> from <literal moreinfo="none">0</literal> to infinity down to
    just <literal moreinfo="none">0</literal> and <literal moreinfo="none">1</literal>. Therefore, one trait
    affects the <emphasis>behavior</emphasis> of another. We might say that
    <literal moreinfo="none">VetoableClicks</literal> is <emphasis>invasive</emphasis>,
    because it changes the behavior of other mixins.<indexterm significance="normal"><primary>mixins</primary><secondary>invasive</secondary></indexterm></para><para id="para_why_is_all_this_important_whi">Why is all this important?
    While the problems of multiple-inheritance are eliminated in Scala’s model
    of single inheritance plus traits, care is required when mixing state and
    behavior contributions to create well-behaved applications. For example,
    if you have a test suite that <literal moreinfo="none">Button</literal> passes, will a
    <literal moreinfo="none">Button with VetoableClicks</literal> instance pass the same test
    suite? The suite won’t pass if it assumes that you can click a button as
    many times as you want. There are different “specifications” for these two
    kinds of buttons. This difference is expressed by the <emphasis>Liskov
    Substitution Principle</emphasis> (see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>). An instance of a
    <literal moreinfo="none">Button with VetoableClicks</literal> won’t be
    <emphasis>substitutable</emphasis> in every situation where a regular
    <literal moreinfo="none">Button</literal> instance is used. This is a consequence of the
    invasive nature of <literal role="keep-together" moreinfo="none">VetoableClicks</literal>.</para><para id="para_similarly_orthogonal_state_an">When a trait adds only
    orthogonal state and behavior, without affecting the rest of the state and
    behavior of the instance, it makes reuse and composition much easier, as
    well as reducing the potential for bugs. The Observer Pattern
    implementations we have seen are quite reusable. The only requirement for
    reuse is to provide some “glue” to adapt the generic subject and observer
    traits to particular circumstances.</para><para id="para_this_does_not_mean_that__invas">This does not mean that
    invasive mixins are bad, just that they should be used wisely. The
    “vetoable events” pattern can be very useful.<indexterm class="endofrange" startref="ch13_appdesigntraits" significance="normal"/><indexterm class="endofrange" startref="ch13_traitseffective" significance="normal"/></para></sect1><sect1 id="DesignPatterns"><title>Design Patterns</title><para id="para_design_patterns_have_taken_a_b">Design patterns have taken
    a beating lately. Critics dismiss them as workarounds for missing language
    features. Indeed, some of the <emphasis>Gang of Four</emphasis> patterns
    (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>)
    are not really needed in Scala, as native features provide better
    substitutes. Other patterns are part of the language itself, so no special
    coding is needed. Of course, patterns are frequently misused, but that’s
    not the fault of the patterns themselves.<indexterm significance="normal"><primary>Gang of Four (GOF) patterns</primary></indexterm><indexterm class="startofrange" id="ch13_designpatterns" significance="normal"><primary>design patterns</primary></indexterm><indexterm class="startofrange" id="ch13_appsdesignpatterns" significance="normal"><primary>application design</primary><secondary>design patterns</secondary></indexterm></para><para id="para_we_think_the_criticisms_often_">We think the criticisms
    often overlook an important point: the distinction between an idea and how
    it is implemented and used in a particular situation. Design patterns
    document recurring, widely useful ideas. These ideas are part of the
    <emphasis>vocabulary</emphasis> that software developers use to describe
    their designs.<indexterm significance="normal"><primary>singleton objects</primary><secondary>eliminating need for Singleton Pattern</secondary></indexterm></para><para id="para_pattern_ideas_language_features">Some common patterns are
    native language features in Scala, like <emphasis>singleton</emphasis>
    objects that eliminate the need for a <emphasis>Singleton
    Pattern</emphasis> (<link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>) implementation like you often
    use in Java code.</para><para id="para_pattern_ideas_language_features2">The <emphasis>Iterator
    Pattern</emphasis> (<link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>) is so pervasive in programming
    that most languages include iteration mechanisms for any type that can be
    treated like a collection. For example, in Scala you can iterate through
    the characters in a <literal moreinfo="none">String</literal> with
    <literal moreinfo="none">foreach</literal>:<indexterm significance="normal"><primary>Iterator Pattern</primary></indexterm></para><screen format="linespecific">"Programming Scala" foreach {c =&gt; println(c)}</screen><para id="para_pattern_ideas_language_features_string_foreach">Actually,
    in this case, an implicit conversion is invoked to convert the
    <literal moreinfo="none">java.lang.String</literal> to a <literal moreinfo="none">RichString</literal>,
    which has the <literal moreinfo="none">foreach</literal> method. That’s an example of the
    pattern called <emphasis>Pimp My Library</emphasis>, which we saw in <xref linkend="ImplicitConversions"/>.</para><para id="para_pattern_ideas_language_better_alternatives">Other common
    patterns have better alternatives in Scala. We’ll discuss a better
    alternative to the <emphasis>Visitor Pattern</emphasis> (<link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>) in a
    moment.</para><para id="para_other_patterns_useful">Finally, still other patterns can be
    implemented in Scala and remain very useful. For example, the
    <emphasis>Observer Pattern</emphasis> that we discussed earlier in this
    chapter and in <xref linkend="Traits"/> is a very useful pattern for many
    design problems. It can be implemented very elegantly using mixin
    composition.<indexterm significance="normal"><primary>Observer Pattern</primary></indexterm></para><para id="para_wont_discuss_all_patterns">We won’t discuss all the well
    known patterns, such as those in <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>. A number of the GOF patterns
    are discussed at <link linkend="ScalaWikiPatterns" xrefstyle="select:nopage">[ScalaWiki:Patterns]</link>, along with other
    patterns that are somewhat specific to Scala. Instead, we’ll discuss a few
    illustrative examples. We’ll start by discussing a replacement for the
    <emphasis>Visitor Pattern</emphasis> that uses functional <phrase role="keep-together">idioms</phrase> and implicit conversions. Then we’ll
    discuss a powerful way of implementing <emphasis>dependency
    injection</emphasis> in Scala using the <emphasis>Cake
    Pattern</emphasis>.</para><sect2 id="VisitorAlternativeInScala"><title>The Visitor Pattern: A Better Alternative</title><para id="para_visitor_pattern_description">The Visitor Pattern solves
      the problem of adding a new operation to a class hierarchy without
      editing the source code for the classes in the hierarchy. For a number
      of practical reasons, it may not be feasible or desirable to edit the
      hierarchy to support the new operation.<indexterm class="startofrange" id="ch13_VisitorPattern" significance="normal"><primary>Visitor Pattern, alternative to</primary></indexterm><indexterm class="startofrange" id="ch13_designpatternVisitor" significance="normal"><primary>design patterns</primary><secondary>alternative to Visitor Pattern</secondary></indexterm></para><para id="para_let_s_look_at_an_example_of_th">Let’s look at an example
      of the pattern using the <literal moreinfo="none">Shape</literal> class hierarchy we
      have used previously. We’ll start with the case class version from <xref linkend="CaseClasses"/>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AdvOOP/shapes/shapes-case.scala</code>

<code role="preproc">package</code> shapes {
  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Point</code>(x:<code role="type"> Double</code>, y:<code role="type"> Double</code>)

  <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>():<code role="type"> Unit</code>
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Circle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Rectangle</code>(lowerLeft:<code role="type"> Point</code>, height:<code role="type"> Double</code>, width:<code role="type"> Double</code>)
      <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Rectangle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Triangle</code>(point1:<code role="type"> Point</code>, point2:<code role="type"> Point</code>, point3:<code role="type"> Point</code>)
      <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">draw</code>() = println(<code role="constant">"Triangle.draw: "</code> + <code role="statement">this</code>)
  }
}
</programlisting><para id="para_suppose_we_don_t_want_the_dra">Suppose we don’t want the
      <literal moreinfo="none">draw</literal> method in the classes. This is a reasonable
      design choice, since the drawing method will be highly dependent on the
      particular context of use, such as details of the graphics libraries on
      the platforms the application will run on. For greater reusability, we
      would like drawing to be an operation we decouple from the shapes
      themselves.</para><para id="para_first_we_refactor_the_shape_">First, we refactor the
      <literal moreinfo="none">Shape</literal> hierarchy to support the Visitor Pattern,
      following the example in <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-visitor.scala</code>

<code role="preproc">package</code> shapes {
  <code role="statement">trait</code> <code role="special">ShapeVisitor</code> {
    <code role="statement">def</code> <code role="identifier">visit</code>(circle:<code role="type"> Circle</code>):<code role="type"> Unit</code>
    <code role="statement">def</code> <code role="identifier">visit</code>(rect:<code role="type"> Rectangle</code>):<code role="type"> Unit</code>
    <code role="statement">def</code> <code role="identifier">visit</code>(tri:<code role="type"> Triangle</code>):<code role="type"> Unit</code>
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Point</code>(x:<code role="type"> Double</code>, y:<code role="type"> Double</code>)

  <code role="statement">sealed</code> <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">accept</code>(visitor:<code role="type"> ShapeVisitor</code>):<code role="type"> Unit</code>
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">accept</code>(visitor:<code role="type"> ShapeVisitor</code>) = visitor.visit(<code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Rectangle</code>(lowerLeft:<code role="type"> Point</code>, height:<code role="type"> Double</code>, width:<code role="type"> Double</code>)
        <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">accept</code>(visitor:<code role="type"> ShapeVisitor</code>) = visitor.visit(<code role="statement">this</code>)
  }

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Triangle</code>(point1:<code role="type"> Point</code>, point2:<code role="type"> Point</code>, point3:<code role="type"> Point</code>)
        <code role="statement">extends</code> <code role="special">Shape</code>() {
    <code role="statement">def</code> <code role="identifier">accept</code>(visitor:<code role="type"> ShapeVisitor</code>) = visitor.visit(<code role="statement">this</code>)
  }
}
</programlisting><para id="para_first_we_define_a_shapevisit">We define a
      <literal moreinfo="none">ShapeVisitor</literal> trait, which has one method for each
      concrete class in the hierarchy, e.g., <literal moreinfo="none">visit(circle:
      Circle)</literal>. Each such method takes one parameter of the
      corresponding type to visit. Concrete derived classes will implement
      each method to do the appropriate operation for the particular type
      passed in.</para><para id="para_the_visitor_pattern_requires_a">The Visitor Pattern
      requires a one-time modification to the class hierarchy. An overridden
      method named <literal moreinfo="none">accept</literal> must be added, which takes a
      <literal moreinfo="none">Visitor</literal> parameter. This method must be overridden for
      each class. It calls the corresponding method defined on the
      <literal moreinfo="none">visitor</literal> instance, passing <literal moreinfo="none">this</literal> as
      the argument.</para><para id="para_finally_note_that_we_declared">Finally, note that we
      declared <literal moreinfo="none">Shape</literal> to be <literal moreinfo="none">sealed</literal>. It
      won’t help us prevent some bugs in the Visitor Pattern implementation,
      but it will prove useful shortly.</para><para id="para_here_is_a_concrete_visitor_tha">Here is a concrete
      visitor that supports our original <literal moreinfo="none">draw</literal>
      operation:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-drawing-visitor.scala</code>

<code role="preproc">package</code> shapes {
  <code role="statement">class</code> <code role="special">ShapeDrawingVisitor</code> <code role="statement">extends</code> <code role="special">ShapeVisitor</code> {
    <code role="statement">def</code> <code role="identifier">visit</code>(circle:<code role="type"> Circle</code>):<code role="type"> Unit</code> =
      println(<code role="constant">"Circle.draw: "</code> + circle)

    <code role="statement">def</code> <code role="identifier">visit</code>(rect:<code role="type"> Rectangle</code>):<code role="type"> Unit</code> =
      println(<code role="constant">"Rectangle.draw: "</code> + rect)

    <code role="statement">def</code> <code role="identifier">visit</code>(tri:<code role="type"> Triangle</code>):<code role="type"> Unit</code> =
      println(<code role="constant">"Triangle.draw: "</code> + tri)
  }
}
</programlisting><para id="para_for_each_visitx_method_it_">For each
      <literal moreinfo="none">visit</literal> method, it “draws” the <literal moreinfo="none">Shape</literal>
      instance appropriately. Finally, here is a script that exercises the
      code:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-drawing-visitor-script.scala</code>

<code role="preproc">import</code> shapes._

<code role="statement">val</code> p00 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p10 = <code role="special">Point</code>(<code role="constant">1.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p01 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">1.0</code>)

<code role="statement">val</code> list = <code role="special">List</code>(<code role="special">Circle</code>(p00, <code role="constant">5.0</code>),
                <code role="special">Rectangle</code>(p00, <code role="constant">2.0</code>, <code role="constant">3.0</code>),
                <code role="special">Triangle</code>(p00, p10, p01))

<code role="statement">val</code> shapesDrawer = <code role="statement">new</code> <code role="special">ShapeDrawingVisitor</code>
list foreach { <code role="statement">_</code>.accept(shapesDrawer) }
</programlisting><para id="shape-hier-draw-visitor-script-output">It produces the
      following output:</para><screen format="linespecific">Circle.draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</screen><para id="para_visitor_has_been_criticized_fo">Visitor has been
      criticized for being somewhat inelegant and for breaking the
      <emphasis>Open-Closed Principle</emphasis> (OCP; see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>),
      because if the hierarchy changes, you are forced to edit (and test and
      redeploy) <emphasis>all</emphasis> the visitors for that hierarchy. Note
      that every <literal moreinfo="none">ShapeVisitor</literal> trait has methods that
      hardcode information about every <literal moreinfo="none">Shape</literal> derived type.
      These kinds of changes are also error-prone.<indexterm significance="normal"><primary>Open-Closed Principle (OCP)</primary><secondary>violation by Visitor Pattern</secondary></indexterm></para><para id="para_visitor_pattern_alt_ruby_open_types">In languages with
      “open types,” like Ruby, an alternative to the Visitor Pattern is to
      create a new source file that reopens all the types in the hierarchy and
      inserts an appropriate method implementation in each one. No
      modifications to the original source code are required.</para><para id="para_scala_does_not_support_open_ty">Scala does not support
      open types, of course, but it offers a few alternatives. The first
      approach we’ll discuss combines pattern matching with implicit
      conversions. Let’s begin by refactoring the
      <literal moreinfo="none">ShapeVisitor</literal> code to remove the Visitor Pattern
      logic:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes.scala</code>

<code role="preproc">package</code> shapes2 {
  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Point</code>(x:<code role="type"> Double</code>, y:<code role="type"> Double</code>)

  <code role="statement">sealed</code> <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">Shape</code>()

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Circle</code>(center:<code role="type"> Point</code>, radius:<code role="type"> Double</code>) <code role="statement">extends</code> <code role="special">Shape</code>()

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Rectangle</code>(lowerLeft:<code role="type"> Point</code>, height:<code role="type"> Double</code>, width:<code role="type"> Double</code>)
      <code role="statement">extends</code> <code role="special">Shape</code>()

  <code role="statement">case</code> <code role="statement">class</code> <code role="special">Triangle</code>(point1:<code role="type"> Point</code>, point2:<code role="type"> Point</code>, point3:<code role="type"> Point</code>)
      <code role="statement">extends</code> <code role="special">Shape</code>()
}
</programlisting><para id="para_if_we_would_like_to_invoke_dr">If we would like to invoke
      <literal moreinfo="none">draw</literal> as a method on any <literal moreinfo="none">Shape</literal>,
      then we will have to use an implicit conversion to a wrapper class with
      the <literal moreinfo="none">draw</literal> method:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-drawing-implicit.scala</code>

<code role="preproc">package</code> shapes2 {
  <code role="statement">class</code> <code role="special">ShapeDrawer</code>(<code role="statement">val</code> shape:<code role="type"> Shape</code>) {
    <code role="statement">def</code> <code role="identifier">draw</code> = shape <code role="statement">match</code> {
      <code role="statement">case</code> c:<code role="type"> Circle    =&gt; println</code>(<code role="constant">"Circle.draw: "</code> + c)
      <code role="statement">case</code> r:<code role="type"> Rectangle =&gt; println</code>(<code role="constant">"Rectangle.draw: "</code> + r)
      <code role="statement">case</code> t:<code role="type"> Triangle  =&gt; println</code>(<code role="constant">"Triangle.draw: "</code> + t)
    }
  }

  <code role="statement">object</code> <code role="special">ShapeDrawer</code> {
    <code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">shape2ShapeDrawer</code>(shape:<code role="type"> Shape</code>) = <code role="statement">new</code> <code role="special">ShapeDrawer</code>(shape)
  }
}
</programlisting><para id="para_instances_of_shapedrawer_hol">Instances of
      <literal moreinfo="none">ShapeDrawer</literal> hold a <literal moreinfo="none">Shape</literal> object.
      When <literal moreinfo="none">draw</literal> is called, the shape is pattern matched
      based on its type to determine the appropriate way to draw it.</para><para id="para_a_companion_object_declares_an">A companion object
      declares an implicit conversion that wraps a <literal moreinfo="none">Shape</literal> in
      a <literal moreinfo="none">ShapeDrawer</literal>.</para><para id="para_implicit_script_exercises_code">This script exercises the
      code:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-drawing-implicit-script.scala</code>

<code role="preproc">import</code> shapes2._

<code role="statement">val</code> p00 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p10 = <code role="special">Point</code>(<code role="constant">1.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p01 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">1.0</code>)

<code role="statement">val</code> list = <code role="special">List</code>(<code role="special">Circle</code>(p00, <code role="constant">5.0</code>),
                <code role="special">Rectangle</code>(p00, <code role="constant">2.0</code>, <code role="constant">3.0</code>),
                <code role="special">Triangle</code>(p00, p10, p01))

<code role="preproc">import</code> shapes2.ShapeDrawer._

list foreach { <code role="statement">_</code>.draw }
</programlisting><para id="para_same_output_as_visitor">It produces the same output as
      the example using the Visitor Pattern.</para><para id="para_this_implementation_shares_a_l">This implementation of
      <literal moreinfo="none">ShapeDrawer</literal> has some similarities with the Visitor
      Pattern, but it is more concise, elegant, and requires no code
      modifications to the original <literal moreinfo="none">Shape</literal> hierarchy.</para><para id="para_the_implementation_of_shapedr">Technically, the
      implementation has the same OCP issue as the Visitor Pattern. Changing
      the <literal moreinfo="none">Shape</literal> hierarchy requires a change to the pattern
      matching expression. However, the required changes are isolated to one
      place and they are more succinct. In fact, all the logic for drawing is
      now contained in one place, rather than separated into
      <literal moreinfo="none">draw</literal> methods in each <literal moreinfo="none">Shape</literal> class
      and potentially scattered across different files. Note that because we
      <literal moreinfo="none">sealed</literal> the hierarchy, a compilation error in
      <literal moreinfo="none">draw</literal> will occur if we forget to change it when the
      hierarchy changes.</para><para id="para_if_we_don_t_like_the_pattern_m">If we don’t like the
      pattern matching in the draw method, we could implement a separate
      “drawer” class and a separate implicit conversion for each
      <literal moreinfo="none">Shape</literal> class. That would allow us to keep each shape
      drawing operation in a separate file, for modularity, with the drawback
      of more code and files to manage.</para><para id="para_if_on_the_other_hand_we_don_">If, on the other hand, we
      don’t care about using the object-oriented <literal moreinfo="none">shape.draw</literal>
      syntax, we could eliminate the implicit conversion and do the same
      pattern matching that is done in <literal moreinfo="none">ShapeDrawer.draw</literal>.
      This approach could be simpler, especially when the extra behavior can
      be isolated to one place. Indeed, this approach would be a conventional
      functional approach, as illustrated in the following script:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-drawing-pattern-script.scala</code>

<code role="preproc">import</code> shapes2._

<code role="statement">val</code> p00 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p10 = <code role="special">Point</code>(<code role="constant">1.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p01 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">1.0</code>)

<code role="statement">val</code> list = <code role="special">List</code>(<code role="special">Circle</code>(p00, <code role="constant">5.0</code>),
                <code role="special">Rectangle</code>(p00, <code role="constant">2.0</code>, <code role="constant">3.0</code>),
                <code role="special">Triangle</code>(p00, p10, p01))

<code role="statement">val</code> drawText = (shape:<code role="type">Shape</code>) <code role="statement">=&gt;</code> shape <code role="statement">match</code> {
  <code role="statement">case</code> circle:<code role="type"> Circle =&gt;  println</code>(<code role="constant">"Circle.draw: "</code> + circle)
  <code role="statement">case</code> rect:<code role="type"> Rectangle =&gt; println</code>(<code role="constant">"Rectangle.draw: "</code> + rect)
  <code role="statement">case</code> tri:<code role="type"> Triangle =&gt;   println</code>(<code role="constant">"Triangle.draw: "</code> + tri)
}

<code role="statement">def</code> <code role="identifier">pointToXML</code>(point:<code role="type"> Point</code>) =
  <code role="constant">"&lt;point&gt;&lt;x&gt;%.1f&lt;/x&gt;&lt;y&gt;%.1f&lt;/y&gt;&lt;/point&gt;"</code>.format(point.x, point.y)

<code role="statement">val</code> drawXML = (shape:<code role="type">Shape</code>) <code role="statement">=&gt;</code> shape <code role="statement">match</code> {
  <code role="statement">case</code> circle:<code role="type"> Circle</code> <code role="statement">=&gt;</code>  {
    println(<code role="constant">"&lt;circle&gt;"</code>)
    println(<code role="constant">"  &lt;center&gt;"</code> + pointToXML(circle.center) + <code role="constant">"&lt;/center&gt;"</code>)
    println(<code role="constant">"  &lt;radius&gt;"</code> + circle.radius + <code role="constant">"&lt;/radius&gt;"</code>)
    println(<code role="constant">"&lt;/circle&gt;"</code>)
  }
  <code role="statement">case</code> rect:<code role="type"> Rectangle</code> <code role="statement">=&gt;</code> {
    println(<code role="constant">"&lt;rectangle&gt;"</code>)
    println(<code role="constant">"  &lt;lower-left&gt;"</code> + pointToXML(rect.lowerLeft) + <code role="constant">"&lt;/lower-left&gt;"</code>)
    println(<code role="constant">"  &lt;height&gt;"</code> + rect.height + <code role="constant">"&lt;/height&gt;"</code>)
    println(<code role="constant">"  &lt;width&gt;"</code> + rect.width + <code role="constant">"&lt;/width&gt;"</code>)
    println(<code role="constant">"&lt;/rectangle&gt;"</code>)
  }
  <code role="statement">case</code> tri:<code role="type"> Triangle</code> <code role="statement">=&gt;</code> {
    println(<code role="constant">"&lt;triangle&gt;"</code>)
    println(<code role="constant">"  &lt;point1&gt;"</code> + pointToXML(tri.point1) + <code role="constant">"&lt;/point1&gt;"</code>)
    println(<code role="constant">"  &lt;point2&gt;"</code> + pointToXML(tri.point2) + <code role="constant">"&lt;/point2&gt;"</code>)
    println(<code role="constant">"  &lt;point3&gt;"</code> + pointToXML(tri.point3) + <code role="constant">"&lt;/point3&gt;"</code>)
    println(<code role="constant">"&lt;/triangle&gt;"</code>)
  }
}

list foreach (drawText)
println(<code role="constant">""</code>)
list foreach (drawXML)
</programlisting><para id="para_we_define_to__function_values_">We define two
      <emphasis>function values</emphasis> and assign them to variables,
      <literal moreinfo="none">drawText</literal> and <literal moreinfo="none">drawXML</literal>,
      respectively. Each <literal moreinfo="none">drawX</literal> function takes an input
      <literal moreinfo="none">Shape</literal>, pattern matches it to the correct type, and
      “draws” it appropriately. We also define a helper method to convert a
      <literal moreinfo="none">Point</literal> to XML in the format we want.</para><para id="para_finally_we_loop_through_the_l">Finally, we loop through
      the list of shapes twice. The first time, we pass
      <literal moreinfo="none">drawText</literal> as the argument to
      <literal moreinfo="none">foreach</literal>. The second time, we pass
      <literal moreinfo="none">drawXML</literal>. Running this script reproduces the previous
      results for “text” output, followed by new XML output:</para><screen format="linespecific">Circle.draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

&lt;circle&gt;
  &lt;center&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/center&gt;
  &lt;radius&gt;5.0&lt;/radius&gt;
&lt;/circle&gt;
&lt;rectangle&gt;
  &lt;lower-left&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/lower-left&gt;
  &lt;height&gt;2.0&lt;/height&gt;
  &lt;width&gt;3.0&lt;/width&gt;
&lt;/rectangle&gt;
&lt;triangle&gt;
  &lt;point1&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point1&gt;
  &lt;point2&gt;&lt;point&gt;&lt;x&gt;1.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point2&gt;
  &lt;point3&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;1.0&lt;/y&gt;&lt;/point&gt;&lt;/point3&gt;
&lt;/triangle&gt;</screen><para id="para_this_is_a_powerful_way_to_add_">Any of these idioms
      provides a powerful way to add additional, special-purpose functionality
      that may not be needed “everywhere” in the application. It’s a great way
      to remove methods from objects that don’t <emphasis>absolutely have to
      be there</emphasis>.</para><para id="para_a_drawing_application_should_o">A drawing application
      should only need to know how to do input and output of shapes in one
      place, whether it is serializing shapes to a textual format for storage
      or rendering shapes to the screen. We can separate the drawing “concern”
      from the rest of the <phrase role="keep-together">functionality</phrase>
      for shapes, and we can isolate the logic for drawing, all without
      modifying the <literal moreinfo="none">Shape</literal> hierarchy or any of the places
      where it is used in the application. The Visitor Pattern gives us some
      of this separation and isolation, but we are required to add visitor
      implementation logic to each <literal moreinfo="none">Shape</literal>.</para><para id="para_let_s_conclude_with_a_discussi">Let’s conclude with a
      discussion of one other option that may be applicable in some contexts.
      If you have complete control over how shapes are constructed, e.g.,
      through a single factory, you can modify the factory to mix in traits
      that add new behaviors as needed:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-drawing-factory.scala</code>

<code role="preproc">package</code> shapes2 {
  <code role="statement">trait</code> <code role="special">Drawing</code> {
    <code role="statement">def</code> <code role="identifier">draw</code>:<code role="type"> Unit</code>
  }

  <code role="statement">trait</code> <code role="special">CircleDrawing</code> <code role="statement">extends</code> <code role="special">Drawing</code> {
    <code role="statement">def</code> <code role="identifier">draw</code> = println(<code role="constant">"Circle.draw "</code> + <code role="statement">this</code>)
  }
  <code role="statement">trait</code> <code role="special">RectangleDrawing</code> <code role="statement">extends</code> <code role="special">Drawing</code> {
    <code role="statement">def</code> <code role="identifier">draw</code> = println(<code role="constant">"Rectangle.draw: "</code> + <code role="statement">this</code>)
  }
  <code role="statement">trait</code> <code role="special">TriangleDrawing</code> <code role="statement">extends</code> <code role="special">Drawing</code> {
    <code role="statement">def</code> <code role="identifier">draw</code> = println(<code role="constant">"Triangle.draw: "</code> + <code role="statement">this</code>)
  }

  <code role="statement">object</code> <code role="special">ShapeFactory</code> {
    <code role="statement">def</code> <code role="identifier">makeShape</code>(args:<code role="type"> Any</code>*) = args(<code role="constant">0</code>) <code role="statement">match</code> {
      <code role="statement">case</code> <code role="constant">"circle"</code> <code role="statement">=&gt;</code> {
        <code role="statement">val</code> center = args(<code role="constant">1</code>).asInstanceOf[<code role="special">Point</code>]
        <code role="statement">val</code> radius = args(<code role="constant">2</code>).asInstanceOf[<code role="special">Double</code>]
        <code role="statement">new</code> <code role="special">Circle</code>(center, radius) <code role="statement">with</code> <code role="special">CircleDrawing</code>
      }
      <code role="statement">case</code> <code role="constant">"rectangle"</code> <code role="statement">=&gt;</code> {
        <code role="statement">val</code> lowerLeft = args(<code role="constant">1</code>).asInstanceOf[<code role="special">Point</code>]
        <code role="statement">val</code> height    = args(<code role="constant">2</code>).asInstanceOf[<code role="special">Double</code>]
        <code role="statement">val</code> width     = args(<code role="constant">3</code>).asInstanceOf[<code role="special">Double</code>]
        <code role="statement">new</code> <code role="special">Rectangle</code>(lowerLeft, height, width) <code role="statement">with</code> <code role="special">RectangleDrawing</code>
      }
      <code role="statement">case</code> <code role="constant">"triangle"</code> <code role="statement">=&gt;</code> {
        <code role="statement">val</code> p1 = args(<code role="constant">1</code>).asInstanceOf[<code role="special">Point</code>]
        <code role="statement">val</code> p2 = args(<code role="constant">2</code>).asInstanceOf[<code role="special">Point</code>]
        <code role="statement">val</code> p3 = args(<code role="constant">3</code>).asInstanceOf[<code role="special">Point</code>]
        <code role="statement">new</code> <code role="special">Triangle</code>(p1, p2, p3) <code role="statement">with</code> <code role="special">TriangleDrawing</code>
      }
      <code role="statement">case</code> x <code role="statement">=&gt;</code> <code role="statement">throw</code> <code role="statement">new</code> <code role="special">IllegalArgumentException</code>(<code role="constant">"unknown: "</code> + x)
    }
  }
}
</programlisting><para id="para_we_define_a_drawing_trait_an">We define a
      <literal moreinfo="none">Drawing</literal> trait and concrete derived traits for each
      <literal moreinfo="none">Shape</literal> class. Then we define a
      <literal moreinfo="none">ShapeFactory</literal> object with a
      <literal moreinfo="none">makeShape</literal> factory method that takes a variable-length
      list of arguments. A match is done on the first argument to determine
      which shape to make. The trailing arguments are cast to appropriate
      types to construct each shape, with the corresponding drawing trait
      mixed in. A similar factory could be written for adding draw methods
      that output XML. (The variable-length list of <literal moreinfo="none">Any</literal>
      values, heavy use of casting, and minimal error checking were done for
      expediency. A real implementation could minimize these “hacks.”)</para><para id="para_factory_script">The following script exercises the
      factory:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/patterns/shapes-drawing-factory-script.scala</code>

<code role="preproc">import</code> shapes2._

<code role="statement">val</code> p00 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p10 = <code role="special">Point</code>(<code role="constant">1.0</code>, <code role="constant">0.0</code>)
<code role="statement">val</code> p01 = <code role="special">Point</code>(<code role="constant">0.0</code>, <code role="constant">1.0</code>)

<code role="statement">val</code> list = <code role="special">List</code>(
    ShapeFactory.makeShape(<code role="constant">"circle"</code>, p00, <code role="constant">5.0</code>),
    ShapeFactory.makeShape(<code role="constant">"rectangle"</code>, p00, <code role="constant">2.0</code>, <code role="constant">3.0</code>),
    ShapeFactory.makeShape(<code role="constant">"triangle"</code>, p00, p10, p01))

list foreach { <code role="statement">_</code>.draw }
</programlisting><para id="para_factory_script_output">Compared to our previous scripts,
      the list of shapes is now constructed using the factory. When we want to
      draw the shapes in the <literal moreinfo="none">foreach</literal> statement, we simply
      call <literal moreinfo="none">draw</literal> on each shape. As before, the output is the
      following:</para><screen format="linespecific">Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</screen><para id="para_there_is_one_subtlety_with_thi">There is one subtlety
      with this approach that we should discuss. Notice that the script never
      assigns the result of a <literal moreinfo="none">ShapeFactory.makeShape</literal> call
      to a <literal moreinfo="none">Shape</literal> variable. If it did that, it would not be
      able to call <literal moreinfo="none">draw</literal> on the instance!</para><para id="para_in_this_script_scala_inferred">In this script, Scala
      inferred a slightly different common supertype for the parameterized
      list. You can see that type if you use the <literal moreinfo="none">:load</literal>
      command to load the script while inside the interactive
      <literal moreinfo="none">scala</literal> interpreter, as in the following
      session:</para><screen format="linespecific">$ scala -cp ...
Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; :load design-patterns/shapes-drawing-factory-script.scala
Loading design-patterns/shapes-drawing-factory-script.scala...
import shapes2._
p00: shapes2.Point = Point(0.0,0.0)
p10: shapes2.Point = Point(1.0,0.0)
p01: shapes2.Point = Point(0.0,1.0)
list: List[Product with shapes2.Shape with shapes2.Drawing] = List(...)
Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

scala&gt;</screen><para id="para_notice_the_line_that_begins_l">Notice the line that
      begins <literal moreinfo="none">list: List[Product with shapes2.Shape with
      shapes2.Draw⁠ing]</literal>. This line was printed after the list of
      shapes was parsed. The inferred common supertype is <literal moreinfo="none">Product
      with shapes2.Shape with shapes2.Drawing</literal>.
      <literal moreinfo="none">Product</literal> is a trait mixed into all case classes, such
      as our concrete subclasses of <literal moreinfo="none">Shape</literal>. Recall that to
      avoid case-class inheritance, <literal moreinfo="none">Shape</literal> itself is not a
      case class. (See <xref linkend="CaseClasses"/> for details on why case
      class inheritance should be avoided.) So, our common supertype is an
      anonymous class that incorporates <literal moreinfo="none">Shape</literal>,
      <literal moreinfo="none">Product</literal>, and the <literal moreinfo="none">Drawing</literal>
      trait.<indexterm significance="normal"><primary>case classes</primary><secondary>inheritance</secondary></indexterm></para><para id="para_if_you_want_to_assign_one_of_t">If you want to assign one
      of these drawable shapes to a variable and still be able to invoke
      <literal moreinfo="none">draw</literal>, use a declaration like the following (shown as
      a continuation of the same interactive <literal moreinfo="none">scala</literal>
      session):</para><screen format="linespecific">scala&gt; val s: Shape with Drawing = ShapeFactory.makeShape("circle", p00, 5.0)
s: shapes2.Shape with shapes2.Drawing = Circle(Point(0.0,0.0),5.0)

scala&gt; s.draw
Circle.draw Circle(Point(0.0,0.0),5.0)

scala&gt;</screen></sect2><sect2 id="DependencyInjectionInScala"><title>Dependency Injection in Scala: The Cake Pattern</title><para id="para_description_of_di"><emphasis>Dependency
      injection</emphasis> (DI), a form of <emphasis>inversion of
      control</emphasis> (IoC), is a powerful technique for resolving
      dependencies between “components” in larger applications. It supports
      minimizing the coupling between these components, so it is relatively
      easy to substitute different components for different
      circumstances.<indexterm significance="normal"><primary>inversion of control (IoC)</primary></indexterm><indexterm class="startofrange" id="ch13_DICakePattern" significance="normal"><primary>dependency injection (DI)</primary><secondary>using Cake Pattern</secondary></indexterm><indexterm class="startofrange" id="ch13_designpatternCAKE" significance="normal"><primary>design patterns</primary><secondary>dependency injection (DI) implementation, Cake
          Pattern</secondary></indexterm><indexterm class="endofrange" startref="ch13_designpatternVisitor" significance="normal"/><indexterm class="endofrange" startref="ch13_VisitorPattern" significance="normal"/></para><para id="para_it_used_to_be_that_when_a_clie">It used to be that when a
      client object needed a database “accessor” object, for example, it would
      just instantiate the accessor itself. While convenient, this approach
      makes unit testing very difficult because you have to test with a real
      database. It also compromises reuse, for those alternative situations
      where another persistence mechanism (or none) is required. Inversion of
      control solves this problem by reversing responsibility for satisfying
      the dependency between the object and the database connection.</para><para id="para_an_example_of_ioc_is_jndi_ins">An example of IoC is JNDI.
      Instead of instantiating an accessor object, the client object asks JDNI
      to provide one. The client doesn’t care what actual type of accessor is
      returned. Hence, the client object is no longer coupled to a concrete
      implementation of the dependency. It only depends on an appropriate
      <emphasis>abstraction</emphasis> of a persistence accessor, i.e., a Java
      interface or Scala trait.</para><para id="para_dependency_injection_takes_ioc">Dependency injection
      takes IoC to its logical conclusion. Now the object does nothing to
      resolve the dependency. Instead, an external mechanism with system-wide
      knowledge “injects” the appropriate accessor object using a constructor
      argument or a setter method. This happens when the client is
      constructed. DI eliminates dependencies on IoC mechanisms in code (e.g.,
      no more JNDI calls) and keeps objects relatively simple, with minimal
      coupling to other objects.</para><para id="para_back_to_unit_testing_it_is_pr">Back to unit testing, it
      is preferable to use a <emphasis>test double</emphasis> for heavyweight
      dependencies to minimize the overhead and other complications of
      testing. Our client object with a dependency on a database accessor
      object is a classic example. While unit testing the client, the overhead
      and complications of using a real database are prohibitive. Using a
      lightweight test double with hardcoded sample data provides simpler
      setup and tear down, faster execution, and predictable behavior from the
      data accessor dependency.</para><para id="para_java_di">In Java, DI is usually done using an inversion
      of control container, like the Spring Framework (<link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link>), or a Java-API
      equivalent like Google’s Guice API (see <link linkend="Guice" xrefstyle="select:nopage">[Guice]</link>). These options can be used
      with Scala code, especially when you are introducing Scala into a mature
      Java environment.<indexterm significance="normal"><primary>Java</primary><secondary>DI (dependency injection)</secondary></indexterm></para><para id="para_the_cake_pattern_">However, Scala offers some unique
      options for implementing DI in Scala code, which are discussed by <link linkend="Boner2008b" xrefstyle="select:nopage">[Bonér2008b]</link>.
      We’ll discuss one of them, the <emphasis>Cake Pattern</emphasis>, which
      can replace or complement these other dependency injection mechanisms.
      We’ll see that it is similar to the implementation of the Observer
      Pattern we discussed earlier in this chapter, in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>. The Cake Pattern
      was described by <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>, although it was given
      that name after that paper was published. <link linkend="Boner2008b" xrefstyle="select:nopage">[Bonér2008b]</link> also discusses
      alternatives.<indexterm class="startofrange" id="ch12_CakePattern" significance="normal"><primary>Cake Pattern</primary></indexterm></para><para id="para_let_s_build_a_simple_component">Let’s build a simple
      component model for an overly simplified Twitter client. We want a
      configurable UI, a configurable local cache of past tweets, and a
      configurable connection to the Twitter service itself. Each of these
      “components” will be specified separately, along with a client component
      that will function as the “middleware” that ties the application
      together. The client component will depend on the other components. When
      we create a concrete client, we’ll configure in the concrete pieces of
      the other components that we need:<indexterm class="startofrange" id="ch13_Twitterclient" significance="normal"><primary>Twitter client, component model for (example)</primary></indexterm></para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/dep-injection/twitter-client.scala</code>

<code role="preproc">package</code> twitterclient
<code role="preproc">import</code> java.util.Date
<code role="preproc">import</code> java.text.DateFormat

<code role="statement">class</code> <code role="special">TwitterUserProfile</code>(<code role="statement">val</code> userName:<code role="type"> String</code>) {
  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = <code role="constant">"@"</code> + userName
}

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Tweet</code>(
  <code role="statement">val</code> tweeter:<code role="type"> TwitterUserProfile</code>,
  <code role="statement">val</code> message:<code role="type"> String</code>,
  <code role="statement">val</code> time:<code role="type"> Date</code>) {

  <code role="statement">override</code> <code role="statement">def</code> <code role="identifier">toString</code> = <code role="constant">"("</code> +
    DateFormat.getDateInstance(DateFormat.<code role="special">FULL</code>).format(time) + <code role="constant">") "</code> +
    tweeter + <code role="constant">": "</code> + message
}

<code role="statement">trait</code> <code role="special">Tweeter</code> {
  <code role="statement">def</code> <code role="identifier">tweet</code>(message:<code role="type"> String</code>)
}

<code role="statement">trait</code> <code role="special">TwitterClientUIComponent</code> {
  <code role="statement">val</code> ui:<code role="type"> TwitterClientUI</code>

  <code role="statement">abstract</code> <code role="statement">class</code> <code role="special">TwitterClientUI</code>(<code role="statement">val</code> client:<code role="type"> Tweeter</code>) {
    <code role="statement">def</code> <code role="identifier">sendTweet</code>(message:<code role="type"> String</code>) = client.tweet(message)
    <code role="statement">def</code> <code role="identifier">showTweet</code>(tweet:<code role="type"> Tweet</code>):<code role="type"> Unit</code>
  }
}

<code role="statement">trait</code> <code role="special">TwitterLocalCacheComponent</code> {
  <code role="statement">val</code> localCache:<code role="type"> TwitterLocalCache</code>

  <code role="statement">trait</code> <code role="special">TwitterLocalCache</code> {
    <code role="statement">def</code> <code role="identifier">saveTweet</code>(tweet:<code role="type"> Tweet</code>):<code role="type"> Unit</code>
    <code role="statement">def</code> <code role="identifier">history</code>:<code role="type"> List[Tweet]</code>
  }
}

<code role="statement">trait</code> <code role="special">TwitterServiceComponent</code> {
  <code role="statement">val</code> service:<code role="type"> TwitterService</code>

  <code role="statement">trait</code> <code role="special">TwitterService</code> {
    <code role="statement">def</code> <code role="identifier">sendTweet</code>(tweet:<code role="type"> Tweet</code>):<code role="type"> Boolean</code>
    <code role="statement">def</code> <code role="identifier">history</code>:<code role="type"> List[Tweet]</code>
  }
}

<code role="statement">trait</code> <code role="special">TwitterClientComponent</code> {
  self:<code role="type"> TwitterClientUIComponent</code> <code role="statement">with</code>
        <code role="special">TwitterLocalCacheComponent</code> <code role="statement">with</code>
        <code role="special">TwitterServiceComponent</code> <code role="statement">=&gt;</code>

  <code role="statement">val</code> client:<code role="type"> TwitterClient</code>

  <code role="statement">class</code> <code role="special">TwitterClient</code>(<code role="statement">val</code> user:<code role="type"> TwitterUserProfile</code>) <code role="statement">extends</code> <code role="special">Tweeter</code> {
    <code role="statement">def</code> <code role="identifier">tweet</code>(msg:<code role="type"> String</code>) = {
      <code role="statement">val</code> twt = <code role="statement">new</code> <code role="special">Tweet</code>(user, msg, <code role="statement">new</code> <code role="special">Date</code>)
      <code role="statement">if</code> (service.sendTweet(twt)) {
        localCache.saveTweet(twt)
        ui.showTweet(twt)
      }
    }
  }
}
</programlisting><para id="para_the_first_class_twitteruserp">The first class,
      <literal moreinfo="none">TwitterUserProfile</literal>, encapsulates a user’s profile,
      which we limit to the username. The second class is a case class,
      <literal moreinfo="none">Tweet</literal>, that encapsulates a single “tweet” (a Twitter
      message, limited to 140 characters by the Twitter service). Besides the
      message string, it encapsulates the user who sent the tweet and the date
      and time when it was sent. We made this class a case class for the
      convenient support case classes provide for creating objects and pattern
      matching on them. We didn’t make the profile class a case class, because
      it is more likely to be used as the parent of more detailed profile
      classes.</para><para id="para_next_is_the_tweeter_trait_th">Next is the
      <literal moreinfo="none">Tweeter</literal> trait that declares one method,
      <literal moreinfo="none">tweet</literal>. This trait is defined solely to eliminate a
      potential circular dependency between two components,
      <literal moreinfo="none">TwitterClientComponent</literal> and
      <literal moreinfo="none">TwitterClientUIComponent</literal>. All the components are
      defined next in the file.</para><para id="para_there_are_four_components_">There are four components.
      Note that they are implemented as traits:<indexterm significance="normal"><primary>traits</primary><secondary>implementing components with</secondary></indexterm><indexterm significance="normal"><primary>components</primary><secondary>implementing as traits</secondary></indexterm></para><itemizedlist><listitem><para><literal moreinfo="none">TwitterClientUIComponent</literal>, for the UI</para></listitem><listitem><para><literal moreinfo="none">TwitterLocalCacheComponent</literal>, for the local
          cache of prior tweets</para></listitem><listitem><para><literal moreinfo="none">TwitterServiceComponent</literal>, for accessing the
          Twitter service</para></listitem><listitem><para><literal moreinfo="none">TwitterClientComponent</literal>, the client that
          pulls the pieces together</para></listitem></itemizedlist><para id="para_they_all_have_a_similar_struct">They all have a similar
      structure. Each one declares a nested trait or class that encapsulates
      the component’s behavior. Each one also declares a
      <literal moreinfo="none">val</literal> with one instance of the nested type.</para><para id="para_java_packages_as_components">Often in Java, packages are
      informally associated with components. This is common in other
      languages, too, using their equivalent of a package, e.g., a module or a
      namespace. Here we define a more precise notion of a component, and a
      trait is the best vehicle for it, because traits are designed for mixin
      composition.</para><para id="para__twitterclientuicomponent_dec"><literal moreinfo="none">TwitterClientUIComponent</literal>
      declares a <literal moreinfo="none">val</literal> named <literal moreinfo="none">ui</literal> of the
      nested type <literal moreinfo="none">TwitterClien⁠tUI</literal>. This class has a
      <literal moreinfo="none">client</literal> field that must be initialized with a
      <literal moreinfo="none">Tweeter</literal> instance. In fact, this instance will be a
      <literal moreinfo="none">TwitterClient</literal> (defined in
      <literal moreinfo="none">TwitterClientComponent</literal>), which extends
      <literal moreinfo="none">Tweeter</literal>.</para><para id="para__twitterclientui_has_two_meth"><literal moreinfo="none">TwitterClientUI</literal>
      has two methods. The first is <literal moreinfo="none">sendTweet</literal>, which is
      defined to call the <literal moreinfo="none">client</literal> object. This method would
      be used by the UI to call the client when the user sends a new tweet.
      The second method, <literal moreinfo="none">showTweet</literal>, goes the other
      direction. It is called whenever a new tweet is to be displayed, e.g.,
      from another user. It is abstract, pending the “decision” of the kind of
      UI to use.</para><para id="para_similarly_twitterlocalcachec">Similarly,
      <literal moreinfo="none">TwitterLocalCacheComponent</literal> declares
      <literal moreinfo="none">TwitterLocalCache</literal> and an instance of it. Instances
      with this trait save tweets to the local persistent cache when
      <literal moreinfo="none">saveTweet</literal> is called. You can retrieve the cached
      tweets with <literal moreinfo="none">history</literal>.</para><para id="para__twitterservicecomponent_is_v"><literal moreinfo="none">TwitterServiceComponent</literal>
      is very similar. Its nested type has a method,
      <literal moreinfo="none">sendTweet</literal>, that sends a new tweet to Twitter. It also
      has a <literal moreinfo="none">history</literal> method that retrieves all the tweets
      for the current user.</para><para id="para_finally_twitterclientcompone">Finally,
      <literal moreinfo="none">TwitterClientComponent</literal> contains a concrete class,
      <literal moreinfo="none">TwitterClient</literal>, that integrates the components. Its
      one <literal moreinfo="none">tweet</literal> method sends new tweets to the Twitter
      service. If successful, it sends the tweet back to the UI and to the
      local persistent cache.</para><para id="para__twitterclientcomponent_also_"><literal moreinfo="none">TwitterClientComponent</literal>
      also has the following <emphasis>self-type
      annotation</emphasis>:<indexterm significance="normal"><primary>self-type annotations</primary><secondary>TwitterClientComponent (example)</secondary></indexterm></para><programlisting language="scala" format="linespecific">self:<code role="type"> TwitterClientUIComponent</code> <code role="statement">with</code>
      <code role="special">TwitterLocalCacheComponent</code> <code role="statement">with</code>
      <code role="special">TwitterServiceComponent</code> <code role="statement">=&gt;</code>
</programlisting><para id="para_the_effect_of_this_declaration">The effect of this
      declaration is to say that any concrete
      <literal moreinfo="none">TwitterClientComponent</literal> must also behave like these
      other three components, thereby composing all the components into one
      client application instance. This composition will be realized by mixing
      in these components, which are traits, when we create concrete clients,
      as we will see shortly.</para><para id="para_the_self_type_annotation_also_">The self-type annotation
      also means we can reference the <literal moreinfo="none">vals</literal> declared in
      these components. Notice how <literal moreinfo="none">TwitterClient.tweet</literal>
      references the <literal moreinfo="none">service</literal>,
      <literal moreinfo="none">localCache</literal>, and the <literal moreinfo="none">ui</literal> as if they
      are variables in the scope of this method. In fact, they
      <emphasis>are</emphasis> in scope, because of the self-type
      annotation.</para><para id="para_notice_also_that_all_the_metho">Notice also that all the
      methods that call other components are concrete. Those inter-component
      relationships are fully specified. The abstractions are directed
      “outward,” toward the graphical user interface, a caching mechanism,
      etc.</para><para id="para_let_s_now_define_a_concrete_tw">Let’s now define a
      concrete Twitter client that uses a textual (command-line) UI, an
      in-memory local cache, and fakes the interaction with the Twitter
      service:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/dep-injection/twitter-text-client.scala</code>

<code role="preproc">package</code> twitterclient

<code role="statement">class</code> <code role="special">TextClient</code>(userProfile:<code role="type"> TwitterUserProfile</code>)
    <code role="statement">extends</code> <code role="special">TwitterClientComponent</code>
    <code role="statement">with</code> <code role="special">TwitterClientUIComponent</code>
    <code role="statement">with</code> <code role="special">TwitterLocalCacheComponent</code>
    <code role="statement">with</code> <code role="special">TwitterServiceComponent</code> {

  <code role="comment">// From TwitterClientComponent:</code>

  <code role="statement">val</code> client = <code role="statement">new</code> <code role="special">TwitterClient</code>(userProfile)

  <code role="comment">// From TwitterClientUIComponent:</code>

  <code role="statement">val</code> ui = <code role="statement">new</code> <code role="special">TwitterClientUI</code>(client) {
    <code role="statement">def</code> <code role="identifier">showTweet</code>(tweet:<code role="type"> Tweet</code>) = println(tweet)
  }

  <code role="comment">// From TwitterLocalCacheComponent:</code>

  <code role="statement">val</code> localCache = <code role="statement">new</code> <code role="special">TwitterLocalCache</code> {
    <code role="statement">private</code> <code role="statement">var</code> tweets:<code role="type"> List[Tweet]</code> = <code role="special">Nil</code>

    <code role="statement">def</code> <code role="identifier">saveTweet</code>(tweet:<code role="type"> Tweet</code>) = tweets ::= tweet

    <code role="statement">def</code> <code role="identifier">history</code> = tweets
  }

  <code role="comment">// From TwitterServiceComponent</code>

  <code role="statement">val</code> service = <code role="statement">new</code> <code role="special">TwitterService</code>() {
    <code role="statement">def</code> <code role="identifier">sendTweet</code>(tweet:<code role="type"> Tweet</code>) = {
      println(<code role="constant">"Sending tweet to Twitter HQ"</code>)
      <code role="constant">true</code>
    }
    <code role="statement">def</code> <code role="identifier">history</code> = <code role="special">List</code><code role="special">[Tweet]</code>()
  }
}
</programlisting><para id="para_our_textclient_concrete_clas">Our
      <literal moreinfo="none">TextClient</literal> concrete class extends
      <literal moreinfo="none">TwitterClientComponent</literal> and mixes in the three other
      components. By mixing in the other components, we satisfy the self-type
      annotations in <literal moreinfo="none">TwitterClientComponent</literal>. In other
      words, <literal moreinfo="none">TextClient</literal> <emphasis>is</emphasis> also a
      <literal moreinfo="none">TwitterClien⁠tUIComponent</literal>, a
      <literal moreinfo="none">TwitterLocalCacheComponent</literal>, and a
      <literal moreinfo="none">TwitterServiceComponent</literal>, in addition to being a
      <literal moreinfo="none">TwitterClientComponent</literal>.</para><para id="para_the_textclient_constructor_t">The
      <literal moreinfo="none">TextClient</literal> constructor takes one argument, a user
      profile, which will be passed onto the nested client class.</para><para id="para__textclient_has_to_define_fou"><literal moreinfo="none">TextClient</literal>
      has to define four <literal moreinfo="none">vals</literal>, one from
      <literal moreinfo="none">TwitterClientComponent</literal> and three from the other
      mixins. For the <literal moreinfo="none">client</literal>, it simply creates a new
      <literal moreinfo="none">TwitterClient</literal>, passing it the
      <literal moreinfo="none">userProfile</literal>.</para><para id="para_for_the_ui_it_instantiates_">For the
      <literal moreinfo="none">ui</literal>, it instantiates an anonymous class derived from
      <literal role="keep-together" moreinfo="none">TwitterClientUI</literal>. It defines
      <literal moreinfo="none">showTweet</literal> to print out the tweet.</para><para id="para_for_the_localcache_it_insta">For the
      <literal moreinfo="none">localCache</literal>, it instantiates an anonymous class
      derived from <literal role="keep-together" moreinfo="none">TwitterLocalC⁠ache</literal>.
      It keeps the history of tweets in a <literal moreinfo="none">List</literal>.</para><para id="para_finally_for_the_service_it">Finally, for the
      <literal moreinfo="none">service</literal>, it instantiates an anonymous class derived
      from <literal role="keep-together" moreinfo="none">TwitterSer⁠vice</literal>. This
      “fake” defines <literal moreinfo="none">sendTweet</literal> to print out a message and
      to return an empty list for the history.</para><para id="para_let_s_try_our_client_with_the_">Let’s try our client with
      the following script:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/dep-injection/twitter-text-client-script.scala</code>

<code role="preproc">import</code> twitterclient._

<code role="statement">val</code> client = <code role="statement">new</code> <code role="special">TextClient</code>(<code role="statement">new</code> <code role="special">TwitterUserProfile</code>(<code role="constant">"BuckTrends"</code>))
client.ui.sendTweet(<code role="constant">"My First Tweet. How's this thing work?"</code>)
client.ui.sendTweet(<code role="constant">"Is this thing on?"</code>)
client.ui.sendTweet(<code role="constant">"Heading to the bathroom..."</code>)
println(<code role="constant">"Chat history:"</code>)
client.localCache.history.foreach {t <code role="statement">=&gt;</code> println(t)}
</programlisting><para id="para_may_3">We instantiate a <literal moreinfo="none">TextClient</literal> for
      the user “BuckTrends.” Old Buck sends three insightful tweets through
      the UI. We finish by reprinting the history of tweets, in reverse order,
      that are cached locally. Running this script yields output like the
      following:</para><screen format="linespecific">Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: My First Tweet. How's this thing work?
Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: Is this thing on?
Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: Heading to the bathroom...
Chat history:
(Sunday, May 3, 2009) @BuckTrends: Heading to the bathroom...
(Sunday, May 3, 2009) @BuckTrends: Is this thing on?
(Sunday, May 3, 2009) @BuckTrends: My First Tweet. How's this thing work?</screen><para id="para_your_date_will_vary_of_course">Your date will vary, of
      course. Recall that the <literal moreinfo="none">Sending tweet to Twitter HQ</literal>
      line is printed by the fake service.</para><para id="para_to_recap_each_major_component">To recap, each major
      component in the Twitter client was declared in its own trait, with a
      nested type for the component’s fields and methods. The client component
      declared its dependencies on the other components through a self-type
      annotation. The concrete client class mixed in those components and
      defined each component <literal moreinfo="none">val</literal> to be an appropriate
      subtype of the corresponding abstract classes and traits that were
      declared in the components.</para><para id="para_other_di_approaches">We get type-safe “wiring” together
      of components, a flexible component model, and we did it all in Scala
      code! There are alternatives to the Cake Pattern for implementing
      dependency injection in Scala. See <link linkend="Boner2008b" xrefstyle="select:nopage">[Bonér2008b]</link> for other
      examples.<indexterm class="endofrange" startref="ch13_designpatternCAKE" significance="normal"/><indexterm class="endofrange" startref="ch13_Twitterclient" significance="normal"/><indexterm class="endofrange" startref="ch13_DICakePattern" significance="normal"/><indexterm class="endofrange" startref="ch12_CakePattern" significance="normal"/><indexterm class="endofrange" startref="ch13_appsdesignpatterns" significance="normal"/><indexterm class="endofrange" startref="ch13_designpatterns" significance="normal"/></para></sect2></sect1><sect1 id="DesignByContractExample"><title>Better Design with Design By Contract</title><para id="para_we_ll_conclude_this_chapter_wi">We’ll conclude this chapter
    with a look at an approach to programming called <emphasis>Design by
    Contract</emphasis> (<link linkend="DesignByContract" xrefstyle="select:nopage">[DesignByContract]</link>), which was developed
    by Bertrand Meyer for the Eiffel language (see <link linkend="Eiffel" xrefstyle="select:nopage">[Eiffel]</link>, <link linkend="Hunt2000" xrefstyle="select:nopage">[Hunt2000]</link>, and <xref linkend="Traits"/>). Design by Contract has been around for about 20
    years. It has fallen somewhat out of favor, but it is still very useful
    for thinking about design.<indexterm significance="normal"><primary>Meyer, Bertrand</primary></indexterm><indexterm significance="normal"><primary>Eiffel language</primary></indexterm><indexterm significance="normal"><primary>Design by Contract</primary></indexterm><indexterm significance="normal"><primary>application design</primary><secondary>Design by Contract</secondary></indexterm></para><para id="para_when_considering_the_contract">When considering the
    “contract” of a module, you can specify three types of conditions. First,
    you can specify the required inputs for a module to successfully perform a
    service (e.g., when a method is called). These constraints are called
    <emphasis>preconditions</emphasis>. They can also include system
    requirements, e.g., global data (which you should normally avoid, of
    course).<indexterm significance="normal"><primary>contractual constraints in Design by Contract</primary></indexterm><indexterm significance="normal"><primary>modules</primary><secondary>contract of</secondary></indexterm><indexterm significance="normal"><primary>preconditions</primary></indexterm></para><para id="para_you_can_also_specify_the_resul">You can also specify the
    results the module guarantees to deliver, the
    <emphasis>postconditions</emphasis>, if the preconditions were
    satisfied.<indexterm significance="normal"><primary>postconditions</primary></indexterm></para><para id="para_finally_you_can_specify__inva">Finally, you can specify
    <emphasis>invariants</emphasis> that must be true before and after an
    invocation of a service.<indexterm significance="normal"><primary>invariants</primary></indexterm></para><para id="para_the_specific_addition_that_des">The specific addition that
    Design by Contract brings is the idea that these contractual constraints
    should be specified as executable code, so they can be enforced
    automatically at runtime, but usually only during testing.</para><para id="para_a_constraint_failure_should_te">A constraint failure should
    terminate execution immediately, forcing you to fix the bug. Otherwise, it
    is very easy to ignore these bugs.</para><para id="para_scala_doesn_t_provide_explicit">Scala doesn’t provide
    explicit support for Design by Contract, but there are several methods in
    <literal moreinfo="none">Predef</literal> that can be used for this purpose. The following
    example shows how to use <literal moreinfo="none">require</literal> and
    <literal moreinfo="none">assume</literal> for contract enforcement:<indexterm significance="normal"><primary>Predef object</primary><secondary>require and assume methods, using for contract
        enforcement</secondary></indexterm></para><?dbfo-need height=”1in”
?><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/design-by-contract/bank-account.scala</code>

<code role="statement">class</code> <code role="special">BankAccount</code>(<code role="statement">val</code> balance:<code role="type"> Double</code>) {
  require(balance &gt;= <code role="constant">0.0</code>)
  <code role="statement">def</code> <code role="identifier">debit</code>(amount:<code role="type"> Double</code>) = {
    require(amount &gt; <code role="constant">0.0</code>, <code role="constant">"The debit amount must be &gt; 0.0"</code>)
    assume(balance - amount &gt; <code role="constant">0.0</code>, <code role="constant">"Overdrafts are not permitted"</code>)
    <code role="statement">new</code> <code role="special">BankAccount</code>(balance - amount)
  }
  <code role="statement">def</code> <code role="identifier">credit</code>(amount:<code role="type"> Double</code>) = {
    require(amount &gt; <code role="constant">0.0</code>, <code role="constant">"The credit amount must be &gt; 0.0"</code>)
    <code role="statement">new</code> <code role="special">BankAccount</code>(balance + amount)
  }
}
</programlisting><para id="para_class_bankaccount_uses_requ">The class
    <literal moreinfo="none">BankAccount</literal> uses <literal moreinfo="none">require</literal> to ensure
    that a non-negative balance is specified for the constructor. Similarly,
    the <literal moreinfo="none">debit</literal> and <literal moreinfo="none">credit</literal> methods use
    <literal moreinfo="none">require</literal> to ensure that a positive
    <literal moreinfo="none">amount</literal> is specified.</para><para id="para_the_following_specification_co">The specification in <xref linkend="design-by-contract-example-spec"/> confirms that the “contract”
    is obeyed.<indexterm significance="normal"><primary>Design by Contract</primary><secondary>BankAccountSpec object (example)</secondary></indexterm></para><example id="design-by-contract-example-spec"><title>design-by-contract/bank-account-spec.scala: Testing the
      contract</title><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/AppDesign/design-by-contract/bank-account-spec.scala</code>

<code role="preproc">import</code> org.specs._

<code role="statement">object</code> <code role="special">BankAccountSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"Creating an account with a negative balance"</code> should {
    <code role="constant">"fail because the initial balance must be positive."</code> in {
      <code role="statement">new</code> <code role="special">BankAccount</code>(-<code role="constant">100.0</code>) must throwAn[<code role="special">IllegalArgumentException</code>]
    }
  }

  <code role="constant">"Debiting an account"</code> should {
    <code role="constant">"fail if the debit amount is &lt; 0"</code> in {
      <code role="statement">val</code> account = <code role="statement">new</code> <code role="special">BankAccount</code>(<code role="constant">100.0</code>)
      (account.debit(-<code role="constant">10.0</code>)) must throwAn[<code role="special">IllegalArgumentException</code>]
    }
  }

  <code role="constant">"Debiting an account"</code> should {
    <code role="constant">"fail if the debit amount is &gt; the balance"</code> in {
      <code role="statement">val</code> account = <code role="statement">new</code> <code role="special">BankAccount</code>(<code role="constant">100.0</code>)
      (account.debit(<code role="constant">110.0</code>)) must throwAn[<code role="special">AssertionError</code>]
    }
  }
}
</programlisting></example><para id="para_if_we_attempt_to_create_a_ban">If we attempt to create a
    <literal moreinfo="none">BankAccount</literal> with a negative balance, an
    <literal moreinfo="none">IllegalArgumentEx⁠ception</literal> is thrown. Similarly, the
    same kind of exception is thrown if the debit amount is less than zero.
    Both conditions are enforced using <literal moreinfo="none">require</literal>, which
    throws an <literal role="keep-together" moreinfo="none">IllegalArgumentException</literal>
    when the condition specified is false.</para><para id="para_the_assume_method_which_is_">The <literal moreinfo="none">assume</literal>
    method, which is used to ensure that overdrafts don’t occur, is
    functionally almost identical to <literal moreinfo="none">require</literal>. It throws an
    <literal moreinfo="none">AssertionError</literal> instead of an <literal role="keep-together" moreinfo="none">IllegalArgumentException</literal>.</para><para id="para_both_require_and_assume_co">Both <literal moreinfo="none">require</literal>
    and <literal moreinfo="none">assume</literal> come in two forms: one that takes just a
    boolean condition, and the other that also takes an error message
    string.</para><para id="para_there_is_also_an_assert_pair">There is also an
    <literal moreinfo="none">assert</literal> pair of methods that behave identically to
    <literal moreinfo="none">assume</literal>, except for a slight change in the generated
    failure message. Pick <literal moreinfo="none">assert</literal> or
    <literal moreinfo="none">assume</literal> depending on which of these “names” provides a
    better conceptual fit in a given context.</para><para id="para__predef_also_defines_an_ensu"><literal moreinfo="none">Predef</literal>
    also defines an <literal moreinfo="none">Ensuring</literal> class that can be used to
    generalize the capabilities of these methods. <literal moreinfo="none">Ensuring</literal>
    has one overloaded method, <literal moreinfo="none">ensure</literal>, some versions of
    which take a function literal as a “predicate.”<indexterm significance="normal"><primary>Ensuring class</primary></indexterm></para><para id="para_a_drawback_of_using_these_meth">A drawback of using these
    methods and <literal moreinfo="none">Ensuring</literal> is that you can’t disable these
    checks in production. It may <emphasis>not</emphasis> be acceptable to
    terminate abruptly if a condition fails, although if the system is allowed
    to “limp along,” it might crash later and the problem would be harder to
    debug. The performance overhead may be another reason to disable contract
    checks at runtime.</para><para id="para_these_days_the_goals_of_desig">These days, the goals of
    Design by Contract are largely met by Test-Driven Development (TDD).
    However, thinking in terms of Design by Contract will complement the
    design benefits of TDD. If you decide to use Design by Contract in your
    code, consider creating a custom module that lets you disable the tests
    for production code.<indexterm significance="normal"><primary>TDD (Test-Driven Development)</primary><secondary>Design by Contract and</secondary></indexterm></para></sect1><sect1 id="_recap_and_what_s_next_4"><title>Recap and What’s Next</title><para id="para_we_learned_a_number_of_pragmat">We learned a number of
    pragmatic techniques, patterns, and idioms for effective application
    development using Scala.</para><para id="para_good_tools_and_libraries_are_i">Good tools and libraries
    are important for building applications in any language. The next chapter
    provides more details about Scala’s command-line tools, describes the
    state of Scala IDE support, and introduces you to some important Scala
    libraries.<indexterm class="endofrange" startref="ch13_appdesign" significance="normal"/></para></sect1></chapter><chapter id="ScalaToolsLibs"><title>Scala Tools, Libraries, and IDE Support</title><para id="para_in_the_last_chapter_applica">In the previous chapter, <xref linkend="ApplicationDesign"/>, we looked at how to design scalable
  applications in Scala. In this chapter, we discuss tools and libraries that
  are essential for Scala application developers.</para><para id="para_we_briefly_introduced_you_to_t">We briefly introduced you to
  the Scala command-line tools in <xref linkend="IntroducingScala"/>. Now we
  explore these tools in greater detail and learn about other tools that are
  essential for the Scala developer. We’ll discuss language-aware plugins for
  editors and IDEs, testing tools, and various libraries and frameworks. We
  won’t cover these topics in exhaustive detail, but we will tell you where to
  look for more information.</para><sect1 id="CommandLineTools"><title>Command-Line Tools</title><para id="para_even_if_you_do_most_of_your_wo">Even if you do most of your
    work with IDEs, understanding how the command-line tools work gives you
    additional flexibility, as well as a fallback should the graphical tools
    fail you. In this chapter, we’ll give you some practical advice for
    interacting with these tools. However, we won’t describe each and every
    command-line option. For those gory details, we recommend downloading and
    consulting the tool documentation package
    <literal moreinfo="none">scala-devel-docs</literal>, as described in <xref linkend="ForMoreInformation"/> and also in <xref linkend="CommandLineToolSbaz"/>.<indexterm class="startofrange" id="ch14_commandlinetools" significance="normal"><primary>command-line tools</primary></indexterm></para><para id="para_all_the_command_line_tools_are">All the command-line tools
    are installed in the
    <replaceable>scala-home</replaceable><filename moreinfo="none">/bin</filename> directory
    (see <xref linkend="InstallingScala"/>).</para><sect2 id="CommandLineToolScalac"><title>scalac Command-Line Tool</title><para id="para_the_scalac_command_compiles_">The
      <literal moreinfo="none">scalac</literal> command compiles Scala source files,
      generating JVM class files. In contrast with Java requirements, the
      source file name doesn’t have to match the public class name in the
      file. In fact, you can define as many public classes in the file as you
      want. You can also use arbitrary package declarations without putting
      the files in corresponding directories.<indexterm significance="normal"><primary>compiler</primary><see>scalac compiler</see></indexterm><indexterm significance="normal"><primary>command-line tools</primary><secondary>scalac</secondary></indexterm><indexterm significance="normal"><primary>scalac compiler</primary></indexterm></para><para id="para_however_in_order_to_conform_t">However, in order to
      conform to JVM requirements, a separate class file will be <phrase role="keep-together">generated</phrase> for each type with a name that
      corresponds to the type’s name (sometimes <phrase role="keep-together">encoded</phrase>, e.g., for nested type
      definitions). Also, the class files will be written to directories
      corresponding to the package declarations. We’ll see an example of the
      types of class files generated in the next section, when we discuss the
      <literal moreinfo="none">scala</literal> command.</para><para id="para_the_scalac_command_is_just_a">The
      <literal moreinfo="none">scalac</literal> command is just a shell-script wrapper around
      the <literal moreinfo="none">java</literal> command, passing it the name of the Scala
      compiler’s <literal moreinfo="none">Main</literal> object. It adds Scala JAR files to
      the <literal role="keep-together" moreinfo="none">CLASSPATH</literal> and it defines
      several Scala-related system properties. You invoke the command as
      follows:<indexterm significance="normal"><primary>java command</primary></indexterm></para><screen format="linespecific"><literal moreinfo="none">scalac</literal> <replaceable>[options ...] [source-files]</replaceable></screen><para id="para_scalac_examples">For example, we used the following
      <literal moreinfo="none">scalac</literal> invocation command in <xref linkend="ATasteOfScala"/>, where we created a simple command-line tool
      to convert input strings to uppercase:</para><screen format="linespecific">scalac upper3.scala</screen><para id="para_options_for_scalac"><xref linkend="scalac-command-options"/> shows the list of the
      <literal moreinfo="none">scalac</literal> <replaceable>options</replaceable>, as
      reported by <literal moreinfo="none">scalac -help</literal>.<indexterm significance="normal"><primary>scalac compiler</primary><secondary>command options</secondary></indexterm></para><table id="scalac-command-options"><title>The scalac command options</title><tgroup cols="2"><thead valign="top"><row><entry>Option</entry><entry><phrase role="keep-together">Description</phrase></entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">-X</literal></para></entry><entry><para>Print a synopsis of advanced
              options.</para></entry></row><row><entry><para><literal moreinfo="none">-bootclasspath</literal>
              <replaceable>path</replaceable></para></entry><entry><para>Override location of bootstrap class
              files.</para></entry></row><row><entry><para><literal moreinfo="none">-classpath</literal>
              <replaceable>path</replaceable></para></entry><entry><para>Specify where to find user class
              files.</para></entry></row><row><entry><para><literal moreinfo="none">-d</literal>
              <replaceable>directory</replaceable></para></entry><entry><para>Specify where to place generated class
              files.</para></entry></row><row><entry><para><literal moreinfo="none">-dependencyfile</literal>
              <replaceable>file</replaceable></para></entry><entry><para>Specify the file in which dependencies are tracked.
              (<phrase role="keep-together">version</phrase>
              2.8)</para></entry></row><row><entry><para><literal moreinfo="none">-deprecation</literal></para></entry><entry><para>Output source locations where deprecated APIs are
              used.</para></entry></row><row><entry><para><literal moreinfo="none">-encoding</literal>
              <replaceable>encoding</replaceable></para></entry><entry><para>Specify character encoding used by source
              files.</para></entry></row><row><entry><para><literal moreinfo="none">-explaintypes</literal></para></entry><entry><para>Explain type errors in more detail.</para></entry></row><row><entry><para><literal moreinfo="none">-extdirs</literal>
              <replaceable>dirs</replaceable></para></entry><entry><para>Override location of installed compiler
              extensions.</para></entry></row><row><entry><para><literal moreinfo="none">-g:</literal><replaceable>level</replaceable></para></entry><entry><para>Specify <replaceable>level</replaceable> of
              generated debugging info: <literal moreinfo="none">none</literal>,
              <literal moreinfo="none">source</literal>, <literal moreinfo="none">line</literal>,
              <literal moreinfo="none">vars</literal>,
              <literal moreinfo="none">notailcalls</literal>.</para></entry></row><row><entry><para><literal moreinfo="none">-help</literal></para></entry><entry><para>Print a synopsis of standard
              options.</para></entry></row><row><entry><para><literal moreinfo="none">-make:</literal><replaceable>strategy</replaceable></para></entry><entry><para>Specify recompilation detection strategy:
              <literal moreinfo="none">all</literal>, <literal moreinfo="none">changed</literal>,
              <literal moreinfo="none">immediate</literal>, <literal moreinfo="none">transitive</literal>.
              (<phrase role="keep-together">version</phrase>
              2.8)</para></entry></row><row><entry><para><literal moreinfo="none">-nowarn</literal></para></entry><entry><para>Generate no warnings.</para></entry></row><row><entry><para><literal moreinfo="none">-optimise</literal></para></entry><entry><para>Generate faster byte code by applying optimizations
              to the program.</para></entry></row><row><entry><para><literal moreinfo="none">-print</literal></para></entry><entry><para>Print program with all Scala-specific features
              removed.</para></entry></row><row><entry><para><literal moreinfo="none">-sourcepath</literal>
              <replaceable>path</replaceable></para></entry><entry><para>Specify where to find input source
              files.</para></entry></row><row><entry><para><literal moreinfo="none">-target:</literal><replaceable>target</replaceable></para></entry><entry><para>Specify for which target JVM object files should be
              built: <literal moreinfo="none">jvm-1.5</literal>, <literal moreinfo="none">jvm-1.4</literal>,
              <literal moreinfo="none">msil</literal>.</para></entry></row><row><entry><para><literal moreinfo="none">-unchecked</literal></para></entry><entry><para>Enable detailed unchecked warnings.</para></entry></row><row><entry><para><literal moreinfo="none">-uniqid</literal></para></entry><entry><para>Print identifiers with unique names for
              debugging.</para></entry></row><row><entry><para><literal moreinfo="none">-verbose</literal></para></entry><entry><para>Output messages about what the compiler is
              doing.</para></entry></row><row><entry><para><literal moreinfo="none">-version</literal></para></entry><entry><para>Print product version and exit.</para></entry></row><row><entry><para><literal moreinfo="none">@</literal>
              <replaceable>file</replaceable></para></entry><entry><para>A text file containing compiler arguments (options
              and source files).</para></entry></row></tbody></tgroup></table><tip id="para_tip_we_recommend_routine_use_"><para>We recommend routine use of the <literal moreinfo="none">-deprecation</literal>
        and <literal moreinfo="none">-unchecked</literal> options. They help prevent some bugs
        and encourage you to eliminate use of obsolete libraries.</para></tip><para id="para_the_advanced_x_options_cont">The advanced
      <literal moreinfo="none">-X</literal> options control verbose output, fine-tune the
      compiler behavior, including use of experimental extensions and plugins,
      etc. We’ll discuss the <literal moreinfo="none">-Xscript</literal> option when we
      discuss the <literal moreinfo="none">scala</literal> command in the next
      section.<indexterm significance="normal"><primary>scalac compiler</primary><secondary><literal moreinfo="none">-X</literal> options</secondary></indexterm></para><para id="para_two_other_advanced_options">A few other advanced options,
      <literal moreinfo="none">-Xfuture</literal> and <literal moreinfo="none">-Xcheckinit</literal>, are
      useful for the <literal moreinfo="none">val</literal> override issue described in <xref linkend="OverridingFieldsInTraits"/> that affects Scala version 2.7.X.
      Similarly, the <literal moreinfo="none">-Xexperimental</literal> option enables
      experimental changes and issues warnings for potentially risky behavior
      changes. See <xref linkend="OverridingFieldsInTraits"/> for
      details.</para><para id="para_an_important_feature_of_scala">An important feature of
      <literal moreinfo="none">scalac</literal> is its plugin architecture, which has been
      significantly enhanced in version 2.8. Compiler plugins can be inserted
      in all phases of the compilation, enabling code transformations,
      analysis, etc. For example, version 2.8 will include a continuations
      plugin that developers can use to generate byte code that uses a
      continuation-passing style (CPS), rather than a stack-based style. Other
      plugins that are under development include an “effects” analyzer, useful
      for determining whether functions are truly side-effect-free, whether or
      not variables are modified, etc. Finally, the preliminary
      <literal moreinfo="none">sxr</literal> documentation tool (see <link linkend="SXR" xrefstyle="select:nopage">[SXR]</link>) uses a compiler plugin to
      generate <phrase role="keep-together">hyperlinked</phrase> documentation
      of Scala code.<indexterm significance="normal"><primary>scalac compiler</primary><secondary>plugin architecture</secondary></indexterm></para><para id="para_scalac_docs">You can read more information about
      <literal moreinfo="none">scalac</literal> in the developer tools documentation that you
      can install with the <literal moreinfo="none">sbaz</literal> command, discussed later in
      <xref linkend="CommandLineToolSbaz"/>. In particular, <xref linkend="sbaz-commands"/> shows an example <literal moreinfo="none">sbaz</literal>
      command that installs the <literal moreinfo="none">scala-devel-docs</literal>
      documentation.</para><warning id="para_warning_scala_version_2_8_com"><para>Scala version 2.8 compiled byte code will not be fully
        compatible with version 2.7.5 byte code. Source compatibility will be
        preserved in most cases. If you have your own collections
        implementations, they may <phrase role="keep-together">require</phrase> changes.</para></warning></sect2><sect2 id="CommandLineToolScala"><title>The scala Command-Line Tool</title><para id="para_the_scala_command_is_also_a_">The
      <literal moreinfo="none">scala</literal> command is also a shell-script wrapper around
      the <literal moreinfo="none">java</literal> command. It adds Scala JAR files to the
      <literal moreinfo="none">CLASSPATH</literal>, and it defines several Scala-related
      system properties. You invoke the command as follows:<indexterm class="startofrange" id="ch14_commandlinescala" significance="normal"><primary>command-line tools</primary><secondary>scala</secondary></indexterm><indexterm class="startofrange" id="ch14_scalacommand" significance="normal"><primary>scala command</primary></indexterm></para><screen format="linespecific">scala <replaceable>[options ...] [script-or-object] [arguments]</replaceable></screen><para id="para_scala_examples">For example, after compiling our
      <filename moreinfo="none">upper3.scala</filename> file in <xref linkend="ATasteOfScala"/>, which we revisited in the previous
      discussion of <literal moreinfo="none">scalac</literal>, we can execute the
      “application” as follows:</para><screen format="linespecific">scala -cp . Upper Hello World!</screen><para id="para_scala_upper_output">The <literal moreinfo="none">-cp .</literal> option
      adds the current working directory to the class path.
      <literal moreinfo="none">Upper</literal> is the class name with a
      <literal moreinfo="none">main</literal> method to run. <literal moreinfo="none">Hello World</literal>
      are arguments passed to <literal moreinfo="none">Upper</literal>. This command produces
      the following output:<indexterm significance="normal"><primary>scala command</primary><secondary>-cp option</secondary></indexterm></para><screen format="linespecific"> HELLO WORLD!</screen><para id="para_the_command_decides_what_to_do">The command decides what
      to do based on the <replaceable>script-or-object</replaceable>
      specified. If you don’t specify a script or object,
      <literal moreinfo="none">scala</literal> runs as an interactive interpreter. You type in
      code that is evaluated on the fly, a setup sometimes referred to as a
      REPL (Read, Evaluate, Print, Loop). There are a few special commands
      available in the interactive mode. Type <literal moreinfo="none">:help</literal> to see
      a list of them.<indexterm significance="normal"><primary>scala command</primary><secondary>script or object specified for</secondary></indexterm></para><note id="para_note_the_version_2_8_repl_add"><para>The version 2.8 REPL adds many enhancements, including code
        <phrase role="keep-together">completion</phrase>.</para></note><para id="para_if_you_specify_a_fully_qualifi">Our
      <literal moreinfo="none">Upper</literal> example demonstrates the case where you specify
      a fully qualified <literal moreinfo="none">object</literal> name (or Java
      <literal moreinfo="none">class</literal> name). In this case, <literal moreinfo="none">scala</literal>
      behaves just like the <literal moreinfo="none">java</literal> command; it searches the
      <literal moreinfo="none">CLASSPATH</literal> for the corresponding code. It will expect
      to find a <literal moreinfo="none">main</literal> method in the type. Recall that for
      Scala types, you have to define <literal moreinfo="none">main</literal> methods in
      <literal moreinfo="none">objects</literal>. Any <replaceable>arguments</replaceable> are
      passed as arguments to the <literal moreinfo="none">main</literal> method.</para><para id="para_if_you_specify_a_scala_source_">If you specify a Scala
      source file for <replaceable>script-or-object</replaceable>,
      <literal moreinfo="none">scala</literal> interprets the file as a script (i.e., compiles
      and runs it). Many of the examples in the book are invoked this way. Any
      <replaceable>arguments</replaceable> are made available to the script in
      the <literal moreinfo="none">args</literal> array. Here is an example script that
      implements the same “upper” feature:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/upper-script.scala</code>

args.map(<code role="statement">_</code>.toUpperCase()).foreach(printf(<code role="constant">"%s "</code>,<code role="statement">_</code>))
println(<code role="constant">""</code>)
</programlisting><para id="para_hello_script_invocation">If we run this script with the
      following command, <literal moreinfo="none">scala upper.scala Hello World</literal>, we
      get the same output we got before, <literal moreinfo="none">HELLO
      WORLD</literal>.</para><para id="para_interactive_mode_invocation">Finally, if you invoke
      <literal moreinfo="none">scala</literal> without a script file or object name argument,
      <literal moreinfo="none">scala</literal> runs in interpreted mode. Here is an example
      interactive session:<indexterm significance="normal"><primary>scala command</primary><secondary>running in interpreted mode</secondary></indexterm></para><screen format="linespecific">$ scala
Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; "Programming Scala" foreach { c =&gt; println(c) }
P
r
o
g
...</screen><para id="para_the_scala_command_accepts_al">The
      <literal moreinfo="none">scala</literal> command accepts all the options that
      <literal moreinfo="none">scalac</literal> accepts (see <xref linkend="scalac-command-options"/>), plus the options listed in <xref linkend="scala-command-options"/>.<indexterm significance="normal"><primary>scala command</primary><secondary>options</secondary></indexterm></para><table id="scala-command-options"><title>The scala command options (in addition to the scalac
        options)</title><tgroup cols="2"><colspec colnum="1" colwidth="1.25in"/><colspec colnum="2" colwidth="3.5in"/><thead valign="top"><row><entry>Option</entry><entry>Description</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">-howtorun script</literal></para></entry><entry><para>Explicitly interpret
              <replaceable>script-or-object</replaceable> as a script
              file.</para></entry></row><row><entry><para><literal moreinfo="none">-howtorun object</literal></para></entry><entry><para>Explicitly interpret
              <replaceable>script-or-object</replaceable> as a compiled
              object.</para></entry></row><row><entry><para><literal moreinfo="none">-howtorun guess</literal></para></entry><entry><para>Guess what
              <replaceable>script-or-object</replaceable> is
              (default).</para></entry></row><row><entry><para><literal moreinfo="none">-i</literal>
              <replaceable>file</replaceable></para></entry><entry><para>Preload <replaceable>file</replaceable>. It is only
              meaningful for interactive shells.</para></entry></row><row><entry><para><literal moreinfo="none">-e</literal>
              <replaceable>argument</replaceable></para></entry><entry><para>Parse <replaceable>argument</replaceable> as Scala
              code.</para></entry></row><row><entry><para><literal moreinfo="none">-savecompiled</literal></para></entry><entry><para>Save the compiled script for future
              use.</para></entry></row><row><entry><para><literal moreinfo="none">-nocompdaemon</literal></para></entry><entry><para>Don’t use <literal moreinfo="none">fsc</literal>, the offline
              compiler. (See <xref linkend="CommandLineToolFsc"/>.)</para></entry></row><row><entry><para><literal moreinfo="none">-D</literal><replaceable>property</replaceable><literal moreinfo="none">=</literal><replaceable>value</replaceable></para></entry><entry><para>Set a Java system
              <replaceable>property</replaceable> to
              <replaceable>value</replaceable>.</para></entry></row></tbody></tgroup></table><para id="para_use_the_i_file_option_in_">Use the <literal moreinfo="none">-i</literal>
      <replaceable>file</replaceable> option in the interactive mode when you
      want to preload a file before typing commands. Once in the shell, you
      can also load a file using the command <literal moreinfo="none">:load</literal>
      <replaceable>filename</replaceable>. <xref linkend="scala-interactive-special-commands"/> lists the special
      <literal moreinfo="none">:X</literal> commands available within the interactive
      mode.<indexterm significance="normal"><primary>scala command</primary><secondary>commands available in scala interactive mode</secondary></indexterm></para><table id="scala-interactive-special-commands"><title>Commands available within the scala interactive mode</title><tgroup cols="2"><colspec colnum="1" colwidth="1.25in"/><colspec colnum="2" colwidth="3.5in"/><thead valign="top"><row><entry>Option</entry><entry>Description</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">:help</literal></para></entry><entry><para>Prints a help message about these
              commands.</para></entry></row><row><entry><para><literal moreinfo="none">:load</literal></para></entry><entry><para>Followed by a file name, loads a Scala
              file.</para></entry></row><row><entry><para><literal moreinfo="none">:replay</literal></para></entry><entry><para>Resets execution and replays all previous
              commands.</para></entry></row><row><entry><para><literal moreinfo="none">:quit</literal></para></entry><entry><para>Exits the interpreter.</para></entry></row><row><entry><para><literal moreinfo="none">:power</literal></para></entry><entry><para>Enables power user mode. (version
              2.8)</para></entry></row></tbody></tgroup></table><para id="para_power_user_mode">The new “power user mode” adds
      additional commands for viewing in-memory data, such as the abstract
      syntax tree and interpreter properties, and for doing other <phrase role="keep-together">operations</phrase>.</para><para id="para_for__batch_mode__invocation_u">For
      <emphasis>batch-mode</emphasis> invocation, use the
      <literal moreinfo="none">-e</literal> <replaceable>argument</replaceable> option to
      specify Scala code to interpret. If you are using command shells that
      support I/O redirection (e.g., the Bourne shell, the C shell, or their
      descendants) and you need to build up lines of code dynamically, you can
      also pipe the code into <literal moreinfo="none">scala</literal>, as shown in the
      following somewhat contrived <emphasis>bash</emphasis> script
      example:</para><programlisting language="sh" format="linespecific"><code role="comment">#!/usr/bin/env bash</code>
<code role="comment"># code-examples/ToolsLibs/pipe-example.sh</code>

<code role="identifier">h</code>=Hello
<code role="identifier">w</code>=World
<code role="identifier">function</code> commands <code role="special">{</code>
<code role="statement">cat</code> <code role="statement">&lt;&lt;-EOF</code>
<code role="constant">println("</code><code role="preproc">$h</code><code role="constant">")</code>
<code role="constant">println("</code><code role="preproc">$w</code><code role="constant">")</code>
<code role="statement">EOF</code>
<code role="special">}</code>

commands <code role="statement">|</code> scala
</programlisting><para id="para_invoking_scripts_with_scala_">Invoking scripts with
      <literal moreinfo="none">scala</literal> is tedious when you use these scripts
      frequently. On Windows and Unix-like systems, you can create standalone
      Scala scripts that don’t require you to use the <literal moreinfo="none">scala</literal>
      <replaceable>script-file-name</replaceable> invocation.<indexterm significance="normal"><primary>scala command</primary><secondary>invoking scripts</secondary></indexterm></para><para id="para_for_unix_like_systems_the_fol">For Unix-like systems, the
      following example demonstrates how to make an executable script.
      Remember that you have to make the permissions executable, e.g.,
      <literal moreinfo="none">chmod +x secho</literal>:</para><programlisting language="sh" format="linespecific"><code role="comment">#!/bin/sh</code>
<code role="statement">exec</code> scala <code role="statement">"</code><code role="preproc">$0</code><code role="statement">"</code> <code role="statement">"</code><code role="preproc">$@</code><code role="statement">"</code>
<code role="statement">!</code><code role="comment">#</code>
<code role="statement">print</code><code role="statement">(</code><code role="statement">"</code><code role="constant">You entered: </code><code role="statement">"</code><code role="statement">)</code>
argv.toList foreach <code role="special">{</code> s <code role="statement">=</code><code role="statement">&gt;</code> format<code role="statement">(</code><code role="statement">"</code><code role="constant">%s </code><code role="statement">"</code>, s<code role="statement">)</code> <code role="special">}</code>
println
</programlisting><para id="para_here_is_how_you_might_use_it_">Here is how you might use
      it:</para><screen format="linespecific">$ secho Hello World
You entered: Hello World</screen><para id="para_similarly_here_is_an_example_">Similarly, here is an
      example Windows <literal moreinfo="none">.bat</literal> command:</para><programlisting language="sh" format="linespecific"><code role="statement">:</code>:<code role="comment">#!</code>
@<code role="statement">echo</code> off
call scala %<code role="constant">0</code> %*
goto :eof
<code role="statement">:</code>:<code role="statement">!</code><code role="comment">#</code>
<code role="statement">print</code><code role="statement">(</code><code role="statement">"</code><code role="constant">You entered: </code><code role="statement">"</code><code role="statement">)</code>
argv.toList foreach <code role="special">{</code> s <code role="statement">=</code><code role="statement">&gt;</code> format<code role="statement">(</code><code role="statement">"</code><code role="constant">%s </code><code role="statement">"</code>, s<code role="statement">)</code> <code role="special">}</code>
println
</programlisting><para id="para_see_the_scala_man_page_in_th">See the
      <literal moreinfo="none">scala</literal> man page in the developer documentation package
      <literal moreinfo="none">scala-devel-docs</literal> to find out more about all the
      command-line options for <literal moreinfo="none">scala</literal>,<indexterm significance="normal"><primary>scala command</primary><secondary>documentation</secondary></indexterm></para><sect3 id="LimitationsOfScalaVsScalac"><title>Limitations of scala versus scalac</title><para id="para_there_are_some_limitations_when_running">There are some
        limitations when running a source file with <literal moreinfo="none">scala</literal>
        versus compiling it with <literal moreinfo="none">scalac</literal>.<indexterm significance="normal"><primary>scalac compiler</primary><secondary>scala command versus</secondary></indexterm><indexterm significance="normal"><primary>scala command</primary><secondary>limitations of, versus scalac</secondary></indexterm></para><para id="para_any_scripts_executed_with_scala">Any scripts executed
        with <literal moreinfo="none">scala</literal> are wrapped in an anonymous
        <literal moreinfo="none">object</literal> that looks more or less like the following
        example:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/script-wrapper.scala</code>

<code role="statement">object</code> <code role="special">Script</code> {
  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>):<code role="type"> Unit</code> = {
    <code role="statement">new</code> <code role="special">AnyRef</code> {
      <code role="comment">// Your script code is inserted here.</code>
    }
  }
}
</programlisting><para id="para_as_of_this_writing_scala_obj">As of this writing, Scala
        <literal moreinfo="none">objects</literal> cannot embed package declarations, and as
        such you can’t declare packages in scripts. This is why the examples
        in this book that declare packages must be compiled and executed
        separately, such as this example from <xref linkend="TypeLessDoMore"/>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/TypeLessDoMore/package-example1.scala</code>

<code role="preproc">package</code> com.example.mypkg

<code role="statement">class</code> <code role="special">MyClass</code> {
  <code role="comment">// ...</code>
}
</programlisting><para id="para_conversely_there_are_valid_sc">Conversely, there are
        valid scripts that can’t be compiled with <literal moreinfo="none">scalac</literal>,
        unless a special <literal role="keep-together" moreinfo="none">-X</literal> option is
        used. For example, function definitions and function invocations
        outside of types are not allowed. The following example runs fine with
        <literal moreinfo="none">scala</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/example-script.scala</code>

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Message</code>(name:<code role="type"> String</code>)

<code role="statement">def</code> <code role="identifier">printMessage</code>(msg:<code role="type"> Message</code>) = {
  println(msg)
}

printMessage(<code role="statement">new</code> <code role="special">Message</code>(
    <code role="constant">"Must compile this script with scalac -Xscript &lt;name&gt;!"</code>))
</programlisting><para id="para_running_this_script">Running this script with
        <literal moreinfo="none">scala</literal> produces the following expected
        output:</para><screen format="linespecific">Message(Must compile this script with scalac -Xscript &lt;name&gt;!)</screen><para id="para_however_if_you_try_to_compile">However, if you try to
        compile the script with <literal moreinfo="none">scalac</literal> (without the
        <literal moreinfo="none">-Xscript</literal> option), you get the following
        errors:<indexterm significance="normal"><primary>scalac compiler</primary><secondary><literal moreinfo="none">-Xscript</literal> option</secondary></indexterm></para><screen format="linespecific">example-script.scala:3: error: expected class or object definition
def printMessage(msg: Message) = {
^
example-script.scala:7: error: expected class or object definition
printMessage(new Message("Must compile this script with scalac -Xscript &lt;name&gt;!"))
^
two errors found</screen><para id="para_the_script_itself_describes_th">The script itself
        describes the solution; to compile this script with
        <literal moreinfo="none">scalac</literal> you must add the option
        <literal moreinfo="none">-Xscript</literal> <replaceable>name</replaceable>, where
        <replaceable>name</replaceable> is the name you want to give the
        compiled class file. For example, using
        <literal moreinfo="none">MessagePrinter</literal> for <replaceable>name</replaceable>
        will result in the creation of several class files with the name
        prefix <literal moreinfo="none">MessagePrinter</literal>:</para><screen format="linespecific">scalac -Xscript MessagePrinter example-script.scala</screen><para id="para_run_msgprinter">You can now run the compiled code with
        the command:</para><screen format="linespecific">scala -classpath . MessagePrinter</screen><para id="para_the_directory_will_contain_the">The current directory
        will contain the following class files:</para><screen format="linespecific">MessagePrinter$$anon$1$Message$.class
MessagePrinter$$anon$1$Message.class
MessagePrinter$$anon$1.class
MessagePrinter$.class
MessagePrinter.class</screen><para id="para_what_are_all_those_files_mes">What are all those files?
        <literal moreinfo="none">MessagePrinter</literal> and
        <literal moreinfo="none">MessagePrinter$</literal> are wrappers generated by
        <literal moreinfo="none">scalac</literal> to provide the entry point for the script as
        an “application.” Recall that we specified
        <literal moreinfo="none">MessagePrinter</literal> as the
        <replaceable>name</replaceable> argument for
        <literal moreinfo="none">-Xscript</literal>. <literal moreinfo="none">MessagePrinter</literal> has the
        <literal moreinfo="none">static main</literal> method we need.</para><para id="para__messageprinter_036_036_ano"><literal moreinfo="none">MessagePrinter$$anon$1</literal>
        is a generated class that wraps the whole script. The
        <literal moreinfo="none">printMes⁠sage</literal> method in the script is a method in
        this class. <literal moreinfo="none">MessagePrinter$$anon$1$Message</literal> and
        <literal moreinfo="none">MessagePrinter$$anon$1$Message$</literal> are the
        <literal moreinfo="none">Message</literal> class and companion object, respectively,
        that are declared in the script. They are nested inside the generated
        class <literal moreinfo="none">MessagePrinter$$anon$1</literal> for the whole script.
        If you want to see what’s inside these class files, use one of the
        decompilers, which we describe next.<indexterm class="endofrange" startref="ch14_scalacommand" significance="normal"/><indexterm class="endofrange" startref="ch14_commandlinescala" significance="normal"/></para></sect3></sect2><sect2 id="CommandLineToolDecompilers"><title>The scalap, javap, and jad Command-Line Tools</title><para id="para_when_you_re_learning_scala_and">When you are learning
      Scala and you want to understand how Scala constructs are mapped to the
      runtime, there are several decompilers that are very useful. They are
      especially useful when you need to invoke Scala code from Java and you
      want to know how Scala names are <emphasis>mangled</emphasis> into
      JVM-compatible names, or you want to understand how the scala compiler
      translates Scala features into valid byte code.<indexterm significance="normal"><primary>decompilers (scalap, javap, and jad)</primary></indexterm><indexterm significance="normal"><primary>scalap tool</primary></indexterm><indexterm significance="normal"><primary>command-line tools</primary><secondary>scalap, javap, and jad</secondary></indexterm></para><para id="para_let_s_discuss_three_decompiler">Let’s discuss three
      decompilers and the benefits they offer. Since the class files generated
      by <literal moreinfo="none">scalac</literal> contain valid JVM byte codes, you can use
      Java decompilers tools:</para><itemizedlist><listitem><para><literal moreinfo="none">scalap</literal> is included with the Scala
          distribution. It outputs declarations as they would appear in Scala
          source code.</para></listitem><listitem><para><literal moreinfo="none">javap</literal> is included with the JDK. It outputs
          declarations as they would appear in Java source code. Therefore,
          running <literal moreinfo="none">javap</literal> on Scala-generated class files is a
          good way to see how Scala definitions are mapped to valid byte
          code.<indexterm significance="normal"><primary>javap tool</primary></indexterm></para></listitem><listitem><para><literal moreinfo="none">jad</literal> is an open source command-line tool
          (see <link linkend="JAD" xrefstyle="select:nopage">[JAD]</link>). It
          attempts to reconstruct an entire Java source file from the class
          file, including method definitions, as well as the
          declarations.<indexterm significance="normal"><primary>jad tool</primary></indexterm></para></listitem></itemizedlist><para id="para_scalap_output"><filename moreinfo="none">MessagePrinter.class</filename>
      is one of the class files generated from the example script in the
      previous section. Let’s run <literal moreinfo="none">scalap -classpath .
      MessagePrinter</literal>. We get the following output:</para><screen format="linespecific">package MessagePrinter;
final class MessagePrinter extends scala.AnyRef {
}
object MessagePrinter {
  def main(scala.Array[java.lang.String]): scala.Unit;
  def $tag(): scala.Int;
    throws java.rmi.RemoteException
}</screen><para id="para_you_can_see_the_main_method_">Note that the first method
      inside <literal moreinfo="none">object MessagePrinter</literal> is the
      <literal moreinfo="none">main</literal> method. The <literal moreinfo="none">$tag</literal> method is
      part of Scala’s internal implementation. It is an abstract method
      defined by <literal moreinfo="none">ScalaObject</literal>. The compiler automatically
      generates implementations for concrete types. The
      <literal moreinfo="none">$tag</literal> method was originally introduced to optimize
      pattern matching, but it is now deprecated and it may be removed in a
      forthcoming release of Scala.<indexterm significance="normal"><primary>ScalaObject class</primary><secondary>$tag method</secondary></indexterm><indexterm significance="normal"><primary sortas="tag method">$tag method (ScalaObject)</primary></indexterm></para><para id="para_javap_output">Let’s compare the <literal moreinfo="none">scalap</literal>
      output to what we get when we run <literal moreinfo="none">javap -classpath .
      MessagePrinter</literal>:</para><screen format="linespecific">Compiled from "(virtual file)"
public final class MessagePrinter extends java.lang.Object{
  public static final void main(java.lang.String[]);
  public static final int $tag()       throws java.rmi.RemoteException;
}</screen><para id="para_javap_output_main_method">Now we see the declaration of
      <literal moreinfo="none">main</literal> as we would typically see it in a Java source
      file.</para><para id="para_jad_output">Finally, to use <literal moreinfo="none">jad</literal>, you
      simply give it the file name of the class file. It generates a
      corresponding output file with the <filename moreinfo="none">.jad</filename> extension.
      If you run <literal moreinfo="none">jad MessagePrinter.class</literal>, you get a long
      file named <filename moreinfo="none">MessagePrinter.jad</filename>. You will also get
      several warnings that <literal moreinfo="none">jad</literal> could not fully decompile
      some methods. We won’t reproduce the output here, but the
      <filename moreinfo="none">.jad</filename> file will print normal Java statements
      interspersed with several sections of JVM byte code instructions, where
      it could not decompile the byte code.</para><para id="para_scalap_javap_jad_help">All these tools have command-line
      help:</para><itemizedlist><listitem><para><literal moreinfo="none">scalap -help</literal></para></listitem><listitem><para><literal moreinfo="none">javap -help</literal></para></listitem><listitem><para><literal moreinfo="none">jad --help</literal></para></listitem></itemizedlist><para id="para_scalap_javap_jad_docs">The Scala developer documentation
      contains documentation for <literal moreinfo="none">scalap</literal>. Similar
      documentation comes with the JDK for <literal moreinfo="none">javap</literal>. The
      <literal moreinfo="none">jad</literal> distribution includes a
      <filename moreinfo="none">README</filename> file with documentation. The Mac and Linux
      distributions also include a man page.</para><para id="para_finally_as_an_exercise_compi">Finally, as an exercise,
      compile the following very simple <literal moreinfo="none">Complex</literal> class,
      representing complex numbers. Then run <literal moreinfo="none">scalap</literal>,
      <literal moreinfo="none">javap</literal>, and <literal moreinfo="none">jad</literal> on the resulting
      class files:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/complex.scala</code>

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Complex</code>(real:<code role="type"> Double</code>, imaginary:<code role="type"> Double</code>) {
  <code role="statement">def</code> <code role="identifier">+</code>(that:<code role="type"> Complex</code>) =
    <code role="statement">new</code> <code role="special">Complex</code>(real + that.real, imaginary + that.imaginary)
  <code role="statement">def</code> <code role="identifier">-</code>(that:<code role="type"> Complex</code>) =
    <code role="statement">new</code> <code role="special">Complex</code>(real - that.real, imaginary - that.imaginary)
}
</programlisting><para id="para_how_are_the_043_and_m">How are the <literal moreinfo="none">+</literal>
      and <literal moreinfo="none">-</literal> methods encoded? What are the names of the
      reader methods for the <literal moreinfo="none">real</literal> and
      <literal moreinfo="none">imaginary</literal> fields? What Java types are used for the
      fields?</para></sect2><sect2 id="CommandLineToolScaladoc"><title>The scaladoc Command-Line Tool</title><para id="para_the_scaladoc_command_is_anal">The
      <literal moreinfo="none">scaladoc</literal> command is analogous to
      <literal moreinfo="none">javadoc</literal>. It is used to generate documentation from
      Scala source files, called Scaladocs. The <literal moreinfo="none">scaladoc</literal>
      parser supports the same <literal moreinfo="none">@</literal> <phrase role="keep-together">annotations</phrase> that
      <literal moreinfo="none">javadoc</literal> supports, such as <literal moreinfo="none">@author</literal>,
      <literal moreinfo="none">@param</literal>, etc.<indexterm significance="normal"><primary>command-line tools</primary><secondary>scaladoc</secondary></indexterm><indexterm significance="normal"><primary>scaladoc tool</primary></indexterm></para><para id="para_if_you_use_scaladoc_for_your">If you use
      <literal moreinfo="none">scaladoc</literal> for your documentation, you might want to
      investigate <literal moreinfo="none">vscaladoc</literal>, an improved
      <literal moreinfo="none">scaladoc</literal> tool that is available at <ulink url="http://code.google.com/p/vscaladoc/"/>. You can also find
      documentation on <literal moreinfo="none">vscaladoc</literal> at <link linkend="ScalaTools" xrefstyle="select:nopage">[ScalaTools]</link>.</para></sect2><sect2 id="CommandLineToolSbaz"><title>The sbaz Command-Line Tool</title><para id="para_scala_bazaar_system_sbaz_i">The Scala Bazaar System
      (<literal moreinfo="none">sbaz</literal>) is a packaging system that helps automate
      maintenance of a Scala installation. It is analogous to the
      <emphasis>gem</emphasis> packaging system for Ruby,
      <emphasis>CPAN</emphasis> for Perl, etc.<indexterm significance="normal"><primary>sbaz tool</primary></indexterm><indexterm significance="normal"><primary>command-line tools</primary><secondary>sbaz</secondary></indexterm></para><para id="para_there_is_a_nice_summary_of_how">There is a nice summary
      of how to use <literal moreinfo="none">sbaz</literal> on the <ulink url="http://www.scala-lang.org/node/93">scala-lang.org website</ulink>.
      All command-line options are described in the developer documentation.
      <xref linkend="sbaz-commands"/> summarizes the most useful
      options.</para><table id="sbaz-commands"><title>The most useful sbaz command options</title><tgroup cols="2"><thead valign="top"><row><entry>Command</entry><entry>Description</entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">sbaz showuniverse</literal></para></entry><entry><para>Show the current “universe” (remote repository).
              Defaults to <ulink url="http://scala-webapps.epfl.ch/sbaz/scala-dev"/>.</para></entry></row><row><entry><para><literal moreinfo="none">sbaz setuniverse</literal>
              <replaceable>univ</replaceable></para></entry><entry><para>Points to a new “universe”
              <replaceable>univ</replaceable>.</para></entry></row><row><entry><para><literal moreinfo="none">sbaz installed</literal></para></entry><entry><para>What’s already installed locally?</para></entry></row><row><entry><para><literal moreinfo="none">sbaz available</literal></para></entry><entry><para>What goodness awaits on the
              Interwebs?</para></entry></row><row><entry><para><literal role="keep-together" moreinfo="none">sbaz install
              scala-devel-docs</literal></para></entry><entry><para>Install the invaluable
              <literal moreinfo="none">scala-devel-docs</literal> package (for
              example).</para></entry></row><row><entry><para><literal moreinfo="none">sbaz upgrade</literal></para></entry><entry><para>Upgrade all installed packages to the latest and
              greatest.</para></entry></row></tbody></tgroup></table><para id="para_note_that_a_remote_repository_">Note that a remote
      repository used by <literal moreinfo="none">sbaz</literal> is called a
      “universe.”<indexterm significance="normal"><primary>universe (sbaz remote repository)</primary></indexterm></para></sect2><sect2 id="CommandLineToolFsc"><title>The fsc Command-Line Tool</title><para id="para_the__fast_offline_scala_comp">The <emphasis>fast
      (offline) scala compiler</emphasis> runs as a daemon process to enable
      faster invocations of the compiler, mostly by eliminating the startup
      overhead. It is particularly useful when running scripts repeatedly (for
      example, when re-running a test suite until a bug can be reproduced). In
      fact, <literal moreinfo="none">fsc</literal> is invoked automatically by the
      <literal moreinfo="none">scala</literal> command. You can also invoke it
      directly.<indexterm significance="normal"><primary>fsc (fast scala compiler) tool</primary></indexterm><indexterm class="endofrange" startref="ch14_commandlinetools" significance="normal"/></para></sect2></sect1><sect1 id="BuildTools"><title>Build Tools</title><para id="para_scala_plugins_have_been_implem">Scala plugins have been
    implemented for several, commonly used build tools, including
    <emphasis><ulink url="http://ant.apache.org/">Ant</ulink></emphasis>,
    <emphasis><ulink url="http://maven.apache.org/">Maven</ulink></emphasis>,
    and <emphasis><ulink url="http://buildr.apache.org/">Buildr</ulink></emphasis>. There are also
    several build tools written in Scala and aimed specifically at Scala
    development. Perhaps the best known example of these tools is SBT (simple
    build tool—see <link linkend="SBT" xrefstyle="select:nopage">[SBT]</link>).<indexterm significance="normal"><primary>SBT (simple build tool)</primary></indexterm><indexterm significance="normal"><primary>Maven build tool</primary></indexterm><indexterm significance="normal"><primary>build tools</primary></indexterm></para><para id="para_build_tools_documented_on_sites">These plugins and tools
    are documented very well on their respective websites, so we refer you to
    those sites for details.<indexterm significance="normal"><primary>Ant, Scala plugin for</primary></indexterm></para><para id="para_ant_support">The Scala distribution includes Ant tasks for
    <literal moreinfo="none">scalac</literal>, <literal moreinfo="none">fsc</literal>, and
    <literal moreinfo="none">scaladoc</literal>. They are used very much like the
    corresponding Java Ant tasks. They are described at <ulink url="http://scala-lang.org/node/98"/>.</para><para id="para_maven_support">A Scala Maven plugin is available at <ulink url="http://scala-tools.org/mvnsites/maven-scala-plugin/"/>. It
    does not require Scala to be installed, as it will download Scala for you.
    Several third-party Scala projects, such as Lift (see <xref linkend="Lift"/>), use Maven.</para><para id="para_buildr_support">Buildr is an Apache project available at
    <ulink url="http://buildr.apache.org/"/>. It is aimed at JVM
    applications written in any language, with built-in support for Scala and
    Groovy as well as Java. It is compatible with Maven repositories and
    project layouts. Since build scripts are written in Ruby, they tend to be
    much more succinct than corresponding Maven files. Buildr is also useful
    for testing JVM applications with Ruby testing tools, like
    <emphasis><ulink url="http://rspec.info">RSpec</ulink></emphasis> and
    <ulink url="http://cukes.info">Cucumber</ulink>, if you use <ulink url="http://jruby.codehaus.org/">JRuby</ulink> to run your
    builds.<indexterm significance="normal"><primary>Buildr tool</primary></indexterm></para><para id="para_sbt_support">The Scala-oriented SBT, available at <ulink url="http://code.google.com/p/simple-build-tool/"/>, has some
    similarities to Buildr. It is also compatible with Maven, but it uses
    Scala as the language for writing build scripts. It also has built-in
    support for generating Scaladocs and for testing with ScalaTest, Specs,
    and ScalaCheck.</para></sect1><sect1 id="IntegrationWithIDEs"><title>Integration with IDEs</title><para id="para_java_background">If you come from a Java background, you
    are probably a little bit spoiled by the rich features of today’s Java
    IDEs. Scala IDE support is not yet as good, but it is evolving rapidly in
    Eclipse, IntelliJ IDEA, and NetBeans. At the time of this writing, all the
    Scala plugins for these IDEs support syntax highlighting, project
    management, limited <phrase role="keep-together">support</phrase> for
    automated refactorings, etc. While each of the plugins has particular
    advantages over the others, they are all close enough in functionality
    that you will probably find it acceptable to adopt the plugin for the IDE
    that you already prefer.<indexterm class="startofrange" id="ch14_IDEs" significance="normal"><primary>IDEs (integrated development environments)</primary></indexterm></para><para id="para_this_section_describes_how_to_">This section describes how
    to use the Scala support available in Eclipse, IntelliJ IDEA, and
    NetBeans. We assume you already know how to use each IDE for development
    in other languages, like Java.</para><sect2 id="_eclipse"><title>Eclipse</title><para id="para_for_details_on_the_eclipse_sca">For details on the
      Eclipse Scala plugin, start at this web page, <ulink url="http://www.scala-lang.org/node/94"/>. If you are interested
      in contributing to the development of the plugin, see this web page,
      <ulink url="http://lampsvn.epfl.ch/trac/scala/wiki/EclipsePlugin"/>.<indexterm significance="normal"><primary>Eclipse IDE</primary><secondary>installing Scala plugin</secondary></indexterm><indexterm significance="normal"><primary>IDEs (integrated development environments)</primary><secondary>Eclipse</secondary><tertiary>installing Scala plugin</tertiary></indexterm></para><sect3 id="_installing_the_scala_plugin"><title>Installing the Scala plugin</title><para id="para_the_plugin_requires_jdk_5_or_h">The plugin requires JDK
        5 or higher (JDK 6 is recommended) and Eclipse 3.3 or higher (Eclipse
        3.4 is recommended). The plugin installs the Scala SDK itself. To
        install the plugin, invoke the “Software Updates” command in the Help
        menu.</para><para id="para_click_the__available_software_">Click the Available
        Software tab and click the “Add Site…” button on the righthand side.
        You will see the dialog shown in <xref linkend="eclipse-add-site"/>.</para><figure float="none" id="eclipse-add-site"><title>The Add Site Eclipse dialog</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1401.pdf" format="PDF" scale="90"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1401.png" format="PNG" scale="90"/></imageobject></mediaobject></figure><?dbfo-need height=”1in”
?><para id="para_enter_the_url_that_shown_in_th">Enter the URL that is
        shown in the figure, <ulink url="http://www.scala-lang.org/scala-eclipse-plugin"/>. Some
        people prefer to work with the <emphasis>nightly</emphasis> releases,
        <ulink url="http://www.scala-lang.org/scala-eclipse-plugin-nightly"/>,
        but you should be aware that there is no guarantee they will
        work!</para><para id="para_select_the_check_box_next_to_t">Select the checkbox
        next to the newly added update site and click the Install button, as
        indicated in <xref linkend="eclipse-install-scala2"/>.
        <emphasis>Don’t</emphasis> click the “default” Close button!</para><figure float="none" id="eclipse-install-scala2"><title>The Software Updates and Add-ons dialog</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1402.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1402.png" format="PNG"/></imageobject></mediaobject></figure><warning id="para_warning_it_is_easy_to_be_conf"><para>It is easy to be confused by the poor usability of the
          Software Updates dialog.</para></warning><para id="para_after_finding_the_plugin_on_th">After finding the
        plugin on the update site, an Install dialog is presented. Click
        through the sequence of screens to complete the installation. You will
        be asked to restart Eclipse when the installation completes.</para></sect3><sect3 id="_developing_scala_applications"><title>Developing Scala applications</title><para id="para_once_the_plugin_is_installed_">Once the plugin is
        installed, you can create Scala projects using the File → New → Other…
        menu item. You will find a <emphasis>Scala Wizards</emphasis> folder
        that contains a wizard called Scala Project. This wizard works just
        like the familiar Java Project Wizard.<indexterm significance="normal"><primary>Eclipse IDE</primary><secondary>developing Scala applications</secondary></indexterm><indexterm significance="normal"><primary>IDEs (integrated development environments)</primary><secondary>Eclipse</secondary><tertiary>developing Scala applications</tertiary></indexterm></para><para id="para_you_can_work_with_your_scala_p">You can work with your
        Scala project using most of the same commands you would use with a
        typical Java project. For example, you can create a new Scala
        <literal moreinfo="none">trait</literal>, <literal moreinfo="none">class</literal>, or
        <literal moreinfo="none">object</literal> using the context menu.</para><para id="para_the_eclipse_scala_plugin_still">The Eclipse Scala
        plugin still has some rough edges, but Scala developers using Eclipse
        should find it acceptable for their daily needs.</para></sect3></sect2><sect2 id="_intellij"><title>IntelliJ</title><para id="para_the_intellij__idea__team_provi">The IntelliJ
      <emphasis>IDEA</emphasis> team provides a
      <emphasis>beta</emphasis>-quality Scala plugin. Start here for details:
      <ulink url="http://www.jetbrains.net/confluence/display/SCA/Scala+Plugin+for+IntelliJ+IDEA"/>.<indexterm significance="normal"><primary>IntelliJ IDEA</primary><secondary>installing Scala plugins</secondary></indexterm><indexterm significance="normal"><primary>IDEs (integrated development environments)</primary><secondary>IntelliJ</secondary><tertiary>installing Scala plugins</tertiary></indexterm></para><sect3 id="_installing_the_scala_plugins"><title>Installing the Scala plugins</title><para id="para_to_use_the_plugin_you_must_us">To use the plugin, you
        must use IntelliJ 8.0.X or later. Consider using the most recent “EAP”
        build for the latest feature updates.</para><para id="para_to_install_the_scala_plugin_s">To install the Scala
        plugin, start IDEA. Open the Settings panel, e.g., using the File →
        Settings menu item. On the lefthand side, scroll down to and click the
        Plugins item, as shown in <xref linkend="idea-settings-plugins"/>.</para><figure float="none" id="idea-settings-plugins"><title>IntelliJ IDEA Settings → Plugins</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1403.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1403.png" format="PNG"/></imageobject></mediaobject></figure><para id="para_select_the__available__tab_on_">Select the Available
        tab on the righthand side. Scroll down to the Scala plugin, as shown
        in <xref linkend="idea-settings-plugins-scala"/>.</para><figure float="none" id="idea-settings-plugins-scala"><title>Available IntelliJ IDEA Scala plugins</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1404.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1404.png" format="PNG"/></imageobject></mediaobject></figure><?dbfo-need height=”2in”
?><para id="para_right_click_the__scala__plugin">Right-click the Scala
        plugin name and select “Download and Install” from the menu. Repeat
        for the Scala Application plugin. You will have to restart IDEA for
        the plugins to be enabled.</para><para id="para_after_idea_restarts_confirm_t">After IDEA restarts,
        confirm that the two plugins were installed correctly by reopening the
        Plugin Manager. Click the Installed tab and scroll down to find the
        two Scala plugins. They should be listed with a black font, and the
        checkboxes next to them should be checked, as seen in <xref linkend="idea-settings-plugins-confirm"/>.</para><figure float="none" id="idea-settings-plugins-confirm"><title>Installed IntelliJ IDEA Scala plugins</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1405.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1405.png" format="PNG"/></imageobject></mediaobject></figure><para id="para_if_the_font_is_red_or_the_chec">If the font is red or
        the checkboxes are not checked, refer to the Scala plugin web page
        above for debugging help.<indexterm significance="normal"><primary>IntelliJ IDEA</primary><secondary>developing Scala applications</secondary></indexterm></para></sect3><sect3 id="_developing_scala_applications_2"><title>Developing Scala applications</title><para id="para_to_create_an_idea_scala_project_sta">To create an IDEA
        Scala project, start by selecting the File → New Project menu item. In
        the dialog, select the appropriate radio button for your situation,
        e.g., “Create New Project from Scratch.”</para><para id="para_on_the_next_screen_select__ja">On the next screen,
        select “Java Module” and fill in the usual project information. An
        example is shown in <xref linkend="idea-new-project1a"/>.<indexterm significance="normal"><primary>IDEs (integrated development environments)</primary><secondary>IntelliJ</secondary><tertiary>developing Scala applications</tertiary></indexterm></para><figure float="none" id="idea-new-project1a"><title>Specifying IntelliJ IDEA Scala project details</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1406.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1406.png" format="PNG"/></imageobject></mediaobject></figure><para id="para_click_through_to_the_screen_ti">Click through to the
        screen titled “Please Select Desired Technology.” Check the “Scala”
        checkbox, and check the “New Scala SDK” checkbox. Click the button
        labeled “…” to navigate to the location of your Scala SDK
        installation, as shown in <xref linkend="idea-new-project1b"/>. You
        will only need to specify the SDK the first time you create a project
        or when you install a new SDK in a different location.</para><figure float="none" id="idea-new-project1b"><title>Adding Scala to the IntelliJ IDEA project</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1407.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1407.png" format="PNG"/></imageobject></mediaobject></figure><para id="para_click__finish__you_will_be_pr">Click Finish. You will
        be prompted to create either a project or an application. Select
        “Application” if you want to share this project with other Scala
        projects on the same machine.</para><para id="para_now_you_can_work_with_your_sca">Now you can work with
        your Scala project using most of the same commands you would use with
        a typical Java project. For example, you can create a new Scala
        <literal moreinfo="none">trait</literal>, <literal moreinfo="none">object</literal>, or
        <literal moreinfo="none">class</literal> using the context menu, as for Java
        projects.</para><para id="para_the_intellij_idea_scala_plugin">The IntelliJ IDEA Scala
        plugin is still <emphasis>beta</emphasis>-quality, but Scala
        developers using IDEA should find it acceptable for their daily
        needs.</para></sect3></sect2><sect2 id="_netbeans"><title>NetBeans</title><para id="para_netbeans_has__beta__quality_sc">NetBeans has
      <emphasis>beta</emphasis>-quality Scala plugins. Start at this web page
      for details, <ulink url="http://wiki.netbeans.org/Scala"/>.
      NetBeans 6.5 or a more recent nightly build is required. The Scala
      plugin contains a version of the Scala SDK. The wiki page provides
      instructions for using a different SDK, when desired.<indexterm significance="normal"><primary>NetBeans</primary><secondary>installing Scala plugins</secondary></indexterm><indexterm significance="normal"><primary>IDEs (integrated development environments)</primary><secondary>NetBeans</secondary><tertiary>installing Scala plugins</tertiary></indexterm></para><sect3 id="_installing_the_scala_plugins_2"><title>Installing the Scala plugins</title><para id="para_to_install_the_plugin_downloa">To install the plugin,
        download the plugins ZIP file from <ulink url="http://sourceforge.net/project/showfiles.php?group_id=192439&amp;package_id=256544"/>.
        Unzip the file in a convenient directory.</para><para id="para_start_netbeans_and_invoke_the_">Start NetBeans and
        invoke the Tools → Plugins menu item. Select the Downloaded tab and
        click the “Add Plugins…” button. Choose the directory where the Scala
        plugins are unzipped, and select all the listed
        <filename moreinfo="none">*.nbm</filename> files, as shown in <xref linkend="netbeans-add-plugins"/>. Click Open.</para><figure float="none" id="netbeans-add-plugins"><title>Adding the Scala plugins to be installed</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1408.pdf" format="PDF" scale="90"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1408.png" format="PNG" scale="90"/></imageobject></mediaobject></figure><para id="para_back_in_the__plugins__dialog_">Back in the Plugins
        dialog, make sure the checkboxes for all the new plugins are checked.
        Click Install.</para><para id="para_click_through_the_installation">Click through the
        installation dialog and restart NetBeans when finished.</para></sect3><sect3 id="_developing_scala_applications_3"><title>Developing Scala applications</title><para id="para_to_create_a_netbeans_scala_project_sta">To create a
        NetBeans Scala Project, start by selecting the File → New Project menu
        item or clicking the New Project button. In the pop-up dialog, select
        “Scala” under Categories and “Scala Application” under Projects, as
        shown in <xref linkend="netbeans-new-project1"/>. Click
        Next.<indexterm significance="normal"><primary>IDEs (integrated development environments)</primary><secondary>NetBeans</secondary><tertiary>developing Scala applications</tertiary></indexterm><indexterm significance="normal"><primary>NetBeans</primary><secondary>developing Scala applications</secondary></indexterm></para><figure float="none" id="netbeans-new-project1"><title>Creating a new NetBeans Scala project</title><mediaobject><imageobject role="print"><imagedata fileref="figs/print/prsc_1409.pdf" format="PDF"/></imageobject><imageobject role="web"><imagedata fileref="figs/web/prsc_1409.png" format="PNG"/></imageobject></mediaobject></figure><para id="para_fill_in_the_project_name_loca">Fill in the project
        name, location, etc., and click Finish.</para><para id="para_once_the_project_is_creates_y">Once the project is
        created, you can work with it using most of the same commands you
        would use with a typical Java project. There are some differences. For
        example, when you invoke the New item in the context menu, the submenu
        does not show items for creating new Scala types. Instead, you have
        invoke the Other… menu item and work through a dialog. This will be
        changed in a future release.</para><para id="para_despite_some_minor_issues_like">Despite some minor
        issues like this, the NetBeans Scala plugin is mature enough for
        regular use.</para></sect3></sect2><sect2 id="_text_editors"><title>Text Editors</title><para id="para_the_sbaz_tool_manages_the_s">The <literal moreinfo="none">sbaz</literal>
      tool manages the <literal moreinfo="none">scala-tool-support</literal> package that
      includes Scala plugins for several editors, including Emacs, Vim,
      TextMate and others. Like <literal moreinfo="none">sbaz</literal>, the
      <literal moreinfo="none">scala-tool-support</literal> package is also included with the
      language installation. See the directories in
      <replaceable>scala-home</replaceable><filename moreinfo="none">/misc/scala-tool-support</filename>
      for the supported editors. Most of the <phrase role="keep-together">editor-</phrase><phrase role="keep-together">specific</phrase> directories contain instructions
      for installing the plugin. In other cases, consult your editor’s
      instructions for installing third-party plugins.<indexterm significance="normal"><primary>Mac OS X</primary><secondary>TextMate editor</secondary></indexterm><indexterm significance="normal"><primary>Vim editor</primary></indexterm><indexterm significance="normal"><primary>Emacs editor</primary></indexterm><indexterm significance="normal"><primary>TextMate editor</primary></indexterm><indexterm significance="normal"><primary>scala-tool-support package</primary></indexterm><indexterm significance="normal"><primary>text editors</primary></indexterm><indexterm significance="normal"><primary>IDEs (integrated development environments)</primary><secondary>text editors</secondary></indexterm></para><para id="para_some_of_the_packages_are_fairl">Some of the packages are
      fairly immature. If you want to contribute to the Scala community,
      please consider improving the quality of the existing plugins or
      contributing new plugins.<indexterm class="endofrange" startref="ch14_IDEs" significance="normal"/></para><note id="para_note_at_the_time_of_this_writ"><para>At the time of this writing, there are several variations of a
        Scala “bundle” for the TextMate editor, which is a popular text editor
        for Mac OS X. These bundles are currently being managed by Paul
        Phillips on the <ulink url="http://github.com/paulp/scala-textmate/tree/master">GitHub
        website</ulink>. Hopefully, the best features of each bundle will be
        unified into an “authoritative” bundle and integrated back into the
        <literal moreinfo="none">scala-tool-support</literal> <phrase role="keep-together">package</phrase>.</para></note></sect2></sect1><sect1 id="_test_driven_development_in_scala"><title>Test-Driven Development in Scala</title><para id="para_one_of_the_most_important_deve">One of the most important
    developer practices introduced in the last decade is <emphasis>Test-Driven
    Development</emphasis> (TDD). The Scala community has created several
    tools to support TDD.<indexterm class="startofrange" id="ch14_TDD" significance="normal"><primary>TDD (Test-Driven Development)</primary></indexterm></para><para id="para_if_you_work_in_a_pure_java">If you work in a “pure” Java
    shop, consider introducing one or more of these Scala testing tools to
    test-drive your Java code. This approach is a low-risk way to introduce
    Scala to your environment, so you can gain experience with it before
    making the commitment to Scala as your production code language. In
    particular, you might experiment with ScalaTest (see <xref linkend="ScalaTest" xrefstyle="select:nopage"/> next), which can be used
    with JUnit (<link linkend="JUnit" xrefstyle="select:nopage">[JUnit]</link>) and TestNG (<link linkend="TestNG" xrefstyle="select:nopage">[TestNG]</link>). You might
    also consider ScalaCheck or Reductio (see <xref linkend="ScalaCheck"/>),
    which offer innovations that may not be available in Java testing
    frameworks. All of the tools we describe here integrate with Java testing
    and build tools, like JUnit, TestNG, various mocking libraries, Ant (<link linkend="Ant" xrefstyle="select:nopage">[Ant]</link>), and Maven (<link linkend="Maven" xrefstyle="select:nopage">[Maven]</link>). All of them
    also offer convenient Scala DSLs for testing.</para><sect2 id="ScalaTest"><title>ScalaTest</title><para id="para_scala_s_version_of_the_venerab">Scala’s version of the
      venerable XUnit tool is ScalaTest, available at <ulink url="http://www.artima.com/scalatest/"/>.<indexterm significance="normal"><primary>ScalaTest</primary></indexterm><indexterm significance="normal"><primary>TDD (Test-Driven Development)</primary><secondary>ScalaTest tool</secondary></indexterm></para><para id="para_you_can_drive_your_tests_using">You can drive your tests
      using the built-in <literal moreinfo="none">Runner</literal> or use the provided
      integration with JUnit or TestNG. ScalaTest also comes with an Ant task
      and it works with the ScalaCheck testing tool (described later).</para><para id="para_besides_supporting_the_traditi">Besides supporting the
      traditional XUnit-style syntax with test methods and assertions,
      ScalaTest provides a <emphasis>Behavior-Driven Development</emphasis>
      (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>) syntax that
      is becoming increasingly popular. The <ulink url="http://www.artima.com/scalatest/"><emphasis>ScalaTest</emphasis>
      website</ulink> provides examples for these and other options.<indexterm significance="normal"><primary>BDD (Behavior-Driven Development)</primary><secondary>BDD syntax provided by ScalaTest</secondary></indexterm></para><para id="para_here_is_an_example_test_for_th">Here is an example
      ScalaTest test for the simple <literal moreinfo="none">Complex</literal> class we used
      in <xref linkend="CommandLineToolDecompilers"/>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/complex-test.scala</code>

<code role="preproc">import</code> org.scalatest.FunSuite

<code role="statement">class</code> <code role="special">ComplexSuite</code> <code role="statement">extends</code> <code role="special">FunSuite</code> {

  <code role="statement">val</code> c1 = <code role="special">Complex</code>(<code role="constant">1.2</code>, <code role="constant">3.4</code>)
  <code role="statement">val</code> c2 = <code role="special">Complex</code>(<code role="constant">5.6</code>, <code role="constant">7.8</code>)

  test(<code role="constant">"addition with (0, 0)"</code>) {
    assert(c1 + <code role="special">Complex</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>) === c1)
  }

  test(<code role="constant">"subtraction with (0, 0)"</code>) {
    assert(c1 - <code role="special">Complex</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>) === c1)
  }

  test(<code role="constant">"addition"</code>) {
    assert((c1 + c2).real === (c1.real + c2.real))
    assert((c1 + c2).imaginary === (c1.imaginary + c2.imaginary))
  }

  test(<code role="constant">"subtraction"</code>) {
    assert((c1 - c2).real === (c1.real - c2.real))
    assert((c1 - c2).imaginary === (c1.imaginary - c2.imaginary))
  }
}
</programlisting><para id="para_this_particular_example_uses_t">This particular example
      uses the “function value” syntax for each test that is provided by the
      <literal moreinfo="none">FunSuite</literal> parent trait. Each call to
      <literal moreinfo="none">test</literal> receives as arguments a descriptive string and a
      <emphasis>function literal</emphasis> with the actual test code.</para><para id="para_the_following_commands_compile">The following commands
      compile <filename moreinfo="none">complex.scala</filename> and
      <filename moreinfo="none">complex-test.scala</filename>, putting the class files in a
      <filename moreinfo="none">build</filename> directory, and then run the tests. Note that
      we assume that <filename role="http://github.com/paulp/scala-textmate/tree/master" moreinfo="none">scalatest-0.9.5.jar</filename>
      (the latest release at the time of this writing) is in the
      <filename moreinfo="none">../lib</filename> directory. The downloadable distribution of
      the code examples is organized this way:</para><screen format="linespecific">scalac -classpath ../lib/scalatest-0.9.5.jar -d build complex.scala complex-test.scala
scala -classpath build:../lib/scalatest-0.9.5.jar org.scalatest.tools.Runner \
  -p build -o -s ComplexSuite</screen><para>(We used a <literal moreinfo="none">\</literal> to continue the long command on a
      second line.) The output is the following:</para><screen format="linespecific">Run starting. Expected test count is: 4
Suite Starting - ComplexSuite: The execute method of a nested suite is \
   about to be invoked.
Test Starting - ComplexSuite: addition with (0, 0)
Test Succeeded - ComplexSuite: addition with (0, 0)
Test Starting - ComplexSuite: subtraction with (0, 0)
Test Succeeded - ComplexSuite: subtraction with (0, 0)
Test Starting - ComplexSuite: addition
Test Succeeded - ComplexSuite: addition
Test Starting - ComplexSuite: subtraction
Test Succeeded - ComplexSuite: subtraction
Suite Completed - ComplexSuite: The execute method of a nested suite \
  returned normally.
Run completed. Total number of tests run was: 4
All tests passed.</screen><para id="para_again_we_wrapped_the_long_out">Again, we wrapped the long
      output lines with a <literal moreinfo="none">\</literal>.</para></sect2><sect2 id="ScalaSpecs"><title>Specs</title><para id="para_the__specs__library_http_co">The Specs library (<link linkend="ScalaSpecsTool" xrefstyle="select:nopage">[ScalaSpecsTool]</link>) is a Behavior-Driven
      Development (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>)
      testing tool for Scala. It is inspired by Ruby’s RSpec (<link linkend="RSpec" xrefstyle="select:nopage">[RSpec]</link>). In a
      nutshell, the goal of BDD is to recast traditional test syntax into a
      form that better emphasizes the role of TDD as a process that drives
      <emphasis>design</emphasis>, which in turn should implement the
      <emphasis>requirements</emphasis> “specification.” The syntax of
      traditional TDD tools, like the XUnit frameworks, tend to emphasize the
      <emphasis>testing</emphasis> role of TDD. With the syntax realigned, it
      is believed that the developer will be more likely to stay focused on
      the <emphasis>primary</emphasis> role of TDD: driving application
      design.<indexterm significance="normal"><primary>requirements specification</primary></indexterm><indexterm class="startofrange" id="ch14_BDDSpecs" significance="normal"><primary>BDD (Behavior-Driven Development)</primary><secondary>Specs library</secondary></indexterm><indexterm class="startofrange" id="ch14_TDDSpecs" significance="normal"><primary>TDD (Test-Driven Development)</primary><secondary>Specs library</secondary></indexterm><indexterm class="startofrange" id="ch14_Specs" significance="normal"><primary>Specs library</primary></indexterm></para><para id="para_you_can_also_find_documentation">You can also find
      documentation on Specs at <link linkend="ScalaTools" xrefstyle="select:nopage">[ScalaTools]</link>.</para><para id="para_we_have_already_used__specs__i">We have already used
      Specs in several examples in the book, e.g.,
      <literal moreinfo="none">ButtonObserverSpec</literal> in <xref linkend="TraitsAsMixins"/>. Here is another example for the simple
      <literal role="keep-together" moreinfo="none">Complex</literal> class we showed
      previously:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/complex-spec.scala</code>

<code role="preproc">import</code> org.specs._

<code role="statement">object</code> <code role="special">ComplexSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"Complex addition with (0.0, 0.0)"</code> should {
    <code role="constant">"return a number N' that is identical to original number N"</code> in {
      <code role="statement">val</code> c1 = <code role="special">Complex</code>(<code role="constant">1.2</code>, <code role="constant">3.4</code>)
      (c1 + <code role="special">Complex</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>)) mustEqual c1
    }
  }
  <code role="constant">"Complex subtraction with (0.0, 0.0)"</code> should {
    <code role="constant">"return a number N' that is identical to original number N"</code> in {
      <code role="statement">val</code> c1 = <code role="special">Complex</code>(<code role="constant">1.2</code>, <code role="constant">3.4</code>)
      (c1 - <code role="special">Complex</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>)) mustEqual c1
    }
  }
  <code role="constant">"Complex addition"</code> should {
    <code role="constant">"""return a new number where</code>
<code role="constant">    the real and imaginary parts are the sums of the</code>
<code role="constant">    input values' real and imaginary parts, respectively."""</code> in {
      <code role="statement">val</code> c1 = <code role="special">Complex</code>(<code role="constant">1.2</code>, <code role="constant">3.4</code>)
      <code role="statement">val</code> c2 = <code role="special">Complex</code>(<code role="constant">5.6</code>, <code role="constant">7.8</code>)
      (c1 + c2).real mustEqual (c1.real + c2.real)
      (c1 + c2).imaginary mustEqual (c1.imaginary + c2.imaginary)
    }
  }
  <code role="constant">"Complex subtraction"</code> should {
    <code role="constant">"""return a new number where</code>
<code role="constant">    the real and imaginary parts are the differences of the</code>
<code role="constant">    input values' real and imaginary parts, respectively."""</code> in {
      <code role="statement">val</code> c1 = <code role="special">Complex</code>(<code role="constant">1.2</code>, <code role="constant">3.4</code>)
      <code role="statement">val</code> c2 = <code role="special">Complex</code>(<code role="constant">5.6</code>, <code role="constant">7.8</code>)
      (c1 - c2).real mustEqual (c1.real - c2.real)
      (c1 - c2).imaginary mustEqual (c1.imaginary - c2.imaginary)
    }
  }
}
</programlisting><para id="para_an_object_that_extends_spec">An <literal moreinfo="none">object</literal>
      that extends <literal moreinfo="none">Specification</literal> is the analog of a test
      suite. The next level of grouping, e.g., the clause <literal moreinfo="none">"Complex
      addition with (0.0, 0.0)" should {...}</literal>, encapsulates the
      information at the level of the type being tested, or perhaps a
      “cluster” of behaviors that go together for the type.</para><para id="para_the_next_level_clause__e_g__">The next level clause,
      e.g., the clause <literal moreinfo="none">"return a number N' that is identical to
      orig⁠inal number N" in {...}</literal>, is called an “example” in BDD
      terminology. It is analogous to a single test. Like typical XUnit
      frameworks, the testing is done using “representative examples,” rather
      than by doing an exhaustive exploration of the entire “space” of
      possible states. Hence, the term “example.” (However, see the discussion
      of <phrase role="keep-together">ScalaCheck</phrase> next.)</para><para id="para_statements_like_c1_complex">Statements like <literal moreinfo="none">(c1
      + Complex(0.0, 0.0)) mustEqual c1</literal> are called “expectations.”
      They do the actual verifications that conditions are satisfied. Hence,
      expectations are analogous to assertions in XUnit tools.<indexterm significance="normal"><primary>expectations</primary></indexterm></para><para id="para_there_are_several_ways_to_run_">There are several ways to
      run your specs. After compiling <filename moreinfo="none">complex-spec.scala</filename>
      earlier, we can run the specs as follows:</para><screen format="linespecific">scala -classpath ../lib/specs-1.4.3.jar:build ComplexSpec</screen><para id="para_here_as_before_we_assume_the">Here, as before, we assume
      the <filename moreinfo="none">Specs</filename> JAR is in the <filename moreinfo="none">../lib</filename>
      directory and we assume the compiled class files are in the
      <filename moreinfo="none">build</filename> directory. We get the following
      output:</para><screen format="linespecific">Specification "ComplexSpec"
  Complex addition with (0.0, 0.0) should
  + return a number N' that is identical to original number N

  Total for SUT "Complex addition with (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  Complex subtraction with (0.0, 0.0) should
  + return a number N' that is identical to original number N

  Total for SUT "Complex subtraction with (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  Complex addition should
  + return a new number where
        the real and imaginary parts are the sums of the
        input values real and imaginary parts, respectively.

  Total for SUT "Complex addition":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

  Complex subtraction should
  + return a new number where
        the real and imaginary parts are the differences of the
        input values real and imaginary parts, respectively.

  Total for SUT "Complex subtraction":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

Total for specification "ComplexSpec":
Finished in 0 second, 37 ms
4 examples, 6 expectations, 0 failure, 0 error</screen><para id="para_note_that_the_strings_in_the_s">Note that the strings in
      the specification are written in a form that reads somewhat like a
      requirements specification:</para><screen format="linespecific">...
Complex addition with (0.0, 0.0) should
+ return a number N' that is identical to original number N
...</screen><para id="para_there_are_many_ways_to_run_spe">There are many ways to
      run specifications, including using an Ant task or using the built-in
      integration with ScalaTest or JUnit. JUnit is the best approach for
      running specifications in some IDEs. These and other options are
      described in the User’s Guide at <ulink url="http://code.google.com/p/specs/wiki/RunningSpecs"/>.<indexterm class="endofrange" startref="ch14_BDDSpecs" significance="normal"/><indexterm significance="normal"><primary>JUnit</primary><secondary>running specifications</secondary></indexterm><indexterm class="endofrange" startref="ch14_TDDSpecs" significance="normal"/><indexterm class="endofrange" startref="ch14_Specs" significance="normal"/></para></sect2><sect2 id="ScalaCheck"><title>ScalaCheck</title><para id="para__scalacheck__http_code_goog">ScalaCheck (<link linkend="ScalaCheckTool" xrefstyle="select:nopage">[ScalaCheckTool]</link> is a Scala port of the
      innovative Haskell QuickCheck (<link linkend="QuickCheck" xrefstyle="select:nopage">[QuickCheck]</link>) tool that supports
      <emphasis>Automated Specification-Based Testing</emphasis>, sometimes
      called <emphasis>type-based “property” testing</emphasis> in the Haskell
      literature (e.g., <link linkend="OSullivan2009" xrefstyle="select:nopage">[O’Sullivan2009]</link>).<indexterm significance="normal"><primary>QuickCheck (Haskell)</primary></indexterm><indexterm significance="normal"><primary>Haskell, QuickCheck tool</primary></indexterm><indexterm significance="normal"><primary>ScalaCheck</primary></indexterm><indexterm significance="normal"><primary>TDD (Test-Driven Development)</primary><secondary>ScalaCheck tool</secondary></indexterm></para><para id="para__scalacheck__can_be_installed_">ScalaCheck can be
      installed using <literal moreinfo="none">sbaz</literal>, i.e., <literal moreinfo="none">sbaz install
      scalacheck</literal>.<indexterm significance="normal"><primary>sbaz tool</primary><secondary>installing ScalaCheck</secondary></indexterm></para><para id="para_using__scalacheck__or__quickc">Using ScalaCheck (or
      QuickCheck for Haskell), conditions for a type are specified that should
      be true for any instances of the type. The tool tries the conditions
      using automatically generated instances of the type and verifies that
      the conditions are satisfied.</para><para id="para_here_is_a__scalacheck__test_fo">Here is a ScalaCheck test
      for <literal moreinfo="none">Complex</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/complex-check-script.scala</code>

<code role="preproc">import</code> org.scalacheck._
<code role="preproc">import</code> org.scalacheck.Prop._

<code role="statement">def</code> <code role="identifier">toD</code>(i:<code role="type"> Int</code>) = i * <code role="constant">.1</code>

<code role="statement">implicit</code> <code role="statement">def</code> <code role="identifier">arbitraryComplex</code>:<code role="type"> Arbitrary[Complex]</code> = <code role="special">Arbitrary</code> {
  Gen.sized {s <code role="statement">=&gt;</code>
    <code role="statement">for</code> {
      r <code role="statement">&lt;-</code> Gen.choose(-toD(s), toD(s))
      i <code role="statement">&lt;-</code> Gen.choose(-toD(s), toD(s))
    } <code role="statement">yield</code> <code role="special">Complex</code>(r, i)
  }
}

<code role="statement">object</code> <code role="special">ComplexSpecification</code> <code role="statement">extends</code> <code role="special">Properties</code>(<code role="constant">"Complex"</code>) {
  <code role="statement">def</code> <code role="identifier">additionTest</code>(a:<code role="type"> Complex</code>, b:<code role="type"> Complex</code>) =
    (a + b).real.equals(a.real + b.real) &amp;&amp;
    (a + b).imaginary.equals(a.imaginary + b.imaginary)

  <code role="statement">def</code> <code role="identifier">subtractionTest</code>(a:<code role="type"> Complex</code>, b:<code role="type"> Complex</code>) =
    (a - b).real.equals(a.real - b.real) &amp;&amp;
    (a - b).imaginary.equals(a.imaginary - b.imaginary)

  <code role="statement">val</code> zero = <code role="special">Complex</code>(<code role="constant">0.0</code>, <code role="constant">0.0</code>)

  specify(<code role="constant">"addition with (0,0)"</code>, (a:<code role="type"> Complex</code>)  <code role="statement">=&gt;</code> additionTest(a, zero))
  specify(<code role="constant">"subtraction with (0,0)"</code>, (a:<code role="type"> Complex</code>)  <code role="statement">=&gt;</code> subtractionTest(a, zero))

  specify(<code role="constant">"addition"</code>, (a:<code role="type"> Complex</code>, b:<code role="type"> Complex</code>) <code role="statement">=&gt;</code> additionTest(a,b))
  specify(<code role="constant">"subtraction"</code>, (a:<code role="type"> Complex</code>, b:<code role="type"> Complex</code>) <code role="statement">=&gt;</code> subtractionTest(a,b))
}
ComplexSpecification.check
</programlisting><para id="para_the_tod_function_just_conver">The <literal moreinfo="none">toD</literal>
      function just converts an <literal moreinfo="none">Int</literal> to a
      <literal moreinfo="none">Double</literal> by dividing by <literal moreinfo="none">0.1</literal>. It’s
      useful to convert an <literal moreinfo="none">Int</literal> index provided by ScalaCheck
      into <literal moreinfo="none">Double</literal> values that we will use to construct
      <literal moreinfo="none">Complex</literal> instances.</para><para id="para_we_also_need_an_implicit_conve">We also need an implicit
      conversion visible in the scope of the test that generates <phrase role="keep-together">new <literal moreinfo="none">Complex</literal> </phrase>values. The
      <literal role="keep-together" moreinfo="none">arbitraryComplex</literal> function
      provides this generator. An <literal role="keep-together" moreinfo="none">Arbitrary[Complex]</literal> object (part of the
      ScalaCheck API) is returned by this method. <phrase role="keep-together">ScalaCheck</phrase> invokes another API method,
      <literal moreinfo="none">Gen[Complex].sized</literal>. We provide a <emphasis>function
      literal</emphasis> that assigns a passed-in <literal moreinfo="none">Int</literal> value
      to a variable <literal moreinfo="none">s</literal>. We then use a <literal moreinfo="none">for</literal>
      comprehension to return <literal moreinfo="none">Complex</literal> numbers with real and
      imaginary parts that range from <literal moreinfo="none">-toD(s)</literal> to
      <literal moreinfo="none">toD(s)</literal> (i.e., <literal moreinfo="none">-(s * .1)</literal> to
      <literal moreinfo="none">(s * .1)</literal>). Fortunately, you don’t have to define
      implicit conversions or generators for most of the commonly used Scala
      and Java types.</para><para id="para_the_most_interesting_part_is_t">The most interesting part
      is the definition and use of <literal moreinfo="none">ComplexSpecification</literal>.
      This object defines a few helper methods,
      <literal moreinfo="none">additionTest</literal> and <literal moreinfo="none">subtractionTest</literal>,
      that each return <literal moreinfo="none">true</literal> if the conditions they define
      are true. For <literal moreinfo="none">additionTest</literal>, if a new
      <literal moreinfo="none">Complex</literal> number is the sum of two other
      <literal moreinfo="none">Complex</literal> numbers, then its <literal moreinfo="none">real</literal>
      part must equal the sum of the <literal moreinfo="none">real</literal> parts of the two
      original numbers. Likewise, a similar condition must hold for the
      <literal moreinfo="none">imaginary</literal> part of the numbers. For
      <literal moreinfo="none">subtractionTest</literal>, the same conditions must hold with
      subtraction substituted for addition.</para><para id="para_next_two_specify_clauses_as">Next, two
      <literal moreinfo="none">specify</literal> clauses assert that the addition and
      subtraction conditions should hold for any <literal moreinfo="none">Complex</literal>
      number when <literal moreinfo="none">Complex(0.0, 0.0)</literal> is added to it or
      subtracted from it, respectively. Two more <literal moreinfo="none">specify</literal>
      classes assert that the conditions should also hold for any pair of
      <literal moreinfo="none">Complex</literal> numbers.</para><para id="para_finally_when_complexspecific">Finally, when
      <literal moreinfo="none">ComplexSpecification.check</literal> is called, test runs are
      made with different values of <literal moreinfo="none">Complex</literal> numbers,
      verifying that the properties specified are valid for each combination
      of numbers passed to the helper methods.</para><para id="para_we_can_run_the_check_using_the">We can run the check
      using the following command (once again assuming that <literal role="keep-together" moreinfo="none">Complex</literal> is already compiled into the
      <filename moreinfo="none">build</filename> directory):</para><screen format="linespecific">scala -classpath ../lib/scalacheck.jar:build complex-check-script.scala</screen><para id="para_it_produces_the_following_outp">It produces the following
      output:</para><screen format="linespecific">+ Complex.addition with (0,0): OK, passed 100 tests.
+ Complex.addition: OK, passed 100 tests.
+ Complex.subtraction with (0,0): OK, passed 100 tests.
+ Complex.subtraction: OK, passed 100 tests.</screen><para id="para_note_that_by_default__scalach">Note that ScalaCheck tried
      each <literal moreinfo="none">specify</literal> case with 100 different inputs.</para><para id="para_it_s_important_to_understand_t">It’s important to
      understand the value that ScalaCheck delivers. Rather than going through
      the process of writing enough “example” test cases with representative
      data, which is tedious and error-prone, we define reusable “generators,”
      like the <literal moreinfo="none">arbitraryComplex</literal> function, to produce an
      appropriate range of instances of the type under test. Then we write
      property specifications that should hold for any instances. ScalaCheck
      does the work of testing the properties against a random sample of the
      instances produced by the generators.</para><para id="para_you_can_find_more_examples_of_">You can find more
      examples of ScalaCheck usage in the online code examples. Some of the
      types used in the payroll example in <xref linkend="InternalDSLs"/>
      were tested with ScalaCheck. These tests were not shown in <xref linkend="InternalDSLs"/>.</para><para id="para_finally_note_that_there_is_an">Finally, note that there
      is another port of QuickCheck called <emphasis>Reductio</emphasis>. It
      is part of the <emphasis>Functional Java</emphasis> project (<link linkend="FunctionalJava" xrefstyle="select:nopage">[FunctionalJava]</link>).
      <emphasis>Reductio</emphasis> is less widely used than ScalaCheck, but
      it offers a “native” Java API as well as a Scala API, so it would be
      more convenient for “pure” Java teams.<indexterm significance="normal"><primary>Functional Java project</primary></indexterm><indexterm significance="normal"><primary>Reductio tool</primary></indexterm><indexterm class="endofrange" startref="ch14_TDD" significance="normal"/></para></sect2></sect1><sect1 id="OtherLibraries"><title>Other Notable Scala Libraries and Tools</title><para id="para_while_scala_benefits_from_the_">While Scala benefits from
    the rich legacy of Java and .NET libraries, there is a growing collection
    of libraries written specifically for Scala. Here we discuss some of the
    more notable ones.<indexterm significance="normal"><primary>libraries</primary><secondary>notable Scala libraries</secondary></indexterm></para><sect2 id="Lift"><title>Lift</title><para id="para__lift__http_liftweb_net_i"><emphasis><ulink url="http://liftweb.net/">Lift</ulink></emphasis> is the leading web
      application framework written in Scala. It recently reached “1.0”
      status. Lift has been used for a number of commercial websites. You can
      also find documentation on the Lift website.<indexterm significance="normal"><primary>web application frameworks</primary></indexterm><indexterm significance="normal"><primary>Lift web framework</primary></indexterm></para><para id="para_other_web_frameworks_include_s">Other web frameworks
      include <ulink url="http://code.google.com/p/sweetscala/">Sweet</ulink>,
      <ulink url="http://bitbucket.org/pk11/pinky/wiki/Home">Pinky</ulink>,
      and <ulink url="http://code.google.com/p/slinky2/">Slinky</ulink>.</para></sect2><sect2 id="Scalaz"><title>Scalaz</title><para id="para__scalaz__http_wiki_workingm"><emphasis><ulink url="http://code.google.com/p/scalaz/">Scalaz</ulink></emphasis> is a
      library that fills in gaps in the standard library. Among its features
      are enhancements to several core Scala types, such as <literal role="keep-together" moreinfo="none">Boolean</literal>, <literal moreinfo="none">Unit</literal>,
      <literal moreinfo="none">String</literal>, and <literal moreinfo="none">Option</literal>, plus support
      for functional <emphasis>control</emphasis> abstractions, such as
      <literal moreinfo="none">FoldLeft</literal>, <literal moreinfo="none">FoldRight</literal>, and
      <literal moreinfo="none">Monad</literal>, that expand upon what is available in the
      standard library.<indexterm significance="normal"><primary>Scalaz library</primary></indexterm></para></sect2><sect2 id="Scalax"><title>Scalax</title><para id="para__scalax__http_scalax_scalaf"><emphasis><ulink url="http://scalax.scalaforge.org/">Scalax</ulink></emphasis> is another
      third-party library effort to supplement the Scala core
      library.<indexterm significance="normal"><primary>Scalax library</primary></indexterm></para></sect2><sect2 id="MetaScala"><title>MetaScala</title><para id="para__metascala__http_www_assemb"><emphasis><ulink url="http://www.assembla.com/wiki/show/metascala">MetaScala</ulink></emphasis>
      is an experimental metaprogramming library for Scala. Metaprogramming
      features tend to be weaker in statically typed languages than in
      dynamically typed languages. Also, the JVM and .NET CLR impose their own
      constraints on metaprogramming.<indexterm significance="normal"><primary>MetaScala library</primary></indexterm></para><para id="para_many_of_the_features_of_scala_">Many of the features of
      Scala obviate the need for metaprogramming, compared to languages like
      Ruby, but sometimes metaprogramming is still useful. MetaScala attempts
      to address those needs more fully than Scala’s built-in reflection
      support.</para></sect2><sect2 id="JavaRebel"><title>JavaRebel</title><para id="para__javarebel__is_a_commercial_to"><emphasis><ulink url="http://www.zeroturnaround.com/javarebel/">JavaRebel</ulink></emphasis>
      is a commercial tool that permits dynamic reloading of classes in a
      running JVM (written in any language), beyond the limited support
      provided natively by the “HotSwap” feature of the JVM. JavaRebel is
      designed to offer the developer faster turnaround for changes, providing
      an experience more like the rapid turnaround that users of dynamic
      languages enjoy. JavaRebel can be used with Scala code as
      well.<indexterm significance="normal"><primary>JavaRebel tool</primary></indexterm></para></sect2><sect2 id="MiscSmallerLibraries"><title>Miscellaneous Smaller Libraries</title><para id="para_finally_here_is_a_list_of_sev">Finally, <xref linkend="misc-scala-libs"/> is a list of several Scala-specific
      libraries you might find useful for your applications.<indexterm significance="normal"><primary>libraries</primary><secondary>miscellaneous smaller Scala libraries</secondary></indexterm></para><table id="misc-scala-libs"><title>Miscellaneous Scala libraries</title><tgroup cols="2"><thead valign="top"><row><entry>Name</entry><entry>Description and URL</entry></row></thead><tbody valign="top"><row><entry><para>Kestrel</para></entry><entry><para>A tiny, very fast queue system (<ulink url="http://github.com/robey/kestrel/tree/master"/>).</para></entry></row><row><entry><para>ScalaModules</para></entry><entry><para>Scala DSL to ease OSGi development (<ulink url="http://code.google.com/p/scalamodules/"/>).</para></entry></row><row><entry><para>Configgy</para></entry><entry><para>Managing configuration files and logging for
              “daemons” written in Scala (<ulink url="http://www.lag.net/configgy/"/>).</para></entry></row><row><entry><para>scouchdb</para></entry><entry><para>Scala interface to CouchDB (<ulink url="http://code.google.com/p/scouchdb/"/>).</para></entry></row><row><entry><para>Akka</para></entry><entry><para>A project to implement a platform for building
              fault-tolerant, distributed applications based on REST, Actors,
              etc. (<ulink url="http://akkasource.org/"/>).</para></entry></row><row><entry><para>scala-query</para></entry><entry><para>A type-safe database query API for Scala (<ulink url="http://github.com/szeiger/scala-query/tree/master"/>).</para></entry></row></tbody></tgroup></table><para id="para_we_ll_discuss_using_scala_with">We’ll discuss using Scala
      with several well-known Java libraries after we discuss Java
      interoperability, next.</para></sect2></sect1><sect1 id="JavaInterop"><title>Java Interoperability</title><para id="para_of_all_the_alternative_jvm_lan">Of all the alternative JVM
    languages, Scala’s interoperability with Java source code is among the
    most seamless. This section begins with a discussion of interoperability
    with code written in Java. Once you understand the details, they can be
    generalized to address interoperability with other JVM languages, such as
    JRuby or Groovy. For example, if you already know how to use JRuby and
    Java together, and you know how to use Java and Scala together, then you
    can generalize to using JRuby and Scala together.<indexterm class="startofrange" id="ch14_JavaScala" significance="normal"><primary>Java</primary><secondary>Scala interoperability with</secondary></indexterm></para><para id="para_because_scala_syntax_is_primar">Because Scala syntax is
    primarily a superset of Java syntax, invoking Java code from Scala is
    usually straightforward. Going the other direction requires that you
    understand how some Scala features are encoded in ways that satisfy the
    JVM specification. We discuss several of the interoperability issues here.
    <link linkend="Spiewak2009a" xrefstyle="select:nopage">[Spiewak2009a]</link> and <link linkend="Odersky2008" xrefstyle="select:nopage">[Odersky2008]</link>
    provide additional information.</para><sect2 id="_java_and_scala_generics"><title>Java and Scala Generics</title><para id="para_we_have_seen_many_examples_of_">We have seen many
      examples of Scala code that uses Java types, such as
      <literal moreinfo="none">java.lang.String</literal> and various java collection classes.
      Instantiating Java generic types is straightforward in Scala (since
      Scala version 2.7.0). Consider the following very simple Java generic
      class, <literal moreinfo="none">JStack</literal>:<indexterm significance="normal"><primary>generics</primary><secondary>Java</secondary><tertiary>using from Scala</tertiary></indexterm><indexterm class="startofrange" id="ch14_generics" significance="normal"><primary>generics</primary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>Scala interoperability with</secondary><tertiary>Java and Scala generics</tertiary></indexterm></para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/ToolsLibs/JStack.java</code>

<code role="preproc">import</code> java.util.*;

<code role="type">public</code> <code role="type">class</code> JStack&lt;T&gt; {
  <code role="type">private</code> List&lt;T&gt; stack = <code role="statement">new</code> ArrayList&lt;T&gt;();
  <code role="type">public</code> <code role="type">void</code> push(T t) {
    stack.add(t);
  }
  <code role="type">public</code> T pop() {
    <code role="statement">return</code> stack.remove(stack.size() - <code role="constant">1</code>);
  }
}
</programlisting><para id="para_we_can_instantiate_it_from_sca">We can instantiate it
      from Scala, specifying the type parameter, as shown in <xref linkend="example_14-1"/>.</para><example id="example_14-1"><title>A Scala “spec” to test the simple Java stack</title><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/JStack-spec.scala</code>

<code role="preproc">import</code> org.specs._

<code role="statement">object</code> <code role="special">JStackSpec</code> <code role="statement">extends</code> <code role="special">Specification</code> {
  <code role="constant">"Calling a Java generic type from Scala"</code> should {
    <code role="constant">"Support parameterization"</code> in {
      <code role="statement">val</code> js = <code role="statement">new</code> <code role="special">JStack</code><code role="special">[String]</code>
      js must notBe(<code role="statement">null</code>)  <code role="comment">// Dummy check...</code>
    }
    <code role="constant">"Support invoking the the type's methods"</code> in {
      <code role="statement">val</code> js = <code role="statement">new</code> <code role="special">JStack</code><code role="special">[String]</code>
      js.push(<code role="constant">"one"</code>)
      js.push(<code role="constant">"two"</code>)
      js.pop() mustEqual <code role="constant">"two"</code>
      js.pop() mustEqual <code role="constant">"one"</code>
    }
  }
}
</programlisting></example><para id="para_since_scala_version_2_7_2_you">Since Scala version 2.7.2,
      you can also use Scala generics from Java. Consider the following JUnit
      4 test, which shows some of the idiosyncrasies you might
      encounter:<indexterm significance="normal"><primary>generics</primary><secondary>Scala, using from Java</secondary></indexterm></para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/ToolsLibs/SMapTest.java</code>

<code role="preproc">import</code> org.junit.*;
<code role="preproc">import static</code> org.junit.Assert.*;
<code role="preproc">import</code> scala.*;
<code role="preproc">import</code> scala.collection.mutable.LinkedHashMap;

<code role="type">public</code> <code role="type">class</code> SMapTest {
  <code role="type">static</code> <code role="type">class</code> Name {
    <code role="type">public</code> String firstName;
    <code role="type">public</code> String lastName;

    <code role="type">public</code> Name(String firstName, String lastName) {
      <code role="type">this</code>.firstName = firstName;
      <code role="type">this</code>.lastName  = lastName;
    }
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  <code role="preproc">@Before</code>
  <code role="type">public</code> <code role="type">void</code> setup() {
    map = <code role="statement">new</code> LinkedHashMap&lt;Integer, Name&gt;();
    map.update(<code role="constant">1</code>, <code role="statement">new</code> Name(<code role="constant">"Dean"</code>, <code role="constant">"Wampler"</code>));
    map.update(<code role="constant">2</code>, <code role="statement">new</code> Name(<code role="constant">"Alex"</code>, <code role="constant">"Payne"</code>));
  }

  <code role="preproc">@Test</code>
  <code role="type">public</code> <code role="type">void</code> usingMapGetWithWarnings() {
    assertEquals(<code role="constant">2</code>, map.size());
    Option&lt;Name&gt; n1 = map.get(<code role="constant">1</code>);  <code role="comment">// warning</code>
    Option&lt;Name&gt; n2 = map.get(<code role="constant">2</code>);  <code role="comment">// warning</code>
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals(<code role="constant">"Dean"</code>, n1.get().firstName);
    assertEquals(<code role="constant">"Alex"</code>, n2.get().firstName);
  }

  <code role="preproc">@Test</code>
  <code role="type">public</code> <code role="type">void</code> usingMapGetWithoutWarnings() {
    assertEquals(<code role="constant">2</code>, map.size());
    Option&lt;?&gt; n1 = map.get(<code role="constant">1</code>);
    Option&lt;?&gt; n2 = map.get(<code role="constant">2</code>);
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals(<code role="constant">"Dean"</code>, ((Name) n1.get()).firstName);
    assertEquals(<code role="constant">"Alex"</code>, ((Name) n2.get()).firstName);
 }
}
</programlisting><para id="para_on_unix_like_systems_it_is_co">On Unix-like systems, it
      is compiled with the following command line:</para><screen format="linespecific">javac -Xlint:unchecked \
  -cp $SCALA_HOME/lib/scala-library.jar:$JUNIT_HOME/junit-4.4.jar SMapTest.java</screen><para>(Again, we wrapped the long line with <literal moreinfo="none">\</literal>.)
      <filename moreinfo="none">SCALA_HOME</filename> and <filename moreinfo="none">JUNIT_HOME</filename> are
      the installation directories of Scala and JUnit, respectively.</para><para id="para_the_smaptest_class_defines_a">The
      <literal moreinfo="none">SMapTest</literal> class defines a nested
      <literal moreinfo="none">Name</literal> class that is used as the “value” type in a
      <literal moreinfo="none">scala.collection.mutable.LinkedHashMap</literal>. For
      simplicity, <literal moreinfo="none">Name</literal> has public
      <literal moreinfo="none">firstName</literal> and <literal moreinfo="none">lastName</literal> fields and
      a constructor.</para><para id="para_the_setup_method_creates_a_n">The
      <literal moreinfo="none">setup</literal> method creates a new
      <literal moreinfo="none">LinkedHashMap&lt;Integer,Name&gt;</literal> and inserts two
      key-value pairs. The two tests,
      <literal moreinfo="none">usingMapGetWithWarnings</literal> and
      <literal moreinfo="none">usingMapGetWithoutWarnings</literal>, exercise the Java-Scala
      interoperability the same way. However, the first test has two
      compile-time warnings, indicated by the <literal moreinfo="none">// warning</literal>
      comments, while the second test compiles without warnings:</para><screen format="linespecific">SMapTest.java:29: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n1 = map.get(1);  // warning
                             ^
SMapTest.java:30: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n2 = map.get(2);  // warning
                             ^
2 warnings</screen><para id="para_the_warnings_occur_because_of_">The warnings occur
      because of type erasure. In the compiled Scala library, the return type
      of <literal moreinfo="none">Map.get</literal> is <literal moreinfo="none">Option</literal> with no type
      parameter, or effectively <literal moreinfo="none">Option&lt;Object&gt;</literal>. So we
      get warnings for the conversion to
      <literal moreinfo="none">Option&lt;Name&gt;</literal>.</para><para id="para_the_second_test_usingmapgetw">The second test,
      <literal moreinfo="none">usingMapGetWithoutWarnings</literal>, has no warnings, because
      we assign the values returned by <literal moreinfo="none">Map.get</literal> to
      <literal moreinfo="none">Option&lt;?&gt;</literal> and then do an explicit cast to
      <literal moreinfo="none">Name</literal> when we call <literal moreinfo="none">Option.get</literal> in
      the final two assertions.<indexterm class="endofrange" startref="ch14_generics" significance="normal"/></para></sect2><sect2 id="FunctionsInJava"><title>Using Scala Functions in Java</title><para id="para_continuing_with_our_previous_">Continuing with our
      previous <literal moreinfo="none">SMapTest</literal> example, we can explore invoking
      Scala code from Java where Scala functions are required:<indexterm significance="normal"><primary>functions</primary><secondary>Scala, using in Java</secondary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>Scala interoperability with</secondary><tertiary>using Scala functions in Java</tertiary></indexterm></para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/ToolsLibs/SMapTestWithFunctions.java</code>

<code role="preproc">import</code> org.junit.*;
<code role="preproc">import static</code> org.junit.Assert.*;
<code role="preproc">import</code> scala.*;
<code role="preproc">import</code> scala.collection.mutable.LinkedHashMap;
<code role="preproc">import static</code> scala.collection.Map.Projection;

<code role="type">public</code> <code role="type">class</code> SMapTestWithFunctions {
  <code role="type">static</code> <code role="type">class</code> Name {
    <code role="type">public</code> String firstName;
    <code role="type">public</code> String lastName;

    <code role="type">public</code> Name(String firstName, String lastName) {
      <code role="type">this</code>.firstName = firstName;
      <code role="type">this</code>.lastName  = lastName;
    }

    <code role="type">public</code> <code role="type">static</code> Name emptyName = <code role="statement">new</code> Name(<code role="constant">""</code>,<code role="constant">""</code>);

    <code role="type">public</code> <code role="type">static</code> Function0&lt;Name&gt; empty = <code role="statement">new</code> Function0&lt;Name&gt;() {
      <code role="type">public</code> Name apply() { <code role="statement">return</code> emptyName; }

      <code role="type">public</code> <code role="type">int</code> $tag() { <code role="statement">return</code> <code role="constant">0</code>; }
    };
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  <code role="preproc">@Before</code>
  <code role="type">public</code> <code role="type">void</code> setup() {
    map = <code role="statement">new</code> LinkedHashMap&lt;Integer, Name&gt;();
    map.update(<code role="constant">1</code>, <code role="statement">new</code> Name(<code role="constant">"Dean"</code>, <code role="constant">"Wampler"</code>));
    map.update(<code role="constant">2</code>, <code role="statement">new</code> Name(<code role="constant">"Alex"</code>, <code role="constant">"Payne"</code>));
  }

  <code role="preproc">@Test</code>
  <code role="type">public</code> <code role="type">void</code> usingMapGetOrElse() {
    assertEquals(<code role="constant">2</code>, map.size());
    assertEquals(<code role="constant">"Dean"</code>, ((Name) map.getOrElse(<code role="constant">1</code>, Name.empty)).firstName);
    assertEquals(<code role="constant">"Alex"</code>, ((Name) map.getOrElse(<code role="constant">2</code>, Name.empty)).firstName);
  }

  Function1&lt;Integer, Boolean&gt; filter = <code role="statement">new</code> Function1&lt;Integer, Boolean&gt;() {
    <code role="type">public</code> Boolean apply(Integer i) { <code role="statement">return</code> i.intValue() &lt;= <code role="constant">1</code>; }

    <code role="type">public</code> &lt;A&gt; Function1&lt;A,Boolean&gt; compose(Function1&lt;A,Integer&gt; g) {
      <code role="statement">return</code> Function1$<code role="type">class</code>.compose(<code role="type">this</code>, g);
    }

    <code role="type">public</code> &lt;A&gt; Function1&lt;Integer,A&gt; andThen(Function1&lt;Boolean,A&gt; g) {
      <code role="statement">return</code> Function1$<code role="type">class</code>.andThen(<code role="type">this</code>, g);
    }

    <code role="type">public</code> <code role="type">int</code> $tag() { <code role="statement">return</code> <code role="constant">0</code>; }
  };

  <code role="preproc">@Test</code>
  <code role="type">public</code> <code role="type">void</code> usingFilterKeys() {
    assertEquals(<code role="constant">2</code>, map.size());
    Projection&lt;Integer, Name&gt; filteredMap =
        (Projection&lt;Integer, Name&gt;) map.filterKeys(filter);
    assertEquals(<code role="constant">1</code>, filteredMap.size());
    assertEquals(<code role="constant">"Dean"</code>, filteredMap.getOrElse(<code role="constant">1</code>, Name.empty).firstName);
    assertEquals(<code role="constant">""</code>,     filteredMap.getOrElse(<code role="constant">2</code>, Name.empty).firstName);
  }
}
</programlisting><para id="para_the_smaptestwithfunctions_cl">The
      <literal moreinfo="none">SMapTestWithFunctions</literal> class has its own
      <literal moreinfo="none">Name</literal> class that adds a static
      <literal moreinfo="none">emptyName</literal> object and a static
      <literal moreinfo="none">scala.Function0</literal> object <literal moreinfo="none">empty</literal>,
      which defines <literal moreinfo="none">apply</literal> to return <literal role="keep-together" moreinfo="none">emptyName</literal>. Note that it is also necessary
      to define the <literal moreinfo="none">$tag</literal> method that was discussed
      previously in <xref linkend="CommandLineToolDecompilers"/>.</para><para id="para_the_empty_function_object_is">The
      <literal moreinfo="none">empty</literal> function object is needed when we use
      <literal moreinfo="none">Map.getOrElse</literal> in the test method,
      <literal moreinfo="none">usingMapGetOrElse</literal>. The signature of
      <literal moreinfo="none">getOrElse</literal> is the following:</para><programlisting language="scala" format="linespecific"><code role="statement">def</code> <code role="identifier">getOrElse</code><code role="identifier">[B2 &gt;: B]</code>(key :<code role="type"> A</code>, default :<code role="type"> =&gt; B2</code>) :<code role="type"> B2</code>
</programlisting><para id="para_where_a_is_the_key_type_para">Where <literal moreinfo="none">A</literal>
      is the key type parameter, <literal moreinfo="none">B</literal> is the value type
      parameter, and <literal moreinfo="none">B2</literal> is a supertype of
      <literal moreinfo="none">B</literal> or the same as <literal moreinfo="none">B</literal>. The second
      <literal moreinfo="none">default</literal> argument is a <emphasis>by-name
      parameter</emphasis>, which we discussed in <xref linkend="FunctionalProgramming"/>. Note that by-name parameters are
      implemented as <literal moreinfo="none">scala.Function0</literal> objects. So, we can’t
      simply pass in the static object <literal moreinfo="none">emptyName</literal>.</para><para id="para_the_second_test_usingfilterk">The second test,
      <literal moreinfo="none">usingFilterKeys</literal>, requires a
      <literal moreinfo="none">Function1</literal> object, which has an
      <literal moreinfo="none">apply</literal> method that takes one argument. We use this
      <literal moreinfo="none">Function1</literal> object as a filter passed to
      <literal moreinfo="none">Map.filterKeys</literal>.</para><para id="para_we_define_the_filter_before_">We define the
      <literal moreinfo="none">filter</literal> before the test. The Java code here is
      considerably more involved than the equivalent Scala code would be! Not
      only do we have to define the <literal moreinfo="none">apply</literal> and
      <literal moreinfo="none">$tag</literal> methods, we must also define methods used for
      function composition, <literal moreinfo="none">compose</literal> and
      <literal moreinfo="none">andThen</literal>. Fortunately, we can delegate to objects that
      are already in the Scala library, as shown. Note that other
      <literal moreinfo="none">FunctionN</literal> types, for <literal moreinfo="none">N</literal> equals 2 to
      22, have other methods that would have to be implemented using similar
      “boilerplate.” For example, these types each have a
      <literal moreinfo="none">curry</literal> method.</para><para id="para_finally_recall_that_in_comp">Finally, recall that in
      <xref linkend="CompanionObjectsAndJavaStaticMethods"/>, we discussed
      that methods defined in companion objects are not visible as
      <literal moreinfo="none">static</literal> methods to Java code. For example,
      <literal moreinfo="none">main</literal> methods defined in companion objects can’t be
      used to run the application. Instead, you should define such methods in
      <emphasis role="keep-together">singleton</emphasis> objects.<indexterm significance="normal"><primary>methods</primary><secondary>Java static methods and companion objects</secondary></indexterm><indexterm significance="normal"><primary>singleton objects</primary><secondary>methods defined in companion objects</secondary></indexterm><indexterm significance="normal"><primary>companion objects</primary><secondary>methods defined in, visibility to Java code</secondary></indexterm></para><para id="para_so_using_scala_function_objec">So, using Scala function
      objects from Java can be challenging. If you find it necessary to use
      them frequently, you could define Java utility classes that handle the
      boilerplate for all the methods except <literal moreinfo="none">apply</literal>.</para></sect2><sect2 id="JavaBeanProperties"><title>JavaBean Properties</title><para id="para_we_saw_in_objectorientedprog">We saw in <xref linkend="BasicObjectOrientedProgramming"/> that Scala does not follow
      the JavaBeans (<link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>) conventions for field
      reader and writer methods, for reasons described in <xref linkend="UniformAccessPrinciple"/>. However, there are times when you
      need JavaBeans accessor <phrase role="keep-together">methods</phrase>.
      For example, you need them when you want your Scala instances to be
      configurable by a <emphasis>dependency injection</emphasis> mechanism,
      like the one provided by the Spring Framework (<link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link>). You may also need
      JavaBeans accessor methods for some IDEs that do bean
      “introspection.”<indexterm significance="normal"><primary>JavaBeans</primary><secondary>conventions for</secondary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>Scala interoperability with</secondary><tertiary>JavaBean properties</tertiary></indexterm></para><para id="para_scala_solves_this_problem_with">Scala solves this problem
      with an annotation that you can apply to a field,
      <literal moreinfo="none">@scala.reflect.BeanProperty</literal>, which tells the compiler
      to generate JavaBeans-style <phrase role="keep-together">getter</phrase>
      and setter methods. We introduced this annotation in <xref linkend="Annotations"/>.<indexterm significance="normal"><primary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty
          annotation</primary></indexterm><indexterm significance="normal"><primary>annotations</primary><secondary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty</secondary></indexterm></para><para id="para_recall_the_complex_class_we_">Recall the
      <literal moreinfo="none">Complex</literal> class we saw previously. Now we add the
      annotation to each constructor argument, which is a field in the
      <literal moreinfo="none">case</literal> class:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/complex-javabean.scala</code>

<code role="statement">case</code> <code role="statement">class</code> <code role="special">ComplexBean</code>(
  @scala.reflect.<code role="special">BeanProperty</code> real:<code role="type"> Double</code>,
  @scala.reflect.<code role="special">BeanProperty</code> imaginary:<code role="type"> Double</code>) {

  <code role="statement">def</code> <code role="identifier">+</code>(that:<code role="type"> ComplexBean</code>) =
    <code role="statement">new</code> <code role="special">ComplexBean</code>(real + that.real, imaginary + that.imaginary)
  <code role="statement">def</code> <code role="identifier">-</code>(that:<code role="type"> ComplexBean</code>) =
    <code role="statement">new</code> <code role="special">ComplexBean</code>(real - that.real, imaginary - that.imaginary)
}
</programlisting><para id="para_if_you_compile_this_class_the">If you compile this class,
      then decompile it with <literal moreinfo="none">javap -classpath ...
      ComplexBean</literal>, you get the following output:</para><programlisting language="java" format="linespecific"><code role="type">public</code> <code role="type">class</code> ComplexBean <code role="type">extends</code> java.lang.Object
  <code role="type">implements</code> scala.ScalaObject,scala.Product,java.io.Serializable{
  <code role="type">public</code> ComplexBean(<code role="type">double</code>, <code role="type">double</code>);
  <code role="type">public</code> java.lang.Object productElement(<code role="type">int</code>);
  <code role="type">public</code> <code role="type">int</code> productArity();
  <code role="type">public</code> java.lang.String productPrefix();
  <code role="type">public</code> <code role="type">boolean</code> equals(java.lang.Object);
  <code role="type">public</code> java.lang.String toString();
  <code role="type">public</code> <code role="type">int</code> hashCode();
  <code role="type">public</code> <code role="type">int</code> $tag();
  <code role="type">public</code> ComplexBean $minus(ComplexBean);
  <code role="type">public</code> ComplexBean $plus(ComplexBean);
  <code role="type">public</code> <code role="type">double</code> imaginary();
  <code role="type">public</code> <code role="type">double</code> real();
  <code role="type">public</code> <code role="type">double</code> getImaginary();
  <code role="type">public</code> <code role="type">double</code> getReal();
}
</programlisting><para id="para_now_compare_this_output_with_t">Now compare this output
      with the result of decompiling the original
      <filename moreinfo="none">Complex.class</filename> file:</para><programlisting language="java" format="linespecific"><code role="type">public</code> <code role="type">class</code> Complex <code role="type">extends</code> java.lang.Object
  <code role="type">implements</code> scala.ScalaObject,scala.Product,java.io.Serializable{
  <code role="type">public</code> Complex(<code role="type">double</code>, <code role="type">double</code>);
  <code role="type">public</code> java.lang.Object productElement(<code role="type">int</code>);
  <code role="type">public</code> <code role="type">int</code> productArity();
  <code role="type">public</code> java.lang.String productPrefix();
  <code role="type">public</code> <code role="type">boolean</code> equals(java.lang.Object);
  <code role="type">public</code> java.lang.String toString();
  <code role="type">public</code> <code role="type">int</code> hashCode();
  <code role="type">public</code> <code role="type">int</code> $tag();
  <code role="type">public</code> Complex $minus(Complex);
  <code role="type">public</code> Complex $plus(Complex);
  <code role="type">public</code> <code role="type">double</code> imaginary();
  <code role="type">public</code> <code role="type">double</code> real();
}
</programlisting><para id="para_the_order_of_the_methods_shown">The order of the methods
      shown may be different when you run <literal moreinfo="none">javap</literal> on these
      files. We reordered them so the two listings would match as closely as
      possible. Note that the only differences are the names of the classes
      and the presence of <literal moreinfo="none">getImaginary</literal> and
      <literal moreinfo="none">getReal</literal> methods in the <literal moreinfo="none">ComplexBean</literal>
      case. We would also have corresponding setter methods if the
      <literal moreinfo="none">real</literal> and <literal moreinfo="none">imaginary</literal> fields were
      declared as <literal moreinfo="none">var</literal>s instead of
      <literal moreinfo="none">val</literal>s.</para><warning id="para_warning_the__scaladoc__page_f"><para>The Scaladoc page for <literal moreinfo="none">@BeanProperty</literal> (version
        2.7) says that you can’t call the bean setter methods from Scala. You
        can call them, but as the <phrase role="keep-together">Scaladoc</phrase> page goes on to say, you should
        use the Scala-style writer (and reader) methods instead.</para></warning></sect2><sect2 id="AnyValTypesAndJavaPrimitives"><title>AnyVal Types and Java Primitives</title><para id="para_notice_also_in_the_previous_c">Notice also in the
      previous <literal moreinfo="none">Complex</literal> example that the
      <literal moreinfo="none">Doubles</literal> were converted to Java primitive
      <literal moreinfo="none">doubles</literal>. All the <literal moreinfo="none">AnyVal</literal> types are
      converted to their corresponding Java primitives. We showed the mapping
      in <xref linkend="AnyVal-value-types"/>. In particular, note that
      <literal moreinfo="none">Unit</literal> is mapped to <literal moreinfo="none">void</literal>.<indexterm significance="normal"><primary>primitive data types</primary><secondary>Java, conversion of AnyVal types to</secondary></indexterm><indexterm significance="normal"><primary>AnyVal types, conversion to Java primitives</primary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>AnyVal types, conversion to Java primitives</secondary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>Scala interoperability with</secondary><tertiary>AnyVal types and Java primitives</tertiary></indexterm></para></sect2><sect2 id="ScalaNamesInJavaCode"><title>Scala Names in Java Code</title><para id="para_as_we_discussed_in_roundingo">As we discussed in <xref linkend="RoundingOutTheEssentials"/>, Scala allows more flexible
      identifiers, e.g., <emphasis>operator characters</emphasis> like
      <literal moreinfo="none">*</literal>, <literal moreinfo="none">&lt;</literal>, etc. These characters are
      encoded (or “mangled,” if you prefer) to satisfy the tighter constraints
      of the JVM specification. They are translated as shown in <xref linkend="char-encoding"/> (adapted from <link linkend="Spiewak2009a" xrefstyle="select:nopage">[Spiewak2009a]</link>).<indexterm significance="normal"><primary>characters</primary><secondary>operator characters, encoding in Java</secondary></indexterm><indexterm significance="normal"><primary>~ (tilde)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary># (pound sign)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>@ (at sign)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>&amp; (ampersand)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>^ (caret)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>% (percent sign)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>: (colon)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>? (question mark)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>! (exclamation point)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>| (vertical bar)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>\ (backslash)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>/ (slash)</primary><secondary>division operator, encoding in Java
          identifiers</secondary></indexterm><indexterm significance="normal"><primary>* (asterisk)</primary><secondary>multiplication operator, encoding in Java
          identifiers</secondary></indexterm><indexterm significance="normal"><primary>- (minus sign)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>+ (plus sign)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&lt; (less than) operator</secondary><tertiary>encoding in Java identifiers</tertiary></indexterm><indexterm significance="normal"><primary>&lt; &gt; (angle brackets)</primary><secondary>&gt; (greater than) operator</secondary><tertiary>encoding in Java identifiers</tertiary></indexterm><indexterm significance="normal"><primary>= (equals sign)</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>operator characters</primary><secondary>encoding in Java identifiers</secondary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>Scala interoperability with</secondary><tertiary>Scala names in Java code</tertiary></indexterm></para><table id="char-encoding"><title>Encoding of operator characters</title><tgroup cols="2"><thead valign="top"><row><entry><phrase role="keep-together">Operator</phrase></entry><entry><phrase role="keep-together">Encoding</phrase></entry></row></thead><tbody valign="top"><row><entry><para><literal moreinfo="none">=</literal></para></entry><entry><para><literal moreinfo="none">$eq</literal></para></entry></row><row><entry><para><literal moreinfo="none">&gt;</literal></para></entry><entry><para><literal moreinfo="none">$greater</literal></para></entry></row><row><entry><para><literal moreinfo="none">&lt;</literal></para></entry><entry><para><literal moreinfo="none">$less</literal></para></entry></row><row><entry><para><literal moreinfo="none">+</literal></para></entry><entry><para><literal moreinfo="none">$plus</literal></para></entry></row><row><entry><para><literal moreinfo="none">-</literal></para></entry><entry><para><literal moreinfo="none">$minus</literal></para></entry></row><row><entry><para><literal moreinfo="none">*</literal></para></entry><entry><para><literal moreinfo="none">$times</literal></para></entry></row><row><entry><para><literal moreinfo="none">/</literal></para></entry><entry><para><literal moreinfo="none">$div</literal></para></entry></row><row><entry><para><literal moreinfo="none">\</literal></para></entry><entry><para><literal moreinfo="none">$bslash</literal></para></entry></row><row><entry><para><literal moreinfo="none">|</literal></para></entry><entry><para><literal moreinfo="none">$bar</literal></para></entry></row><row><entry><para><literal moreinfo="none">!</literal></para></entry><entry><para><literal moreinfo="none">$bang</literal></para></entry></row><row><entry><para><literal moreinfo="none">?</literal></para></entry><entry><para><literal moreinfo="none">$qmark</literal></para></entry></row><row><entry><para><literal moreinfo="none">:</literal></para></entry><entry><para><literal moreinfo="none">$colon</literal></para></entry></row><row><entry><para><literal moreinfo="none">%</literal></para></entry><entry><para><literal moreinfo="none">$percent</literal></para></entry></row><row><entry><para><literal moreinfo="none">^</literal></para></entry><entry><para><literal moreinfo="none">$up</literal></para></entry></row><row><entry><para><literal moreinfo="none">&amp;</literal></para></entry><entry><para><literal moreinfo="none">$amp</literal></para></entry></row><row><entry><para><literal moreinfo="none">@</literal></para></entry><entry><para><literal moreinfo="none">$at</literal></para></entry></row><row><entry><para><literal moreinfo="none">#</literal></para></entry><entry><para><literal moreinfo="none">$hash</literal></para></entry></row><row><entry><para><literal moreinfo="none">~</literal></para></entry><entry><para><literal moreinfo="none">$tilde</literal></para></entry></row></tbody></tgroup></table><para id="para_you_can_see_this_at_work_in_th">You can see this at work
      in the following contrived trait, where each character is used to
      declare an abstract method that takes no arguments and returns
      <literal moreinfo="none">Unit</literal>:</para><programlisting language="java" format="linespecific"><code role="comment">// code-examples/ToolsLibs/all-op-chars.scala</code>

trait AllOpChars {
  def == : Unit   <code role="comment">// $eq$eq</code>
  def &gt;  : Unit   <code role="comment">// $greater</code>
  def &lt;  : Unit   <code role="comment">// $less</code>
  def +  : Unit   <code role="comment">// $plus</code>
  def -  : Unit   <code role="comment">// $minus</code>
  def *  : Unit   <code role="comment">// $times</code>
  def /  : Unit   <code role="comment">// $div</code>
  def <code role="error">\</code>  : Unit   <code role="comment">// $bslash</code>
  def |  : Unit   <code role="comment">// $bar</code>
  def !  : Unit   <code role="comment">// $bang</code>
  def ?  : Unit   <code role="comment">// $qmark</code>
<code role="statement">  def </code>:: : Unit   <code role="comment">// $colon$colon</code>
  def %  : Unit   <code role="comment">// $percent</code>
  def ^  : Unit   <code role="comment">// $up</code>
  def &amp;  : Unit   <code role="comment">// $amp</code>
  def <code role="error">@@</code> : Unit   <code role="comment">// $at$at</code>
  def <code role="error">##</code> : Unit   <code role="comment">// $hash$hash</code>
  def ~  : Unit   <code role="comment">// $tilde</code>
}
</programlisting><para id="para_note_that_we_doubled_up_some_o">Note that we doubled up
      some of the characters to get them to compile as method names, where
      using single characters would have been ambiguous. Compiling this file
      and decompiling the resulting class file with <literal moreinfo="none">javap
      AllOpChars</literal> yields the following Java interface. (We have
      rearranged the output order of the methods to match the order in the
      original Scala file.)</para><programlisting language="scala" format="linespecific"><code role="special">Compiled</code> from <code role="constant">"all-op-chars.scala"</code>
public interface <code role="special">AllOpChars</code>{
  public <code role="statement">abstract</code> void $eq$eq();
  public <code role="statement">abstract</code> void $greater();
  public <code role="statement">abstract</code> void $less();
  public <code role="statement">abstract</code> void $plus();
  public <code role="statement">abstract</code> void $minus();
  public <code role="statement">abstract</code> void $times();
  public <code role="statement">abstract</code> void $div();
  public <code role="statement">abstract</code> void $bslash();
  public <code role="statement">abstract</code> void $bar();
  public <code role="statement">abstract</code> void $bang();
  public <code role="statement">abstract</code> void $qmark();
  public <code role="statement">abstract</code> void $colon$colon();
  public <code role="statement">abstract</code> void $percent();
  public <code role="statement">abstract</code> void $up();
  public <code role="statement">abstract</code> void $amp();
  public <code role="statement">abstract</code> void $at$at();
  public <code role="statement">abstract</code> void $hash$hash();
  public <code role="statement">abstract</code> void $tilde();
}
</programlisting><para id="para_to_conclude_interoperability_">To conclude,
      interoperability between Java and Scala works very well, but there are a
      few things you must remember when invoking Scala code from Java. If
      you’re uncertain about how a Scala identifier is encoded or a Scala
      method is translated to valid byte code, use <literal moreinfo="none">javap</literal> to
      find out.<indexterm class="endofrange" startref="ch14_JavaScala" significance="normal"/></para></sect2></sect1><sect1 id="JavaLibraryInterop"><title>Java Library Interoperability</title><para id="para_this_section_specifically_cons">This section specifically
    considers interoperability with several important Java frameworks:
    AspectJ, the Spring Framework, Terracotta, and Hadoop. Because they are
    widely used in “enterprise” and Internet Java applications, successful
    interoperability with Scala is important.<indexterm class="startofrange" id="ch14_Javalibraries" significance="normal"><primary>Java</primary><secondary>libraries, interoperability with Scala</secondary></indexterm><indexterm class="startofrange" id="ch14_librariesJava" significance="normal"><primary>libraries</primary><secondary>Java library interoperability</secondary></indexterm></para><sect2 id="AspectJInterop"><title>AspectJ</title><para id="para_aspectj_aspectj_is_an_exte">AspectJ (<link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link>) is an
      extension of Java that supports <emphasis>aspect-oriented
      programming</emphasis> (AOP), also known as <emphasis>aspect-oriented
      software development</emphasis> (<link linkend="AOSD" xrefstyle="select:nopage">[AOSD]</link>). The goal of AOP is to enable
      systemic changes of the same kind across many modules, while avoiding
      copying and pasting the same code over and over into each location.
      Avoiding this duplication not only improves productivity, it greatly
      reduces bugs.<indexterm significance="normal"><primary>AOP</primary><see>aspect-oriented programming</see></indexterm><indexterm class="startofrange" id="ch14_librariesJavaAspectJ" significance="normal"><primary>libraries</primary><secondary>Java library interoperability</secondary><tertiary>AspectJ</tertiary></indexterm><indexterm class="startofrange" id="ch14_JavaLibrariesAspectJ" significance="normal"><primary>Java</primary><secondary>libraries, interoperability with Scala</secondary><tertiary>AspectJ</tertiary></indexterm><indexterm significance="normal"><primary>aspect-oriented programming (AOP)</primary></indexterm><indexterm class="startofrange" id="ch14_AspectJ" significance="normal"><primary>AspectJ library</primary></indexterm></para><para id="para_for_example_if_you_want_all_f">For example, if you want
      all field changes to all “domain model” objects to be persisted
      automatically after the changes occur, you can write an aspect that
      observes those changes and triggers a persistence write after each
      change.</para><para id="para_aspectj_supports_aop_by_provid">AspectJ supports AOP by
      providing a <emphasis>pointcut language</emphasis> for specifying in a
      declarative way all the “execution points” in a program for which a
      particular behavior modification (called <emphasis>advice</emphasis>) is
      required. In AspectJ parlance, each execution point is called a
      <emphasis>join point</emphasis>, and a particular query over join points
      is a <emphasis>pointcut</emphasis>. Hence the <emphasis>pointcut
      language</emphasis> is a query language, of sorts. For a given pointcut,
      AspectJ incorporates the desired behavior modifications into each join
      point. Manual insertion of these changes is not required. An
      <emphasis>aspect</emphasis> encapsulates pointcuts and advices, much the
      way a class encapsulates member fields and methods.<indexterm significance="normal"><primary>advice (in AOP)</primary></indexterm><indexterm significance="normal"><primary>pointcuts</primary></indexterm><indexterm significance="normal"><primary>join points</primary></indexterm></para><para id="para_for_a_detailed_introduction_to">For a detailed
      introduction to AspectJ with many practical examples, refer to <link linkend="Laddad2009" xrefstyle="select:nopage">[Laddad2009]</link>.</para><para id="para_there_are_two_issues_that_must">There are two issues that
      must be considered when using AspectJ with Scala. The first issue is how
      to reference Scala execution points using AspectJ’s pointcut language,
      e.g., Scala types and methods. The second issue is how to invoke Scala
      code as <emphasis>advice</emphasis>.</para><para id="para_let_s_look_at_an_aspect_that_l">Let’s look at an aspect
      that logs method calls to the <literal moreinfo="none">Complex</literal> class we used
      previously in this chapter. We’ll add a package declaration this time to
      provide some scope:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/aspectj/complex.scala</code>

<code role="preproc">package</code> example.aspectj

<code role="statement">case</code> <code role="statement">class</code> <code role="special">Complex</code>(real:<code role="type"> Double</code>, imaginary:<code role="type"> Double</code>) {
  <code role="statement">def</code> <code role="identifier">+</code>(that:<code role="type"> Complex</code>) =
    <code role="statement">new</code> <code role="special">Complex</code>(real + that.real, imaginary + that.imaginary)
  <code role="statement">def</code> <code role="identifier">-</code>(that:<code role="type"> Complex</code>) =
    <code role="statement">new</code> <code role="special">Complex</code>(real - that.real, imaginary - that.imaginary)
}
</programlisting><para id="para_here_is_an_object_that_uses_">Here is an
      <literal moreinfo="none">object</literal> that uses <literal moreinfo="none">Complex</literal>:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/aspectj/complex-main.scala</code>

<code role="preproc">package</code> example.aspectj

<code role="statement">object</code> <code role="special">ComplexMain</code> {
  <code role="statement">def</code> <code role="identifier">main</code>(args:<code role="type"> Array[String]</code>) {
    <code role="statement">val</code> c1 = <code role="special">Complex</code>(<code role="constant">1.0</code>, <code role="constant">2.0</code>)
    <code role="statement">val</code> c2 = <code role="special">Complex</code>(<code role="constant">3.0</code>, <code role="constant">4.0</code>)
    <code role="statement">val</code> c12 = c1 + c2
    println(c12)
  }
}
</programlisting><para id="para_next_here_is_an_aspectj_aspec">Next, here is an AspectJ
      aspect that defines one <emphasis>pointcut</emphasis> for the creation
      of <literal moreinfo="none">Complex</literal> instances and another pointcut for
      invocations of the <literal moreinfo="none">+</literal> method:</para><?dbfo-need height=”1in”
?><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/aspectj/LogComplex.aj</code>

<code role="preproc">package</code> example.aspectj;

public aspect <code role="special">LogComplex</code> {
  public pointcut newInstances(double real, double imag):
    execution(Complex.<code role="statement">new</code>(..)) &amp;&amp; args(real, imag);

  public pointcut plusInvocations(<code role="special">Complex</code> self, <code role="special">Complex</code> other):
    execution(<code role="special">Complex</code> Complex.$plus(<code role="special">Complex</code>)) &amp;&amp; <code role="statement">this</code>(self) &amp;&amp; args(other);

  before(double real, double imag):<code role="type"> newInstances</code>(real, imag) {
    System.out.println(<code role="constant">"new Complex("</code> + real + <code role="constant">","</code> + imag + <code role="constant">") called."</code>);
  }

  before(<code role="special">Complex</code> self, <code role="special">Complex</code> other):<code role="type"> plusInvocations</code>(self, other) {
    System.out.println(<code role="constant">"Calling "</code> + self + <code role="constant">".+("</code> + other + <code role="constant">")"</code>);
  }

  after(<code role="special">Complex</code> self, <code role="special">Complex</code> other) returning(<code role="special">Complex</code> c):
    plusInvocations(self, other) {
    System.out.println(<code role="constant">"Complex.+ returned "</code> + c);
  }
}
</programlisting><para id="para_we_won_t_explain_all_the_detai">We won’t explain all the
      details of AspectJ syntax here. See the AspectJ document at <link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link> and <link linkend="Laddad2009" xrefstyle="select:nopage">[Laddad2009]</link> for
      those details. We’ll limit ourselves to a “conceptual” overview of this
      aspect.</para><para id="para_the_first_pointcut_newinst">The first
      <literal moreinfo="none">pointcut</literal>, <literal moreinfo="none">newInstances</literal>, matches on
      executions of the constructor calls, using the syntax
      <literal moreinfo="none">Complex.new</literal> to refer to the constructor. We expect
      <literal moreinfo="none">double</literal> arguments to the constructor call. As we saw
      previously, <literal moreinfo="none">scala.Double</literal> occurrences are converted to
      Java primitive <literal moreinfo="none">doubles</literal> when generating byte code. The
      <literal moreinfo="none">args</literal> clause “binds” the values of the arguments
      passed in, so we can refer to them in
      <emphasis>advice</emphasis>.</para><para id="para_the_second_pointcut_plusca">The second
      <literal moreinfo="none">pointcut</literal>, <literal moreinfo="none">plusInvocations</literal>, matches
      on “executions” of the <literal moreinfo="none">+</literal> method, which is actually
      <literal moreinfo="none">$plus</literal> in the byte code. The <literal moreinfo="none">self</literal>
      and <literal moreinfo="none">other</literal> parameters are bound to the object on which
      the <literal moreinfo="none">+</literal> method is invoked (using the
      <literal moreinfo="none">this</literal> clause) and the argument to it (using the
      <literal moreinfo="none">args</literal> clause), respectively.</para><para id="para_the_first_before__advice__is">The first
      <literal moreinfo="none">before</literal> advice is executed for the
      <literal moreinfo="none">newInstances</literal> pointcut, that is, before we actually
      enter the constructor. We “log” the call, displaying the actual real and
      imaginary values passed in.</para><para id="para_the_next_before__advice__is_">The next
      <literal moreinfo="none">before</literal> advice is executed for the
      <literal moreinfo="none">plusInvocations</literal> pointcut, that is, before the
      <literal moreinfo="none">+</literal> method is executed. We log the value of
      <literal moreinfo="none">self</literal> (i.e., <literal moreinfo="none">this</literal> instance) and the
      other <phrase role="keep-together">number</phrase>.</para><para id="para_finally_an_after_returning_">Finally, an <literal moreinfo="none">after
      returning</literal> advice is also executed for the
      <literal moreinfo="none">plusInvocations</literal> pointcut, that is, after the
      <literal moreinfo="none">+</literal> method returns. We capture the return value in the
      variable <literal moreinfo="none">c</literal> and we log it.</para><para id="para_if_you_have_aspectj_installed_">If you have AspectJ
      installed in an <replaceable>aspectj-home</replaceable> directory, you
      can compile this file as follows:</para><screen format="linespecific">ajc -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar \
  aspectj/LogComplex.aj</screen><para id="para_this_is_one_line_we_used_the_">This is one line; we used
      the <literal moreinfo="none">\</literal> to indicate a line wrap. To run this code with
      the <literal moreinfo="none">LogComplex</literal> aspect, we use <emphasis><ulink url="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">load-time
      weaving</ulink></emphasis>. We’ll invoke Java with an
      <emphasis>agent</emphasis> that “weaves” the advice from
      <literal moreinfo="none">LogComplex</literal> into <literal moreinfo="none">Complex</literal>. To use
      load-time weaving, we also need the following configuration file,
      <literal moreinfo="none">META-INF/aop.xml</literal>:<indexterm significance="normal"><primary>weaving, load-time</primary></indexterm><indexterm significance="normal"><primary>load-time weaving</primary></indexterm></para><programlisting language="xml" format="linespecific"><code role="comment">&lt;!</code><code role="comment">-- code-examples/ToolsLibs/META-INF/aop.xml --</code><code role="comment">&gt;</code>

<code role="identifier">&lt;</code><code role="identifier">aspectj</code><code role="identifier">&gt;</code>
  <code role="identifier">&lt;</code><code role="identifier">aspects</code><code role="identifier">&gt;</code>
    <code role="identifier">&lt;</code><code role="identifier">aspect</code><code role="identifier"> </code><code role="type">name</code>=<code role="constant">"example.aspectj.LogComplex"</code><code role="identifier"> /&gt;</code>
    <code role="identifier">&lt;</code><code role="identifier">include</code><code role="identifier"> </code><code role="type">within</code>=<code role="constant">"example.aspectj.*"</code><code role="identifier"> /&gt;</code>
  <code role="identifier">&lt;/aspects&gt;</code>

  <code role="identifier">&lt;</code><code role="identifier">weaver</code><code role="identifier"> </code><code role="type">options</code>=<code role="constant">"-verbose"</code><code role="identifier">&gt;</code>
    <code role="identifier">&lt;</code><code role="identifier">dump</code><code role="identifier"> </code><code role="type">within</code>=<code role="constant">"example.aspectj.*"</code><code role="identifier"> </code><code role="type">beforeandafter</code>=<code role="constant">"true"</code><code role="identifier">&gt;</code>
      <code role="identifier">&lt;</code><code role="identifier">include</code><code role="identifier"> </code><code role="type">within</code>=<code role="constant">"example.aspectj.*"</code><code role="identifier"> /&gt;</code>
    <code role="identifier">&lt;/dump&gt;</code>
  <code role="identifier">&lt;/weaver&gt;</code>
<code role="identifier">&lt;/aspectj&gt;</code>
</programlisting><para>(The <filename moreinfo="none">META-INF</filename> directory should be on the
      class path; we’ll assume it’s in the current working directory.) This
      file tells the weaver which aspects to use (the
      <literal moreinfo="none">aspect</literal> tag) and which classes to target for weaving
      (the <literal moreinfo="none">include</literal> tag), and it also enables verbose
      output, which is useful for debugging purposes. Finally, we can run the
      application with the following command:</para><screen format="linespecific">java -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar \
  -javaagent:aspectj-home/lib/aspectjweaver.jar example.aspectj.ComplexMain</screen><para id="para_you_get_several_lines_of_messa">You get several lines of
      messages logging the weaving process. The output ends with these
      lines:</para><screen format="linespecific">new Complex(1.0,2.0) called.
new Complex(3.0,4.0) called.
Calling Complex(1.0,2.0).+(Complex(3.0,4.0))
new Complex(4.0,6.0) called.
Complex.+ returned Complex(4.0,6.0)
Complex(4.0,6.0)</screen><para id="para_all_but_the_last_line_were_out">All but the last line
      were output by <literal moreinfo="none">LogComplex</literal>. We added this additional
      behavior without manually inserting these statements in
      <literal moreinfo="none">Complex</literal> itself!</para><para id="para_recall_we_said_that_the_second">Recall we said that the
      second issue you might encounter when using AspectJ is how to invoke
      Scala code from <emphasis>advice</emphasis>. In our
      <literal moreinfo="none">LogComplex</literal> aspect, the statements inside our
      different <literal moreinfo="none">before</literal> and <literal moreinfo="none">after</literal> advices
      are really just Java code. Therefore, we can just as easily invoke Scala
      code, applying the same lessons we have already learned for invoking
      Scala from Java.</para><para id="para_scala_traits__almost__replace_">Scala traits
      <emphasis>almost</emphasis> replace aspects. We saw in Chapters <xref linkend="Traits" xrefstyle="select: labelnumber"/> and <xref linkend="ApplicationDesign" xrefstyle="select: labelnumber"/> how you
      can construct traits that modify the behavior of other traits, then mix
      the behaviors together when you create new classes or instances. This
      powerful technique lets you implement a form of aspect advice. However,
      Scala doesn’t have a pointcut language, like AspectJ. When you need to
      affect a set of join points that don’t share a common supertype, you’ll
      need the capabilities of AspectJ. However, if you find yourself in that
      situation, you should consider if you can refactor your code to extract
      a common trait that provides the “hooks” you need for advice implemented
      using traits.<indexterm class="endofrange" startref="ch14_JavaLibrariesAspectJ" significance="normal"/><indexterm class="endofrange" startref="ch14_librariesJavaAspectJ" significance="normal"/><indexterm class="endofrange" startref="ch14_AspectJ" significance="normal"/><indexterm significance="normal"><primary>traits</primary><secondary>aspects versus</secondary></indexterm></para></sect2><sect2 id="TheSpringFrameworkInterop"><title>The Spring Framework</title><para id="para_the_spring_framework_springf">The Spring Framework (see
      <link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link>) is an open source,
      modular Java <phrase role="keep-together">enterprise</phrase> framework
      that provides a “pure” Java AOP API, integrated support for <phrase role="keep-together">AspectJ</phrase>, a <emphasis>dependency
      injection</emphasis> (DI) container, uniform and well-designed APIs for
      <phrase role="keep-together">invoking</phrase> a variety of other Java
      third-party APIs, and additional components for <phrase role="keep-together">security</phrase>, web development, etc.<indexterm significance="normal"><primary>libraries</primary><secondary>Java library interoperability</secondary><tertiary>Spring Framework</tertiary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>libraries, interoperability with Scala</secondary><tertiary>Spring Framework</tertiary></indexterm><indexterm significance="normal"><primary>Spring Framework</primary></indexterm></para><para id="para_here_we_focus_on_dependency_in">Here we focus on
      dependency injection, as interoperability issues with the other parts of
      the Spring Framework boil down to either Java or AspectJ issues, which
      we covered earlier.<indexterm significance="normal"><primary>dependency injection (DI)</primary><secondary>Spring Framework</secondary></indexterm></para><para id="para_we_discussed_the_concept_of_de">We discussed the concept
      of DI in <xref linkend="DependencyInjectionInScala"/>, where we showed
      elegant patterns for injecting dependencies using Scala itself. However,
      if you are in a mixed Java/Scala environment, it might be necessary to
      use a DI framework like the one provided by Spring to manage
      dependencies.</para><para id="para_in_spring_di_dependencies_are">In Spring DI, dependencies
      are specified using a combination of XML configuration files and
      source-code annotations. The Spring API resolves these dependencies as
      classes are instantiated. Spring expects these classes to follow
      JavaBean conventions (see <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>). Well-designed classes
      will only depend on abstractions, i.e., Java interfaces or Scala traits,
      and the concrete instances satisfying those dependencies will be given
      to the bean through constructor arguments or through JavaBean setter
      methods. Hence, if you use Spring DI with Scala classes, you will need
      to use the <literal moreinfo="none">@scala.reflect.BeanProperty</literal> annotation
      when you use setter injection. The annotation is not needed when you use
      constructor injection.<indexterm significance="normal"><primary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty
          annotation</primary></indexterm><indexterm significance="normal"><primary>annotations</primary><secondary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty</secondary></indexterm><indexterm significance="normal"><primary>JavaBeans</primary><secondary>conventions for</secondary></indexterm></para><tip id="para_tip_prefer_constructor_inject"><para>Prefer constructor injection, when possible. Not only does this
        choice eliminate the need to use the <literal moreinfo="none">@BeanProperty</literal>
        annotation, it leaves each instances in a known good state when the
        construction process is <phrase role="keep-together">finished</phrase>.</para></tip><para id="para_however_if_you_inject_depende">However, if you inject
      dependencies into Scala <literal moreinfo="none">objects</literal>, you must use setter
      injection, as you have no way to define constructor parameters and you
      have no control over the construction process.</para><para id="para_one_other_point_remember_that">One other point; remember
      that Spring will expect Java-compatible names, so you must use
      <emphasis>encoded</emphasis> names for methods and
      <literal moreinfo="none">objects</literal>, as needed.</para><para id="para_here_is_an_example_that_illust">Here is an example that
      illustrates “wiring together” objects with Spring:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/spring/object-bean.scala</code>

<code role="preproc">package</code> example.spring

<code role="statement">case</code> <code role="statement">class</code> <code role="special">NamedObject</code>(name:<code role="type"> String</code>)

<code role="statement">trait</code> <code role="special">Factory</code> {
  @scala.reflect.<code role="special">BeanProperty</code>
  <code role="statement">var</code> nameOfFactory = <code role="constant">"unknown"</code>

  <code role="statement">def</code> <code role="identifier">make</code>(name:<code role="type"> String</code>):<code role="type"> AnyRef</code>
}

<code role="statement">object</code> <code role="special">NamedObjectFactory</code> <code role="statement">extends</code> <code role="special">Factory</code> {
  <code role="statement">def</code> <code role="identifier">make</code>(name:<code role="type"> String</code>) = <code role="special">NamedObject</code>(name)
}

<code role="statement">case</code> <code role="statement">class</code> <code role="special">FactoryUsingBean</code>(factory:<code role="type"> Factory</code>)
</programlisting><para id="para_the_case_class_factoryusingbe">The case class
      <literal moreinfo="none">FactoryUsingBean</literal> is a simple type with a dependency
      on a <literal moreinfo="none">Factory</literal> abstraction that we want to inject using
      constructor injection.</para><para id="para_the_trait_factory_defines_th">The trait
      <literal moreinfo="none">Factory</literal> defines the factory abstraction. It has a
      <literal moreinfo="none">make</literal> method to create instances of some kind. To
      demonstrate setter injection on <literal moreinfo="none">objects</literal>, we also give
      it a <literal moreinfo="none">nameOfFac⁠tory</literal> field. This will demonstrate
      <literal moreinfo="none">object</literal> dependency injection because the concrete
      subtype we will actually use, <literal moreinfo="none">NamedObjectFactory</literal>, is
      an <literal moreinfo="none">object</literal>.</para><para id="para_scala_requires_us_to_initializ">Scala requires us to
      initialize <literal moreinfo="none">nameOfFactory</literal> with a value, but we will
      use Spring to set the real value. We have to use the
      <literal moreinfo="none">@BeanProperty</literal> annotation to generate the
      <literal moreinfo="none">setNameOfFactory</literal> method Spring will expect to
      find.</para><para id="para_the_concrete_make_method_in_">The concrete
      <literal moreinfo="none">make</literal> method in <literal moreinfo="none">NamedObjectFactory</literal>
      creates a new <literal moreinfo="none">NamedObject</literal>. It is a simple case class
      with a <literal moreinfo="none">name</literal> field.</para><para id="para_note_that_none_of_these_types_">Note that none of these
      types depend on the Spring API. You can compile this file without any
      Spring JAR files.</para><para id="para_next_we_define_the_dependency">Next, we define the
      dependency “wiring” using a standard Spring XML configuration
      file:</para><programlisting language="xml" format="linespecific"><code role="comment">&lt;!</code><code role="comment">-- code-examples/ToolsLibs/spring/scala-spring.xml --</code><code role="comment">&gt;</code>

<code role="identifier">&lt;</code><code role="identifier">beans</code><code role="identifier"> </code><code role="type">xmlns</code>=<code role="constant">""</code>
<code role="identifier">       </code><code role="type">xmlns</code><code role="comment">:</code><code role="type">xsi</code>=<code role="constant">""</code>
<code role="identifier">       </code><code role="type">xsi</code><code role="comment">:</code><code role="type">schemaLocation</code>=<code role="constant">"</code>
<code role="constant">         "</code><code role="identifier">&gt;</code>

  <code role="identifier">&lt;</code><code role="identifier">bean</code><code role="identifier"> </code><code role="type">id</code>=<code role="constant">"factory"</code><code role="identifier"> </code><code role="type">class</code>=<code role="constant">"example.spring.NamedObjectFactory$"</code><code role="identifier">&gt;</code>
    <code role="identifier">&lt;</code><code role="identifier">property</code><code role="identifier"> </code><code role="type">name</code>=<code role="constant">"nameOfFactory"</code><code role="identifier"> </code><code role="type">value</code>=<code role="constant">"Factory for Named Objects"</code><code role="identifier"> /&gt;</code>
  <code role="identifier">&lt;/bean&gt;</code>

  <code role="identifier">&lt;</code><code role="identifier">bean</code><code role="identifier"> </code><code role="type">id</code>=<code role="constant">"factoryUsingBean"</code><code role="identifier"> </code><code role="type">class</code>=<code role="constant">"example.spring.FactoryUsingBean"</code><code role="identifier">&gt;</code>
    <code role="identifier">&lt;</code><code role="identifier">constructor-arg</code><code role="identifier"> </code><code role="type">ref</code>=<code role="constant">"factory"</code><code role="identifier"> /&gt;</code>
  <code role="identifier">&lt;/bean&gt;</code>
<code role="identifier">&lt;/beans&gt;</code>
</programlisting><para id="para_we_define_two_beans_our_fac">We define two
      <literal moreinfo="none">beans</literal>. Our factory is given the ID
      <literal moreinfo="none">factory</literal>. The “class” is actually the
      <literal moreinfo="none">object</literal> <literal moreinfo="none">NamedObjectFactory</literal>. Note
      that we have to append a <literal moreinfo="none">$</literal> to the end of the name,
      the actual name of the <literal moreinfo="none">object</literal> in the byte
      code.</para><para id="para_the_property_tag_sets_the_va">The
      <literal moreinfo="none">property</literal> tag sets the value of
      <literal moreinfo="none">nameOfFactory</literal>. We can’t control instantiation of
      <literal moreinfo="none">objects</literal>, so we have to inject the correct dependency
      after construction completes.</para><para id="para_the_second_bean_is_our_simple_">The second bean is our
      simple <literal moreinfo="none">FactoryUsingBean</literal>. Since this is a
      <literal moreinfo="none">class</literal>, we can use constructor injection. The
      <literal moreinfo="none">constructor</literal> tag specifies that the
      <literal moreinfo="none">factory</literal> bean is used to satisfy the dependency at
      construction time.</para><para id="para_spring_di_script">Finally, here is a script that uses
      these types to demonstrate Spring DI with Scala:</para><programlisting language="scala" format="linespecific"><code role="comment">// code-examples/ToolsLibs/spring/object-bean-script.scala</code>

<code role="preproc">import</code> example.spring._
<code role="preproc">import</code> org.springframework.context.support._

<code role="statement">val</code> context = <code role="statement">new</code> <code role="special">ClassPathXmlApplicationContext</code>(<code role="constant">"spring/scala-spring.xml"</code>);

<code role="statement">val</code> bean = context.getBean(<code role="constant">"factoryUsingBean"</code>).asInstanceOf[<code role="special">FactoryUsingBean</code>]
println(<code role="constant">"Factory Name: "</code> + bean.factory.nameOfFactory)

<code role="statement">val</code> obj  = bean.factory.make(<code role="constant">"Dean Wampler"</code>)
println(<code role="constant">"Object: "</code> + obj)
</programlisting><para id="para_we_create_an_instance_of_clas">We create an instance of
      <literal moreinfo="none">ClassPathXmlApplicationContext</literal>, specifying our XML
      file. This context object is our gateway to the DI container. We ask it
      for our <literal moreinfo="none">factoryUsingBean</literal>. We have to cast the
      returned <literal moreinfo="none">AnyRef</literal> (i.e., Java
      <literal moreinfo="none">Object</literal>) to the correct type. We print out the
      factory’s name, to see if it is correct.</para><para id="para_next_we_ask_the_bean_s_factor">Next, we ask the bean’s
      factory to make “something” with the string <literal moreinfo="none">"Dean
      Wampler"</literal>. When we print the returned object, it should be a
      <literal moreinfo="none">NamedObject</literal>.</para><para id="para_if_you_have_spring_installed_i">If you have Spring
      installed in a <replaceable>spring-home</replaceable> directory, you can
      run this script with the following command:</para><screen format="linespecific">scala -cp \
  spring-home/dist/spring.jar:spring-home/.../commons-logging.jar:. \
  spring/object-bean-script.scala</screen><?dbfo-need height=”1in”
?><para>(The current working directory “<filename moreinfo="none">.</filename>” is needed
      in the classpath to find the XML file.) There are many lines of logging
      output. The last two lines are what we care about:</para><screen format="linespecific">...
Factory Name: Factory for Named Objects
Object: NamedObject(Dean Wampler)</screen><para id="para_this_example_required_a_number">This example required a
      number of files and configuration details to get working. For a
      moderately large Java application, the effort is justified. However,
      Scala gives you new and simpler ways to implement dependency injection
      in Scala code without configuration files and a DI container.</para></sect2><sect2 id="TerracottaInterop"><title>Terracotta</title><para id="para_terracotta_terracotta_is_a">Terracotta (see <link linkend="Terracotta" xrefstyle="select:nopage">[Terracotta]</link>) is
      an open source clustering product that distributes an application over
      several servers by clustering JVMs upon which the application executes.
      For efficiency, not all of the application’s heap objects are
      distributed. Instead, the programmer specifies which data structures to
      distribute through configuration files. A benefit of Terracotta is that
      the application does not require code changes to support this clustering
      (at least in principle; some limited customization can be useful for
      performance reasons). Instead, the byte code is instrumented to provide
      the clustering. Terracotta is an alternative to distributed caches that
      require code changes.<indexterm significance="normal"><primary>libraries</primary><secondary>Java library interoperability</secondary><tertiary>Terracotta</tertiary></indexterm><indexterm significance="normal"><primary>Java</primary><secondary>libraries, interoperability with Scala</secondary><tertiary>Terracotta</tertiary></indexterm><indexterm significance="normal"><primary>Terracotta library</primary></indexterm></para><para id="para_terracotta_example"><link linkend="Boner2008a" xrefstyle="select:nopage">[Bonér2008a]</link> provides a detailed
      write-up of how to use Terracotta with Scala Actors. A Scala-specific
      Terracotta Integration Module (TIM) must be installed. When configuring
      which objects to distribute, you have to use the encoded names for
      companion objects, method names, etc., as they exist at the byte code
      level. We discussed these encodings in <xref linkend="ScalaNamesInJavaCode"/>. Finally, you have to add some more
      parameters to the <literal moreinfo="none">java</literal> invocation command inside the
      <literal moreinfo="none">scala</literal> script. Otherwise, clustering Scala
      applications with Terracotta works just like it does for Java <phrase role="keep-together">applications</phrase>.</para></sect2><sect2 id="HadoopInterop"><title>Hadoop</title><para id="para_what_is_mapreduce"><emphasis>MapReduce</emphasis> is a
      divide-and-conquer programming model for processing large data sets in
      parallel. In the “map” phase, a data set is divided into N subsets of
      approximately equal size, where N is chosen to optimize the amount of
      work that can be done in parallel. For example, N might be close to the
      total number of processor cores available. (A few cores might be left
      idle as “backups” or for doing other processing.) The desired
      computation is performed on each subset. The “reduce” phase combines the
      results of the subset calculations into a final result.<indexterm significance="normal"><primary>Java</primary><secondary>libraries, interoperability with Scala</secondary><tertiary>Hadoop</tertiary></indexterm><indexterm significance="normal"><primary>libraries</primary><secondary>Java library interoperability</secondary><tertiary>Hadoop</tertiary></indexterm><indexterm significance="normal"><primary>Hadoop library</primary></indexterm></para><para id="para_note_that_mapping_and_reducing">Note that mapping and
      reducing are essentially functional operations. Therefore, a functional
      language like Scala is ideally suited for writing MapReduce
      applications.<indexterm significance="normal"><primary>MapReduce</primary></indexterm></para><?dbfo-need height=”2in”
?><para id="para_mapreduce_frameworks">MapReduce frameworks provide tools
      for mapping and reducing data sets, managing all phases of the
      computation, including the processing nodes, restarting operations that
      fail for some reason, etc. The user of a MapReduce framework only has to
      write the algorithms for mapping (subdividing) the input data, the
      computations with the data subsets, and reducing the results. See <link linkend="MapReduceTutorial" xrefstyle="select:nopage">[MapReduceTutorial]</link> for a succinct
      overview and <link linkend="MapReduce" xrefstyle="select:nopage">[MapReduce]</link> for a description of
      Google’s MapReduce framework. The name of the Google framework has
      become a de facto standard for these frameworks.</para><para id="para_hadoop_hadoop_is_an_open_s">Hadoop (see <link linkend="Hadoop" xrefstyle="select:nopage">[Hadoop]</link>) is an open
      source MapReduce framework created and maintained by Yahoo!. There are
      two Scala wrappers around the Hadoop API: <emphasis>SHadoop</emphasis>
      (see <link linkend="SHadoop" xrefstyle="select:nopage">[SHadoop]</link>)
      and <emphasis>SMR</emphasis> (see <link linkend="SMRa" xrefstyle="select:nopage">[SMRa]</link> and (<link linkend="SMRb" xrefstyle="select:nopage">[SMRb]</link>). Both examples demonstrate the
      great reduction in code size when using Scala. <link linkend="SMRa" xrefstyle="select:nopage">[SMRa]</link> attributes this code reduction
      to Scala’s support for higher-order and anonymous functions, its
      sophisticated type system and type inference, and the ability of
      <literal moreinfo="none">for</literal> comprehensions to generate maps in an elegant and
      succinct way.<indexterm class="endofrange" startref="ch14_librariesJava" significance="normal"/><indexterm class="endofrange" startref="ch14_Javalibraries" significance="normal"/></para></sect2></sect1><sect1 id="_recap_and_what_s_next_5"><title>Recap and What’s Next</title><para id="para_this_chapter_filled_in_the_det">This chapter filled in the
    details of the Scala command-line tools that you will use every day. We
    also surveyed the available support for Scala in various text editors and
    IDEs. We discussed a number of important libraries, such as testing APIs.
    Finally, we discussed interoperability between Scala and other JVM
    languages and libraries.</para><para id="para_this_completes_our_survey_of_t">This completes our survey
    of the world of Scala programming. The next chapter is a list of
    references for further exploration, followed by a glossary of terms that
    we have used throughout the book.</para></sect1></chapter><appendix id="References"><title>References</title><para id="Abelson1996">[Abelson1996] Harold Abelson, Gerald Jay Sussman, and
  Julie Sussman, <citetitle>Structure and Interpretation of Computer
  Programs</citetitle>, The MIT Press, 1996.</para><para id="Agha1987">[Agha1987] Gul Agha, <citetitle>Actors</citetitle>, The
  MIT Press, 1987.</para><para id="Akka">[Akka] Akka: RESTful Distributed Persistent Transactional
  Actors, <ulink url="http://akkasource.org">http://akkasource.org</ulink>.</para><para id="Ant">[Ant] <citetitle>The Apache Ant Project</citetitle>, <ulink url="http://ant.apache.org/"/>.</para><para id="Antlr">[Antlr] <citetitle>Antlr</citetitle>, <ulink url="http://www.antlr.org/"/>.</para><para id="AOSD">[AOSD] <citetitle>Aspect-Oriented Software
  Development</citetitle>, <ulink url="http://aosd.net/"/>.</para><para id="AspectJ">[AspectJ] <citetitle>The AspectJ Project</citetitle>,
  <ulink url="http://www.eclipse.org/aspectj/"/>.</para><para id="BDD">[BDD] <citetitle>Behavior-Driven Development</citetitle>,
  <ulink url="http://behaviour-driven.org/"/>.</para><para id="Bloch2008">[Bloch2008] Joshua Bloch, <citetitle>Effective
  Java</citetitle> (Second Edition), Addison-Wesley, 2008.</para><para id="Boner2008a">[Bonér2008a] Jonas Bonér, <citetitle>Clustering Scala
  Actors with Terracotta</citetitle>, <ulink url="http://jonasboner.com/2008/01/25/clustering-scala-actors-with-terracotta.html"/>.</para><para id="Boner2008b">[Bonér2008b] Jonas Bonér, <citetitle>Real-World Scala:
  Dependency Injection (DI)</citetitle>, <ulink url="http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di.html"/>.</para><para id="Bruce1998">[Bruce1998] Kim Bruce, Martin Odersky, and Philip
  Wadler, <citetitle>A Statically Safe Alternative to Virtual
  Types</citetitle>, <citetitle>Proc. ECOOP ’98</citetitle>, E. Jul (Ed.),
  LNCS 1445, pp. 523–549, Springer-Verlag, 1998.</para><para id="Buildr">[Buildr] <citetitle>Buildr</citetitle>, <ulink url="http://buildr.apache.org/"/>.</para><para id="Contract4J">[Contract4J] <citetitle>Contract4J: Design by Contract
  for Java</citetitle>, <ulink url="http://contract4j.org/"/>.</para><para id="Cucumber">[Cucumber] <citetitle>Cucumber - Making BDD
  Fun</citetitle>, <ulink url="http://cukes.info"/>.</para><para id="DesignByContract">[DesignByContract] <citetitle>Building bug-free
  O-O software: An introduction to Design by Contract™</citetitle>, <ulink url="http://archive.eiffel.com/doc/manuals/technology/contract/"/>.</para><para id="Deursen">[Deursen] Arie van Deursen, Paul Klint, and Joost Visser,
  <citetitle>Domain-Specific Languages: An Annotated Bibliography</citetitle>,
  <ulink url="http://homepages.cwi.nl/~arie/papers/dslbib/"/>.</para><para id="EBNF">[EBNF] <citetitle>Extended Backus-Naur Form</citetitle>,
  <ulink url="http://en.wikipedia.org/wiki/Extended_Backus–Naur_Form"/>.</para><para id="Eiffel">[Eiffel] <citetitle>Eiffel Software</citetitle>, <ulink url="http://eiffel.com"/>.</para><para id="Ford">[Ford] Bryan Ford, <citetitle>The Packrat Parsing and
  Parsing Expression Grammars Page</citetitle>, <ulink url="http://pdos.csail.mit.edu/~baford/packrat/"/>.</para><para id="Ford2009">[Ford2009] Neal Ford, <citetitle>Advanced DSLs in
  Ruby</citetitle>, <ulink url="http://github.com/nealford/presentations/tree/master"/>.</para><para id="Fowler2009">[Fowler2009] Martin Fowler, <citetitle>Domain Specific
  Languages</citetitle> (forthcoming), <ulink url="http://martinfowler.com/dslwip/"/>.</para><para id="FunctionalJava">[FunctionalJava] <citetitle>Functional
  Java</citetitle>, <ulink url="http://functionaljava.org"/>.</para><para id="Ghosh2008a">[Ghosh2008a] Debasish Ghosh, <citetitle>External DSLs
  made easy with Scala Parser Combinators</citetitle>, <ulink url="http://debasishg.blogspot.com/2008/04/external-dsls-made-easy-with-scala.html"/>.</para><para id="Ghosh2008b">[Ghosh2008b] Debasish Ghosh, <citetitle>Designing
  Internal DSLs in Scala</citetitle>, <ulink url="http://debasishg.blogspot.com/2008/05/designing-internal-dsls-in-scala.html"/>.</para><para id="GOF1995">[GOF1995] Erich Gamma, Richard Helm, Ralph Johnson, and
  John Vlissides (“Gang of Four”), <citetitle>Design Patterns: Elements of
  Reusable Object-Oriented Software</citetitle>, Addison-Wesley, 1995.</para><para id="Guice">[Guice] <citetitle>Guice</citetitle>, <ulink url="http://code.google.com/p/google-guice/"/>.</para><para id="Hadoop">[Hadoop] <citetitle>Hadoop</citetitle>, <ulink url="http://hadoop.apache.org"/>.</para><para id="Haller2007">[Haller2007] Philipp Haller and Martin Odersky,
  <citetitle>Actors That Unify Threads and Events</citetitle>, <ulink url="http://lamp.epfl.ch/~phaller/doc/haller07coord.pdf"/>.</para><para id="Hewitt1973">[Hewitt1973] Carl Hewitt, Peter Bishop, and Richard
  Steiger, <citetitle>A Universal Modular Actor Formalism for Artificial
  Intelligence</citetitle>, <ulink url="http://dli.iiit.ac.in/ijcai/IJCAI-73/PDF/027B.pdf"/>,
  1973.</para><para id="Hoare2009">[Hoare2009] Tony Hoare, <citetitle>Null References: The
  Billion Dollar Mistake</citetitle>, <ulink url="http://qconlondon.com/london-2009/speaker/Tony+Hoare"/>.</para><para id="Hofer2008">[Hofer2008] Christian Hofer, Klaus Ostermann, Tillmann
  Rendel, and Adriaan Moors, <citetitle>Polymorphic Embedding of
  DSLs</citetitle>, GPCE ’08, October 19–23, 2008, Nashville, Tennessee,
  <ulink url="http://www.daimi.au.dk/~ko/papers/gpce50_hofer.pdf"/>.</para><para id="HTTP11">[HTTP11] <citetitle>Hypertext Transfer
  Protocol — HTTP/1.1</citetitle>, <ulink url="http://www.w3.org/Protocols/rfc2616/rfc2616.html"/>.</para><para id="Hunt2000">[Hunt2000] Andrew Hunt and Dave Thomas, <citetitle>The
  Pragmatic Programmer</citetitle>, Addison-Wesley, 2000.</para><para id="JAD">[JAD] <citetitle>JAva Decompiler (JAD)</citetitle>, <ulink url="http://www.varaneckas.com/jad"/>.</para><para id="Java6API">[Java6API] <citetitle>Java Platform SE 6
  API</citetitle>, <ulink url="http://java.sun.com/javase/6/docs/api/"/>.</para><para id="JavaBeansSpec">[JavaBeansSpec] <citetitle>JavaBeans
  Specification</citetitle>, <ulink url="http://java.sun.com/javase/technologies/desktop/javabeans/docs/spec.html"/>.</para><para id="JPAScala">[JPAScala] <citetitle>Using JPA with Scala</citetitle>,
  <ulink url="http://www.hars.de/2009/03/jpa-with-scala.html"/>.</para><para id="JRuby">[JRuby] <citetitle>JRuby</citetitle>, <ulink url="http://jruby.codehaus.org/"/>.</para><para id="JUnit">[JUnit] <citetitle>JUnit</citetitle>, <ulink url="http://junit.org"/>.</para><para id="Laddad2009">[Laddad2009] Ramnivas Laddad, <citetitle>AspectJ in
  Action</citetitle> (Second Edition), Manning Press, 2009.</para><para id="Mailslot">[Mailslot] <citetitle>Mailslot</citetitle>, <ulink url="http://github.com/stevej/mailslot/"/>.</para><para id="MapReduce">[MapReduce] <citetitle>MapReduce</citetitle>, <ulink url="http://labs.google.com/papers/mapreduce.html"/>.</para><para id="MapReduceTutorial">[MapReduceTutorial] <citetitle>Introduction to
  Parallel Programming and MapReduce</citetitle>, <ulink url="http://code.google.com/edu/parallel/mapreduce-tutorial.html"/>.</para><para id="Martin2003">[Martin2003] Robert C. Martin, <citetitle>Agile
  Software Development: Principles, Patterns, and Practices</citetitle>,
  Prentice Hall, 2003.</para><para id="Maven">[Maven] <citetitle>The Apache Maven Project</citetitle>,
  <ulink url="http://maven.apache.org/"/>.</para><para id="McBeath">[McBeath] Jim McBeath, <citetitle>Scala Syntax
  Primer</citetitle>, <ulink url="http://jim-mcbeath.blogspot.com/2008/09/scala-syntax-primer.html"/>.</para><para id="McIver2009">[McIver2009] David R. MacIver, <citetitle>Scala trivia
  of the day: Traits can extend classes</citetitle>, <ulink url="http://www.drmaciver.com/2009/04/scala-trivia-of-the-day-traits-can-extend-classes/"/>.</para><para id="Meyer1997">[Meyer1997] Bertrand Meyer, <citetitle>Object-Oriented
  Software Construction</citetitle> (Second Edition), Prentice Hall,
  1997.</para><para id="MINA">[MINA] <citetitle>Apache MINA</citetitle>, <ulink url="http://mina.apache.org/"/>.</para><para id="MoneyInJava">[MoneyInJava] Thomas Paul, <citetitle>Working with
  Money in Java</citetitle>, <ulink url="http://www.javaranch.com/journal/2003/07/MoneyInJava.html"/>.</para><para id="Naftalin2006">[Naftalin2006] Maurice Naftalin and Philip Wadler,
  <citetitle>Java Generics and Collections</citetitle>, O’Reilly Media,
  2006.</para><para id="Naggati">[Naggati] <citetitle>Naggati</citetitle>, <ulink url="http://github.com/robey/naggati/"/>.</para><para id="Odersky2005">[Odersky2005] Martin Odersky and Matthias Zenger,
  <citetitle>Scalable Component Abstractions</citetitle>, <emphasis>OOPSLA
  ’05</emphasis>, October 16–20, 2005, San Diego, California, USA.</para><para id="Odersky2006">[Odersky2006] Martin Odersky, <citetitle>Pimp My
  Library</citetitle>, <ulink url="http://www.artima.com/weblogs/viewpost.jsp?thread=179766"/>.</para><para id="Odersky2008">[Odersky2008] Martin Odersky, Lex Spoon, and Bill
  Venners, <citetitle>Programming in Scala</citetitle>, Artima Press,
  2008.</para><para id="Odersky2009">[Odersky2009] Martin Odersky, Lex Spoon, and Bill
  Venners, <citetitle>How to Write an Equality Method in Java</citetitle>,
  <ulink url="http://www.artima.com/lejava/articles/equality.html"/>.</para><para id="Okasaki1998">[Okasaki1998] Chris Okasaki, <citetitle>Purely
  Functional Data Structures</citetitle>, Cambridge University Press,
  1998.</para><para id="Ortiz2007">[Ortiz2007] Jorge Ortiz, <citetitle>Fun with Project
  Euler and Scala</citetitle>, <ulink url="http://scala-blogs.org/2007/12/project-euler-fun-in-scala.html"/>.</para><para id="Ortiz2008">[Ortiz2008] Jorge Ortiz, <citetitle>Manifests: Reified
  Types</citetitle>, <ulink url="http://scala-blogs.org/2008/10/manifests-reified-types.html"/>.</para><para id="OSullivan2009">[OSullivan2009] Bryan O’Sullivan, John Goerzen, and
  Don Steward, <citetitle>Real World Haskell</citetitle>, O’Reilly Media,
  2009.</para><para id="PEG">[PEG] <citetitle>Parsing Expression Grammar</citetitle>,
  <ulink url="http://en.wikipedia.org/wiki/Parsing_expression_grammar"/>.</para><para id="Pierce2002">[Pierce2002] Benjamin C. Pierce, <citetitle>Types and
  Programming Languages</citetitle>, The MIT Press, 2002.</para><para id="Pollak2007">[Pollak2007] David Pollak, <citetitle>The Scala Option
  class and how lift uses it</citetitle>, <ulink url="http://blog.lostlake.org/index.php?/archives/50-The-Scala-Option-class-and-how-lift-uses-it.html"/>.</para><para id="QuickCheck">[QuickCheck] <citetitle>QuickCheck, Automated
  Specification-Based Testing</citetitle>, <ulink url="http://www.cs.chalmers.se/~rjmh/QuickCheck/"/>.</para><para id="Rabhi1999">[Rabhi1999] Fethi Rabhi and Guy Lapalme,
  <citetitle>Algorithms: A Functional Programming Approach</citetitle>,
  Addison-Wesley, 1999.</para><para id="RSpec">[RSpec] <citetitle>RSpec</citetitle>, <ulink url="http://rspec.info/"/>.</para><para id="SBT">[SBT] <citetitle>Simple Build Tool</citetitle>, <ulink url="http://code.google.com/p/simple-build-tool/"/>.</para><para id="Scala">[Scala] <citetitle>The Scala Programming
  Language</citetitle>, <ulink url="http://www.scala-lang.org/"/>.</para><para id="ScalaAPI2008">[ScalaAPI2008] <citetitle>The Scala
  Library</citetitle>, <ulink url="http://www.scala-lang.org/docu/files/api/index.html"/>.</para><para id="ScalaCheckTool">[ScalaCheckTool]
  <citetitle>ScalaCheck</citetitle>, <ulink url="http://code.google.com/p/scalacheck/"/>.</para><para id="ScalaSpec2009">[ScalaSpec2009] <citetitle>The Scala Language
  Specification</citetitle>, <ulink url="http://www.scala-lang.org/sites/default/files/linuxsoft_archives/docu/files/ScalaReference.pdf"/>.</para><para id="ScalaSpecsTool">[ScalaSpecsTool] <citetitle>Specs</citetitle>,
  <ulink url="http://code.google.com/p/specs/"/>.</para><para id="ScalaTestTool">[ScalaTestTool] <citetitle>ScalaTest</citetitle>,
  <ulink url="http://www.artima.com/scalatest/"/>.</para><para id="ScalaTips">[ScalaTips] <citetitle>Scala Tips Blog</citetitle>,
  <ulink url="http://scalatips.tumblr.com/"/>.</para><para id="ScalaTools">[ScalaTools] <citetitle>Scala Tools</citetitle>,
  <ulink url="http://www.scala-tools.org/"/>.</para><para id="ScalaWiki">[ScalaWiki] <citetitle>Scala Wiki</citetitle>, <ulink url="http://scala.sygneca.com/"/>.</para><para id="ScalaWikiPatterns">[ScalaWikiPatterns] <citetitle>Scala Wiki:
  Scala Design Patterns</citetitle>, <ulink url="http://scala.sygneca.com/patterns/start"/>.</para><para id="Scalaz_bibentry">[ScalaZ] <citetitle>Scalaz</citetitle>, <ulink url="http://code.google.com/p/scalaz/"/>.</para><para id="SHadoop">[SHadoop] Jonhnny Weslley (sic), <citetitle>SHadoop: What
  is Scala and Hadoop?</citetitle>, <ulink url="http://jonhnny-weslley.blogspot.com/2008/05/shadoop.html"/>.</para><para id="SleepingBarberProblem">[SleepingBarberProblem] <citetitle>Sleeping
  barber problem</citetitle>, <ulink url="http://en.wikipedia.org/wiki/Sleeping_barber_problem"/>.</para><para id="SMRa">[SMRa] David Hall, <citetitle>A Scalable Language, and a
  Scalable Framework</citetitle>, <ulink url="http://scala-blogs.org/2008/09/scalable-language-and-scalable.html"/>.</para><para id="SMRb">[SMRb] <citetitle>Scala Map Reduce</citetitle>, <ulink url="http://github.com/dlwh/smr/"/>.</para><para id="Smith2009a">[Smith2009a] Eishay Smith, <citetitle>Beware of
  Scala’s Type Inference</citetitle>, <ulink url="http://www.eishay.com/2009/05/beware-of-scalas-type-inference.html"/>.</para><para id="Smith2009b">[Smith2009b] Eishay Smith, <citetitle>Unexpected
  repeated execution in Scala</citetitle>, <ulink url="http://www.eishay.com/2009/06/unexpected-repeated-execution-in-scala.html"/>.</para><para id="Spiewak2008">[Spiewak2008] Daniel Spiewak, <citetitle>What is
  Hindley-Milner? (and why is it cool?)</citetitle>, <ulink url="http://www.codecommit.com/blog/scala/what-is-hindley-milner-and-why-is-it-cool"/>.</para><para id="Spiewak2009a">[Spiewak2009a] Daniel Spiewak, <citetitle>Interop
  Between Java and Scala</citetitle>, <ulink url="http://www.codecommit.com/blog/java/interop-between-java-and-scala"/>.</para><para id="Spiewak2009b">[Spiewak2009b] Daniel Spiewak, <citetitle>The Magic
  Behind Parser Combinators</citetitle>, <ulink url="http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators"/>.</para><para id="Spiewak2009c">[Spiewak2009c] Daniel Spiewak,
  <citetitle>Practically Functional</citetitle>, talk at the Chicago-Area
  Scala Enthusiasts, May 21, 2009.</para><para id="SpringFramework">[SpringFramework] <citetitle>The Spring
  Framework</citetitle>, <ulink url="http://springframework.org"/>.</para><para id="SXR">[SXR] <citetitle>A Scala source code browser</citetitle>,
  <ulink url="http://github.com/harrah/browse/tree/master"/>.</para><para id="Szyperski1998">[Szyperski1998] Clemens Szyperski,
  <citetitle>Component Software: Beyond Object-Oriented
  Programming</citetitle>, Addison-Wesley Longman Limited, 1998.</para><para id="TDD">[TDD] <citetitle>Test-Driven Development</citetitle>, <ulink url="http://en.wikipedia.org/wiki/Test-driven_development"/>.</para><para id="Terracotta">[Terracotta] <citetitle>Terracotta</citetitle>, <ulink url="http://terracotta.org/"/>.</para><para id="TestNG">[TestNG] <citetitle>TestNG</citetitle>, <ulink url="http://testng.org/"/>.</para><para id="Turbak2008">[Turbak2008] Franklyn Turbak, David Gifford, and Mark
  A. Sheldon, <citetitle>Design Concepts of Programming Languages</citetitle>,
  The MIT Press, 2008.</para><para id="TypeInference">[TypeInference] <citetitle>Type
  inference</citetitle>, <ulink url="http://en.wikipedia.org/wiki/Type_inference"/>.</para><para id="VanRoy2004">[VanRoy2004] Peter Van Roy and Seif Haridi,
  <citetitle>Concepts, Techniques, and Models of Computer
  Programming</citetitle>, The MIT Press, 2004.</para><para id="Wampler2008">[Wampler2008] Dean Wampler, <citetitle>Traits vs.
  Aspects in Scala</citetitle>, <ulink url="http://blog.objectmentor.com/articles/2008/09/27/traits-vs-aspects-in-scala"/>.</para><para id="WirfsBrock2003">[WirfsBrock2003] Rebecca Wirfs-Brock and Alan
  McKean, <citetitle>Object Design: Roles, Responsibilities, and
  Collaborations</citetitle>, Pearson Education, 2003.</para></appendix><glossary id="Glossary"><title>Glossary</title><glossentry id="glossentry-tag"><glossterm>$tag</glossterm><glossdef><para>A method declared by the <literal moreinfo="none">ScalaObject</literal> trait and
      used internally by Scala. It takes no arguments and returns an integer.
      It is currently used to optimize pattern matching, but it may be removed
      in a future release of Scala. While normally invisible to Scala code (it
      is generated automatically by the compiler), Java code that extends some
      Scala traits and classes may need to implement this method.<indexterm significance="normal"><primary sortas="tag method">$tag method (ScalaObject)</primary></indexterm><indexterm significance="normal"><primary>ScalaObject class</primary><secondary>$tag method</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-abstraction"><glossterm>Abstraction</glossterm><glossdef><para>The outwardly visible state, state transformations, and other
      operations supported by a type. This is separate from the
      <emphasis>encapsulated</emphasis> implementation (fields and methods) of
      the abstraction. Scala <emphasis>traits</emphasis> and
      <emphasis>abstract classes</emphasis> are often used to define
      abstractions and optionally implement them. <emphasis>Concrete
      types</emphasis> provide complete implementations.<indexterm significance="normal"><primary>abstraction</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-abstract-type"><glossterm>Abstract Type</glossterm><glossdef><orderedlist id="glossary_abstract_type" numeration="lowerroman" inheritnum="ignore" continuation="restarts"><listitem><para>A <emphasis>class</emphasis> or <emphasis>trait</emphasis>
          with one or more methods, fields, or types declared, but <phrase role="keep-together">undefined</phrase>. Abstract types can’t be
          instantiated. Contrast with <emphasis>concrete
          types</emphasis>.<indexterm significance="normal"><primary>abstract types</primary><secondary>defined</secondary></indexterm></para></listitem><listitem><para>A <literal moreinfo="none">type</literal> declaration within an
          <emphasis>class</emphasis> or <emphasis>trait</emphasis> that is
          abstract.</para></listitem></orderedlist></glossdef></glossentry><glossentry id="glossentry-actor"><glossterm>Actor</glossterm><glossdef><para>An autonomous sender and receiver of messages in the
      <emphasis>Actor model of concurrency</emphasis>.<indexterm significance="normal"><primary>Actors</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-actor-model-of-concurrency"><glossterm>Actor Model of Concurrency</glossterm><glossdef><para>A concurrency model where autonomous <emphasis>Actors</emphasis>
      coordinate work by exchanging <phrase role="keep-together">messages</phrase>. An Actor’s messages are stored
      in a <emphasis>mailbox</emphasis> until the Actor processes
      them.<indexterm significance="normal"><primary>concurrency</primary><secondary>Actor model of</secondary></indexterm><indexterm significance="normal"><primary>Actors</primary><secondary>Actor model of concurrency</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-annotated-type"><glossterm>Annotated Type</glossterm><glossdef><para>Any type that has one or more <literal moreinfo="none">@</literal> annotations
      applied to it.<indexterm significance="normal"><primary>annotated types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-annotation"><glossterm>Annotation</glossterm><glossdef><para>A way of attaching “metadata” to a declaration that can be
      exploited by the compiler and other tools for code generation,
      verification and validation, etc. In Scala (and Java), an annotation is
      a class. When used, it is prefixed with the <literal moreinfo="none">@</literal>
      character.<indexterm significance="normal"><primary>annotations</primary><secondary>defined</secondary></indexterm></para><para id="para_any_explicit_type_declarations">Any explicit type
      declarations are also called <emphasis>type
      annotations</emphasis>.</para><para id="para_one_or_more_additions_to_a_typ">One or more additions to
      a type declaration that specify behaviors like variance under
      inheritance, bounds, and views.</para></glossdef></glossentry><glossentry id="glossentry-application"><glossterm>Application</glossterm><glossdef><para>In Scala, any <literal moreinfo="none">object</literal> with a
      <literal moreinfo="none">main</literal> routine that is invoked by the JVM or .NET CLR
      at the start of a new process.<indexterm significance="normal"><primary>applications</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-arity"><glossterm>Arity</glossterm><glossdef><para>The number of arguments to a function.<indexterm significance="normal"><primary>arity</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-aspect-oriented-programming"><glossterm>Aspect-Oriented Programming</glossterm><glossdef><para>(Sometimes called <emphasis>aspect-oriented software
      development</emphasis>.) An approach to <emphasis>cross-cutting
      concerns</emphasis>, where the concerns are designed and implemented in
      a “modular” way (that is, with appropriate encapsulation, lack of
      duplication, etc.), then integrated into all the relevant execution
      points in a succinct and robust way, e.g., through declarative or
      programmatic means. In AOP terms, the execution points are called
      <emphasis>join points</emphasis>; a particular set of them is called a
      <emphasis>pointcut</emphasis>; and the new behavior that is executed
      before, after, or “around” a join point is called
      <emphasis>advice</emphasis>. <emphasis>AspectJ</emphasis> is the best
      known AOP toolkit. Scala <emphasis>traits</emphasis> can be used to
      implement some aspect-like functionality.<indexterm significance="normal"><primary>aspect-oriented programming (AOP)</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-aspectj"><glossterm>AspectJ</glossterm><glossdef><para>An extension of Java that supports <emphasis>Aspect-Ori⁠ented
      Programming</emphasis>. AspectJ (<link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link>) supports two forms of
      syntax: an extended Java-based syntax, and a “pure” Java syntax that
      uses Java annotations to indicate the <emphasis>pointcuts</emphasis> and
      <emphasis>advices</emphasis> of an aspect. The aspect behaviors
      (advices) can be incorporated into the target code at compile time, as a
      <phrase role="keep-together">post-</phrase><phrase role="keep-together">compile</phrase> “weaving” step, or at load
      time.<indexterm significance="normal"><primary>AspectJ library</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-attribute"><glossterm>Attribute</glossterm><glossdef><para>Another name for a <emphasis>field</emphasis>, used by <phrase role="keep-together">convention</phrase> in many object-oriented
      programming languages. Scala follows Java’s convention of preferring the
      term <emphasis>field</emphasis> over <emphasis role="keep-together">attribute</emphasis>.<indexterm significance="normal"><primary>attributes</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-auxiliary-constructor"><glossterm>Auxiliary Constructor</glossterm><glossdef><para>A secondary constructor of a class, declared as a method named
      <literal moreinfo="none">this</literal> with no return type. An auxiliary constructor
      must invoke the <emphasis>primary constructor</emphasis> or a previously
      defined <emphasis>auxiliary constructor</emphasis> as the first or only
      statement in its method body.<indexterm significance="normal"><primary>auxiliary constructors</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-base-type"><glossterm>Base Type</glossterm><glossdef><para>A synonym for <emphasis>parent type</emphasis>.<indexterm significance="normal"><primary>base type</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-behavior-driven-development"><glossterm>Behavior-Driven Development</glossterm><glossdef><para>A style of <emphasis>Test-Driven Development</emphasis> (TDD) that
      emphasizes TDD’s role in driving the understanding of requirements for
      the code. You follow the same process as in TDD, where the “tests” are
      written before the code. The difference is that the automated tests are
      written in a format that looks more like a requirements (or behavioral)
      specification and less like a test of the code’s conformance to the
      requirements. However, the specification format is still executable and
      it still provides the verification, validation, and regression testing
      service that TDD tests provide.<indexterm significance="normal"><primary>BDD (Behavior-Driven Development)</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-bound-variable"><glossterm>Bound Variable</glossterm><glossdef><para>A <emphasis>variable</emphasis> that is declared as an argument to
      a <emphasis>function literal</emphasis>. It is “bound” to a value when
      the <emphasis>closure</emphasis> created from the function literal is
      invoked.<indexterm significance="normal"><primary>bound variables</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-by-name-parameter"><glossterm>By-Name Parameter</glossterm><glossdef><para>A <emphasis>by-name parameter</emphasis> looks like a function
      value that takes no parameters, but rather than being declared with the
      signature <literal moreinfo="none">p: () ⇒ R</literal>, where <literal moreinfo="none">R</literal> is
      the return type, it is declared with the signature <literal moreinfo="none">p: ⇒
      R</literal>. By-name parameters are evaluated every time they are
      referenced in the function, rather than being evaluated
      <emphasis>once</emphasis> just before the function call, like a
      <emphasis>by-value parameter</emphasis>. For example, they are useful
      for a function that is designed to look like a control construct that
      takes a “block,” not a function with explicit parameter arguments (think
      of how <literal moreinfo="none">while</literal> loops look, for example). The function
      argument that has block-like behavior would be a by-name
      parameter.<indexterm significance="normal"><primary>by-name parameters</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-by-value-parameter"><glossterm>By-Value Parameter</glossterm><glossdef><para>A <emphasis>by-value parameter</emphasis> is the usual kind of
      method parameter that is evaluated before it is passed to the method.
      Contrast with <emphasis>by-name parameter</emphasis>.<indexterm significance="normal"><primary>by-value parameters</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-call-by-name"><glossterm>Call By Name</glossterm><glossdef><para>See <emphasis>by-name parameter</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-call-by-value"><glossterm>Call By Value</glossterm><glossdef><para>See <emphasis>by-value parameter</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-call-site"><glossterm>Call Site</glossterm><glossdef><para>See <emphasis>declaration site</emphasis>.<indexterm significance="normal"><primary>call site</primary><see>declaration site</see></indexterm></para></glossdef></glossentry><glossentry id="glossentry-case"><glossterm>Case</glossterm><glossdef><para>The keyword used in <emphasis>pattern matching</emphasis>
      expressions for testing an object against an
      <emphasis>extractor</emphasis>, type check, etc.<indexterm significance="normal"><primary>case keyword</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-case-class"><glossterm>Case Class</glossterm><glossdef><para>A class declared with the keyword <literal moreinfo="none">case</literal>. The
      Scala compiler automatically defines <literal moreinfo="none">equals</literal>,
      <literal moreinfo="none">hashCode</literal> and <literal moreinfo="none">toString</literal> methods for
      the class and creates a <emphasis>companion object</emphasis> with an
      <literal role="keep-together" moreinfo="none">apply</literal> factory method and an
      <literal moreinfo="none">unapply</literal> extractor method. Case classes are
      particularly convenient for use with <emphasis>pattern
      matching</emphasis> (<emphasis>case</emphasis>) expressions.<indexterm significance="normal"><primary>case classes</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-child-type"><glossterm>Child Type</glossterm><glossdef><para>A class or trait that inherits from a <literal moreinfo="none">parent</literal>
      class or trait. Sometimes called a <emphasis>subtype</emphasis> or
      <emphasis>derived type</emphasis>. See
      <emphasis>inheritance</emphasis>.<indexterm significance="normal"><primary>derived types</primary></indexterm><indexterm significance="normal"><primary>subtypes</primary></indexterm><indexterm significance="normal"><primary>child types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-client"><glossterm>Client</glossterm><glossdef><para>An informal term used throughout the book to indicate a section of
      software that uses another as an API, etc.<indexterm significance="normal"><primary>clients</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-class"><glossterm>Class</glossterm><glossdef><para>A template for <emphasis>instances</emphasis> that will have the
      same fields, representing state values, and the same methods. Scala
      classes support single <emphasis>inheritance</emphasis> and zero or more
      <emphasis>mixin</emphasis> traits. Contrast with
      <emphasis>type</emphasis>.<indexterm significance="normal"><primary>classes</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-closure"><glossterm>Closure</glossterm><glossdef><para>In Scala, an instance that has been created from a
      <emphasis>function literal</emphasis> with all the <emphasis>free
      variables</emphasis> referenced in the function literal bound to
      variables of the same name in the enclosing scope where the function
      literal was defined. In other words, the instance is “closed” in the
      sense that the free variables are bound. Because they are instances,
      closures are <emphasis>first-class</emphasis> values. They can be passed
      to other functions to customize their behavior. For example,
      <literal moreinfo="none">List.foreach</literal> takes a closure that is applied to each
      element in the list. See also <emphasis>bound variables</emphasis> and
      <emphasis>function literals</emphasis>.<indexterm significance="normal"><primary>closures</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-comments"><glossterm>Comments</glossterm><glossdef><para>Scala follows the same comment conventions as Java, C#, C++, etc.
      A <literal moreinfo="none">// <replaceable>comment</replaceable></literal> goes to the
      end of a line, while a <literal moreinfo="none">/* <replaceable role="keep-together">comment</replaceable> */</literal> can cross line
      boundaries.<indexterm significance="normal"><primary>comments</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-companion-class"><glossterm>Companion Class</glossterm><glossdef><para>A <literal moreinfo="none">class</literal> declared with the same name as an
      object and defined in the same source file. See also <emphasis>companion
      object</emphasis>.<indexterm significance="normal"><primary>companion classes</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-companion-object"><glossterm>Companion Object</glossterm><glossdef><para>An <literal moreinfo="none">object</literal> declared with the same name as a
      class (called its <emphasis>companion class</emphasis>) and <phrase role="keep-together">defined</phrase> in the same source file. Companion
      objects are where methods and fields are defined that would be statics
      in Java classes, such as factory methods, <literal moreinfo="none">apply</literal> and
      <literal role="keep-together" moreinfo="none">unapply</literal> for pattern matching,
      etc.<indexterm significance="normal"><primary>companion objects</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-component"><glossterm>Component</glossterm><glossdef><para>For our purposes, an aggregation of cohesive types that expose
      services through well-defined abstractions, while encapsulating
      implementation details and minimizing coupling to other components.
      (There is a wide-range of definitions for <emphasis>component</emphasis>
      in computer science and industry.)<indexterm significance="normal"><primary>components</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-compound-type"><glossterm>Compound Type</glossterm><glossdef><para>The actual type of a declaration of the form <literal moreinfo="none">T1 extends
      T2 with T3 with ... TN { R }</literal>, where <literal moreinfo="none">R</literal> is
      the <emphasis>refinement</emphasis> (body). Definitions in
      <literal moreinfo="none">R</literal> affect the type.<indexterm significance="normal"><primary>compound types</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-concrete-type"><glossterm>Concrete Type</glossterm><glossdef><para>A <emphasis>class</emphasis>, <emphasis>trait</emphasis>, or
      <emphasis>object</emphasis> with all methods, fields, and types defined.
      <emphasis>Instances</emphasis> can be created from concrete types.
      Contrast with <emphasis>abstract types</emphasis>.<indexterm significance="normal"><primary>concrete types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-contract"><glossterm>Contract</glossterm><glossdef><para>The protocol and requirements that exist between a module (e.g.,
      class, trait, object, or even function or method) and clients of the
      module. More specifically, see <emphasis>Design by
      Contract</emphasis>.<indexterm significance="normal"><primary>contract</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-context-free-grammar"><glossterm>Context-Free Grammar</glossterm><glossdef><para>A kind of language grammar for which each
      <emphasis>nonterminal</emphasis> can be specified as a
      <emphasis>production</emphasis> without reference to additional context
      information. That is, each nonterminal can appear by itself on the
      lefthand side of the production the specifies it.<indexterm significance="normal"><primary>grammars</primary><secondary>context-free</secondary></indexterm><indexterm significance="normal"><primary>context-free grammars</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-contravariance-or-contravariant"><glossterm>Contravariance or Contravariant</glossterm><glossdef><para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal moreinfo="none">A</literal>
      is <emphasis>contravariant</emphasis> in a parameterized type
      <literal moreinfo="none">T[-A]</literal>, then the <literal moreinfo="none">-</literal> is the
      <emphasis>variance annotation</emphasis>, and a type
      <literal moreinfo="none">T[B]</literal> is a <emphasis>supertype</emphasis> of
      <literal moreinfo="none">T[A]</literal> if <literal moreinfo="none">B</literal> is a
      <emphasis>subtype</emphasis> of <literal moreinfo="none">A</literal>. See also
      <emphasis>covariance</emphasis> and
      <emphasis>invariance</emphasis>.<indexterm significance="normal"><primary>contravariance or contravariant</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-covariance-or-covariant"><glossterm>Covariance or Covariant</glossterm><glossdef><para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal moreinfo="none">A</literal>
      is <emphasis>covariant</emphasis> in a parameterized type
      <literal moreinfo="none">T[+A]</literal>, then the <literal moreinfo="none">+</literal> is the
      <emphasis>variance annotation</emphasis>, and a type
      <literal moreinfo="none">T[B]</literal> is a <emphasis>subtype</emphasis> of
      <literal moreinfo="none">T[A]</literal> if <literal moreinfo="none">B</literal> is a
      <emphasis>subtype</emphasis> of <literal moreinfo="none">A</literal>. See also
      <emphasis>contravariance</emphasis> and
      <emphasis>invariance</emphasis>.<indexterm significance="normal"><primary>covariance or covariant</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-cross-cutting-concerns"><glossterm>Cross-Cutting Concerns</glossterm><glossdef><para>“Concerns” (kinds of requirements, design or coding issues) that
      don’t fit in the same boundaries as the primary modularity
      decomposition. The same behaviors must be invoked consistently at
      specific execution points over a range of objects and functions. For
      example, the same ORM (<phrase role="keep-together">Object-</phrase><phrase role="keep-together">Relational</phrase> Mapping) persistence strategy
      needs to be used consistently for a set of classes, not just a single
      class. Hence, such concerns are said to be cross-cutting. Supporting
      these concerns should not involve duplication of code, etc. See also
      <emphasis>aspect-</emphasis><emphasis role="keep-together">oriented
      programming</emphasis>.<indexterm significance="normal"><primary>cross-cutting concerns</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-currying"><glossterm>Currying</glossterm><glossdef><para>Converting an N argument function into a sequence of N functions
      of one argument, where each function except for the last <phrase role="keep-together">returns</phrase> a new function that takes a single
      argument that returns a new function, etc., until the last function that
      takes a single <phrase role="keep-together">argument</phrase> and
      returns a value.<indexterm significance="normal"><primary>currying</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-declaration-site"><glossterm>Declaration Site</glossterm><glossdef><para>In reference to how the <emphasis>variance</emphasis> behavior of
      parameterized types is specified, in Scala, this is done when types are
      <emphasis>declared</emphasis>, i.e., at the <emphasis>declaration
      site</emphasis>. In Java, it is done when types are
      <emphasis>called</emphasis> (that is, used), i.e., at the <emphasis>call
      site</emphasis>.<indexterm significance="normal"><primary>declaration site</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-declarative-programming"><glossterm>Declarative Programming</glossterm><glossdef><para>The quality of many <emphasis>functional</emphasis> programs and
      <emphasis>Domain-Specific Languages</emphasis> where the code consists
      of statements that declare relationships between values and types,
      rather than directing the system to take a particular sequence of
      action. Contrast with <emphasis>imperative
      programming</emphasis>.<indexterm significance="normal"><primary>declarative programming</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-default-argument-value"><glossterm>Default Argument Value</glossterm><glossdef><para>(Scala version 2.8.) The ability to define a default value for a
      method argument that will be used if the caller does not specify a
      value. See also <emphasis>implicit argument</emphasis> and
      <emphasis>named argument</emphasis>.<indexterm significance="normal"><primary>default argument value</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-dependency-injection"><glossterm>Dependency Injection</glossterm><glossdef><para>A form of <emphasis>inversion of control</emphasis> where an
      object’s external dependencies are given to it, either programmatically
      or through a DI framework that is driven by configuration information.
      Hence, the object remains “passive,” rather than taking an active role
      in resolving dependencies. The injection mechanism uses constructor
      arguments or field setters provided by the object. DI minimizes the
      coupling of objects; they only need to know about the abstractions of
      their dependencies.<indexterm significance="normal"><primary>dependency injection (DI)</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-derived-type"><glossterm>Derived Type</glossterm><glossdef><para>A synonym for <emphasis>child type</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-design-by-contract"><glossterm>Design By Contract</glossterm><glossdef><para>An approach to class and module design invented by Bertrand Meyer
      for the Eiffel language. For each entry point, valid inputs are
      specified in a programmatic way, so they can be validated during
      testing. These specifications are called
      <emphasis>preconditions</emphasis>. Similarly, <phrase role="keep-together">assuming</phrase> the preconditions are specified,
      specifications on the guaranteed results are called
      <emphasis>postconditions</emphasis> and are also specified in an
      executable way. <emphasis>Invariants</emphasis> can also be specified
      that should be true on entry and on exit.<indexterm significance="normal"><primary>Design by Contract</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-design-pattern"><glossterm>Design Pattern</glossterm><glossdef><para>A solution to a problem in a context. A code idiom or design
      structure that satisfies the needs of a frequently occurring problem,
      constraint, requirement, etc.<indexterm significance="normal"><primary>design patterns</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-domain-specific-language"><glossterm>Domain-Specific Language</glossterm><glossdef><para>A custom programming language that resembles the terms, idioms,
      and expressions of a particular domain. An <emphasis>internal</emphasis>
      DSL is an idiomatic form of a general-purpose programming language. That
      is, no <phrase role="keep-together">special-</phrase><phrase role="keep-together">purpose</phrase> parser is created for the
      language. <phrase role="keep-together">Instead</phrase>, DSL code is
      written in the general-purpose language and parsed just like any other
      code. An <emphasis>external</emphasis> DSL is a language with its own
      grammar and parser.<indexterm significance="normal"><primary>DSLs (Domain-Specific Languages)</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-duck-typing"><glossterm>Duck Typing</glossterm><glossdef><para>A term used in languages with <emphasis>dynamic typing</emphasis>
      for the way method resolution works. As long as an object accepts a
      method call (message send), the runtime is satisfied. “If it walks like
      a duck and talks like a duck, it’s a duck.” Contrast with the use of
      <emphasis>structural types</emphasis> in some <emphasis>statically
      typed</emphasis> languages like Scala.<indexterm significance="normal"><primary>duck typing</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-dynamic-typing"><glossterm>Dynamic Typing</glossterm><glossdef><para>Loosely speaking, late binding of type information, sometimes
      referred to as binding to the value a reference is assigned to, rather
      than to the reference itself. Contrast with <emphasis>static
      typing</emphasis>.<indexterm significance="normal"><primary>dynamic typing</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-encapsulation"><glossterm>Encapsulation</glossterm><glossdef><para>Restricting the visibility of members of a type so they are not
      visible to clients of the type when they shouldn’t be. This is a way of
      exposing only the <emphasis>abstraction</emphasis> supported by the
      type, while hiding implementation details, which prevents unwanted
      access to them from clients and keeps the
      <emphasis>abstraction</emphasis> exposed by the type consistent and
      <phrase role="keep-together">minimal</phrase>.<indexterm significance="normal"><primary>encapsulation</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-event"><glossterm>Event</glossterm><glossdef><para>The notification of a state change in <emphasis>event-based
      concurrency</emphasis>.<indexterm significance="normal"><primary>events</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-event-based-concurrency"><glossterm>Event-Based Concurrency</glossterm><glossdef><para>A high-performance form of concurrency where events are used to
      signal important state changes and handlers are used to <phrase role="keep-together">respond</phrase> to the events.<indexterm significance="normal"><primary>events</primary><secondary>using for concurrency</secondary></indexterm><indexterm significance="normal"><primary>concurrency</primary><secondary>event-based</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-existential-types"><glossterm>Existential Types</glossterm><glossdef><para>A way of expressing the presence of a type without knowing its
      concrete value, sometimes, because it can’t be known. It is used
      primarily to support aspects of Java’s type system within Scala’s type
      system, including <emphasis>type erasure</emphasis>, “raw” types (e.g.,
      pre-Java 5 collections), and <emphasis>call site</emphasis>
      <emphasis>type variance</emphasis>.<indexterm significance="normal"><primary>existential types</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-extractor"><glossterm>Extractor</glossterm><glossdef><para>An <literal moreinfo="none">unapply</literal> method defined in a
      <emphasis>companion object</emphasis> that is used to extract the
      constituent values for fields in an object. They are most commonly used
      in <emphasis>pattern matching</emphasis> <phrase role="keep-together">expressions</phrase>.<indexterm significance="normal"><primary>extractors</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-field"><glossterm>Field</glossterm><glossdef><para>A <literal moreinfo="none">val</literal> or <literal moreinfo="none">var</literal> in a type that
      represents part, if not all, of the state of a corresponding instance of
      the type.<indexterm significance="normal"><primary>fields</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-final"><glossterm>Final</glossterm><glossdef><para>Keyword for declarations. For types, <literal moreinfo="none">final</literal>
      prevents users from subclassing the type. For type members,
      <literal moreinfo="none">final</literal> prevents users from overriding the
      members.<indexterm significance="normal"><primary>final keyword</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-first-class"><glossterm>First Class</glossterm><glossdef><para>An adjective indicating that the applicable “thing” is a
      first-class value in the language, meaning you can assign instances to
      variables, pass them as function parameters, and return them from
      functions. Often used to refer to <emphasis>functions</emphasis>, which
      are first-class values in Scala and other <emphasis>functional
      programming</emphasis> languages.<indexterm significance="normal"><primary>first class</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-for-comprehension"><glossterm>For Comprehension</glossterm><glossdef><para>Another name for Scala’s <literal moreinfo="none">for</literal> expression.</para></glossdef></glossentry><glossentry id="glossentry-formal-parameter"><glossterm>Formal Parameter</glossterm><glossdef><para>Another name for a function argument, used in the context of
      binding the <emphasis>free variables</emphasis> in the
      function.<indexterm significance="normal"><primary>formal parameters</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-free-variable"><glossterm>Free Variable</glossterm><glossdef><para>A <emphasis>variable</emphasis> that is referenced in a
      <emphasis>function literal</emphasis> but is not passed in as an
      argument. Therefore, it must be “bound” to a defined variable of the
      same name in the context where the function literal is defined, to form
      a <emphasis>closure</emphasis>.<indexterm significance="normal"><primary>free variables</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-function"><glossterm>Function</glossterm><glossdef><para>In Scala, the term <emphasis>function</emphasis> is used for a
      function that is not tied to a particular object or class. Contrast with
      <emphasis>method</emphasis>. Functions are instances of
      <literal moreinfo="none">FunctionN</literal> types, where <literal moreinfo="none">N</literal> is the
      <emphasis>arity</emphasis> of the function.<indexterm significance="normal"><primary>functions</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-function-literal"><glossterm>Function Literal</glossterm><glossdef><para>Scala’s term for an anonymous <emphasis>function</emphasis>
      expression, from which <emphasis>closures</emphasis> are
      created.<indexterm significance="normal"><primary>function literals</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-function-type"><glossterm>Function Type</glossterm><glossdef><para>In Scala, all functions are instances of <literal role="keep-together" moreinfo="none">FunctionN[-T1, T2, ..., TN, +R]</literal> types,
      where <literal moreinfo="none">N</literal> is the number of arguments (0 through 22 are
      supported). The type signature syntax <literal moreinfo="none">(T1, T2, ..., TN) ⇒
      R</literal> is used for declaring concrete instances, i.e., function
      literals.<indexterm significance="normal"><primary>function types</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-functional-programming"><glossterm>Functional Programming</glossterm><glossdef><para>A form of programming that mimics the way mathematical functions
      and variables work. Mathematical functions are
      <emphasis>side-effect-free</emphasis>, and they are composable from
      other functions. Variables are assigned once. Functions can be assigned
      to variables and <phrase role="keep-together">returned</phrase> from
      other functions.<indexterm significance="normal"><primary>functional programming</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-generator"><glossterm>Generator</glossterm><glossdef><para>Expressions like <literal moreinfo="none">i &lt;- listOfInts</literal> in
      <literal moreinfo="none">for</literal> expressions. Each pass through the loop
      <emphasis>generates</emphasis> a new <literal moreinfo="none">val</literal>
      <literal moreinfo="none">i</literal> taken from the list <literal moreinfo="none">listOfInts</literal>,
      in this example.<indexterm significance="normal"><primary>generators</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-generics"><glossterm>Generics</glossterm><glossdef><para>Another term for <emphasis>parameterized types</emphasis>, used
      more often in Java than Scala.<indexterm significance="normal"><primary>generics</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-higher-order-functions"><glossterm>Higher-Order Functions</glossterm><glossdef><para>Functions that take other functions as arguments or return a
      function value.<indexterm significance="normal"><primary>functions</primary><secondary>higher order</secondary></indexterm><indexterm significance="normal"><primary>higher-order functions</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-immutable-value"><glossterm>Immutable Value</glossterm><glossdef><para>A value that can’t be changed after it has been initialized.
      Contrast with <emphasis>mutable value</emphasis>.<indexterm significance="normal"><primary>immutable values</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-imperative-programming"><glossterm>Imperative Programming</glossterm><glossdef><para>The quality of many <emphasis>object-oriented</emphasis> and
      “procedural” programs where the code consists of statements directing
      the system to take a particular sequence of actions. Contrast with
      <emphasis>declarative programming</emphasis>.<indexterm significance="normal"><primary>imperative programming</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-implicit"><glossterm>Implicit</glossterm><glossdef><para>A Scala keyword used to mark a method or function value as
      eligible for use as an <emphasis>implicit type conversion</emphasis>.
      The keyword is also used to mark an <emphasis>implicit
      argument</emphasis>.<indexterm significance="normal"><primary>implicit keyword</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-implicit-type-conversion"><glossterm>Implicit Type Conversion</glossterm><glossdef><para>A method or function value that is marked with the
      <emphasis>implicit</emphasis> keyword, marking it as eligible for use as
      an <emphasis>implicit type conversion</emphasis>, whenever it is in
      scope and conversion is needed (e.g., for the <emphasis>Pimp My
      Library</emphasis> <phrase role="keep-together">pattern</phrase>).<indexterm significance="normal"><primary>implicit conversions</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-implicit-argument"><glossterm>Implicit Argument</glossterm><glossdef><para>Method arguments that are optional for the user to specify and
      indicated with the <literal moreinfo="none">implicit</literal> keyword. If the user does
      not specify a value for the argument, a default value is used instead,
      which is either an in-scope value of the same type or the result of
      calling an in-scope, no-argument method that returns an instance of the
      same type. See also <emphasis>default argument
      value</emphasis>.<indexterm significance="normal"><primary>implicit arguments</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-infinite-data-structure"><glossterm>Infinite Data Structure</glossterm><glossdef><para>A data structure that represents a non-<phrase role="keep-together">terminating</phrase> collection of values, but
      which is capable of doing so without exhausting system resources. The
      values are not computed until the data structure is asked to produce
      them. As long as only a finite subset of the values are requested,
      resource exhaustion is avoided.<indexterm significance="normal"><primary>infinite data structures</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-infix-notation"><glossterm>Infix Notation</glossterm><glossdef><para>A syntax supported by the compiler for methods with one argument.
      The method can be invoked without the period between the object and the
      method name and without the parentheses around the argument. When used
      for methods named with <emphasis>operator characters</emphasis>, the
      syntax provides a form of <emphasis>operator overloading</emphasis>.
      Sometimes also called <emphasis>operator notation</emphasis>. See also
      <emphasis>postfix no⁠tation</emphasis>.<indexterm significance="normal"><primary>operator notation</primary></indexterm><indexterm significance="normal"><primary>infix notation</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-infix-type"><glossterm>Infix Type</glossterm><glossdef><para>When a parameterized type of the form <literal moreinfo="none">Op[A,B]</literal>
      is used to instantiate a type, it can also be written as <literal moreinfo="none">A Op
      B</literal>. For example, <literal moreinfo="none">Or[Throwable,Boolean]</literal> can
      be written <literal role="keep-together" moreinfo="none">Throwable Or
      Boolean</literal>.<indexterm significance="normal"><primary>infix types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-inheritance"><glossterm>Inheritance</glossterm><glossdef><para>A strong relationship between one class or trait and another class
      or trait. The <phrase role="keep-together">inheriting</phrase>
      (<emphasis>derived</emphasis>) class or trait incorporates the members
      of the <emphasis>parent</emphasis> class or trait, as if they were
      defined within the derivative. The derivative may override inherited
      members (in most cases). Instances of a derivative are
      <emphasis>substitutable</emphasis> for instances of the
      parent.<indexterm significance="normal"><primary>inheritance</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-instance-or-instantiate"><glossterm>Instance or Instantiate</glossterm><glossdef><para>An <emphasis>object</emphasis> created by invoking a
      <emphasis>class</emphasis> constructor. The word
      <emphasis>object</emphasis> is synonymous in most object-oriented
      languages, but we use the term <emphasis>object</emphasis> to refer to
      an explicitly <phrase role="keep-together">declared</phrase> Scala
      <emphasis>object</emphasis>, and we use the term <emphasis role="keep-together">instance</emphasis> (and the verb
      <emphasis>instantiate</emphasis>) for the more general case.<indexterm significance="normal"><primary>instantiate</primary></indexterm><indexterm significance="normal"><primary>instance</primary></indexterm></para><para id="para_instantiation_can_also_refer_t">Instantiation can also
      refer to creating a <emphasis>concrete type</emphasis> from a
      <emphasis>parameterized type</emphasis> <phrase role="keep-together">by
      specifying concrete</phrase> types for the <phrase role="keep-together">parameters</phrase>.</para></glossdef></glossentry><glossentry id="glossentry-invariance-and-invariant"><glossterm>Invariance and Invariant</glossterm><glossdef><para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal moreinfo="none">A</literal>
      is <emphasis>invariant</emphasis> in a parameterized type
      <literal moreinfo="none">T[A]</literal>, then there is no <emphasis>variance
      annotation</emphasis>, and a type <literal moreinfo="none">T[B]</literal> is a
      <emphasis>subtype</emphasis> of <literal moreinfo="none">T[A]</literal> if and only if
      <literal moreinfo="none">B</literal> equals <literal moreinfo="none">A</literal>. That is, the type
      can’t be changed. See also <emphasis>covariance</emphasis> and <emphasis role="keep-together">contravariance</emphasis>.<indexterm significance="normal"><primary>invariance and invariant</primary></indexterm></para><para id="para_in_the_context_of__design_by_c">In the context of
      <emphasis>Design by Contract</emphasis>, an assertion that should be
      true before and after a method is executed.</para></glossdef></glossentry><glossentry id="glossentry-inversion-of-control"><glossterm>Inversion of Control</glossterm><glossdef><para>The idea that an object should not instantiate its own copies of
      external dependencies, but rather rely on other mechanisms to supply
      those dependencies. IoC promotes better decoupling and testability, as
      the object only knows about the abstractions of its dependencies, not
      specific concrete implementers of them. A weak form of IoC is when an
      object calls a factory, service locator, etc., to obtain the dependents.
      Hence, the object still has an active role and it has a dependency on
      the “provider.” The strongest form of IoC is <emphasis>dependency
      injection</emphasis>, where the object remains “passive.”<indexterm significance="normal"><primary>inversion of control (IoC)</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-lazy"><glossterm>Lazy</glossterm><glossdef><para>Immutable variables (<literal moreinfo="none">val</literal>s) can be declared
      <literal moreinfo="none">lazy</literal>, meaning they will only be evaluated when they
      are read. This feature is useful for expensive evaluations that may not
      be <phrase role="keep-together">needed</phrase>.<indexterm significance="normal"><primary>lazy, defined</primary></indexterm></para><para id="para_lazy_data_structures_can_also_">Lazy data structures can
      also be used to <phrase role="keep-together">define</phrase> infinite
      data structures that won’t exhaust system resources as long as only a
      finite subset of the structure is evaluated. The
      <literal moreinfo="none">Stream</literal> and <literal moreinfo="none">Range</literal> classes are both
      lazy. <phrase role="keep-together">Contrast</phrase> with
      <emphasis>strict</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-linearization"><glossterm>Linearization</glossterm><glossdef><para>The algorithm used for a type to resolve member lookup, such as
      overridden methods, including calls to
      <literal moreinfo="none">super</literal>.<indexterm significance="normal"><primary>linearization of object hierarchy</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-literal"><glossterm>Literal</glossterm><glossdef><para>Used to refer to “literal” value expressions, such as numbers
      (e.g., <literal moreinfo="none">1</literal>, <literal moreinfo="none">3.14</literal>), strings (e.g.,
      “Hello Scala!”), tuples (e.g., <literal moreinfo="none">(1, 2, 3)</literal>), and
      <emphasis>function literals</emphasis> (e.g., <literal moreinfo="none">(x) ⇒ x +
      x</literal>).<indexterm significance="normal"><primary>literals</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-lower-type-bounds"><glossterm>Lower Type Bounds</glossterm><glossdef><para>See <emphasis>type bounds</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-mailbox"><glossterm>Mailbox</glossterm><glossdef><para>The queue where an <emphasis>Actor’s</emphasis> messages are
      stored until the Actor processes them in the A<emphasis>ctor model of
      concurrency</emphasis>.<indexterm significance="normal"><primary>mailbox for Actors</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-main"><glossterm>Main</glossterm><glossdef><para>The entry function for an application that is invoked by the
      runtime is called <literal moreinfo="none">main</literal>. The name dates back to the
      <emphasis>C</emphasis> language. In Scala, a <literal moreinfo="none">main</literal>
      <emphasis>method</emphasis> must be defined in an
      <literal moreinfo="none">object</literal>. Java, by way of contrast, requires a
      <literal moreinfo="none">main</literal> method to be defined as a static method of a
      <literal moreinfo="none">class</literal>.<indexterm significance="normal"><primary>main method</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-mapreduce"><glossterm>MapReduce</glossterm><glossdef><para>A divide-and-conquer strategy for processing large data sets in
      parallel. In the “map” phase, the data sets are subdivided. The desired
      computation is performed on each subset. The “reduce” phase combines the
      results of the subset calculations into a final result. MapReduce
      frameworks handle the details of managing the operations and the nodes
      they run on, including restarting <phrase role="keep-together">operations</phrase> that fail for some reason. The
      user of the framework only has to write the algorithms for mapping and
      reducing <phrase role="keep-together">the data sets and</phrase>
      computing with the <phrase role="keep-together">subsets</phrase>.<indexterm significance="normal"><primary>MapReduce</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-member"><glossterm>Member</glossterm><glossdef><para>A generic term for a <emphasis>type</emphasis>,
      <emphasis>field</emphasis>, or <emphasis>method</emphasis> declared in a
      <emphasis>class</emphasis> or <emphasis>trait</emphasis>.<indexterm significance="normal"><primary>members</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-memoization"><glossterm>Memoization</glossterm><glossdef><para>A form of caching that optimizes function invocations. The results
      from a function’s invocations are saved so that when repeated
      invocations with the same inputs are made, the cached results can be
      returned instead of reinvoking the function.<indexterm significance="normal"><primary>memoization</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-message"><glossterm>Message</glossterm><glossdef><para>In the <emphasis>Actor model of concurrency</emphasis>, messages
      are exchanged between Actors to coordinate their work.<indexterm significance="normal"><primary>messages</primary></indexterm></para><para id="para_in_object_oriented_programming">In object-oriented
      programming, method invocation is sometimes referred to as “sending a
      message to an object,” especially in certain languages, like Smalltalk
      and, to some extent, Ruby.</para></glossdef></glossentry><glossentry id="glossentry-method"><glossterm>Method</glossterm><glossdef><para>A <emphasis>function</emphasis> that is associated exclusively
      with an instance, either defined in a <emphasis>class</emphasis>,
      <emphasis>trait</emphasis>, or <emphasis>object</emphasis> definition.
      Methods can only be invoked using the <literal moreinfo="none">object.method</literal>
      syntax.<indexterm significance="normal"><primary>methods</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-mixin"><glossterm>Mixin</glossterm><glossdef><para>A narrowly focused encapsulation of state and behavior that is
      more useful as an adjunct to another object’s state and behavior, rather
      than standing on its own. Mixins in Scala are implemented using
      <emphasis>traits</emphasis>.<indexterm significance="normal"><primary>mixins</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-multiple-inheritance"><glossterm>Multiple Inheritance</glossterm><glossdef><para>In some languages, but not Scala, a type can extend more than one
      parent class. Compare to <emphasis>single
      inheritance</emphasis>.<indexterm significance="normal"><primary>multiple inheritance</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-mutable-value"><glossterm>Mutable Value</glossterm><glossdef><para>A value that can be changed after it has been initialized.
      Contrast with <emphasis>immutable value</emphasis>.<indexterm significance="normal"><primary>mutable values</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-named-argument"><glossterm>Named Argument</glossterm><glossdef><para>(Scala version 2.8.) The ability to refer to a method argument by
      name when calling the method. It is useful in combination with
      <emphasis>default argument values</emphasis> for minimizing the number
      of arguments that have to be specified by the caller.<indexterm significance="normal"><primary>named arguments</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-nonterminal"><glossterm>Nonterminal</glossterm><glossdef><para>An item in a grammar that requires further decomposition into one
      or more <emphasis>nonterminals</emphasis> (including possibly a
      recursive reference to itself) and
      <emphasis>terminals</emphasis>.<indexterm significance="normal"><primary>nonterminals</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-object"><glossterm>Object</glossterm><glossdef><para>A cohesive unit with a particular state, possible state
      transitions, and behaviors. In Scala, the keyword
      <literal moreinfo="none">object</literal> is used to declare a
      <emphasis>singleton</emphasis> explicitly, using the same syntax as
      <emphasis>class</emphasis> declarations, except for the lack of
      constructor parameters and auxiliary parameters (because
      <literal moreinfo="none">objects</literal> are instantiated by the Scala runtime, not by
      user code). To avoid confusion with <literal moreinfo="none">objects</literal>, we use
      the term <emphasis>instance</emphasis> to refer to
      <emphasis>instances</emphasis> of <emphasis>classes</emphasis> and
      <literal moreinfo="none">objects</literal> generically.<indexterm significance="normal"><primary>objects</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-object-oriented-programming"><glossterm>Object-Oriented Programming</glossterm><glossdef><para>A form of programming that encapsulates state values and
      operations on that state, exposing a cohesive abstraction to clients of
      the object while hiding internal implementation details. OOP also
      supports subtyping to define specializations and “family” relationships
      between types.<indexterm significance="normal"><primary>object-oriented programming (OOP)</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-operator-characters"><glossterm>Operator Characters</glossterm><glossdef><para>Characters like <literal moreinfo="none">&lt;</literal>, <literal moreinfo="none">*</literal>,
      etc. that are not letters, nor digits, nor reserved characters, like
      left and right parentheses, curly braces, square brackets, the
      semicolon, colon, or comma. These characters can be used in method names
      to implement a form of <emphasis>operator</emphasis> <emphasis role="keep-together">overloading</emphasis>.<indexterm significance="normal"><primary>operator characters</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-operator-notation"><glossterm>Operator Notation</glossterm><glossdef><para>See <emphasis>infix notation</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-operator-overloading"><glossterm>Operator Overloading</glossterm><glossdef><para>The feature in some languages where standard mathematical
      operators, like <literal moreinfo="none">*</literal>, <literal moreinfo="none">/</literal>,
      <literal moreinfo="none">&lt;</literal>, etc., can be defined by users for custom types.
      In Scala, a form of operator overloading is supported by allowing
      operator characters to be used as normal method names and by allowing
      methods with one argument to be invoked with <emphasis>infix
      notation</emphasis>. The “operator precedence” for these methods is
      determined by the first character, e.g., method <literal moreinfo="none">*&lt;</literal>
      will have higher precedence than method
      <literal moreinfo="none">+&lt;</literal>.<indexterm significance="normal"><primary>operator overloading</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-overloaded-functions"><glossterm>Overloaded Functions</glossterm><glossdef><para>Two or more functions defined in the same scope (e.g., as methods
      in a type or as “bare” functions) that have the same name but different
      <emphasis>signatures</emphasis>.<indexterm significance="normal"><primary>functions</primary><secondary>overloaded</secondary></indexterm><indexterm significance="normal"><primary>overloaded functions</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-package-objects"><glossterm>Package Objects</glossterm><glossdef><para>A special kind of object declaration that declares members that
      should be visible at the scope of the named package. For example, for
      the declaration <literal moreinfo="none">package object math { type Complex = ...
      }</literal>, the <literal moreinfo="none">Complex</literal> type can be referenced as
      <literal moreinfo="none">math.Complex</literal>. (Scala version 2.8.)<indexterm significance="normal"><primary>package objects</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-packrat-parsers"><glossterm>Packrat Parsers</glossterm><glossdef><para>Parsers for <emphasis>parsing expression grammars</emphasis>
      (PEGs; see <link linkend="Ford" xrefstyle="select:nopage">[Ford]</link>). They have several benefits,
      such as lack of ambiguity and good performance characteristics. The
      forthcoming Scala version 2.8 parser combinator library will add support
      for creating packrat <phrase role="keep-together">parsers</phrase>.<indexterm significance="normal"><primary>packrat parsers</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-parameterized-types"><glossterm>Parameterized Types</glossterm><glossdef><para>Scala’s analog of <emphasis>generics</emphasis> in Java.
      Parameterized types are defined with placeholder parameters for types
      they use. When an instance of a parameterized type is created, specific
      types must be specified to replace <phrase role="keep-together">all the
      type</phrase> parameters. See also <emphasis>type</emphasis> <emphasis role="keep-together">constructor</emphasis>.<indexterm significance="normal"><primary>parameterized types</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-parent-type"><glossterm>Parent Type</glossterm><glossdef><para>A class or trait from which another class or trait is
      <emphasis>derived</emphasis>. Also called a
      <emphasis>supertype</emphasis> or <emphasis>base type</emphasis>. See
      <emphasis>inheritance</emphasis>.<indexterm significance="normal"><primary>parent classes</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-parsing-expression-grammars-pegs"><glossterm>Parsing expression grammars (PEGs)</glossterm><glossdef><para>An alternative to <emphasis>context-free grammars</emphasis> that
      provide guaranteed linear-time parsing <phrase role="keep-together">using</phrase> <emphasis>memoization</emphasis> and
      unambiguous <phrase role="keep-together">grammars</phrase> (<link linkend="PEG" xrefstyle="select:nopage">[PEG]</link>).<indexterm significance="normal"><primary>PEGs (parsing expression grammars)</primary></indexterm><indexterm significance="normal"><primary>grammars</primary><secondary>parsing expression grammars (PEGs)</secondary></indexterm><indexterm significance="normal"><primary>parsing expression grammars (PEGs)</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-partial-application"><glossterm>Partial Application</glossterm><glossdef><para>Associated with <emphasis>currying</emphasis>, where a subset of a
      curried function’s arguments are applied, yielding a new function that
      takes the remaining arguments.<indexterm significance="normal"><primary>partial application</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-partial-function"><glossterm>Partial Function</glossterm><glossdef><para>A function that is not valid over the whole range of its
      arguments. Pattern matching expressions can be converted to partial
      functions by the compiler in some contexts.<indexterm significance="normal"><primary>partial functions</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-path-dependent-type"><glossterm>Path-Dependent Type</glossterm><glossdef><para>A nested type T is unique based on its “path,” the hierarchical,
      period-delimited list of the enclosing packages, the enclosing types,
      and finally the type T itself. Instances of T can have different,
      incompatible types. For example, if T is nested in a trait and the trait
      appears in the <emphasis>linearizations</emphasis> of different types,
      then the instances in those Ts will have different types.<indexterm significance="normal"><primary>path-dependent types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-pattern-matching"><glossterm>Pattern Matching</glossterm><glossdef><para>Case expressions, usually in a match expression, that compare an
      object against <phrase role="keep-together">possible</phrase> types,
      type extractors, regular expressions, etc., to determine the appropriate
      handling.<indexterm significance="normal"><primary>pattern matching</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-pimp-my-library"><glossterm>Pimp My Library</glossterm><glossdef><para>The name of a design pattern that appears to add new methods to a
      type. It uses an <emphasis>implicit type conversion</emphasis> to
      automatically wrap the type in a wrapper type, where the wrapper type
      has the desired methods.<indexterm significance="normal"><primary>Pimp My Library design pattern</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-precondition"><glossterm>Precondition</glossterm><glossdef><para>An assertion that should be true on entry to a method or other
      entry point. See <emphasis>Design by Contract</emphasis>.<indexterm significance="normal"><primary>preconditions</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-postcondition"><glossterm>Postcondition</glossterm><glossdef><para>An assertion that should be true on exit from a method or other
      boundary point. See <emphasis>Design by Contract</emphasis>.<indexterm significance="normal"><primary>postconditions</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-postfix-notation"><glossterm>Postfix Notation</glossterm><glossdef><para>A syntax supported by the compiler for methods with no argument,
      sometimes called <emphasis>nullary</emphasis> methods. The method can be
      invoked without the period between the <phrase role="keep-together">object</phrase> and the method name. See also
      <emphasis>infix no⁠tation</emphasis>.<indexterm significance="normal"><primary>postfix notation</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-primary-constructor"><glossterm>Primary Constructor</glossterm><glossdef><para>The main constructor of a class, consisting of the class body with
      the parameter list specified after the name of the class. See also
      <emphasis>auxiliary constructor</emphasis>.<indexterm significance="normal"><primary>primary constructor</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-primitive-type"><glossterm>Primitive Type</glossterm><glossdef><para>A non-object type on the underlying runtime platform (e.g., JVM
      and .NET). Scala does not have primitive types at the source code level.
      Rather, it uses <emphasis>value types</emphasis>, which are subclasses
      of <literal moreinfo="none">AnyVal</literal>, to wrap runtime primitives, providing
      object semantics at the code level, while using boxing and unboxing of
      primitives at the byte code level to optimize performance.<indexterm significance="normal"><primary>primitive data types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-production"><glossterm>Production</glossterm><glossdef><para>A term used for each part of a grammar that decomposes a specific
      <emphasis>nonterminal</emphasis> into other nonterminals (perhaps
      including a <phrase role="keep-together">recursive</phrase> reference to
      the original nonterminal) and <emphasis>terminals</emphasis>.<indexterm significance="normal"><primary>production</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-pure"><glossterm>Pure</glossterm><glossdef><para>Used in the context of functions to mean that they are
      <emphasis>side-effect-free</emphasis>. See also <emphasis>referential
      transparency</emphasis>.<indexterm significance="normal"><primary>pure (side-effect-free functions)</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-recursion"><glossterm>Recursion</glossterm><glossdef><para>When a function calls itself as part of its computation. A
      termination condition is required to prevent an infinite recursion. See
      also <emphasis>tail-call recursion</emphasis>.<indexterm significance="normal"><primary>recursion</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-reference-type"><glossterm>Reference Type</glossterm><glossdef><para>A type whose instances are implemented as objects on the runtime
      platform. All reference types subtype
      <literal moreinfo="none">AnyRef</literal>.<indexterm significance="normal"><primary>reference types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-referential-transparency"><glossterm>Referential Transparency</glossterm><glossdef><para>The property of an expression, such as a function, where it can be
      replaced with its value without changing the behavior of the code. This
      can be done with <emphasis>side-effect-free</emphasis> functions when
      the inputs are the same. The primary benefit of referential transparency
      is that it is easy to reason about the behavior of a function, without
      having to understand the context in which it is invoked. That makes the
      function easier to test, refactor, and reuse.<indexterm significance="normal"><primary>referential transparency</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-refinement"><glossterm>Refinement</glossterm><glossdef><para>The term used for adding or overriding members in a type body for
      a <emphasis>compound type</emphasis>.<indexterm significance="normal"><primary>refinement in compound type declarations</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-reified-types"><glossterm>Reified Types</glossterm><glossdef><para>Where the specific types used when instantiating a generic type
      are retained in the byte code, so the information is available at
      runtime. This is a property of .NET byte code, but not JVM byte code,
      which uses <emphasis>type erasure</emphasis>. To minimize
      incompatibilities, both the Java and .NET Scala versions use
      <emphasis>type erasure.<indexterm significance="normal"><primary>reified types</primary></indexterm></emphasis></para></glossdef></glossentry><glossentry id="glossentry-repl"><glossterm>REPL</glossterm><glossdef><para>A name given to interactive language interpreters, like the
      <literal moreinfo="none">scala</literal> command in interpreter mode. REPL is an acronym
      for <emphasis>Read, Evaluate, Print, Loop</emphasis>.<indexterm significance="normal"><primary>REPL (Read, Evaluate, Print, Loop)</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-scaladocs"><glossterm>Scaladocs</glossterm><glossdef><para>The API documentation generated from Scala source code using the
      <literal moreinfo="none">scaladoc</literal> tool, analogous to Java’s
      Javadocs.<indexterm significance="normal"><primary>Scaladocs</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-scope"><glossterm>Scope</glossterm><glossdef><para>A defined boundary of <emphasis>visibility</emphasis>,
      constraining what types and their members are visible within
      it.<indexterm significance="normal"><primary>scope</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-sealed"><glossterm>Sealed</glossterm><glossdef><para>Keyword for parent classes when <emphasis>all</emphasis> the
      direct subclasses allowed are defined in the same source
      <emphasis>file</emphasis>.<indexterm significance="normal"><primary>sealed keyword</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-self-type-annotation"><glossterm>Self-Type Annotation</glossterm><glossdef><para>A declaration in a trait or class that changes its type, sometimes
      with an alias for <literal moreinfo="none">this</literal> defined
      (<literal moreinfo="none">self</literal> is conventional). A self type can be used to
      indicate dependencies on other traits that will have to be mixed into a
      concrete instance to resolve the dependency. In some cases, these
      dependencies are used to ensure that an instance of the current type can
      be used as an instance of a dependent type in certain contexts (e.g., as
      used in the Observer Pattern in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>).<indexterm significance="normal"><primary>self-type annotations</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-side-effect-free"><glossterm>Side-Effect-Free</glossterm><glossdef><para>Functions or expressions that have no side effects, meaning they
      modify no global or “object” state.<indexterm significance="normal"><primary>side-effect-free</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-signature"><glossterm>Signature</glossterm><glossdef><para>For a function: the name, parameter list types, and return value.
      For a <emphasis>method</emphasis>: also includes the type that defines
      the method.<indexterm significance="normal"><primary>signature</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-single-inheritance"><glossterm>Single Inheritance</glossterm><glossdef><para>A class, object, or trait can extend one parent class. Compare to
      <emphasis>multiple inheritance</emphasis>.<indexterm significance="normal"><primary>single inheritance</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-singleton"><glossterm>Singleton</glossterm><glossdef><para>A class that has only one instance. In Scala, singletons are
      declared using the keyword <literal moreinfo="none">object</literal> instead of
      <literal moreinfo="none">class</literal>.<indexterm significance="normal"><primary>singletons</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-singleton-types"><glossterm>Singleton Types</glossterm><glossdef><para>The unique type designator that excludes path dependencies. If
      <literal moreinfo="none">p1</literal> and <literal moreinfo="none">p2</literal> are two different
      path-dependent types, their singleton types are
      <literal moreinfo="none">p1.type</literal> and <literal moreinfo="none">p2.type</literal>, which may be
      the same. Contrast with <emphasis>singleton</emphasis> objects.
      Singleton types are not specifically the types of singleton objects, but
      singleton objects do have singleton types.<indexterm significance="normal"><primary>singleton types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-stable-types"><glossterm>Stable Types</glossterm><glossdef><para>Used in the context of <emphasis>path-dependent types</emphasis>,
      all but the last elements in the path must be
      <emphasis>stable</emphasis>, which roughly means that they are either
      packages, singleton objects, or type declarations that alias the
      same.<indexterm significance="normal"><primary>stable types</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-state"><glossterm>State</glossterm><glossdef><para>As in, “the state of an object,” where it informally means the set
      of all the current values of an object’s
      <emphasis>fields</emphasis>.<indexterm significance="normal"><primary>state</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-static-typing"><glossterm>Static Typing</glossterm><glossdef><para>Loosely speaking, early binding of type information, sometimes
      referred to as binding to a reference, rather than the value to which
      the reference is assigned.<indexterm significance="normal"><primary>static typing</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-strict"><glossterm>Strict</glossterm><glossdef><para>Used to refer to data structures that are not
      <emphasis>lazy</emphasis>, i.e., they are defined “eagerly” by the
      expressions used to construct them.<indexterm significance="normal"><primary>strict</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-structural-type"><glossterm>Structural Type</glossterm><glossdef><para>A <emphasis>structural type</emphasis> is like an anonymous type,
      where only the “structure” a candidate type must support is specified,
      such as <emphasis>members</emphasis> that must be present. Structural
      types do not name the candidate types that can match, nor do any
      matching types need to share a common <emphasis>parent trait</emphasis>
      or <emphasis>class</emphasis> with the structural type. Hence,
      structural types are a type-safe analog to <emphasis>duck
      typing</emphasis> in dynamically typed languages, like Ruby.<indexterm significance="normal"><primary>structural types</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-subtype"><glossterm>Subtype</glossterm><glossdef><para>A synonym for <emphasis>derived type</emphasis>.<indexterm significance="normal"><primary>subtypes</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-supertype"><glossterm>Supertype</glossterm><glossdef><para>A synonym for <emphasis>parent type</emphasis>.<indexterm significance="normal"><primary>supertype</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-symbol"><glossterm>Symbol</glossterm><glossdef><para>An interned string. Literal symbols are written starting with a
      single “right quote,” e.g., <literal moreinfo="none">'name</literal>.<indexterm significance="normal"><primary>symbols</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-tail-call-recursion"><glossterm>Tail-Call Recursion</glossterm><glossdef><para>A form of recursion where a function calls itself as the
      <emphasis>last</emphasis> thing it does, i.e., it does no additional
      computations with the result of the recursive call. The Scala compiler
      will optimize <emphasis>tail-call</emphasis> recursions into a
      loop.<indexterm significance="normal"><primary>tail-call recursion</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-test-driven-development"><glossterm>Test-Driven Development</glossterm><glossdef><para>A development discipline where no new functionality is implemented
      until a test has been written that will pass once the functionality is
      implemented. See also <emphasis>Behavior-Driven
      Development</emphasis>.<indexterm significance="normal"><primary>TDD (Test-Driven Development)</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-terminal"><glossterm>Terminal</glossterm><glossdef><para>A token in a grammar, such as a keyword, that requires no further
      decomposition. See also <emphasis>nonterminal</emphasis>.<indexterm significance="normal"><primary>terminals</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-test-double"><glossterm>Test Double</glossterm><glossdef><para>When testing the behavior of one object, a test double is another
      object that satisfies a dependency in the object under test. The test
      double may assist in the testing process, provide controlled test data
      and behaviors, and modify the interaction between the object under test
      and the test double. Specific types of test doubles include “fakes,”
      “mocks,” and “stubs.”<indexterm significance="normal"><primary>test double</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-trait"><glossterm>Trait</glossterm><glossdef><para>A class-like encapsulation of state (fields) and behavior
      (methods) that is used for <emphasis>mixin</emphasis> composition. Zero
      or more traits can be mixed into class declarations or when creating
      instances directly, effectively creating an anonymous class.<indexterm significance="normal"><primary>traits</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-trampoline"><glossterm>Trampoline</glossterm><glossdef><para>A loop that iterates through a list of functions, invoking each in
      turn. The metaphor of bouncing the functions off a trampoline is the
      source of the name. It can be used to rewrite a form of recursion where
      a function doesn’t call itself, but rather calls a different function
      that invokes the original function, and so forth, back and forth. There
      is a proposal for the Scala version 2.8 compiler to include a trampoline
      implementation.<indexterm significance="normal"><primary>trampolines</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-tuple"><glossterm>Tuple</glossterm><glossdef><para>A grouping of two or more items of arbitrary types into a
      “Cartesian product,” without first defining a class to hold them.
      Literal tuple values are written in parentheses and separated by commas,
      e.g., <literal moreinfo="none">(x1, x2, ...)</literal>. They are
      <emphasis>first-class</emphasis> values, so you can assign them to
      variables, pass them as values, and return them from functions. Tuples
      are represented by <literal moreinfo="none">TupleN</literal> classes, for N between 2
      and 22, inclusive.<indexterm significance="normal"><primary>tuples</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type"><glossterm>Type</glossterm><glossdef><para>A categorization of allowed states and operations on those states,
      including transformations from one state to another. The type of an
      instance is the combination of its declared <emphasis>class</emphasis>
      (explicitly named or anonymous), mixed-in <emphasis>traits</emphasis>,
      and the specific types used to resolve any parameters if the class or
      traits are <emphasis>parameterized types</emphasis>. In Scala,
      <literal moreinfo="none">type</literal> is also a keyword. When indicated in the text,
      we sometimes use the term type to refer to a <emphasis>class</emphasis>,
      <emphasis>object</emphasis>, or <emphasis>trait</emphasis>
      generically.<indexterm significance="normal"><primary>types</primary><secondary>defined</secondary></indexterm><indexterm significance="normal"><primary>data types</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-annotation"><glossterm>Type Annotation</glossterm><glossdef><para>An explicit declaration of the type of a value, e.g.,
      <literal moreinfo="none">count: Int</literal>, where <literal moreinfo="none">Int</literal> is the
      <emphasis>type annotation</emphasis>. A type annotation is required when
      <emphasis>type inference</emphasis> can’t be used. In Scala, function
      parameters require type annotations, and annotations are required in
      some other contexts where the type can’t be inferred, e.g., for return
      values of some functions.<indexterm significance="normal"><primary>type annotations</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-bounds"><glossterm>Type Bounds</glossterm><glossdef><para>Constraints on the allowed types that can be used for a parameter
      in a <emphasis>parameterized type</emphasis> or assigned to an
      <emphasis>abstract type</emphasis>. In Scala, the expression <literal moreinfo="none">A
      &lt;: B</literal> defines an <emphasis>upper bound</emphasis> on
      <literal moreinfo="none">A</literal>; it must be a <emphasis>subtype</emphasis> or the
      same as <literal moreinfo="none">B</literal>. The expression <literal moreinfo="none">A &gt;:
      B</literal> defines a <emphasis>lower bound</emphasis> on
      <literal moreinfo="none">A</literal>; it must be a <emphasis>supertype</emphasis> or the
      same as <literal moreinfo="none">B</literal>.<indexterm significance="normal"><primary>type bounds</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-constructor"><glossterm>Type Constructor</glossterm><glossdef><para>Informally, a <emphasis>parameterized type</emphasis> is sometimes
      called a type constructor, although a “non-parameterized” type is really
      a type constructor too, just with zero parameters! The analogy with an
      instance constructor is that you specify specific concrete types for the
      parameters to create a new concrete type, just as you specify values to
      an instance constructor to create an instance.<indexterm significance="normal"><primary>type constructors</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-designators"><glossterm>Type Designators</glossterm><glossdef><para>The conventional type IDs commonly used, e.g., <literal moreinfo="none">class
      Person</literal>, <literal moreinfo="none">object O { type t }</literal>. They are
      actually a shorthand syntax for <emphasis>type
      projections</emphasis>.<indexterm significance="normal"><primary>type designators</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-erasure"><glossterm>Type Erasure</glossterm><glossdef><para>A property of the generics type model on the JVM. When a type is
      created from a generic, the information about the specific types
      substituted for the type parameters is not stored in the byte code and
      is therefore not available at runtime. Scala must follow the same model.
      So, for example, instances of <literal moreinfo="none">List[String]</literal> and
      <literal moreinfo="none">List[Int]</literal> are indistinguishable. Contrast with
      <emphasis>reified types</emphasis>.<indexterm significance="normal"><primary>type erasure</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-inference"><glossterm>Type Inference</glossterm><glossdef><para>Inferring the type of a value based on the context in which it is
      used, rather than <phrase role="keep-together">relying</phrase> on
      explicit type <emphasis>annotations</emphasis>. Sometimes called
      <emphasis>implicit typing</emphasis>.<indexterm significance="normal"><primary>implicit typing</primary></indexterm><indexterm significance="normal"><primary>type inference</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-projections"><glossterm>Type Projections</glossterm><glossdef><para>A way to refer to a type nested within another type. For example,
      if a type <literal moreinfo="none">t</literal> is declared in a class
      <literal moreinfo="none">C</literal>, then the type projection for <literal moreinfo="none">t</literal>
      is <literal moreinfo="none">C#t</literal>.<indexterm significance="normal"><primary>type projections</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-variance"><glossterm>Type Variance</glossterm><glossdef><para>When a <emphasis>parameterized type</emphasis> is declared, the
      variance behavior under inheritance of each type parameter can be
      specified using a <emphasis>type variance annotation</emphasis> on the
      type symbol.<indexterm significance="normal"><primary>type variance</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-type-variance-annotation"><glossterm>Type Variance Annotation</glossterm><glossdef><para>On a type parameter in a parameterized types, a
      <literal moreinfo="none">+</literal> prefixed to the type symbol is used to indicate
      <emphasis>covariance</emphasis>. A <literal moreinfo="none">-</literal> prefix on the
      type symbol is used to indicate <emphasis>contravariance</emphasis>. No
      variance annotation is used to indicate <emphasis>invariance</emphasis>
      (the default).<indexterm significance="normal"><primary>type variance annotations</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-upper-type-bounds"><glossterm>Upper Type Bounds</glossterm><glossdef><para>See <emphasis>type bounds</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-value"><glossterm>Value</glossterm><glossdef><para>The actual state of an instance, usually in the context of a
      variable that refers to the instance. See also <emphasis>value
      type</emphasis>.<indexterm significance="normal"><primary>values</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-value-object"><glossterm>Value Object</glossterm><glossdef><para>An immutable instance or object.<indexterm significance="normal"><primary>Value object</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-value-type"><glossterm>Value Type</glossterm><glossdef><para>A subclass of <literal moreinfo="none">AnyVal</literal> that wraps a corresponding
      non-object “primitive” type on the runtime platform (e.g., JVM and
      .NET). The value types are <literal moreinfo="none">Boolean</literal>,
      <literal moreinfo="none">Char</literal>, <literal moreinfo="none">Byte</literal>, <literal role="keep-together" moreinfo="none">Double</literal>, <literal moreinfo="none">Float</literal>,
      <literal moreinfo="none">Long</literal>, <literal moreinfo="none">Int</literal>, and
      <literal moreinfo="none">Short</literal>. (<literal moreinfo="none">Unit</literal> is also a value
      type.) All are declared <literal moreinfo="none">abstract final</literal> so they can’t
      be used in <literal moreinfo="none">new V</literal> expressions. Instead, programs
      specify literal values, e.g., <literal moreinfo="none">3.14</literal> for a
      <literal moreinfo="none">Double</literal> or use methods that return new values. The
      Scala runtime handles instantiation. All the instances of value types
      are immutable <emphasis>value objects</emphasis>.<indexterm significance="normal"><primary>value types</primary><secondary>defined</secondary></indexterm></para><para id="para_the_term__value_type__is_also_">The term <emphasis>value
      type</emphasis> is also used to mean the categories of types for
      instances. That is, the type of every instance must fall into one
      <phrase role="keep-together">of several</phrase> categories:
      <emphasis>annotated types</emphasis>, <emphasis role="keep-together">compound types</emphasis>, <emphasis>function
      types</emphasis>, <emphasis>infix types</emphasis>,
      <emphasis>parameterized types</emphasis>, <emphasis>tuples</emphasis>,
      <emphasis>type designators</emphasis>, <emphasis>type
      projections</emphasis>, and <emphasis>singleton types</emphasis>.</para></glossdef></glossentry><glossentry id="glossentry-variable"><glossterm>Variable</glossterm><glossdef><para>A named reference to a value. If the variable is declared with the
      <literal moreinfo="none">val</literal> keyword, a new value can’t be assigned to the
      variable. If the variable is declared with the <literal moreinfo="none">var</literal>
      keyword, a new value can be assigned to the variable. The value a
      variable references must be type-compatible with the declared or
      inferred type of the variable.<indexterm significance="normal"><primary>variables</primary><secondary>defined</secondary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-view"><glossterm>View</glossterm><glossdef><para>An implicit value of function type that converts a type
      <literal moreinfo="none">A</literal> to <literal moreinfo="none">B</literal>. The function has the type
      <literal moreinfo="none">A =&gt; B</literal> or <literal moreinfo="none">(=&gt; A) =&gt; B</literal>.
      (In the later case, the <literal moreinfo="none">(=&gt; A)</literal> is a
      <emphasis>by-name parameter</emphasis>.) An in-scope <emphasis>implicit
      type conversion</emphasis> method with the same signature can also be
      used as a view.<indexterm significance="normal"><primary>views</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-view-bounds"><glossterm>View Bounds</glossterm><glossdef><para>A type specification of the form <literal moreinfo="none">A &lt;% B</literal>,
      which says that any type can be used for <literal moreinfo="none">A</literal> as long as
      an in-scope <emphasis>view</emphasis> exists that can convert an
      <literal moreinfo="none">A</literal> to a <literal moreinfo="none">B</literal>.<indexterm significance="normal"><primary>view bounds</primary></indexterm></para></glossdef></glossentry><glossentry id="glossentry-visibility"><glossterm>Visibility</glossterm><glossdef><para>The <emphasis>scope</emphasis> in which a declared
      <emphasis>type</emphasis> or type <emphasis>member</emphasis> is visible
      to other types and <phrase role="keep-together">members</phrase>.<indexterm significance="normal"><primary>visibility</primary></indexterm></para></glossdef></glossentry></glossary><index/><colophon id="colophon"><title>Colophon</title><para>The animal on the cover of <citetitle>Programming Scala</citetitle> is
  a Malayan tapir (<emphasis>Tapirus indicus</emphasis>), also called an Asian
  tapir. It is a black-and-white hoofed mammal with a round, stocky body
  similar to that of a pig. At 6–8 feet long and 550–700 pounds, the Malayan
  is the largest of the four tapir species. It lives in tropical rain forests
  in Southeast Asia.</para><para>The Malayan tapir’s appearance is striking: its front half and hind
  legs are solid black, and its midsection is marked with a white saddle. This
  pattern provides perfect camouflage for the tapir in a moonlit jungle. Other
  physical characteristics include a thick hide, a stumpy tail, and a short,
  flexible snout. Despite its body shape, the Malayan tapir is an agile
  climber and a fast runner.</para><para>The tapir is a solitary and mainly nocturnal animal. It tends to have
  very poor vision, so it relies on smell and hearing as it roams large
  territories in search of food, tracking other tapirs’ scents and
  communicating via high-pitched whistles. The Malayan tapir’s predators are
  tigers, leopards, and humans, and it is considered endangered due to habitat
  destruction and overhunting.</para><para>The cover image is from the Dover Pictorial Archive. The cover font is
  Adobe ITC Garamond. The text font is Linotype Birka; the heading font is
  Adobe Myriad Condensed; and the code font is LucasFont’s <phrase role="keep-together">TheSansMonoCondensed</phrase>.</para></colophon></book>
