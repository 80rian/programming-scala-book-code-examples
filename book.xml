<?xml version="1.0"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<book>
  <title>Programming Scala</title>
  <bookinfo>
  <othercredit role="proofreader">
    <firstname>Sarah</firstname>

    <surname>Schneider</surname>
  </othercredit>

  <othercredit role="interiordesigner">
    <firstname>David</firstname>

    <surname>Futato</surname>
  </othercredit>

  <othercredit role="illustrator">
    <firstname>Robert</firstname>

    <surname>Romano</surname>
  </othercredit>

  <!-- All rights reserved. -->

  <publisher>
    <publishername>O&#x2019;Reilly Media, Inc.</publishername>

    <address format="linespecific">
      <street>1005 Gravenstein Highway North</street>
      <city>Sebastopol</city>
      <state>CA</state>
      <postcode>95472</postcode>
    </address>
  </publisher>

  <legalnotice role="printlocation">
    <para>Printed in the United States of America.</para>
  </legalnotice>

  <legalnotice role="printer">
    <para>[M]</para>
  </legalnotice>

  <legalnotice role="use">
    <para>O&#x2019;Reilly books may be purchased for educational, business, or sales
    promotional use. Online editions are also available for most titles
    (<ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>).
    For more information, contact our corporate/institutional sales
    department: 800-998-9938 or <email>corporate@oreilly.com</email>.</para>
  </legalnotice>

  <legalnotice role="trademarks">
    <para>O&#x2019;Reilly and the O&#x2019;Reilly logo are registered trademarks of O&#x2019;Reilly
    Media, Inc. <citetitle>Programming Scala</citetitle>, the image of a
    Malayan tapir, and related trade dress are trademarks of O&#x2019;Reilly Media,
    Inc.</para>

    <para>Many of the designations used by manufacturers and sellers to
    distinguish their products are claimed as trademarks. Where those
    designations appear in this book, and O&#x2019;Reilly Media, Inc. was aware of a
    trademark claim, the designations have been printed in caps or initial
    caps.</para>
  </legalnotice>

  <legalnotice role="damages">
    <para>While every precaution has been taken in the preparation of this
    book, the publisher and authors assume no responsibility for errors or
    omissions, or for damages resulting from the use of the information
    contained herein. This work has been released under the <ulink url="http://creativecommons.org/licenses/by-nc/3.0/">Creative Commons
    Attribution-Noncommercial license</ulink>.</para>
  </legalnotice>

  <isbn>9780596155957</isbn>

  <edition>1</edition>

  <author>
    <firstname>Dean</firstname>

    <surname>Wampler</surname>

    <authorblurb>
      <para><emphasis role="strong">Dean Wampler</emphasis> is a consultant,
      trainer, and mentor with Object Mentor, Inc. He specializes in Scala,
      Java, and Ruby, and works with clients on application design strategies
      that combine object-oriented programming, functional programming, and
      <phrase role="keep-together">aspect-</phrase><phrase role="keep-together">oriented</phrase> programming. He also consults on
      Agile methods, such as Lean and XP. Dean is a frequent speaker at
      industry and academic conferences on these topics. He has a Ph.D. in
      physics from the University of Washington.</para>
    </authorblurb>
  </author>

  <author>
    <firstname>Alex</firstname>

    <surname>Payne</surname>

    <authorblurb>
      <para><emphasis role="strong">Alex Payne</emphasis> is Platform Lead at
      Twitter, Inc., where he develops services that enable programmers to
      build atop the popular social messaging service. Alex has previously
      built web applications for political campaigns, non-profits, and
      early-stage startups, and supported information security efforts for
      military and intelligence customers. In his free time, Alex studies,
      speaks, and writes about the history, present use, and evolution of
      programming languages, as well as minimalist art and design.</para>
    </authorblurb>
  </author>

  <editor>
    <firstname>Mike</firstname>

    <surname>Loukides</surname>
  </editor>

  <copyright>
    <year>2009</year>

    <holder>Dean Wampler and Alex Payne</holder>
  </copyright>

  <editor role="production">
    <firstname>Sarah</firstname>

    <surname>Schneider</surname>
  </editor>

  <othercredit role="indexer">
    <firstname>Ellen</firstname>

    <surname>Troutman Zaig</surname>
  </othercredit>

  <othercredit role="coverdesigner">
    <firstname>Karen</firstname>

    <surname>Montgomery</surname>
  </othercredit>

  <printhistory>
    <formalpara>
      <title>First Edition</title>

      <para>September, 2009</para>
    </formalpara>
  </printhistory>
</bookinfo>
  <dedication id="dedication">
  <title>Dedication</title>

  <blockquote>
    <attribution>Dean</attribution>

    <para>To Dad and Mom, who always believed in me.</para>

    <para>To Ann, who was always there for me.</para>
  </blockquote>

  <blockquote>
    <attribution>Alex</attribution>

    <para>To my mother, who gave me an appreciation for good writing and the
    accompanying intellectual tools with which to attempt to produce
    it.</para>

    <para>To Kristen, for her unending patience, love, and kindness.</para>
  </blockquote>
</dedication>
  <preface id="foreword" role="foreword">
  <prefaceinfo>
    <author>
      <firstname>Jonas</firstname>

      <surname>Bon&#xE9;r</surname>

      <affiliation>
        <jobtitle>Independent Consultant, Scalable Solutions AB</jobtitle>
      </affiliation>
    </author>

    <date>August, 2009</date>
  </prefaceinfo>

  <title>Foreword</title>

  <para>If there has been a common theme throughout my career as a programmer,
  it has been the quest for better abstractions and better tools to support
  the craft of writing software. Over the years, I have come to value one
  trait more than any other: composability. If one can write code with good
  composability, it usually means that other traits we software developers
  value&#x2014;such as orthogonality, loose coupling, and high <phrase role="keep-together">cohesion&#x2014;</phrase>are already present. It is all
  connected.</para>

  <para>When I discovered Scala some years ago, the thing that made the
  biggest impression on me was its composability. Through some very elegant
  design choices and simple yet powerful abstractions that were taken from the
  object-oriented and functional <phrase role="keep-together">programming</phrase> worlds, Martin Odersky has managed
  to create a language with high <phrase role="keep-together">cohesion</phrase> and orthogonal, deep abstractions
  that invites composability in all dimensions of software design. Scala is
  truly a SCAlable LAnguage that scales with usage, from scripting all the way
  up to large-scale enterprise applications and middleware. Scala was born out
  of academia, but it has grown into a pragmatic and practical language that
  is very much ready for real-world production use.</para>

  <para>What excites me most about this book is that it&#x2019;s so practical. Dean
  and Alex have done a fantastic job, not only by explaining the language
  through interesting discussions and samples, but also by putting it in the
  context of the real world. It&#x2BC;s written for the programmer who wants to get
  things done. I had the pleasure of getting to know Dean some years ago when
  we were both part of the aspect-oriented programming community. Dean holds a
  rare mix of deep analytical academic thinking and a pragmatic,
  get-things-done kind of mentality. Alex, whom I&#x2019;ve had the pleasure to meet
  once, is leading the API team at Twitter, Inc. Alex has played a leading
  role in moving Twitter&#x2019;s code and infrastructure to Scala, making it one on
  the first companies to successfully deploy Scala in production.</para>

  <?dbfo-need height=”2in”
?>

  <para>You are about to learn how to write reusable components using mixin
  and function composition; how to write concurrent applications using Scala&#x2019;s
  Actors; how to make effective use of Scala&#x2019;s XML/XPath support; how to
  utilize Scala&#x2BC;s rich, flexible, and expressive syntax to build
  Domain-Specific Languages; how to effectively test your Scala code; how to
  use Scala with popular frameworks such as Spring, Hadoop, and Terracotta;
  and much, much more. Enjoy the ride. I sure did.</para>
</preface>
  <preface id="Preface">
  <title>Preface</title>

  <para><citetitle>Programming Scala</citetitle> introduces an exciting new
  language that offers all the benefits of a modern object model, functional
  programming, and an advanced type system. Packed with code examples, this
  comprehensive book teaches you how to be productive with Scala quickly, and
  explains what makes this language ideal for today&#x2019;s scalable, distributed,
  component-based applications that support concurrency and distribution.
  You&#x2019;ll also learn how Scala takes advantage of the advanced Java Virtual
  Machine as a platform for programming languages.</para>

  <para>Learn more at <ulink url="http://programmingscala.com">http://programmingscala.com</ulink> or at
  the book&#x2019;s <ulink url="http://oreilly.com/catalog/9780596155957/">catalog
  page</ulink>.</para>

  <sect1>
    <title>Welcome to Programming Scala</title>

    <para>Programming languages become popular for many reasons. Sometimes,
    programmers on a given platform prefer a particular language, or one is
    institutionalized by a vendor. Most Mac OS programmers use Objective-C.
    Most Windows programmers use C++ and .NET languages. Most embedded-systems
    developers use C and C++.</para>

    <para>Sometimes, popularity derived from technical merit gives way to
    fashion and fanaticism. C++, Java, and Ruby have been the objects of
    fanatical devotion among <phrase role="keep-together">programmers</phrase>.</para>

    <para>Sometimes, a language becomes popular because it fits the needs of
    its era. Java was initially seen as a perfect fit for browser-based, rich
    client applications. Smalltalk <phrase role="keep-together">captured</phrase> the essence of object-oriented
    programming (OOP) as that model of programming entered the
    mainstream.</para>

    <para>Today, concurrency, heterogeneity, always-on services, and
    ever-shrinking development schedules are driving interest in functional
    programming (FP). It appears that the dominance of object-oriented
    programming may be over. Mixing paradigms is becoming popular, even
    necessary.</para>

    <para>We gravitated to Scala from other languages because Scala embodies
    many of the optimal qualities we want in a general-purpose programming
    language for the kinds of applications we build today: reliable,
    high-performance, highly concurrent Internet and enterprise
    applications.</para>

    <para>Scala is a multi-paradigm language, supporting both object-oriented
    and functional programming approaches. Scala is scalable, suitable for
    everything from short scripts up to large-scale, component-based
    applications. Scala is sophisticated, incorporating state-of-the-art ideas
    from the halls of computer science departments worldwide. Yet Scala is
    practical. Its creator, Martin Odersky, participated in the development of
    Java for years and understands the needs of professional
    developers.</para>

    <para>Both of us were seduced by Scala, by its concise, elegant, and
    expressive syntax and by the breadth of tools it put at our disposal. In
    this book, we strive to demonstrate why all these qualities make Scala a
    compelling and indispensable programming language.</para>

    <para>If you are an experienced developer who wants a fast, thorough
    introduction to Scala, this book is for you. You may be evaluating Scala
    as a replacement for or complement to your current languages. Maybe you
    have already decided to use Scala, and you need to learn its features and
    how to use it well. Either way, we hope to illuminate this powerful
    language for you in an accessible way.</para>

    <para>We assume that you are well versed in object-oriented programming,
    but we don&#x2019;t assume that you have prior exposure to functional
    programming. We assume that you are experienced in one or more other
    programming languages. We draw parallels to features in Java, C#, Ruby,
    and other languages. If you know any of these languages, we&#x2019;ll point out
    similar features in Scala, as well as many features that are new.</para>

    <para>Whether you come from an object-oriented or functional programming
    background, you will see how Scala elegantly combines both paradigms,
    demonstrating their complementary nature. Based on many examples, you will
    understand how and when to apply OOP and FP techniques to many different
    design problems.</para>

    <para>In the end, we hope that you too will be seduced by Scala. Even if
    Scala does not end up becoming your day-to-day language, we hope you will
    gain insights that you can apply regardless of which language you are
    using.</para>
  </sect1>

  <sect1 id="_conventions_used_in_this_book">
    <title>Conventions Used in This Book</title>

    <para id="para_the_following_typographical_co">The following typographical
    conventions are used in this book:</para>

    <variablelist id="para_book_conventions">
      <varlistentry id="varlistentry-italic">
        <term><emphasis>Italic</emphasis></term>

        <listitem>
          <para>Indicates new terms, URLs, email addresses, file names, and
          file extensions. Many italicized terms are defined in the <xref linkend="Glossary"/>.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-constant-width">
        <term><literal>Constant width</literal></term>

        <listitem>
          <para>Used for program listings, as well as within paragraphs to
          refer to program elements such as variable or function names,
          databases, data types, environment variables, statements, and
          keywords.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-constant-width-bold">
        <term><userinput>Constant width bold</userinput></term>

        <listitem>
          <para>Shows commands or other text that should be typed literally by
          the user.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-constant-width-italic">
        <term><replaceable>Constant width italic</replaceable></term>

        <listitem>
          <para>Shows text that should be replaced with user-supplied values
          or by values determined by context.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <tip id="para_tip_this_icon_signifies_a_tip">
      <para>This icon signifies a tip, suggestion, or general note.</para>
    </tip>

    <caution id="para_caution_this_icon_indicates_a">
      <para>This icon indicates a warning or caution.</para>
    </caution>
  </sect1>

  <sect1 id="UsingCodeExamples">
    <title>Using Code Examples</title>

    <para id="para_this_book_is_here_to_help_you_">This book is here to help
    you get your job done. In general, you may use the code in this book in
    your programs and documentation. You do not need to contact us for
    permission unless you&#x2019;re reproducing a significant portion of the code.
    For example, writing a program that uses several chunks of code from this
    book does not require permission. Selling or distributing a CD-ROM of
    examples from O&#x2019;Reilly books does require permission. Answering a question
    by citing this book and quoting example code does not require permission.
    Incorporating a significant amount of example code from this book into
    your product&#x2019;s documentation does require permission.</para>

    <para id="para_we_appreciate_but_do_not_requ">We appreciate, but do not
    require, attribution. An attribution usually includes the title, author,
    publisher, and ISBN. For example: &#x201C;<emphasis>Programming Scala</emphasis>
    by Dean Wampler and Alex Payne. Copyright 2009 Dean Wampler and Alex
    Payne, 978-0-596-15595-7.&#x201D;</para>

    <para id="para_if_you_feel_your_use_of_code_e">If you feel your use of
    code examples falls outside fair use or the permission given above, feel
    free to contact us at <email>permissions@oreilly.com</email>.</para>

    <sect2 id="GettingCodeExamples">
      <title>Getting the Code Examples</title>

      <para id="para_you_can_download_the_code_exam">You can download the code
      examples from <ulink url="http://examples.oreilly.com/9780596155964/">http://examples.oreilly.com/9780596155964/</ulink>.
      Unzip the files to a convenient location. See the
      <filename>README.txt</filename> file in the distribution for
      instructions on building and using the examples.</para>

      <para id="para_file_name_conventions">Some of the example files can be
      run as scripts using the <literal>scala</literal> command. Others must
      be compiled into class files. Some files contain deliberate errors and
      won&#x2019;t compile. We have adopted a file naming convention to indicate each
      of these cases, although as you learn Scala it should become obvious
      from the contents of the files, in most cases:<indexterm>
          <primary>code examples in this book</primary>
        </indexterm><indexterm>
          <primary>web page for this book</primary>

          <secondary>code examples</secondary>
        </indexterm></para>

      <variablelist id="para_script_file_convention">
        <varlistentry id="varlistentry-script-scala">
          <term><filename>*-script.scala</filename></term>

          <listitem>
            <para>Files that end in <filename>-script.scala</filename> can be
            run on a command line using <literal>scala</literal>, e.g.,
            <literal>scala foo-script.scala</literal>. You can also start
            <literal>scala</literal> in the interpreter mode (when you <phrase role="keep-together">don&#x2019;t specify</phrase> a script file) and
            load any script file in the interpreter using the <literal>:load
            file&#x2060;name</literal> command.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-wont-compile-scala">
          <term><filename>*-wont-compile.scala</filename></term>

          <listitem>
            <para>Files that end in <filename>-wont-compile.scala</filename>
            contain deliberate errors that will cause them to fail to compile.
            We use this naming convention, along with one or more embedded
            comments about the errors, so it will be clear that they are
            invalid. Also, these files are skipped by the build process for
            the examples.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-sake-scala">
          <term><filename>sake.scala</filename></term>

          <listitem>
            <para>Files named <filename>sake.scala</filename> are used by our
            build tool, called <literal>sake</literal>. The
            <filename>README.txt</filename> file describes this tool.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-scala">
          <term><filename>*.scala</filename></term>

          <listitem>
            <para>All other Scala files must be compiled using
            <literal>scalac</literal>. In the distribution, they are used
            either by other compiled or script files, such as tests, not all
            of which are listed in this book.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1>
    <title>Safari&#xAE; Books Online</title>

    <note role="safarienabled">
      <para>Safari Books Online is an on-demand digital library that lets you
      easily search over 7,500 technology and creative reference books and
      videos to find the answers you need quickly.</para>
    </note>

    <para>With a subscription, you can read any page and watch any video from
    our library online. Read books on your cell phone and mobile devices.
    Access new titles before they are available for print, and get exclusive
    access to manuscripts in development and post feedback for the authors.
    Copy and paste code samples, organize your favorites, download chapters,
    bookmark key sections, create notes, print out pages, and benefit from
    tons of other time-saving features.</para>

    <para>O&#x2019;Reilly Media has uploaded this book to the Safari Books Online
    service. To have full digital access to this book and others on similar
    topics from O&#x2019;Reilly and other publishers, sign up for free at <ulink role="orm:hideurl:ital" url="http://my.safaribooksonline.com/?portal=oreilly">http://my.safaribooksonline.com</ulink>.</para>
  </sect1>

  <sect1 id="_how_to_contact_us">
    <title>How to Contact Us</title>

    <para id="para_please_address_comments_and_qu">Please address comments and
    questions concerning this book to the publisher:</para>

    <simplelist type="vert">
      <member>O&#x2019;Reilly Media, Inc.</member>

      <member>1005 Gravenstein Highway North</member>

      <member>Sebastopol, CA 95472</member>

      <member>800-998-9938 (in the United States or Canada)<?dbfo-need height=”1in”
?></member>

      <member>707-829-0515 (international or local)</member>

      <member>707-829-0104 (fax)</member>
    </simplelist>

    <para id="para_we_have_a_web_page_for_this_bo">We have a web page for this
    book, where we list errata, examples, and any additional information. You
    can access this page at:<indexterm>
        <primary>web page for this book</primary>
      </indexterm></para>

    <simplelist type="vert">
      <member><ulink url="http://oreilly.com/catalog/9780596155957/"/></member>
    </simplelist>

    <para id="para_to_comment_or_ask_technical_qu">To comment or ask technical
    questions about this book, send email to:</para>

    <simplelist type="vert">
      <member><email>bookquestions@oreilly.com</email></member>
    </simplelist>

    <para id="para_for_more_information_about_our">For more information about
    our books, conferences, Resource Centers, and the <phrase role="keep-together">O&#x2019;Reilly</phrase> Network, see our website at:</para>

    <simplelist type="vert">
      <member><ulink url="http://oreilly.com"/></member>
    </simplelist>
  </sect1>

  <sect1>
    <title>Acknowledgments</title>

    <para>As we developed this book, many people read early drafts and
    suggested numerous improvements to the text, for which we are eternally
    grateful. We are especially grateful to Steve Jensen, Ramnivas Laddad,
    Marcel Molina, Bill Venners, and Jonas Bon&#xE9;r for their extensive
    feedback.</para>

    <para>Much of the feedback we received came through the Safari Rough Cuts
    releases and the online edition available at <ulink url="http://programmingscala.com">http://programmingscala.com</ulink>. We
    are grateful for the feedback provided by (in no particular order) Iulian
    Dragos, Nikolaj Lindberg, Matt Hellige, David Vydra, Ricky Clarkson, Alex
    Cruise, Josh Cronemeyer, Tyler Jennings, Alan Supynuk, Tony Hillerson,
    Roger Vaughn, Arbi Sookazian, Bruce Leidl, Daniel Sobral, Eder Andres
    Avila, Marek Kubica, Henrik Huttunen, Bhaskar Maddala, Ged Byrne, Derek
    Mahar, Geoffrey Wiseman, Peter Rawsthorne, Geoffrey Wiseman, Joe Bowbeer,
    Alexander Battisti, Rob Dickens, Tim MacEachern, Jason Harris, Steven
    Grady, Bob Follek, Ariel Ortiz, Parth Malwankar, Reid Hochstedler, Jason
    Zaugg, Jon Hanson, Mario Gleichmann, David Gates, Zef Hemel, Michael Yee,
    Marius Kreis, Martin S&#xFC;sskraut, Javier Vegas, Tobias Hauth, Francesco
    Bochicchio, Stephen Duncan Jr., Patrik Dudits, Jan Niehusmann, Bill
    Burdick, David Holbrook, Shalom Deitch, Jesper Nordenberg, Esa Laine, Gleb
    Frank, Simon Andersson, Patrik Dudits, Chris Lewis, Julian Howarth, Dirk
    Kuzemczak, Henri Gerrits, John Heintz, Stuart Roebuck, and Jungho Kim.
    Many other readers for whom we only have usernames also provided feedback.
    We wish to thank Zack, JoshG, ewilligers, abcoates, brad, teto, pjcj,
    mkleint, dandoyon, Arek, rue, acangiano, vkelman, bryanl, Jeff, mbaxter,
    pjb3, kxen, hipertracker, ctran, Ram R., cody, Nolan, Joshua, Ajay, Joe,
    and anonymous contributors. We apologize if we have overlooked
    anyone!</para>

    <para>Our editor, Mike Loukides, knows how to push and prod gentle. He&#x2019;s
    been a great help throughout this crazy process. Many other people at
    O&#x2019;Reilly were always there to answer our questions and help us move
    forward.</para>

    <para>We thank Jonas Bon&#xE9;r for writing the <xref linkend="foreword" xrefstyle="select:nopage"/> for the book. Jonas is a longtime friend and
    collaborator from the aspect-oriented programming (AOP) community. For
    years, he has done pioneering work in the Java community. Now he is
    applying his energies to promoting Scala and growing that
    community.</para>

    <para>Bill Venners graciously provided the quote on the back cover. The
    first published book on Scala, <citetitle>Programming in Scala</citetitle>
    (Artima), that he cowrote with Martin Odersky and Lex Spoon, is
    indispensable for the Scala developer. Bill has also created the wonderful
    ScalaTest library.</para>

    <para>We have learned a lot from fellow developers around the world.
    Besides Jonas and Bill, Debasish Ghosh, James Iry, Daniel Spiewak, David
    Pollack, Paul Snively, Ola Bini, Daniel Sobral, Josh Suereth, Robey
    Pointer, Nathan Hamblen, Jorge Ortiz, and others have illuminated dark
    corners with their blog entries, forum discussions, and personal
    conversations.</para>

    <para>Dean thanks his colleagues at Object Mentor and several developers
    at client sites for many stimulating discussions on languages, software
    design, and the pragmatic issues facing developers in industry. The
    members of the Chicago Area Scala Enthusiasts (CASE) group have also been
    a source of valuable feedback and inspiration.</para>

    <para>Alex thanks his colleagues at Twitter for their encouragement and
    superb work in demonstrating Scala&#x2019;s effectiveness as a language. He also
    thanks the Bay Area Scala Enthusiasts (BASE) for their motivation and
    <phrase role="keep-together">community</phrase>.</para>

    <para>Most of all, we thank Martin Odersky and his team for creating
    Scala.</para>
  </sect1>
</preface>
  <chapter id="IntroducingScala">
  <title>Zero to Sixty: Introducing Scala</title>

  <sect1 id="_why_scala">
    <title>Why Scala?</title>

    <para id="para_why_scala1">Today&#x2019;s enterprise and Internet applications
    must balance a number of concerns. They must be implemented quickly and
    reliably. New features must be added in short, incremental cycles. Beyond
    simply providing business logic, applications must support secure access,
    persistence of data, transactional behavior, and other advanced features.
    Applications must be highly available and scalable, requiring designs that
    support <phrase role="keep-together">concurrency</phrase> and
    distribution. Applications are networked and provide interfaces for both
    people and other applications to use.</para>

    <para id="para_why_scala2">To meet these challenges, many developers are
    looking for new languages and tools. Venerable standbys like Java, C#, and
    C++ are no longer optimal for developing the next generation of
    applications.</para>

    <sect2 id="_if_you_are_a_java_programmer_8230">
      <title>If You Are a Java Programmer&#x2026;</title>

      <para id="para_java_was_officially_introduced">Java was officially
      introduced by Sun Microsystems in May of 1995, at the advent of
      widespread interest in the Internet. Java was immediately hailed as an
      ideal language for writing browser-based applets, where a secure,
      portable, and developer-friendly application language was needed. The
      reigning language of the day, C++, was not suitable for this
      domain.<indexterm>
          <primary>Java</primary>
        </indexterm></para>

      <para id="para_today_java_is_more_often_used">Today, Java is more often
      used for server-side applications. It is one of the most popular
      languages in use for the development of web and enterprise
      applications.</para>

      <para id="para_however_java_was_a_child_of_i">However, Java was a child
      of its time. Now it shows its age. In 1995, Java provided a syntax
      similar enough to C++ to entice C++ developers, while avoiding many of
      that language&#x2019;s deficiencies and &#x201C;sharp edges.&#x201D; Java adopted the most
      useful ideas for the development problems of its era, such as
      object-oriented programming (OOP), while discarding more troublesome
      techniques, such as manual memory management. These design choices
      struck an excellent balance that minimized complexity and maximized
      developer productivity, while trading-off performance compared to
      natively compiled code. While Java has evolved since its birth, many
      people believe it has grown too complex without adequately addressing
      some newer development challenges.</para>

      <para id="para_developers_want_languages_that">Developers want languages
      that are more succinct and flexible to improve their productivity. This
      is one reason why so-called scripting languages like Ruby and Python
      have become more popular recently.<indexterm>
          <primary>scripting languages, popularity of</primary>
        </indexterm></para>

      <para id="para_the_never_ending_need_to_scale">The never-ending need to
      scale is driving architectures toward pervasive concurrency. However,
      Java&#x2019;s concurrency model, which is based on synchronized access to
      shared, mutable state, results in complex and error-prone
      programs.<indexterm>
          <primary>concurrency</primary>

          <secondary>Java and</secondary>
        </indexterm></para>

      <para id="para_while_the_java_language_is_sho">While the Java language
      is showing its age, the Java Virtual Machine (JVM) on which it runs
      continues to shine. The optimizations performed by today&#x2019;s JVM are
      extraordinary, allowing byte code to outperform natively compiled code
      in many cases. Today, many developers believe that using the JVM with
      new languages is the path forward. Sun is embracing this trend by
      employing many of the lead developers of JRuby and Jython, which are JVM
      ports of Ruby and Python, respectively.<indexterm>
          <primary>JVM (Java Virtual Machine)</primary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>JVM (Java Virtual Machine)</secondary>
        </indexterm></para>

      <para id="para_the_appeal_of_scala_for_the_ja">The appeal of Scala for
      the Java developer is that it gives you a newer, more modern language,
      while leveraging the JVM&#x2019;s amazing performance and the wealth of Java
      libraries that have been developed for over a decade.</para>
    </sect2>

    <sect2 id="_if_you_are_a_ruby_python_etc_programmer_8230">
      <title>If You Are a Ruby, Python, etc. Programmer&#x2026;</title>

      <para id="para__dynamically_typed__languages_"><emphasis>Dynamically
      typed</emphasis> languages like Ruby, Python, Groovy, JavaScript, and
      Smalltalk <phrase role="keep-together">offer</phrase> very high
      productivity due to their flexibility, powerful metaprogramming, and
      <phrase role="keep-together">elegance</phrase>.<indexterm>
          <primary>Ruby</primary>

          <secondary>dynamic typing</secondary>
        </indexterm><indexterm>
          <primary>dynamically typed languages</primary>
        </indexterm></para>

      <sidebar>
        <title>Statically Typed Versus Dynamically Typed Languages</title>

        <para id="para_one_of_the_fundamental_languag">One of the fundamental
        language design choices is <emphasis>static versus dynamic</emphasis>
        typing.<indexterm>
            <primary>data types</primary>

            <secondary>static versus dynamic typing</secondary>
          </indexterm><indexterm>
            <primary>static typing</primary>

            <secondary>versus dynamic typing</secondary>
          </indexterm><indexterm>
            <primary>dynamic typing</primary>

            <secondary>versus static typing</secondary>
          </indexterm></para>

        <para id="para_the_word_typing_is_used_in">The word &#x201C;typing&#x201D; is used
        in many contexts in software. The following is a &#x201C;plausible&#x201D;
        definition that is useful for our purposes.<indexterm>
            <primary>typing</primary>
          </indexterm></para>

        <blockquote>
          <attribution>Benjamin C. Pierce, <citetitle>Types and Programming
          Languages</citetitle> (MIT Press, 2002)</attribution>

          <para>A type system is a tractable syntactic method for preserving
          the absence of certain program behaviors by classifying phrases
          according to the kinds of values they compute.</para>
        </blockquote>

        <para id="para_note_the_emphasis_on_how_a_typ">Note the emphasis on
        how a type system allows reasoning about what a system
        <emphasis>excludes</emphasis> from happening. That&#x2019;s generally easier
        than trying to determine the set of all allowed possibilities. A type
        system is used to catch various errors, like unsupported operations on
        particular data structures, attempting to combine data in an undefined
        way (e.g., trying to add an integer to a string), breaking
        abstractions, etc.<indexterm>
            <primary>type system</primary>
          </indexterm></para>

        <para id="para_informally_in_static_typing_">Informally, in static
        typing, a <emphasis>variable</emphasis> is bound to a particular type
        for its lifetime. Its type can&#x2019;t be changed and it can only reference
        type-compatible instances. That is, if a variable refers to a value of
        type <literal>A</literal>, you can&#x2019;t assign a value of a different
        type <literal>B</literal> to it, unless <literal>B</literal> is a
        subtype of <literal>A</literal>, for some reasonable definition of
        &#x201C;subtype.&#x201D;<indexterm>
            <primary>variables</primary>

            <secondary sortas="static and dynamic typing">in static and
            dynamic typing</secondary>
          </indexterm></para>

        <para id="para_in_dynamic_typing_the_type_is">In dynamic typing, the
        type is bound to the <emphasis>value</emphasis>, not the
        <emphasis>variable</emphasis>. So, a variable might refer to a value
        of type <literal>A</literal>, then be reassigned later to a value of
        an unrelated type <literal>X</literal>.</para>

        <para id="para_the_term__dynamically_typed__i">The term
        <emphasis>dynamically typed</emphasis> is used because the type of a
        <emphasis>variable</emphasis> is evaluated when it is used during
        runtime, while in a statically typed language the type is evaluated at
        parse time.</para>

        <para id="para_this_may_seem_like_a_small_dis">This may seem like a
        small distinction, but it has a pervasive impact on the philosophy,
        design, and implementation of a language. We&#x2019;ll explore some of these
        implications as we go through the book.</para>

        <para id="para_scala_and_java_are_statically_">Scala and Java are
        statically typed languages, whereas Ruby, Python, Groovy, JavaScript,
        and Smalltalk are dynamically typed languages.<indexterm>
            <primary>Java</primary>

            <secondary>static typing</secondary>
          </indexterm></para>

        <para id="para_for_simplicity_we_will_often_">For simplicity, we will
        often use the terms <emphasis>static language</emphasis> and
        <emphasis>dynamic language</emphasis> as shorthands for
        <emphasis>statically typed language</emphasis> and
        <emphasis>dynamically typed language</emphasis>, respectively.</para>

        <para id="para_an__orthogonal__design_conside">An
        <emphasis>orthogonal</emphasis> design consideration is
        <emphasis>strong versus weak</emphasis> typing. In strong typing,
        every variable (for static typing) or value (for dynamic typing) must
        have an unambiguous type. In weak typing, a specific type is not
        required. While most languages allow some mixture of strong versus
        weak typing, Scala, Java, and Ruby are
        <emphasis>predominantly</emphasis> strongly typed languages. Some
        languages, like C and Perl, are more weakly typed.<indexterm>
            <primary>weak versus strong typing</primary>
          </indexterm><indexterm>
            <primary>strong versus weak typing</primary>
          </indexterm></para>
      </sidebar>

      <para id="para_despite_their_productivity_adv">Despite their
      productivity advantages, <emphasis>dynamic</emphasis> languages may not
      be the best choices for all applications, particularly for very large
      code bases and high-performance applications. There is a longstanding,
      spirited debate in the programming community about the relative merits
      of dynamic versus static typing. Many of the points of comparison are
      somewhat subjective. We won&#x2019;t go through all the arguments here, but we
      will offer a few thoughts for consideration.</para>

      <para id="para_optimizing_the_performance_of_">Optimizing the
      performance of a dynamic language is more challenging than for a static
      language. In a static language, optimizers can exploit the type
      information to make decisions. In a dynamic language, fewer such clues
      are available for the optimizer, making optimization choices harder.
      While recent advancements in optimizations for dynamic languages are
      promising, they lag behind the state of the art for static languages.
      So, if you require very high performance, static languages are probably
      a safer choice.</para>

      <para id="para_static_languages_can_also_bene">Static languages can also
      benefit the development process. Integrated development environment
      (IDE) features like <emphasis>autocompletion</emphasis> (sometimes
      called <emphasis>code sense</emphasis>) are <phrase role="keep-together">easier to implement</phrase> for static languages,
      again because of the extra type information available. The more explicit
      type information in static code promotes better &#x201C;<phrase role="keep-together">self-</phrase><phrase role="keep-together">documentation</phrase>,&#x201D; which can be important for
      communicating intent among developers, especially as a project
      grows.</para>

      <para id="para_when_using_a_static_language_">When using a static
      language, you have to think about appropriate type choices more often,
      which forces you to weigh design choices more carefully. While this may
      slow down daily design decisions, thinking through the types in the
      application can result in a more coherent design over time.</para>

      <para id="para_another_small_benefit_of_stati">Another small benefit of
      static languages is the extra checking the compiler performs. We think
      this advantage is often oversold, as type mismatch errors are a small
      fraction of the runtime errors you typically see. The compiler can&#x2019;t
      find <emphasis>logic</emphasis> errors, which are far more significant.
      Only a comprehensive, automated test suite can find logic errors. For
      dynamically typed languages, the tests must cover possible type errors,
      too. If you are coming from a dynamically typed language, you may find
      that your test suites are a little smaller as a result, but not
      <emphasis>that</emphasis> much smaller.</para>

      <para id="para_many_developers_who_find_stati">Many developers who find
      static languages too verbose often blame static typing for the verbosity
      when the real problem is a lack of <emphasis>type inference</emphasis>.
      In type inference, the compiler infers the types of values based on the
      context. For example, the compiler will recognize that <literal>x = 1 +
      3</literal> means that <literal>x</literal> must be an integer. Type
      inference reduces verbosity significantly, making the code feel more
      like code written in a dynamic <phrase role="keep-together">language</phrase>.</para>

      <para id="para_we_have_worked_with_both_stati">We have worked with both
      static and dynamic languages, at various times. We find both kinds of
      languages compelling for different reasons. We believe the modern
      software developer must master a range of languages and tools.
      Sometimes, a dynamic language will be the right tool for the job. At
      other times, a static language like Scala is just what you need.</para>
    </sect2>

    <sect2 id="_introducing_scala">
      <title>Introducing Scala</title>

      <para id="para__scala__is_a_language_that_add"><emphasis>Scala</emphasis> is a
      language that addresses the major needs of the modern developer. It is a
      statically typed, mixed-paradigm, JVM language with a succinct, elegant,
      and flexible syntax, a sophisticated type system, and idioms that
      promote scalability from small, interpreted scripts to large,
      sophisticated applications. That&#x2019;s a mouthful, so let&#x2019;s look at each of
      those ideas in more detail:<indexterm>
          <primary>Scala</primary>

          <secondary>introduction to</secondary>
        </indexterm></para>

      <variablelist id="para_scala_characteristics">
        <varlistentry id="varlistentry-statically-typed">
          <term>Statically typed</term>

          <listitem>
            <para>As we described in the previous section, a statically typed
            language binds the type to a <emphasis>variable</emphasis> for the
            lifetime of that variable. In contrast, <emphasis>dynamically
            typed</emphasis> languages bind the type to the actual
            <emphasis>value</emphasis> referenced by a variable, meaning that
            the type of a <emphasis>variable</emphasis> can change along with
            the value it references.</para>

            <para id="para_of_the_set_of_newer_jvm_langua">Of the set of newer
            JVM languages, Scala is one of the few that is statically typed,
            and it is the best known among them.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-mixed-paradigm-object-oriented-programming">
          <term>Mixed paradigm&#x2014;object-oriented programming</term>

          <listitem>
            <para>Scala fully supports <emphasis>object-oriented
            programming</emphasis> (OOP). Scala improves upon Java&#x2019;s support
            for OOP with the addition of <emphasis>traits</emphasis>, a clean
            way of implementing classes using <emphasis>mixin
            composition</emphasis>. Scala&#x2019;s traits work much like Ruby&#x2019;s
            <emphasis>modules</emphasis>. If you&#x2019;re a Java programmer, think
            of traits as unifying interfaces with their <phrase role="keep-together">implementations</phrase>.<indexterm>
                <primary>object-oriented programming (OOP)</primary>

                <secondary>mixed paradigm in Scala</secondary>
              </indexterm><indexterm>
                <primary>mixin composition</primary>
              </indexterm><indexterm>
                <primary>traits</primary>
              </indexterm></para>

            <para id="para_everything_is_object">In Scala, everything is
            <emphasis>really</emphasis> an object. Scala does not have
            primitive types, like Java. Instead, all numeric types are true
            objects. However, for optimal <phrase role="keep-together">performance</phrase>, Scala uses the
            underlying primitives types of the runtime whenever possible.
            Also, Scala does not support &#x201C;static&#x201D; or class-level members of
            types, since they are not associated with an actual instance.
            Instead, Scala supports a singleton object construct to support
            those cases where exactly one instance of a type is
            needed.<indexterm>
                <primary>FP</primary>

                <see>functional programming</see>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-mixed-paradigm-functional-programming">
          <term>Mixed paradigm&#x2014;functional programming</term>

          <listitem>
            <para>Scala fully supports <emphasis>functional
            programming</emphasis> (FP). FP is a programming paradigm that is
            older than OOP, but it has been sheltered in the ivory towers of
            academia until recently. Interest in FP is increasing because of
            the ways it simplifies certain design problems, especially
            concurrency. &#x201C;Pure&#x201D; functional languages don&#x2019;t allow for any
            mutable state, thereby avoiding the need for synchronization on
            shared access to mutable state. Instead, programs written in pure
            functional languages communicate by passing messages between
            concurrent, autonomous processes. Scala supports this model with
            its Actors library, but it allows for both mutable and immutable
            variables.<indexterm>
                <primary>immutable variables</primary>
              </indexterm><indexterm>
                <primary>Actors</primary>
              </indexterm><indexterm>
                <primary>variables</primary>

                <secondary>mutable and immutable</secondary>
              </indexterm><indexterm>
                <primary>functional programming</primary>

                <secondary>mixed paradigm in Scala</secondary>
              </indexterm></para>

            <para id="para_functions_are_first_class_">Functions are
            &#x201C;first-class&#x201D; citizens in FP, meaning they can be assigned to
            variables, passed to other functions, etc., just like other
            values. This feature promotes composition of advanced behavior
            using primitive operations. Because Scala adheres to the dictum
            that <emphasis>everything is an object</emphasis>, functions are
            themselves objects in Scala.<indexterm>
                <primary>objects</primary>

                <secondary sortas="Scala">in Scala</secondary>
              </indexterm></para>

            <para id="para_scala_also_offers__closures__">Scala also offers
            <emphasis>closures</emphasis>, a feature that dynamic languages
            like Python and Ruby have adopted from the functional programming
            world, and one sadly absent from recent versions of Java. Closures
            are functions that reference variables from the scope enclosing
            the function definition. That is, the variables aren&#x2019;t passed in
            as arguments or defined as local variables within the function. A
            closure &#x201C;closes around&#x201D; these references, so the function
            invocation can safely refer to the variables even when the
            variables have gone out of scope! Closures are such a powerful
            abstraction that object systems and fundamental control structures
            are often <phrase role="keep-together">implemented</phrase> using
            them.<indexterm>
                <primary>closures</primary>

                <secondary>defined</secondary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-a-jvm-and-net-language">
          <term>A JVM and .NET language</term>

          <listitem>
            <para>While Scala is primarily known as a JVM language, meaning
            that Scala generates JVM byte code, a .NET version of Scala that
            generates Common Language Runtime (CLR) byte code is also under
            development. When we refer to the underlying &#x201C;runtime,&#x201D; we will
            usually discuss the JVM, but most of what we will say applies
            equally to both runtimes. When we discuss JVM-specific details,
            they generalize to the .NET version, except where noted.<indexterm>
                <primary>CLR (Common Language Runtime), Scala running
                on</primary>
              </indexterm><indexterm>
                <primary>JVM version of Scala</primary>
              </indexterm><indexterm>
                <primary sortas="NET version of Scala">.NET version of
                Scala</primary>
              </indexterm></para>

            <para id="para_the_scala_parser_uses_clever_t">The Scala compiler
            uses clever techniques to map Scala extensions to valid byte code
            idioms. From Scala, you can easily invoke byte code that
            originated as Java source (for the JVM) or C# source (for .NET).
            Conversely, you can invoke Scala code from Java, C#, etc. Running
            on the JVM and CLR allows the Scala developer to leverage
            available libraries and to interoperate with other languages
            hosted on those runtimes.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-a-succinct-elegant-and-flexible-syntax">
          <term>A succinct, elegant, and flexible syntax</term>

          <listitem>
            <para>Java syntax can be verbose. Scala uses a number of
            techniques to minimize unnecessary syntax, making Scala code as
            succinct as code in most dynamically typed languages.
            <emphasis>Type inference</emphasis> minimizes the need for
            explicit type information in many contexts. Declarations of types
            and functions are very concise.</para>

            <para id="para_scala_allows_function_names_to">Scala allows
            function names to include non-alphanumeric characters. Combined
            with some syntactic sugar, this feature permits the user to define
            methods that look and behave like operators. As a result,
            libraries outside the core of the language can feel &#x201C;native&#x201D; to
            users.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-a-sophisticated-type-system">
          <term>A sophisticated type system</term>

          <listitem>
            <para>Scala extends the type system of Java with more flexible
            generics and a number of more advanced typing constructs. The type
            system can be intimidating at first, but most of the time you
            won&#x2019;t need to worry about the advanced constructs. Type inference
            helps by automatically inferring type signatures, so that the user
            doesn&#x2019;t have to provide trivial type information manually. When
            you need them, though, the advanced type features provide you with
            greater flexibility for solving design problems in a type-safe
            way.<indexterm>
                <primary>type system</primary>

                <secondary>Scala</secondary>
              </indexterm><indexterm>
                <primary>data types</primary>

                <secondary>Scala&#x2019;s sophisticated type system</secondary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-scalable-architectures">
          <term>Scalable&#x2014;architectures</term>

          <listitem>
            <para>Scala is designed to scale from small, interpreted scripts
            to large, distributed applications. Scala provides four language
            mechanisms that promote scalable composition of systems: 1)
            explicit <emphasis>self types</emphasis>; 2) abstract type members
            and generics; 3) nested classes; and 4) <emphasis>mixin</emphasis>
            composition using <emphasis>traits</emphasis>.<indexterm>
                <primary>scalability, Scala support for</primary>
              </indexterm><indexterm>
                <primary>generics</primary>
              </indexterm><indexterm>
                <primary>abstract type members</primary>
              </indexterm><indexterm>
                <primary>self types</primary>
              </indexterm><indexterm>
                <primary>mixin composition</primary>

                <secondary>using traits</secondary>
              </indexterm></para>

            <para id="para_no_other_language_provides_all">No other language
            provides all these mechanisms. Together, they allow applications
            to be constructed from reusable &#x201C;components&#x201D; in a type-safe and
            succinct manner. As we will see, many common design patterns and
            architectural techniques like dependency injection are easy to
            implement in Scala without the boilerplate code or lengthy XML
            configuration files that can make Java development tedious.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-scalable-performance">
          <term>Scalable&#x2014;performance</term>

          <listitem>
            <para>Because Scala code runs on the JVM and the CLR, it benefits
            from all the performance optimizations provided by those runtimes
            and all the third-party tools that support performance and
            scalability, such as profilers, distributed cache libraries,
            clustering mechanisms, etc. If you trust Java&#x2019;s and C#&#x2019;s
            performance, you can trust Scala&#x2019;s performance. Of course, some
            particular constructs in the language and some parts of the
            library may perform significantly better or worse than alternative
            options in other languages. As always, you should profile your
            code and optimize it when necessary.<indexterm>
                <primary>performance</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para id="para_it_might_appear_that_oop_and_f">It might appear that OOP
      and FP are incompatible. In fact, a design philosophy of Scala is that
      OOP and FP are more synergistic than opposed. The features of one
      approach can enhance the other.</para>

      <para id="para_in_fp_functions_have_no_side_">In FP, functions have no
      side effects and variables are immutable, while in OOP, mutable state
      and side effects are common, even encouraged. Scala lets you choose the
      approach that best fits your design problems. Functional programming is
      especially useful for concurrency, since it eliminates the need to
      synchronize access to mutable state. However, &#x201C;pure&#x201D; FP can be
      restrictive. Some design problems are easier to solve with mutable
      objects.</para>

      <para id="para_the_name__scala__is_a_contract">The name
      <emphasis>Scala</emphasis> is a contraction of the words
      <emphasis>scalable language</emphasis>. While this suggests that the
      pronunciation should be <emphasis>scale-ah</emphasis>, the creators of
      Scala actually pronounce it <emphasis>scah-lah</emphasis>, like the
      Italian word for &#x201C;stairs.&#x201D; The two &#x201C;a&#x201D;s are pronounced the
      same.<indexterm>
          <primary>scalable language (Scala)</primary>
        </indexterm></para>

      <para id="para_scala_was_started_by_martin_od">Scala was started by
      Martin Odersky in 2001. Martin is a professor in the School of Computer
      and Communication Sciences at the Ecole Polytechnique F&#xE9;d&#xE9;rale de
      Lausanne (EPFL). He spent his graduate years working in the group headed
      by Niklaus Wirth, of Pascal fame. Martin worked on Pizza, an early
      functional language on the JVM. He later worked on GJ, a prototype of
      what later became Generics in Java, with Philip Wadler of Haskell fame.
      Martin was hired by Sun Microsystems to produce the reference
      implementation of <literal>javac</literal>, the Java compiler that ships
      with the Java Developer Kit (JDK) today.<indexterm>
          <primary>Odersky, Martin</primary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>JDK (Java Development Kit)</secondary>
        </indexterm><indexterm>
          <primary>javac compiler</primary>
        </indexterm><indexterm>
          <primary>JDK (Java Development Kit)</primary>
        </indexterm><indexterm>
          <primary>Odersky, Martin</primary>
        </indexterm></para>

      <para id="para_martin_odersky_s_background_an">Martin Odersky&#x2019;s
      background and experience are evident in the language. As you learn
      Scala, you come to understand that it is the product of carefully
      considered design decisions, exploiting the state of the art in type
      theory, OOP, and FP. Martin&#x2019;s experience with the JVM is evident in
      Scala&#x2019;s elegant integration with that platform. The synthesis it creates
      between OOP and FP is an excellent &#x201C;best of both worlds&#x201D;
      solution.</para>
    </sect2>

    <sect2 id="_the_seductions_of_scala">
      <title>The Seductions of Scala</title>

      <para id="para_today_our_industry_is_fortuna">Today, our industry is
      fortunate to have a wide variety of language options. The power,
      flexibility, and elegance of dynamically typed languages have made them
      very popular again. Yet the wealth of Java and .NET libraries and the
      performance of the JVM and CLR meet many practical needs for enterprise
      and Internet projects.<indexterm>
          <primary>Scala</primary>

          <secondary>benefits of</secondary>
        </indexterm></para>

      <para id="para_scala_is_compelling_because_it">Scala is compelling
      because it feels like a dynamically typed scripting language, due to its
      succinct syntax and type inference. Yet Scala gives you all the benefits
      of static typing, a modern object model, functional programming, and an
      advanced type system. These tools let you build scalable, modular
      applications that can reuse legacy Java and .NET APIs and leverage the
      performance of the JVM and CLR.</para>

      <para id="para_scala_is_a_language_for__profe">Scala is a language for
      <emphasis>professional</emphasis> developers. Compared to languages like
      Java and Ruby, Scala is a more difficult language to master because it
      requires competency with OOP, FP, and static typing to use it most
      effectively. It is tempting to prefer the relative simplicity of
      dynamically typed languages. Yet this simplicity can be deceptive. In a
      dynamically typed language, it is often necessary to use metaprogramming
      features to implement advanced designs. While metaprogramming is
      powerful, using it well takes experience and the resulting code tends to
      be hard to understand, maintain, and debug. In Scala, many of the same
      design goals can be achieved in a type-safe manner by exploiting its
      type system and mixin composition through
      <emphasis>traits</emphasis>.<indexterm>
          <primary>metaprogramming</primary>
        </indexterm></para>

      <para id="para_we_feel_that_the_extra_effort_">We feel that the extra
      effort required day to day to use Scala will promote more careful
      reflection about your designs. Over time, this discipline will yield
      more coherent, modular, and maintainable applications. Fortunately, you
      don&#x2019;t need all of the sophistication of Scala all of the time. Much of
      your code will have the simplicity and clarity of code written in your
      favorite dynamically typed language.</para>

      <para id="para_an_alternative_strategy_is_to_">An alternative strategy
      is to combine several, simpler languages, e.g., Java for object-oriented
      code and Erlang for functional, concurrent code. Such a decomposition
      can work, but only if your system decomposes cleanly into such discrete
      parts and your team can manage a heterogeneous environment. Scala is
      attractive for situations in which a single, all-in-one language is
      preferred. That said, Scala code can happily coexist with other
      languages, especially on the JVM or .NET.<indexterm>
          <primary>Scala</primary>

          <secondary>combining with other languages</secondary>
        </indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="InstallingScala">
    <title>Installing Scala</title>

    <para id="para_to_get_up_and_running_as_quick">To get up and running as
    quickly as possible, this section describes how to install the
    command-line tools for Scala, which are all you need to work with the
    examples in the book. For details on using Scala in various editors and
    IDEs, see <xref linkend="IntegrationWithIDEs"/>. The examples used in
    this book were written and compiled using Scala version 2.7.5.final, the
    latest release at the time of this writing, and &#x201C;nightly builds&#x201D; of Scala
    version 2.8.0, which may be finalized by the time you read this.<indexterm>
        <primary>Scala</primary>

        <secondary>installing</secondary>
      </indexterm></para>

    <note id="para_v28_new_features">
      <para>Version 2.8 introduces many new features, which we will highlight
      throughout the book.</para>
    </note>

    <para id="para_we_will_work_with_the_jvm_vers">We will work with the JVM
    version of Scala in this book. First, you must have Java 1.4 or greater
    installed (1.5 or greater is recommended). If you need to install Java, go
    to <ulink url="http://www.java.com/en/download/manual.jsp"/> and
    follow the instructions to install Java on your machine.<indexterm>
        <primary>JVM version of Scala</primary>

        <secondary>installing</secondary>
      </indexterm></para>

    <para id="para_the_official_scala_web_site_is">The official Scala website
    is <ulink url="http://www.scala-lang.org/"/>. To install Scala, go
    to the <ulink url="http://www.scala-lang.org/downloads">downloads
    page</ulink>. Download the installer for your environment and follow the
    instructions on the downloads page.<indexterm>
        <primary>Scala</primary>

        <secondary>official website</secondary>
      </indexterm></para>

    <para id="para_the_easiest_installer_to_use_f">The easiest cross-platform
    installer is the <emphasis>IzPack</emphasis> installer. Download the Scala
    JAR file, either <filename>scala-2.7.5.final-installer.jar</filename> or
    <filename>scala-2.8.0.N-installer.jar</filename>, where
    <replaceable>N</replaceable> is the latest release of the 2.8.0 version.
    Go to the download directory in a terminal <phrase role="keep-together">window</phrase>, and install Scala with the
    <literal>java</literal> command. Assuming you downloaded <filename role="keep-together">scala-2.8.0.final-</filename><filename>in&#x2060;staller.jar</filename>,
    run the following command, which will guide you through the
    process:<indexterm>
        <primary>Mac OS X</primary>

        <secondary>installing Scala</secondary>
      </indexterm><indexterm>
        <primary>cross-platform installer (lzPack)</primary>
      </indexterm></para>

    <screen>java -jar scala-2.8.0.final-installer.jar</screen>

    <tip id="para_tip_on_mac_os_x_the_easiest_">
      <para>On Mac OS X, the easiest route to a working Scala installation is
      via MacPorts. Follow the installation instructions at <ulink url="http://www.macports.org/"/>, then <literal>sudo port install
      scala</literal>. You&#x2019;ll be up and running in a few minutes.</para>
    </tip>

    <para id="para_throughout_this_book_we_will_">Throughout this book, we
    will use the symbol <replaceable>scala-home</replaceable> to refer to the
    &#x201C;root&#x201D; directory of your Scala installation.</para>

    <note id="para_note_on_unix_linux_and_maco">
      <para>On Unix, Linux, and Mac OS X systems, you will need to run this
      <phrase role="keep-together">command</phrase> as the
      <literal>root</literal> user or using the <literal>sudo</literal>
      command if you want to <phrase role="keep-together">install
      Scala</phrase> under a system directory, e.g.,
      <replaceable>scala-home</replaceable> <filename>=
      /usr/local/scala-2.8.0.final</filename>.</para>
    </note>

    <para id="para_as_an_alternative_you_can_dow">As an alternative, you can
    download and expand the compressed TAR file (e.g.,
    <filename>scala-2.8.0.final.tgz</filename>) or ZIP file
    (<filename>scala-2.8.0.final.zip</filename>). On Unix-like systems, expand
    the compressed file into a location of your choosing. Afterward, add the
    <replaceable>scala-home</replaceable><filename>/bin</filename>
    subdirectory in the new directory to your <literal>PATH</literal>. For
    example, if you installed into <filename role="keep-together">/usr/local/scala-2.8.0.final</filename>, then add
    <filename>/usr/local/scala-2.8.0.final/bin</filename> to your
    <literal>PATH</literal>.</para>

    <para id="para_to_test_your_installation_run">To test your installation,
    run the following command on the command line:</para>

    <screen>scala -version</screen>

    <para id="para_we_ll_learn_more_about_the_sc">We&#x2019;ll learn more about the
    <literal>scala</literal> command-line tool later. You should get something
    like the following output:</para>

    <screen>Scala code runner version 2.8.0.final -- Copyright 2002-2009, LAMP/EPFL</screen>

    <para id="para_of_course_the_version_number_">Of course, the version
    number you see will be different if you installed a different release.
    From now on, when we show command output that contains the version number,
    we&#x2019;ll show it as <literal>version 2.8.0.final</literal>.<indexterm>
        <primary>versions, Scala</primary>
      </indexterm></para>

    <para id="para_congratulations_you_have_installed_scala">Congratulations,
    you have installed Scala! If you get an error message along the lines of
    <literal>scala: command not found</literal>, make sure your environment&#x2019;s
    <literal>PATH</literal> is set properly to include the correct
    <filename>bin</filename> directory.<indexterm>
        <primary>classes</primary>

        <secondary>JDK and .NET, use in Scala</secondary>
      </indexterm></para>

    <note id="para_note_scala_versions_2_7_x_and">
      <para>Scala versions 2.7.X and earlier are compatible with JDK 1.4 and
      later. Scala version 2.8 drops 1.4 compatibility. Note that Scala uses
      many JDK classes as its own, for example, the <literal>String</literal>
      class. On .NET, Scala uses the corresponding .NET classes.</para>
    </note>

    <para id="para_you_can_also_find_downloads_fo">You can also find downloads
    for the API documentation and the sources for Scala itself on the same
    downloads page.</para>
  </sect1>

  <sect1 id="ForMoreInformation">
    <title>For More Information</title>

    <para id="para_as_you_explore_scala_you_will">As you explore Scala, you
    will find other useful resources that are available on <ulink url="http://scala-lang.org"/>. You will find links for development
    support tools and libraries, tutorials, the language specification <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>,
    and academic papers that describe features of the language.<indexterm>
        <primary>Scala</primary>

        <secondary>resources for more information</secondary>
      </indexterm></para>

    <para id="para_the_documentation_for_the_scal">The documentation for the
    Scala tools and APIs are especially useful. You can browse the API at
    <ulink url="http://www.scala-lang.org/docu/files/api/index.html"/>.
    This documentation was generated using the <literal>scaladoc</literal>
    tool, analogous to Java&#x2019;s <literal>javadoc</literal> tool. See <xref linkend="CommandLineToolScaladoc"/> for more information.<indexterm>
        <primary>documentation</primary>

        <secondary>Scala tools and APIs</secondary>
      </indexterm><indexterm>
        <primary>scaladoc tool</primary>
      </indexterm></para>

    <para id="para_you_can_also_download_a_compre">You can also download a
    compressed file of the API documentation for local browsing using the
    appropriate link on the <ulink url="http://www.scala-lang.org/downloads">downloads page</ulink>, or you
    can install it with the <literal>sbaz</literal> package tool, as
    follows:<indexterm>
        <primary>sbaz tool</primary>
      </indexterm><indexterm>
        <primary>code examples in this book</primary>
      </indexterm><indexterm>
        <primary>web page for this book</primary>

        <secondary>code examples</secondary>
      </indexterm></para>

    <screen>sbaz install scala-devel-docs</screen>

    <para id="para__sbaz_is_installed_in_the_sam"><literal>sbaz</literal> is
    installed in the same <filename>bin</filename> directory as the
    <literal>scala</literal> and <literal>scalac</literal> command-line tools.
    The installed documentation also includes details on the scala tool chain
    (including <literal>sbaz</literal>) and code examples. For more
    information on the Scala command-line tools and other resources, see <xref linkend="ScalaToolsLibs"/>.<indexterm>
        <primary>command-line tools</primary>

        <secondary>information on</secondary>
      </indexterm><indexterm>
        <primary>scalac compiler</primary>
      </indexterm><indexterm>
        <primary>scala command</primary>
      </indexterm></para>
  </sect1>

  <sect1 id="ATasteOfScala">
    <title>A Taste of Scala</title>

    <para id="para_it_s_time_to_whet_your_appetit">It&#x2019;s time to whet your
    appetite with some real Scala code. In the following examples, we&#x2019;ll
    describe just enough of the details so you understand what&#x2019;s going on. The
    goal is to give you a sense of what programming in Scala is like. We&#x2019;ll
    explore the details of the features in subsequent chapters.<indexterm class="startofrange" id="ch01_Scalaexamples">
        <primary>Scala</primary>

        <secondary>code examples</secondary>
      </indexterm></para>

    <para id="para_for_our_first_example_you_cou">For our first example, you
    could run it one of two ways: interactively, or as a &#x201C;script.&#x201D;<indexterm>
        <primary>scala command</primary>

        <secondary>interactive mode</secondary>
      </indexterm><indexterm>
        <primary>interpreter, starting</primary>
      </indexterm></para>

    <para id="para_let_s_start_with_the_interacti">Let&#x2019;s start with the
    interactive mode. Start the scala interpreter by typing
    <literal>scala</literal> and the return key on your command line. You&#x2019;ll
    see the following output. (Some of the version numbers may vary.)</para>

    <screen>Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt;</screen>

    <para id="para_the_last_line_is_the_prompt_th">The last line is the prompt
    that is waiting for your input. The interactive mode of the
    <literal>scala</literal> command is very convenient for experimentation
    (see <xref linkend="CommandLineToolScala"/> for more details). An
    interactive interpreter like this is called a REPL: <emphasis>Read,
    Evaluate, Print, Loop</emphasis>.<indexterm>
        <primary>interactive mode, scala command</primary>
      </indexterm></para>

    <?dbfo-need height=”2in”
?>

    <para id="para_type_in_the_following_two_line">Type in the following two
    lines of code:</para>

    <screen>val book = "Programming Scala"
println(book)</screen>

    <para id="para_the_actual_input_and_output_sh">The actual input and output
    should look like the following:</para>

    <screen>scala&gt; val book = "Programming Scala"
book: java.lang.String = Programming Scala

scala&gt; println(book)
Programming Scala

scala&gt;</screen>

    <para id="para_the_first_line_used_the_val_">The first line uses the
    <literal>val</literal> keyword to declare a read-only variable named
    <literal>book</literal>. Note that the output returned from the
    interpreter shows you the type and value of <literal>book</literal>. This
    can be very handy for understanding complex declarations. The second line
    prints the value of <literal>book</literal>, which is &#x201C;Programming
    Scala&#x201D;.<indexterm>
        <primary>val keyword</primary>

        <secondary sortas="declaration">in declaration of read-only
        variable</secondary>
      </indexterm></para>

    <tip id="para_note_experimenting_with_the_">
      <para>Experimenting with the <literal>scala</literal> command in the
      interactive mode (REPL) is a great way to learn the details of
      Scala.</para>
    </tip>

    <para id="para_many_of_the_examples_in_this_b">Many of the examples in
    this book can be executed in the interpreter like this. However, it&#x2019;s
    often more convenient to use the second option we mentioned, writing Scala
    scripts in a text editor or IDE and executing them with the same
    <literal>scala</literal> command. We&#x2019;ll do that for most of the remaining
    examples in this chapter.</para>

    <para id="para_in_your_text_editor_of_choice_">In your text editor of
    choice, save the Scala code in the following example to a file named
    <filename>upper1-script.scala</filename> in a directory of your
    choosing:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/upper1-script.scala

class Upper {
  def upper(strings: String*): Seq[String] = {
    strings.map((s:String) =&gt; s.toUpperCase())
  }
}

val up = new Upper
Console.println(up.upper("A", "First", "Scala", "Program"))</programlisting>

    <para id="para_this_scala_script_converts_str">This Scala script converts
    strings to uppercase.</para>

    <para id="para_by_the_way_that_s_a_comment_o">By the way, that&#x2019;s a comment
    on the first line (with the name of the source file for the code example).
    Scala follows the same comment conventions as Java, C#, C++, etc. A
    <literal>// <replaceable>comment</replaceable></literal> goes to the end
    of a line, while a <literal>/* <replaceable>comment</replaceable>
    */</literal> can cross line boundaries.<indexterm>
        <primary>/ (slash)</primary>

        <secondary>/* */ in multi-line comments</secondary>
      </indexterm><indexterm>
        <primary>/ (slash)</primary>

        <secondary>// in single-line comments</secondary>
      </indexterm><indexterm>
        <primary>comments</primary>
      </indexterm></para>

    <?dbfo-need height=”2in”
?>

    <para id="para_to_run_this_script_go_to_a_co">To run this script, go to a
    command window, change to the same directory, and run the following
    command:</para>

    <screen>scala upper1-script.scala</screen>

    <para id="para_the_file_is_interpreted_meani">The file is interpreted,
    meaning it is compiled and executed in one step. You should get the
    following output:</para>

    <programlisting linenumbering="unnumbered">Array(A, FIRST, SCALA, PROGRAM)</programlisting>

    <sidebar>
      <title>Interpreting Versus Compiling and Running Scala Code</title>

      <para id="para_to_summarize_if_you_type_sca">To summarize, if you type
      <literal>scala</literal> on the command line without a file argument,
      the interpreter runs in interactive mode. You type in definitions and
      statements that are evaluated on the fly. If you give the command a
      scala source file argument, it compiles and runs the file as a script,
      as in our <literal>scala upper1-script.scala</literal> example. Finally,
      you can compile Scala files separately and execute the
      <literal>class</literal> file, as long as it has a
      <literal>main</literal> method, just as you would normally do with the
      <literal>java</literal> command. (We&#x2019;ll show an example
      shortly.)<indexterm>
          <primary>scala command</primary>
        </indexterm><indexterm>
          <primary>compiling versus interpreting</primary>
        </indexterm><indexterm>
          <primary>interpreting versus compiling</primary>
        </indexterm></para>

      <para id="para_there_are_some_subtleties_you_">There are some subtleties
      you&#x2019;ll need to understand about the limitations of using the interpreter
      modes versus separate compilation and execution steps. We discuss these
      subtleties in <xref linkend="CommandLineTools"/>.</para>

      <para id="para_whenever_we_refer_to__executin">Whenever we refer to
      <emphasis>executing a script</emphasis>, we mean running a Scala source
      file with the <literal>scala</literal> command.<indexterm>
          <primary>executing a script</primary>
        </indexterm></para>
    </sidebar>

    <para id="para_in_this_example_the_upper_m">In the current example, the
    <literal>upper</literal> method in the <literal>Upper</literal> class (no
    pun intended) converts the input strings to uppercase and returns them in
    an array. The last line in the example converts four strings and prints
    the resulting <literal>Array</literal>.</para>

    <para id="para_let_s_examine_the_code_in_deta">Let&#x2019;s examine the code in
    detail, so we can begin to learn Scala syntax. There are a lot of details
    in just six lines of code! We&#x2019;ll explain the general ideas here. All the
    ideas used in this example will be explained more thoroughly in later
    sections of the book.<indexterm>
        <primary>classes</primary>

        <secondary>Upper class (example)</secondary>
      </indexterm></para>

    <para id="para_in_the_example_the_upper_cl">In the example, the
    <literal>Upper</literal> class begins with the <literal>class</literal>
    keyword. The class body is inside the outermost curly braces
    (<literal>{...}</literal>).<indexterm>
        <primary>class keyword</primary>
      </indexterm><indexterm>
        <primary>{ } (curly braces)</primary>

        <secondary>enclosing class body</secondary>
      </indexterm></para>

    <para id="para_the_upper_method_definition_">The <literal>upper</literal>
    method definition begins on the second line with the
    <literal>def</literal> keyword, followed by the method name and an
    argument list, the return type of the method, an equals sign
    (<literal>=</literal>), and then the method body.<indexterm>
        <primary>methods</primary>

        <secondary>defining</secondary>
      </indexterm><indexterm>
        <primary>def keyword</primary>
      </indexterm></para>

    <para id="para_the_argument_list_in_parenthes">The argument list in
    parentheses is actually a <emphasis>variable-length argument
    list</emphasis> of <literal>String</literal>s, indicated by the
    <literal>String*</literal> type following the colon. That is, you can pass
    in as many comma-separated strings as you want (including an empty list).
    These strings are stored in a parameter named <literal>strings</literal>.
    Inside the method, <literal>strings</literal> is actually an
    <literal>Array</literal>.<indexterm>
        <primary>: (colon)</primary>

        <secondary>separator between identifiers and type
        annotations</secondary>
      </indexterm><indexterm>
        <primary>type annotations</primary>
      </indexterm><indexterm>
        <primary>variable-length argument lists</primary>
      </indexterm></para>

    <note id="para_note_when_explicit_type_infor">
      <para>When explicit type information for variables is written in the
      code, these <emphasis>type annotations</emphasis> follow the colon after
      the item name (i.e., Pascal-like syntax). Why doesn&#x2019;t Scala follow Java
      conventions? Recall that type information is often
      <emphasis>inferred</emphasis> in Scala (unlike Java), meaning we don&#x2019;t
      always show type annotations explicitly. Compared to Java&#x2019;s <literal role="keep-together">type item</literal> convention, the <literal>item:
      type</literal> convention is easier for the compiler to analyze
      unambiguously when you omit the colon and the type annotation and just
      write <literal>item</literal>.</para>
    </note>

    <para id="para_the_method_return_type_appears">The method return type
    appears after the argument list. In this case, the return type is
    <literal>Seq[String]</literal>, where <literal>Seq</literal> (&#x201C;sequence&#x201D;)
    is a particular kind of collection. It is a <emphasis>parameterized
    type</emphasis> (like a <emphasis>generic</emphasis> type in Java),
    parameterized here with <literal>String</literal>. Note that Scala uses
    square brackets (<literal>[...]</literal>) for parameterized types,
    whereas Java uses angle brackets
    (<literal>&lt;...&gt;</literal>).<indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary sortas="method names">in method names</secondary>
      </indexterm><indexterm>
        <primary>[ ] (square brackets)</primary>

        <secondary>use with parameterized types</secondary>
      </indexterm><indexterm>
        <primary>parameterized types</primary>
      </indexterm></para>

    <note id="para_note_scala_allows_angle_brack">
      <para>Scala allows angle brackets to be used in method names, e.g.,
      naming a &#x201C;less than&#x201D; method <literal>&lt;</literal> is common. So, to
      avoid ambiguities, Scala uses square brackets instead for parameterized
      types. They can&#x2019;t be used in method names. Allowing
      <literal>&lt;</literal> and <literal>&gt;</literal> in method names is
      why Scala doesn&#x2019;t follow Java&#x2019;s convention for angle brackets.</para>
    </note>

    <para id="para_the_body_of_the_upper_method">The body of the
    <literal>upper</literal> method comes after the equals sign
    (<literal>=</literal>). Why an equals sign? Why not just curly braces
    (<literal>{...}</literal>), like in Java? Because semicolons, function
    return types, method arguments lists, and even the curly braces are
    sometimes omitted, using an equals sign prevents several possible parsing
    ambiguities. Using an equals sign also reminds us that even functions are
    values in Scala, which is consistent with Scala&#x2019;s support of
    <emphasis>functional programming</emphasis>, described in more detail in
    <xref linkend="FunctionalProgramming"/>.<indexterm>
        <primary>= (equals sign)</primary>

        <secondary sortas="method definitions">in method
        definitions</secondary>
      </indexterm></para>

    <para id="para_the_method_body_calls_the_map">The method body calls the
    <literal>map</literal> method on the <literal>strings</literal> array,
    which takes a <emphasis>function literal</emphasis> as an argument.
    Function literals are &#x201C;anonymous&#x201D; functions. They are similar to
    <emphasis>lambdas</emphasis>, <emphasis>closures</emphasis>,
    <emphasis>blocks</emphasis>, or <emphasis>procs</emphasis> in other
    languages. In Java, you would have to use an anonymous inner class here
    that implements a method defined by an interface, etc.<indexterm>
        <primary>function literals</primary>

        <secondary>defined</secondary>
      </indexterm></para>

    <para id="para_in_this_case_the_function_lit">In this case, we passed in
    the following function literal:</para>

    <programlisting linenumbering="unnumbered">(s:String) =&gt; s.toUpperCase()</programlisting>

    <para id="para_takes_a_single_string_argume">It takes an argument list
    with a single <literal>String</literal> argument named
    <literal>s</literal>. The body of the function literal is after the
    &#x201C;arrow,&#x201D; <literal>=&gt;</literal>. It calls
    <literal>toUpperCase()</literal> on <literal>s</literal>. The result of
    this call is returned by the function literal. In Scala, the last
    <emphasis>expression</emphasis> in a function is the return value,
    although you can have <literal>return</literal> statements elsewhere, too.
    The <literal>return</literal> keyword is optional here and is rarely used,
    except when returning out of the middle of a block (e.g., in an
    <literal>if</literal> statement).<indexterm>
        <primary>return keyword</primary>
      </indexterm></para>

    <note id="para_note_the_value_of_the_last_ex">
      <para>The value of the last expression is the default return value of a
      function. No <literal>return</literal> is required.</para>
    </note>

    <para id="para_so_map_passes_each_string_">So, <literal>map</literal>
    passes each <literal>String</literal> in <literal>strings</literal> to the
    function literal and builds up a new collection with the results returned
    by the function literal.</para>

    <para id="para_to_exercise_the_code_we_creat">To exercise the code, we
    create a new <literal>Upper</literal> instance and assign it to a variable
    named <literal>up</literal>. As in Java, C#, and similar languages, the
    syntax <literal>new Upper</literal> creates a new instance. The
    <literal>up</literal> variable is declared as a read-only &#x201C;value&#x201D; using
    the <literal>val</literal> keyword.<indexterm>
        <primary>println function</primary>
      </indexterm><indexterm>
        <primary>new operator</primary>
      </indexterm><indexterm>
        <primary>val keyword</primary>
      </indexterm></para>

    <para id="para_finally_we_call_the_upper_m">Finally, we call the
    <literal>upper</literal> method on a list of strings, and print out the
    result with <literal>Console.println(...)</literal>, which is equivalent
    to Java&#x2019;s <literal>System.out.println(...)</literal>.<indexterm>
        <primary>Console.println( ) method</primary>
      </indexterm></para>

    <para id="para_we_can_actually_simplify_this_">We can actually simplify
    our script even further. Consider this simplified version of the
    script:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/upper2-script.scala

object Upper {
  def upper(strings: String*) = strings.map(_.toUpperCase())
}

println(Upper.upper("A", "First", "Scala", "Program"))</programlisting>

    <para id="para_this_code_does_exactly_the_sam">This code does exactly the
    same thing, but with a third fewer characters.<indexterm>
        <primary>singleton objects</primary>
      </indexterm><indexterm>
        <primary>objects</primary>

        <secondary sortas="Scala">in Scala</secondary>

        <tertiary>versus class-level members</tertiary>
      </indexterm></para>

    <para id="para_on_the_first_line_upper_is_">On the first line,
    <literal>Upper</literal> is now declared as an <literal>object</literal>,
    which is a <emphasis>singleton</emphasis>. We are declaring a class, but
    the Scala runtime will only ever create one instance of
    <literal>Upper</literal>. (You can&#x2019;t write <literal>new Upper</literal>,
    for example.) Scala uses <literal>objects</literal> for situations where
    other languages would use &#x201C;class-level&#x201D; members, like
    <literal>static</literal>s in Java. We don&#x2019;t really need more than one
    <emphasis>instance</emphasis> here, so a singleton is fine.</para>

    <note id="para_note_why_doesn_t_scala_suppor">
      <para>Why doesn&#x2019;t Scala support <literal>static</literal>s? Since
      <emphasis>everything</emphasis> is an object in Scala, the
      <literal>object</literal> construct keeps this policy consistent. Java&#x2019;s
      <literal>static</literal> methods and fields are not tied to an actual
      instance.</para>
    </note>

    <para id="para_note_that_this_code_is_fully_t">Note that this code is
    fully thread-safe. We don&#x2019;t declare any variables that might cause
    thread-safety issues. The API methods we use are also thread-safe.
    Therefore, we don&#x2019;t need multiple instances. A singleton
    <literal>object</literal> works fine.</para>

    <para id="para_the_implementation_of_upper_">The implementation of
    <literal>upper</literal> on the second line is also simpler. Scala can
    usually infer the return type of the method (but not the types of the
    method arguments), so we drop the explicit declaration. Also, because
    there is only one expression in the method body, we drop the braces and
    put the entire method definition on one line. The equals sign before the
    method body tells the compiler, as well as the human reader, where the
    method body begins.</para>

    <para id="para_we_have_also_exploited_a_short">We have also exploited a
    shorthand for the function literal. Previously we wrote it as
    follows:</para>

    <programlisting linenumbering="unnumbered">(s:String) =&gt; s.toUpperCase()</programlisting>

    <para id="para_we_can_shorten_it_to_the_follo">We can shorten it to the
    following expression:</para>

    <programlisting linenumbering="unnumbered">_.toUpperCase()</programlisting>

    <para id="para_because_map_takes_one_argume">Because
    <literal>map</literal> takes one argument, a function, we can use the
    &#x201C;placeholder&#x201D; indicator <literal>_</literal> instead of a named parameter.
    That is, the <literal>_</literal> acts like an anonymous variable, to
    which each string will be assigned before <literal>toUpperCase</literal>
    is called. Note that the <literal>String</literal> type is inferred for
    us, too. As we will see, Scala uses <literal>_</literal> as a &#x201C;wildcard&#x201D;
    in several contexts.<indexterm>
        <primary>_ (underscore)</primary>

        <secondary>placeholder in imports, function literals, etc.</secondary>
      </indexterm></para>

    <para id="para_you_can_also_use_this_short_ha">You can also use this
    shorthand syntax in some more complex function literals, as we will see in
    <xref linkend="RoundingOutTheEssentials"/>.</para>

    <para id="para_on_the_last_line_using_an_ob">On the last line, using an
    <literal>object</literal> rather than a <literal>class</literal>
    simplifies the code. Instead of creating an instance with <literal>new
    Upper</literal>, we can just call the <literal>upper</literal> method on
    the <literal>Upper</literal> object directly (note how this looks like the
    syntax you would use when calling static methods in a Java class).</para>

    <para id="para_finally_scala_automatically_i">Finally, Scala automatically
    imports many methods for I/O, like <literal>println</literal>, so we don&#x2019;t
    need to call <literal>Console.println()</literal>. We can just use
    <literal>println</literal> by itself. (See <xref linkend="PredefObject"/>
    for details on the types and methods that are automatically imported or
    defined.)<indexterm>
        <primary>println function</primary>
      </indexterm><indexterm>
        <primary>I/O (input/output)</primary>

        <secondary>automatic importation of methods by Scala</secondary>
      </indexterm></para>

    <para id="para_let_s_do_one_last__refactoring">Let&#x2019;s do one last
    <emphasis>refactoring</emphasis>. Convert the script into a compiled,
    command-line tool:<indexterm>
        <primary>main method</primary>
      </indexterm><indexterm>
        <primary>compiled, command-line tool, converting script to</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/upper3.scala

object Upper {
  def main(args: Array[String]) = {
    args.map(_.toUpperCase()).foreach(printf("%s ",_))
    println("")
  }
}</programlisting>

    <para id="para_now_the_upper_method_has_bee">Now the
    <literal>upper</literal> method has been renamed <literal>main</literal>.
    Because <literal>Upper</literal> is an <literal>object</literal>, this
    <literal>main</literal> method works exactly like a <literal>static
    main</literal> method in a Java class. It is the entry point to the
    <literal>Upper</literal> <emphasis>application</emphasis>.</para>

    <note id="para_note_in_scala_main_must_be">
      <para>In Scala, <literal>main</literal> must be a method in an
      <literal>object</literal>. (In Java, <literal>main</literal> must be a
      <literal>static</literal> method in a <literal>class</literal>.) The
      command-line arguments for the application are passed to
      <literal>main</literal> in an array of strings, e.g., <literal>args:
      Array[String]</literal>.</para>
    </note>

    <para id="para_the_first_line_inside_the_mai">The first line inside the
    <literal>main</literal> method uses the same shorthand notation for
    <literal>map</literal> that we just examined:</para>

    <programlisting linenumbering="unnumbered">args.map(_.toUpperCase())...</programlisting>

    <para id="para_the_call_to_map_returns_a_ne">The call to
    <literal>map</literal> returns a new collection. We iterate through it
    with <literal>foreach</literal>. We use a <literal>_</literal> placeholder
    shortcut again in another <emphasis>function literal</emphasis> that we
    pass to <literal>foreach</literal>. In this case, each string in the
    collection is passed as an argument to
    <literal>printf</literal>:<indexterm>
        <primary>function literals</primary>

        <secondary>passing to foreach</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">...foreach(printf("%s ",_))</programlisting>

    <para id="para_to_be_clear_these_two_uses_of">To be clear, these two uses
    of <literal>_</literal> are completely independent of each other. Method
    chaining and function-literal shorthands, as in this example, can take
    some getting used to, but once you are comfortable with them, they yield
    very readable code with minimal use of temporary variables.<indexterm>
        <primary>_ (underscore)</primary>

        <secondary>method chaining and function-literal shorthands</secondary>
      </indexterm></para>

    <para id="para_the_last_line_in_main_adds_a">The last line in
    <literal>main</literal> adds a final line feed to the output.</para>

    <para id="para_this_time_you_must_first_comp">This time, you must first
    compile the code to a JVM <filename>.class</filename> file using
    <literal>scalac</literal>:<indexterm>
        <primary>scalac compiler</primary>

        <secondary>compiling code into JVM .class file</secondary>
      </indexterm></para>

    <screen>scalac upper3.scala</screen>

    <para id="para_you_should_now_have_a_file_nam">You should now have a file
    named <filename>Upper.class</filename>, just as if you had just compiled a
    Java class.</para>

    <note id="para_note_you_may_have_noticed_tha">
      <para>You may have noticed that the compiler did not complain when the
      <phrase role="keep-together">file was</phrase> named
      <filename>upper3.scala</filename> and the <literal>object</literal> was
      named <literal>Upper</literal>. Unlike <phrase role="keep-together">Java, the</phrase> file name doesn&#x2019;t have to match
      the name of the type with <literal>public</literal> scope. (We&#x2019;ll
      explore the visibility rules in <xref linkend="VisibilityRules"/>.) In
      fact, unlike Java, you can have as many public types in a single file as
      you want. Furthermore, the directory location of a file doesn&#x2019;t have to
      match the package declaration. However, you can certainly follow the
      Java conventions, if you want to.</para>
    </note>

    <para id="para_now_you_can_execute_this_comm">Now, you can execute this
    command for any list of strings. Here is an example:<indexterm>
        <primary>scala command</primary>

        <secondary>-cp option</secondary>
      </indexterm></para>

    <screen>scala -cp . Upper Hello World!</screen>

    <para id="para_the_cp_option_adds_he_cur">The <literal>-cp .</literal>
    option adds the current directory to the search &#x201C;class path.&#x201D; You should
    get the following output:</para>

    <screen> HELLO WORLD!</screen>

    <para id="para_therefore_we_have_met_the_req">Therefore, we have met the
    requirement that a programming language book must start with a &#x201C;hello
    world&#x201D; program.<indexterm class="endofrange" startref="ch01_Scalaexamples"/></para>
  </sect1>

  <sect1 id="ATasteOfConcurrency">
    <title>A Taste of Concurrency</title>

    <para id="para_there_are_many_reasons_to_be_s">There are many reasons to
    be seduced by Scala. One reason is the Actors API included in the Scala
    library, which is based on the robust Actors concurrency model built into
    Erlang (see <link linkend="Haller2007" xrefstyle="select:nopage">[Haller2007]</link>). Here is an example to whet
    your appetite.<indexterm class="startofrange" id="ch01_concurrency">
        <primary>concurrency</primary>
      </indexterm></para>

    <para id="para_in_the_actor_model_of_concurre">In the Actor model of
    concurrency (<link linkend="Agha1987" xrefstyle="select:nopage">[Agha1987]</link>), independent software
    entities called <emphasis>Actors</emphasis> share no state information
    with each other. Instead, they communicate by <phrase role="keep-together">exchanging</phrase> messages. By eliminating the need
    to synchronize access to shared, mutable state, it is far easier to write
    robust, concurrent applications.<indexterm class="startofrange" id="ch01_actors">
        <primary>Actors</primary>

        <secondary>example</secondary>
      </indexterm></para>

    <para id="para_in_this_example_instances_in_a_">In this example, instances
    in a geometric <literal>Shape</literal> hierarchy are sent to an Actor for
    drawing on a display. Imagine a scenario where a rendering &#x201C;farm&#x201D;
    generates scenes in an animation. As the rendering of a scene is
    completed, the shape &#x201C;primitives&#x201D; that are part of the scene are sent to
    an Actor for a display subsystem.</para>

    <para id="para_to_begin_we_define_a_shape_">To begin, we define a
    <literal>Shape</literal> class hierarchy:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/shapes.scala

package shapes {
  class Point(val x: Double, val y: Double) {
    override def toString() = "Point(" + x + "," + y + ")"
  }

  abstract class Shape() {
    def draw(): Unit
  }

  class Circle(val center: Point, val radius: Double) extends Shape {
    def draw() = println("Circle.draw: " + this)
    override def toString() = "Circle(" + center + "," + radius + ")"
  }

  class Rectangle(val lowerLeft: Point, val height: Double, val width: Double)
        extends Shape {
    def draw() = println("Rectangle.draw: " + this)
    override def toString() =
      "Rectangle(" + lowerLeft + "," + height + "," + width + ")"
  }

  class Triangle(val point1: Point, val point2: Point, val point3: Point)
        extends Shape {
    def draw() = println("Triangle.draw: " + this)
    override def toString() =
      "Triangle(" + point1 + "," + point2 + "," + point3 + ")"
  }
}</programlisting>

    <para id="para_the_shape_class_hierarchy_is">The <literal>Shape</literal>
    class hierarchy is defined in a <literal>shapes</literal> package. You can
    declare the package using Java syntax, but Scala also supports a syntax
    similar to C#&#x2019;s &#x201C;namespace&#x201D; syntax, where the entire declaration is scoped
    using curly braces, as used here. The Java-style package declaration
    syntax is far more commonly used, however, being both compact and
    readable.</para>

    <para id="para_the_point_class_represents_a">The <literal>Point</literal>
    class represents a two-dimensional point on a plane. Note the argument
    list after the class name. Those are constructor parameters. In Scala, the
    <emphasis>whole</emphasis> class body is the constructor, so you list the
    arguments for the <emphasis>primary</emphasis> constructor after the class
    name and before the class body. (We&#x2019;ll see how to define auxiliary
    constructors in <xref linkend="Constructors"/>.) Because we put the
    <literal>val</literal> keyword before each parameter declaration, they are
    automatically converted to read-only fields with the same names with
    public reader methods of the same name. That is, when you instantiate a
    <literal>Point</literal> instance, e.g., <literal>point</literal>, you can
    read the fields using <literal>point.x</literal> and
    <literal>point.y</literal>. If you want <emphasis>mutable</emphasis>
    fields, then use the keyword <literal>var</literal>. We&#x2019;ll explore
    variable declarations and the <literal>val</literal> and
    <literal>var</literal> keywords in <xref linkend="VariableDeclarationsAndDefinitions"/>.<indexterm>
        <primary>fields</primary>

        <secondary>mutable</secondary>
      </indexterm><indexterm>
        <primary>mutable fields</primary>
      </indexterm><indexterm>
        <primary>var keyword</primary>
      </indexterm><indexterm>
        <primary>constructors</primary>
      </indexterm></para>

    <para id="para_the_body_of_point_defines_on">The body of
    <literal>Point</literal> defines one method, an
    <emphasis>override</emphasis> of the familiar <literal>toString</literal>
    method in Java (like <literal>ToString</literal> in C#). Note that Scala,
    like C#, requires the <literal>override</literal> keyword whenever you
    override a concrete method. Unlike C#, you don&#x2019;t have to use a <literal role="keep-together">virtual</literal> keyword on the original concrete
    method. In fact, there is no <literal>virtual</literal> keyword in Scala.
    As before, we omit the curly braces (<literal>{...}</literal>) around the
    body of <literal>toString</literal>, since it has only one
    expression.<indexterm>
        <primary>C#</primary>

        <secondary>override keyword for concrete methods</secondary>
      </indexterm><indexterm>
        <primary>override keyword</primary>
      </indexterm><indexterm>
        <primary>classes</primary>

        <secondary>abstract</secondary>
      </indexterm><indexterm>
        <primary>abstract classes</primary>
      </indexterm></para>

    <para id="para__shape_is_an_abstract_class_"><literal>Shape</literal> is
    an abstract class. Abstract classes in Scala are similar to those in Java
    and C#. We can&#x2019;t instantiate instances of abstract classes, even when all
    their field and method members are concrete.</para>

    <para id="para_in_this_case_shape_declares_a">In this case, Shape declares
    an <emphasis>abstract</emphasis> <literal>draw</literal> method. We know
    it is abstract because it has no body. No <literal>abstract</literal>
    keyword is required on the method. Abstract methods in Scala are just like
    abstract methods in Java and C#. (See <xref linkend="OverridingMembers"/>
    for more details.)<indexterm>
        <primary>C#</primary>

        <secondary>abstract methods</secondary>
      </indexterm></para>

    <para>The <literal>draw</literal> method returns <literal>Unit</literal>,
    which is a type that is roughly equivalent to <literal>void</literal> in
    C-derived languages like Java, etc. (See <xref linkend="ScalaTypeHierarchy"/> for more details.)</para>

    <para id="para__circle_is_declared_as_a_conc"><literal>Circle</literal> is
    declared as a concrete subclass of <literal>Shape</literal>. It defines
    the <literal>draw</literal> method to simply print a message to the
    console. <literal>Circle</literal> also overrides
    <literal>toString</literal>.</para>

    <para id="para__rectangle_is_also_a_concrete"><literal>Rectangle</literal>
    is also a concrete subclass of <literal>Shape</literal> that defines
    <literal>draw</literal> and overrides <literal>toString</literal>. For
    simplicity, we assume it is not rotated relative to the
    <emphasis>x</emphasis> and <emphasis>y</emphasis> axes. Hence, all we need
    is one point, the lower lefthand point will do, and the height and width
    of the rectangle.</para>

    <para id="para__triangle_follows_the_same_pa"><literal>Triangle</literal>
    follows the same pattern. It takes three <literal>Points</literal> as its
    constructor arguments.<indexterm>
        <primary>this keyword</primary>
      </indexterm></para>

    <para id="para_both_draw_methods_in_circle">Both <literal>draw</literal>
    methods in <literal>Circle</literal>, <literal>Rectangle</literal>, and
    <literal>Triangle</literal> use <literal>this</literal>. As in Java and
    C#, <literal>this</literal> is how an instance refers to itself. In this
    context, where <literal>this</literal> is the righthand side of a String
    concatenation expression (using the plus sign),
    <literal>this.toString</literal> is invoked implicitly.<indexterm>
        <primary>C#</primary>

        <secondary>this keyword</secondary>
      </indexterm></para>

    <note id="para_note_of_course_in_a_real_app">
      <para>Of course, in a real application, you would not implement drawing
      in &#x201C;domain model&#x201D; classes like this, since the implementations would
      depend on details like the operating system platform, graphics API, etc.
      We will see a better design approach when we discuss
      <emphasis>traits</emphasis> in <xref linkend="Traits"/>.</para>
    </note>

    <para id="para_now_that_we_have_defined_our_s">Now that we have defined
    our shapes types, let&#x2019;s return to Actors. We define an Actor that receives
    &#x201C;messages&#x201D; that are shapes to draw:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/shapes-actor.scala

package shapes {
  import scala.actors._
  import scala.actors.Actor._

  object ShapeDrawingActor extends Actor {
    def act() {
      loop {
        receive {
          case s: Shape =&gt; s.draw()
          case "exit"   =&gt; println("exiting..."); exit
          case x: Any   =&gt; println("Error: Unknown message! " + x)
        }
      }
    }
  }
}</programlisting>

    <para id="para_the_actor_is_declared_to_be_pa">The Actor is declared to be
    part of the <literal>shapes</literal> package. Next, we have two import
    <phrase role="keep-together">statements</phrase>.<indexterm>
        <primary>import statements</primary>
      </indexterm></para>

    <para id="para_the_first_import_statement_imp">The first import statement
    imports all the types in the <literal>scala.actors</literal> package. In
    Scala, the underscore <literal>_</literal> is used the way the star
    <literal>*</literal> is used in Java.<indexterm>
        <primary>_ (underscore)</primary>

        <secondary>wildcard character in Scala</secondary>
      </indexterm></para>

    <note id="para_note_because_is_a_valid_cha">
      <para>Because <literal>*</literal> is a valid character for a function
      name, it can&#x2019;t be used as the <literal>import</literal> wildcard.
      Instead, <literal>_</literal> is reserved for this purpose.</para>
    </note>

    <para id="para_all_the_methods_and_public_fie">All the methods and public
    fields from <literal>Actor</literal> are imported by the second
    <literal>import</literal>. These are not <literal>static</literal> imports
    from the <literal>Actor</literal> type, as they would be in Java. Rather,
    they are imported from an <literal>object</literal> that is also named
    <literal>Actor</literal>. The <literal>class</literal> and
    <literal>object</literal> can have the same name, as we will see in <xref linkend="CompanionObjects"/>.<indexterm>
        <primary>Actors</primary>

        <secondary>Actor class and object</secondary>
      </indexterm></para>

    <para id="para_our_actor_class_definition_s">Our Actor class definition,
    <literal>ShapeDrawingActor</literal>, is an <literal>object</literal> that
    extends <literal>Actor</literal> (the type, not the
    <literal>object</literal>). The <literal>act</literal> method is
    overridden to do the unique work of the Actor. Because
    <literal>act</literal> is an abstract method, we don&#x2019;t need to explicitly
    override it with the <literal>override</literal> keyword. Our Actor loops
    indefinitely, waiting for incoming messages.</para>

    <para id="para_during_each_pass_in_the_loop_">During each pass in the
    loop, the <literal>receive</literal> method is called. It blocks until a
    new message arrives. Why is the code after <literal>receive</literal>
    enclosed in curly braces <literal>{...}</literal> and not parentheses
    <literal>(...)</literal>? We will learn later that there are cases where
    this substitution is allowed and is quite useful (see <xref linkend="RoundingOutTheEssentials"/>). For now, what you need to know is
    that the expressions inside the braces constitute a single
    <emphasis>function literal</emphasis> that is passed to
    <literal>receive</literal>. This function literal does a <emphasis>pattern
    match</emphasis> on the message instance to decide how to handle the
    message. Because of the <literal>case</literal> clauses, it looks like a
    typical switch statement in Java, for example, and the behavior is very
    similar.<indexterm>
        <primary>function literals</primary>

        <secondary>passing to method for pattern matching</secondary>
      </indexterm><indexterm>
        <primary>{ } (curly braces)</primary>

        <secondary>substituting for parentheses in method call</secondary>
      </indexterm><indexterm>
        <primary>( ) (parentheses)</primary>

        <secondary>substituting curly braces for in method call</secondary>
      </indexterm><indexterm>
        <primary>pattern matching</primary>
      </indexterm></para>

    <para id="para_the_first_case_does_a_type_c">The first
    <literal>case</literal> does a type comparison with the message. (There is
    no explicit variable for the message instance in the code; it is
    inferred.) If the message is of type <literal>Shape</literal>, the first
    <literal>case</literal> matches. The message instance is cast to a
    <literal>Shape</literal> and assigned to the variable
    <literal>s</literal>, and then the <literal>draw</literal> method is
    called on it.</para>

    <para id="para_if_the_message_is_not_a_shape">If the message is not a
    <literal>Shape</literal>, the second <literal>case</literal> is tried. If
    the message is the string <literal>"exit"</literal>, the Actor prints a
    message and terminates execution. Actors should usually have a way to exit
    gracefully!</para>

    <para id="para_the_last_case_handles_any_ot">The last
    <literal>case</literal> clause handles any other message instance, thereby
    functioning as the <emphasis>default</emphasis> case. The Actor reports an
    error and then drops the message. <literal>Any</literal> is the parent of
    all types in the Scala type hierarchy, like <literal>Object</literal> is
    the root type in Java and other languages. Hence, this case clause will
    match any message of any type. Pattern matching is eager; we have to put
    this case clause at the end, so it doesn&#x2019;t consume the messages we are
    expecting!</para>

    <para id="para_recall_that_we_declared_draw_">Recall that we declared
    <literal>draw</literal> as an abstract method in <literal>Shape</literal>
    and we implemented <literal>draw</literal> in the concrete subclasses.
    Hence, the code in the first <literal>case</literal> statement invokes a
    polymorphic operation.</para>

    <sidebar>
      <title>Pattern Matching Versus Polymorphism</title>

      <para id="para__pattern_matching__plays_a_cen"><emphasis>Pattern
      matching</emphasis> plays a central role in functional programming just
      as polymorphism plays a central role in object-oriented programming.
      Functional pattern matching is much more important and sophisticated
      than the corresponding <literal>switch/case</literal> statements found
      in most <emphasis>imperative</emphasis> languages, like Java. We will
      examine Scala&#x2019;s support for pattern matching in more detail in <xref linkend="FunctionalProgramming"/>. In our example here, we can begin to
      see that joining functional-style pattern matching with object-oriented
      polymorphic dispatching is a powerful combination that is a benefit of
      mixed paradigm languages like Scala.<indexterm>
          <primary>imperative languages</primary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary>polymorphism versus</secondary>
        </indexterm><indexterm>
          <primary>polymorphism</primary>

          <secondary>pattern matching versus</secondary>
        </indexterm></para>
    </sidebar>

    <para id="para_finally_here_is_a_script_that">Finally, here is a script
    that uses the <literal>ShapeDrawingActor</literal> Actor:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/shapes-actor-script.scala

import shapes._

ShapeDrawingActor.start()

ShapeDrawingActor ! new Circle(new Point(0.0,0.0), 1.0)
ShapeDrawingActor ! new Rectangle(new Point(0.0,0.0), 2, 5)
ShapeDrawingActor ! new Triangle(new Point(0.0,0.0),
                                 new Point(1.0,0.0),
                                 new Point(0.0,1.0))
ShapeDrawingActor ! 3.14159

ShapeDrawingActor ! "exit"</programlisting>

    <?dbfo-need height=”1in”
?>

    <para id="para_the_shapes_in_the_shapes_pac">The shapes in the
    <literal>shapes</literal> package are imported.</para>

    <para id="para_the_shapedrawingactor_actor_">The
    <literal>ShapeDrawingActor</literal> Actor is started. By default, it runs
    in its own thread (there are alternatives we will discuss in <xref linkend="Concurrency"/>), waiting for messages.</para>

    <para id="para_five_messages_are_sent_to_the_">Five messages are sent to
    the Actor, using the syntax <literal>actor ! message</literal>. The first
    message sends a <literal>Circle</literal> instance. The Actor &#x201C;draws&#x201D; the
    circle. The second message sends a <literal>Rectangle</literal> message.
    The Actor &#x201C;draws&#x201D; the rectangle. The third message does the same thing for
    a <literal>Triangle</literal>. The fourth message sends a
    <literal>Double</literal> that is approximately equal to
    <emphasis>Pi</emphasis>. This is an unknown message for the Actor, so it
    just prints an error message. The final message sends an &#x201C;exit&#x201D; string,
    which causes the Actor to terminate.<indexterm>
        <primary>! (exclamation point)</primary>

        <secondary>! method, sending messages to Actors</secondary>
      </indexterm></para>

    <para id="para_to_try_out_the_actor_example_">To try out the Actor
    example, start by compiling the first two files. You can get <phrase role="keep-together">the sources</phrase> from the <ulink url="http://examples.oreilly.com/9780596155964/">O&#x2019;Reilly download
    site</ulink> (see <xref linkend="GettingCodeExamples"/> for details), or
    you can create them yourself.</para>

    <para id="para_use_the_following_command_to_c">Use the following command
    to compile the files:</para>

    <screen> scalac shapes.scala shapes-actor.scala</screen>

    <para id="para_while_the_source_file_names_an">While the source file names
    and locations don&#x2019;t have to match the file contents, you will notice that
    the generated class files are written to a <filename>shapes</filename>
    directory and there is one class file for each class we defined. The class
    file names and locations must conform to the JVM requirements.</para>

    <para id="para_now_you_can_run_the_script_to_">Now you can run the script
    to see the Actor in action:</para>

    <screen> scala -cp . shapes-actor-script.scala</screen>

    <para id="para_you_should_see_the_following_o">You should see the
    following output:</para>

    <screen>Circle.draw: Circle(Point(0.0,0.0),1.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,5.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))
Error: Unknown message! 3.14159
exiting...</screen>

    <para id="para_for_more_on_actors_see_co">For more on Actors, see <xref linkend="Concurrency"/>.<indexterm class="endofrange" startref="ch01_actors"/><indexterm class="endofrange" startref="ch01_concurrency"/></para>
  </sect1>

  <sect1 id="_recap_and_what_8217_s_next">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_made_the_case_for_scala_and">We made the case for Scala
    and got you started with two sample Scala programs, one of which gave you
    a taste of Scala&#x2019;s Actors library for concurrency. Next, we&#x2019;ll dive into
    more Scala syntax, emphasizing various keystroke-economical ways of
    getting lots of work done.</para>
  </sect1>
</chapter>
  <chapter id="TypeLessDoMore">
  <title>Type Less, Do More</title>

  <sect1 id="_in_this_chapter">
    <title>In This Chapter</title>

    <para id="para_we_ended_the_last_chapter_with">We ended the previous
    chapter with a few &#x201C;teaser&#x201D; examples of Scala code. This chapter discusses
    uses of Scala that promote succinct, flexible code. We&#x2019;ll discuss
    organization of files and packages, importing other types, variable
    declarations, miscellaneous syntax conventions, and a few other concepts.
    We&#x2019;ll emphasize how the concise syntax of Scala helps you work better and
    faster.</para>

    <para id="para_scala_s_syntax_is_especially_u">Scala&#x2019;s syntax is
    especially useful when writing scripts. Separate compile and run steps
    aren&#x2019;t required for simple programs that have few dependencies on
    libraries outside of what Scala provides. You compile and run such
    programs in one shot with the <literal>scala</literal> command. If you&#x2019;ve
    <ulink role="orm:hideurl" url="http://examples.oreilly.com/9780596155964/">downloaded the example
    code</ulink> for this book, many of the smaller examples can be run using
    the <literal>scala</literal> command, e.g., <literal>scala
    </literal><replaceable>filename</replaceable><literal>.scala</literal>.
    See the <filename>README.txt</filename> files in each chapter&#x2019;s code
    examples for more details. See also <xref linkend="CommandLineTools"/>
    for more information about using the <literal>scala</literal>
    command.</para>
  </sect1>

  <sect1 id="Semicolons">
    <title>Semicolons</title>

    <para id="para_you_may_have_already_noticed_t">You may have already
    noticed that there were very few semicolons in the code examples in the
    previous chapter. You can use semicolons to separate statements and
    expressions, as in Java, C, PHP, and similar languages. In most cases,
    though, Scala behaves like many scripting languages in treating the end of
    the line as the end of a statement or an expression. When a statement or
    expression is too long for one line, Scala can usually infer when you are
    continuing on to the next line, as shown in this example:<indexterm>
        <primary>; (semicolon)</primary>

        <secondary>ending statements in Scala code</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/semicolon-example-script.scala

// Trailing equals sign indicates more code on next line
def equalsign = {
  val reallySuperLongValueNameThatGoesOnForeverSoYouNeedANewLine =
    "wow that was a long value name"

  println(reallySuperLongValueNameThatGoesOnForeverSoYouNeedANewLine)
}

// Trailing opening curly brace indicates more code on next line
def equalsign2(s: String) = {
  println("equalsign2: " + s)
}

// Trailing comma, operator, etc. indicates more code on next line
def commas(s1: String,
           s2: String) = {
  println("comma: " + s1 +
          ", " + s2)
}</programlisting>

    <para id="para_when_you_want_to_put_multiple_">When you want to put
    multiple statements or expressions on the same line, you can use
    semicolons to separate them. We used this technique in the
    <literal>ShapeDrawingActor</literal> example in <xref linkend="ATasteOfConcurrency"/>:</para>

    <programlisting linenumbering="unnumbered">case "exit" =&gt; println("exiting..."); exit</programlisting>

    <para id="para_this_line_could_also_be_writte">This code could also be
    written as follows:</para>

    <programlisting linenumbering="unnumbered">...
case "exit" =&gt;
      println("exiting...")
      exit
...</programlisting>

    <para id="para_why_no_curly_braces">You might wonder why you don&#x2019;t need
    curly braces (<literal>{...}</literal>) around the two statements after
    the <literal>case ... =&gt;</literal> line. You can put them in if you
    want, but the compiler knows when you&#x2019;ve reached the end of the &#x201C;block&#x201D;
    when it finds the next <literal>case</literal> clause or the curly brace
    (<literal>}</literal>) that ends the enclosing block for all the
    <literal>case</literal> clauses.<indexterm>
        <primary>{ } (curly braces)</primary>

        <secondary>{ indicating more code on next line</secondary>
      </indexterm></para>

    <para id="para_omitting_optional_semicolons_m">Omitting optional
    semicolons means fewer characters to type and fewer characters to clutter
    your code. Breaking separate statements onto their own lines increases
    your code&#x2019;s readability.</para>
  </sect1>

  <sect1 id="VariableDeclarationsAndDefinitions">
    <title>Variable Declarations</title>

    <para id="para_scala_allows_you_to_decide_whe">Scala allows you to decide
    whether a variable is immutable (read-only) or not (read-write) when you
    declare it. An immutable &#x201C;variable&#x201D; is declared with the keyword
    <literal>val</literal> (think <emphasis>value
    object</emphasis>):<indexterm>
        <primary>val keyword</primary>

        <secondary>using in declaration of immutable variable</secondary>
      </indexterm><indexterm>
        <primary>immutable variables</primary>

        <secondary>declaring</secondary>
      </indexterm><indexterm>
        <primary>variables</primary>

        <secondary>declarations</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">val array: Array[String] = new Array(5)</programlisting>

    <para id="para_immutable_precise">To be more precise, the
    <literal>array</literal> reference cannot be changed to point to a
    different <literal>Array</literal>, but the array itself can be modified,
    as shown in the following <literal>scala</literal> session:</para>

    <programlisting linenumbering="unnumbered">scala&gt; val array: Array[String] = new Array(5)
array: Array[String] = Array(null, null, null, null, null)

scala&gt; array = new Array(2)
&lt;console&gt;:5: error: reassignment to val<?dbfo-need height="1in"
?>
       array = new Array(2)
             ^

scala&gt; array(0) = "Hello"

scala&gt; array
res3: Array[String] = Array(Hello, null, null, null, null)

scala&gt;</programlisting>

    <para id="para_an_immutable_object_must_be_in">An immutable
    <literal>val</literal> must be initialized&#x2014;that is, defined&#x2014;when it is
    declared.</para>

    <para id="para_a_mutable_variable_is_declared">A mutable variable is
    declared with the keyword <literal>var</literal>:</para>

    <programlisting linenumbering="unnumbered">scala&gt; var stockPrice: Double = 100.
stockPrice: Double = 100.0

scala&gt; stockPrice = 10.
stockPrice: Double = 10.0

scala&gt;</programlisting>

    <para id="para_scala_also_requires_you_to_ini">Scala also requires you to
    initialize a <literal>var</literal> when it is declared. You can assign a
    new value to a <literal>var</literal> as often as you want. Again, to be
    precise, the <literal>stockPrice</literal> reference can be changed to
    point to a different <literal>Double</literal> object (e.g.,
    <literal>10.</literal>). In this case, the object that
    <literal>stockPrice</literal> refers to can&#x2019;t be changed, because
    <literal>Doubles</literal> in Scala are immutable.</para>

    <para id="para_there_s_one_exception_to_the_r">There are a few exceptions
    to the rule that you must initialize <literal>val</literal>s and
    <literal>var</literal>s when they are declared. Both keywords can be used
    with constructor parameters. When used as constructor parameters, the
    mutable or immutable variables specified will be initialized when an
    object is instantiated. Both keywords can be used to declare &#x201C;abstract&#x201D;
    (uninitialized) variables in abstract types. Also, derived types can
    override <literal>val</literal>s declared inside parent types. We&#x2019;ll
    discuss these exceptions in <xref linkend="BasicObjectOrientedProgramming"/>.<indexterm>
        <primary>parameters</primary>

        <secondary>constructor, initialization of vals and vars</secondary>
      </indexterm><indexterm>
        <primary>classes</primary>

        <secondary>derived, overriding vals declared in parent
        classes</secondary>
      </indexterm></para>

    <para id="para_scala_encourages_you_to_use_im">Scala encourages you to use
    immutable values whenever possible. As we will see, this promotes better
    object-oriented design and is consistent with the principles of &#x201C;pure&#x201D;
    functional programming. It may take some getting used to, but you&#x2019;ll find
    a newfound confidence in your code when it is written in an immutable
    style.</para>

    <note id="para_note_the_var_and_val_keyw">
      <para>The <literal>var</literal> and <literal>val</literal> keywords
      only specify whether the reference can be changed to refer to a
      different object (<literal>var</literal>) or not
      (<literal>val</literal>). They don&#x2019;t specify whether or not the object
      they reference is mutable.</para>
    </note>
  </sect1>

  <sect1 id="MethodDeclarationsAndDefinitions">
    <title>Method Declarations</title>

    <para id="para_method_declarations">In <xref linkend="IntroducingScala"/>
    we saw several examples of how to define <emphasis>methods</emphasis>,
    which are functions that are members of a class. Method
    <emphasis>definitions</emphasis> start with the <literal>def</literal>
    keyword, followed by optional argument lists, a colon character
    (<literal>:</literal>) and the return type of the method, an equals sign
    (<literal>=</literal>), and finally the method body. Methods are
    implicitly <emphasis>declared</emphasis> &#x201C;abstract&#x201D; if you leave off the
    equals sign and method body. The enclosing type is then itself abstract.
    We&#x2019;ll discuss abstract types in more detail in <xref linkend="BasicObjectOrientedProgramming"/>.<indexterm>
        <primary>= (equals sign)</primary>

        <secondary sortas="method definitions">in method
        definitions</secondary>
      </indexterm><indexterm>
        <primary>def keyword</primary>
      </indexterm><indexterm>
        <primary>definitions, method</primary>
      </indexterm><indexterm class="startofrange" id="ch02_methodsdeclare">
        <primary>methods</primary>

        <secondary>declarations</secondary>
      </indexterm></para>

    <para id="para_multiple_arg_lists">We said &#x201C;optional argument lists,&#x201D;
    meaning more than one. Scala lets you define more than one argument list
    for a method. This is required for <emphasis>currying</emphasis> methods,
    which we&#x2019;ll discuss in <xref linkend="Currying"/>. It is also very useful
    for defining your own Domain-Specific Languages (DSLs), as we&#x2019;ll see in
    <xref linkend="DomainSpecificLanguages"/>. Note that each argument list
    is surrounded by parentheses and the arguments are separated by
    commas.</para>

    <para id="para_if_a_method_body_has_more_than">If a method body has more
    than one expression, you must surround it with curly braces
    (<literal>{...}</literal>). You can omit the braces if the method body has
    just one expression.<indexterm>
        <primary>{ } (curly braces)</primary>

        <secondary sortas="method declarations">in method
        declarations</secondary>
      </indexterm></para>

    <sect2 id="MethodDefaultAndNamedArguments">
      <title>Method Default and Named Arguments (Scala Version 2.8)</title>

      <para id="para_many_languages_let_you_define_">Many languages let you
      define default values for some or all of the arguments to a method.
      Consider the following script with a <literal>StringUtil</literal>
      object that lets you join a list of strings with a user-specified
      separator:<indexterm>
          <primary>methods</primary>

          <secondary>declarations</secondary>

          <tertiary>default and named arguments</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/string-util-v1-script.scala
// Version 1 of "StringUtil".

object StringUtil {
  def joiner(strings: List[String], separator: String): String =
    strings.mkString(separator)

  def joiner(strings: List[String]): String = joiner(strings, " ")
}
import StringUtil._    // Import the joiner methods.

println( joiner(List("Programming", "Scala")) )</programlisting>

      <para id="para_there_are_actually_two_joiner">There are actually two,
      &#x201C;overloaded&#x201D; <literal>joiner</literal> methods. The second one uses a
      single space as the &#x201C;default&#x201D; separator. Having two methods seems a bit
      wasteful. It would be nice if we could eliminate the second
      <literal>joiner</literal> method and declare that the <literal role="keep-together">separator</literal> argument in the first
      <literal>joiner</literal> has a default value. In fact, in Scala version
      2.8, you can now do this:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/string-util-v2-v28-script.scala
// Version 2 of "StringUtil" for Scala v2.8 only.

object StringUtil {
  def joiner(strings: List[String], separator: String = " "): String =
    strings.mkString(separator)
}
import StringUtil._    // Import the joiner methods.

println(joiner(List("Programming", "Scala")))</programlisting>

      <para id="para_there_are_two_workarounds_for_">There is another
      alternative for earlier versions of Scala. You can use
      <emphasis>implicit</emphasis> arguments, which we will discuss in <xref linkend="ImplicitFunctionParameters"/>.</para>

      <para id="para_scala_version_2_8_offers_anoth">Scala version 2.8 offers
      another enhancement for method argument lists, <emphasis>named
      arguments</emphasis>. We could actually write the last line of the
      previous example in several ways. All of the following
      <literal>println</literal> statements are functionally
      equivalent:<indexterm>
          <primary>named arguments</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">println(joiner(List("Programming", "Scala")))
println(joiner(strings = List("Programming", "Scala")))
println(joiner(List("Programming", "Scala"), " "))   // #1
println(joiner(List("Programming", "Scala"), separator = " ")) // #2
println(joiner(strings = List("Programming", "Scala"), separator = " "))</programlisting>

      <para id="para_why_is_this_useful_first_if_">Why is this useful? First,
      if you choose good names for the method arguments, then your calls to
      those methods document each argument with a name. For example, compare
      the two lines with comments #1 and #2. In the first line, it may not be
      obvious what the second <literal>" "</literal> argument is for. In the
      second case, we supply the name <literal role="keep-together">separator</literal>, which suggests the purpose of
      the argument.<indexterm>
          <primary>parameters</primary>

          <secondary>order of, named arguments and</secondary>
        </indexterm></para>

      <para id="para_the_second_benefit_is_that_you">The second benefit is
      that you can specify the parameters in any order when you specify them
      by name. Combined with default values, you can write code like the
      following:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/user-profile-v28-script.scala
// Scala v2.8 only.

object OptionalUserProfileInfo {
  val UnknownLocation = ""
  val UnknownAge = -1
  val UnknownWebSite = ""
}

class OptionalUserProfileInfo(
  location: String = OptionalUserProfileInfo.UnknownLocation,
  age: Int         = OptionalUserProfileInfo.UnknownAge,
  webSite: String  = OptionalUserProfileInfo.UnknownWebSite)

println( new OptionalUserProfileInfo )
println( new OptionalUserProfileInfo(age = 29) )
println( new OptionalUserProfileInfo(age = 29, location="Earth") )</programlisting>

      <para id="para__optionaluserprofileinfo_repr"><literal>OptionalUserProfileInfo</literal>
      represents all the &#x201C;optional&#x201D; user profile data in your next Web 2.0
      social networking site. It defines default values for all its fields.
      The script creates instances with zero or more named parameters. The
      order of those parameters is arbitrary.</para>

      <para id="para_the_examples_we_have_shown_use">The examples we have
      shown use constant values as the defaults. Most languages with default
      argument values only allow constants or other values that can be
      determined at parse time. However, in Scala, any expression can be used
      as the default, as long as it can compile where used. For example, an
      expression could not refer to an instance field that will be computed
      inside the class or object body, but it could invoke a method on a
      singleton object.<indexterm>
          <primary>constants</primary>

          <secondary>default argument values</secondary>
        </indexterm></para>

      <para id="para_a_related_limitation_is_that_a">A related limitation is
      that a default expression for one parameter can&#x2019;t refer to another
      parameter in the list, unless the parameter that is referenced appears
      earlier in the list <emphasis>and</emphasis> the parameters are
      <emphasis>curried</emphasis>, a concept we&#x2019;ll discuss in <xref linkend="Currying"/>.</para>

      <para id="para_finally_another_constraint_on">Finally, another
      constraint on named parameters is that once you provide a name for a
      parameter in a method invocation, the rest of the parameters appearing
      after it must also be named. For example, <literal role="keep-together">new OptionalUserProfileInfo(age = 29,
      "Earth")</literal> would not compile because the second argument is not
      invoked by name.</para>

      <para id="para_we_ll_see_another_useful_examp">We&#x2019;ll see another useful
      example of named and default arguments when we discuss <emphasis>case
      classes</emphasis> in <xref linkend="CaseClasses"/>.</para>
    </sect2>

    <sect2 id="NestingMethodDefinitions">
      <title>Nesting Method Definitions</title>

      <para id="param_method_nesting">Method definitions can also be nested.
      Here is an implementation of a factorial calculator, where we use a
      conventional technique of calling a second, nested method to do the
      work:<indexterm>
          <primary>methods</primary>

          <secondary>declarations</secondary>

          <tertiary>nesting method definitions</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/factorial-script.scala

def factorial(i: Int): Int = {
  def fact(i: Int, accumulator: Int): Int = {
    if (i &lt;= 1)
      accumulator
    else
      fact(i - 1, i * accumulator)
  }

  fact(i, 1)
}

println( factorial(0) )
println( factorial(1) )
println( factorial(2) )
println( factorial(3) )
println( factorial(4) )
println( factorial(5) )</programlisting>

      <para id="para_the_second_method_is_nested_in">The second method calls
      itself recursively, passing an <literal>accumulator</literal> parameter,
      where the result of the calculation is &#x201C;accumulated.&#x201D; Note that we
      return the accumulated value when the counter <literal>i</literal>
      reaches 1. (We&#x2019;re ignoring invalid negative integers. The function
      actually returns 1 for <literal>i &lt; 0</literal>.) After the
      definition of the nested method, <literal role="keep-together">factorial</literal> calls it with the passed-in
      value <literal>i</literal> and the initial accumulator value of
      1.<indexterm>
          <primary>recursion</primary>
        </indexterm></para>

      <para id="para_like_a_local_variable_declarat">Like a local variable
      declaration in many languages, a nested method is only visible inside
      the enclosing method. If you try to call <literal>fact</literal> outside
      of <literal>factorial</literal>, you will get a compiler error.</para>

      <para id="para_shadowing_variables">Did you notice that we use
      <literal>i</literal> as a parameter name twice, first in the
      <literal>factorial</literal> method and again in the nested
      <literal>fact</literal> method? As in many languages, the use of
      <literal>i</literal> as a parameter name for <literal>fact</literal>
      &#x201C;shadows&#x201D; the outer use of <literal>i</literal> as a parameter name for
      <literal>factorial</literal>. This is fine, because we don&#x2019;t need the
      outer value of <literal>i</literal> inside <literal>fact</literal>. We
      only use it the first time we call <literal>fact</literal>, at the end
      of <literal>factorial</literal>.</para>

      <para id="para_what_if_we_need_to_use_a_varia">What if we need to use a
      variable that is defined outside a nested function? Consider this
      contrived example:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/count-to-script.scala

def countTo(n: Int):Unit = {
  def count(i: Int): Unit = {
    if (i &lt;= n) {
      println(i)
      count(i + 1)
    }
  }
  count(1)
}

countTo(5)</programlisting>

      <para id="para_note_that_the_nested_count_m">Note that the nested
      <literal>count</literal> method uses the <literal>n</literal> value that
      is passed as a parameter to <literal>countTo</literal>. There is no need
      to pass <literal>n</literal> as an argument to <literal>count</literal>.
      Because <literal>count</literal> is nested inside
      <literal>countTo</literal>, <literal>n</literal> is visible to
      it.</para>

      <para id="para_when_a_variable_or_method_defi">The declaration of a
      field (member variable) can be prefixed with keywords indicating the
      <emphasis>visibility</emphasis>, just as in languages like Java and C#.
      Similarly the declaration of a non-nested method can be prefixed with
      the same keywords. We will discuss the visibility rules and keywords in
      <xref linkend="VisibilityRules"/>.<indexterm class="endofrange" startref="ch02_methodsdeclare"/></para>
    </sect2>
  </sect1>

  <sect1 id="InferringTypes">
    <title>Inferring Type Information</title>

    <para id="para_statically_typed_languages_can">Statically typed languages
    can be very verbose. Consider this typical declaration in Java:<indexterm class="startofrange" id="ch02_typeinfer">
        <primary>type inference</primary>
      </indexterm><indexterm class="startofrange" id="ch02_datatypesinfer">
        <primary>data types</primary>

        <secondary>inferring type information</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">import java.util.Map;
import java.util.HashMap;
...
Map&lt;Integer, String&gt; intToStringMap = new HashMap&lt;Integer, String&gt;();</programlisting>

    <para id="para_we_have_to_specify_the_type_pa">We have to specify the type
    parameters <literal>&lt;Integer, String&gt;</literal> twice. (Scala uses
    the term <emphasis>type annotations</emphasis> for explicit type
    declarations like <literal>HashMap&lt;Integer,
    String&gt;</literal>.)</para>

    <para id="para_scala_supports__type_inferenci">Scala supports
    <emphasis>type inference</emphasis> (see, for example, <link linkend="TypeInference" xrefstyle="select:nopage">[TypeInference]</link>
    and <link linkend="Pierce2002" xrefstyle="select:nopage">[Pierce2002]</link>). The language&#x2019;s compiler
    can discern quite a bit of type information from the context, without
    explicit type annotations. Here&#x2019;s the same declaration rewritten in Scala,
    with inferred type information:</para>

    <programlisting linenumbering="unnumbered">import java.util.Map
import java.util.HashMap
...
val intToStringMap: Map[Integer, String] = new HashMap</programlisting>

    <para id="para_recall_from_chapter_1_that_sca">Recall from <xref linkend="IntroducingScala"/> that Scala uses square brackets
    (<literal>[...]</literal>) for generic type parameters. We specify
    <literal>Map[Integer, String]</literal> on the lefthand side of the equals
    sign. (We are sticking with Java types for the example.) On the righthand
    side, we instantiate the actual type we want, a
    <literal>HashMap</literal>, but we don&#x2019;t have to repeat the type
    parameters.<indexterm>
        <primary>[ ] (square brackets)</primary>

        <secondary>use with parameterized types</secondary>
      </indexterm></para>

    <para id="para_for_completeness_suppose_we_d">For completeness, suppose we
    don&#x2019;t actually care if the instance is of type <literal>Map</literal> (the
    Java interface type). It can be of type <literal>HashMap</literal> for all
    we care:</para>

    <programlisting linenumbering="unnumbered">import java.util.Map
import java.util.HashMap
...
val intToStringMap2 = new HashMap[Integer, String]</programlisting>

    <para id="para_this_declaration_requires_no_t">This declaration requires
    no type annotations on the lefthand side because all of the type
    information needed is on the righthand side. The compiler automatically
    makes <literal>intToStringMap2</literal> a
    <literal>HashMap[Integer,String]</literal>.</para>

    <para id="para_method_type_inference">Type inference is used for methods,
    too. In most cases, the return type of the method can be inferred, so the
    <literal>:</literal> and return type can be omitted. However, type
    annotations are required for all method parameters.<indexterm>
        <primary>recursion</primary>

        <secondary>explicit return type annotation</secondary>
      </indexterm><indexterm class="startofrange" id="cg02_returntype">
        <primary>return type for methods</primary>
      </indexterm><indexterm>
        <primary>parameters</primary>

        <secondary>required return type annotations</secondary>
      </indexterm></para>

    <para id="para_functional_languages_like_hask">Pure functional languages
    like Haskell (see, e.g., <link linkend="OSullivan2009" xrefstyle="select:nopage">[O&#x2019;Sullivan2009]</link>) use type inference
    algorithms like <emphasis>Hindley-Milner</emphasis> (see <link linkend="Spiewak2008" xrefstyle="select:nopage">[Spiewak2008]</link> for
    an easily digested explanation). Code written in these languages require
    type annotations less often than in Scala, because Scala&#x2019;s type inference
    algorithm has to support object-oriented typing as well as functional
    typing. So, Scala requires more type annotations than languages like
    Haskell. Here is a summary of the rules for when explicit type annotations
    are required in Scala.</para>

    <sidebar>
      <title>When Explicit Type Annotations Are Required</title>

      <para id="para_in_practical_terms_you_have_t">In practical terms, you
      have to provide explicit type annotations for the following <phrase role="keep-together">situations</phrase>:<indexterm>
          <primary>type annotations</primary>

          <secondary>required explicit type annotations</secondary>
        </indexterm></para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>A variable declaration, unless you assign a value to the
          variable (e.g., <literal>val name = "Programming
          Scala"</literal>)</para>
        </listitem>

        <listitem>
          <para>All method parameters (e.g., <literal>def deposit(amount:
          Money)...</literal>)</para>
        </listitem>

        <listitem>
          <para>Method return values in the following cases:</para>

          <orderedlist numeration="loweralpha">
            <listitem>
              <para>When you explicitly call <literal>return</literal> in a
              method (even at the end)</para>
            </listitem>

            <listitem>
              <para>When a method is recursive</para>
            </listitem>

            <listitem>
              <para>When a method is overloaded and one of the methods calls
              another; the <emphasis>calling</emphasis> method needs a return
              type annotation</para>
            </listitem>

            <listitem>
              <para>When the inferred return type would be more general than
              you intended, e.g., <literal>Any</literal></para>
            </listitem>
          </orderedlist>
        </listitem>
      </orderedlist>
    </sidebar>

    <note id="para_note_the_any_type_is_the_su">
      <para>The <literal>Any</literal> type is the root of the Scala type
      hierarchy (see <xref linkend="ScalaTypeHierarchy"/> for more details).
      If a block of code returns a value of type <literal>Any</literal>
      unexpectedly, chances are good that the type inferencer couldn&#x2019;t figure
      out what type to return, so it chose the most generic type
      possible.</para>
    </note>

    <para id="para_method_return_value_cases">Let&#x2019;s look at examples where
    explicit declarations of method return types are required. In the
    following script, the <literal>upCase</literal> method has a conditional
    return statement for zero-length strings:<indexterm>
        <primary>return type for methods</primary>

        <secondary>required explicit declarations of</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/method-nested-return-script.scala
// ERROR: Won't compile until you put a String return type on upCase.

def upCase(s: String) = {
  if (s.length == 0)
    return s
  else
    s.toUpperCase()
}

println( upCase("") )
println( upCase("Hello") )</programlisting>

    <para id="para_running_this_script_gives_you_">Running this script gives
    you the following error:</para>

    <screen>... 6: error: method upCase has return statement; needs result type
        return s
         ^</screen>

    <para>You can fix this error by changing the first line of the method to
    the following:</para>

    <programlisting linenumbering="unnumbered">def upCase(s: String): String = {</programlisting>

    <para id="para_actually_for_this_particular_">Actually, for this
    particular script, an alternative fix is to remove the
    <literal>return</literal> keyword from the line. It is not needed for the
    code to work properly, but it illustrates our point.<indexterm>
        <primary>return keyword</primary>
      </indexterm></para>

    <para id="para_recursive_methods_require_a_re">Recursive methods also
    require an explicit return type. Recall our <literal>factorial</literal>
    method in <xref linkend="NestingMethodDefinitions"/>. Let&#x2019;s remove the
    <literal>: Int</literal> return type on the nested <literal>fact</literal>
    method:<indexterm>
        <primary>recursion</primary>

        <secondary>explicit return type annotation</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/method-recursive-return-script.scala
// ERROR: Won't compile until you put an Int return type on "fact".

def factorial(i: Int) = {
  def fact(i: Int, accumulator: Int) = {
    if (i &lt;= 1)
      accumulator
    else
      fact(i - 1, i * accumulator)
  }

  fact(i, 1)
}</programlisting>

    <para id="para_now_it_fails_to_compile_">Now it fails to compile:</para>

    <screen>... 9: error: recursive method fact needs result type
            fact(i - 1, i * accumulator)
             ^</screen>

    <para id="para_like_recursive_method_calls_w"><emphasis>Overloaded</emphasis>
    methods can sometimes require an explicit return type. When one such
    method calls another, we have to add a return type to the one doing the
    calling, as in this example:<indexterm>
        <primary>overloaded methods</primary>

        <secondary>explicit return type requirement</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/method-overloaded-return-script.scala
// Version 1 of "StringUtil" (with a compilation error).
// ERROR: Won't compile: needs a String return type on the second "joiner".

object StringUtil {
  def joiner(strings: List[String], separator: String): String =
    strings.mkString(separator)

  def joiner(strings: List[String]) = joiner(strings, " ")
}
import StringUtil._    // Import the joiner methods.

println( joiner(List("Programming", "Scala")) )</programlisting>

    <para id="para_the_two_joiner_methods_conca">The two
    <literal>joiner</literal> methods concatenate a <literal>List</literal> of
    strings together. The first method also takes an argument for the
    separator string. The second method calls the first with a &#x201C;default&#x201D;
    separator of a single space.</para>

    <para id="para_string_util_error">If you run this script, you get the
    following error:</para>

    <screen>... 9: error: overloaded method joiner needs result type
    def joiner(strings: List[String]) = joiner(strings, "")
                                         ^</screen>

    <para id="para_the_second_joiner_method_calls_the_first">Since the
    <emphasis>second</emphasis> <literal>joiner</literal> method calls the
    first, it requires an explicit <literal>String</literal> return type. It
    should look like this:</para>

    <programlisting linenumbering="unnumbered">    def joiner(strings: List[String]): String = joiner(strings, " ")</programlisting>

    <para id="para_note_that_any_is_the_root_of">The final scenario can be
    subtle, when a more general return type is inferred than what you
    expected. You usually see this error when you assign a value returned from
    a function to a variable with a more specific type. For example, you were
    expecting a <literal>String</literal>, but the function inferred an
    <literal>Any</literal> for the returned object. Let&#x2019;s see a contrived
    example that reflects a bug where this scenario can occur:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/method-broad-inference-return-script.scala
// ERROR: Won't compile; needs a String return type on the second "joiner".

def makeList(strings: String*) = {
  if (strings.length == 0)
    List(0)  // #1
  else
    strings.toList
}

val list: List[String] = makeList()</programlisting>

    <para id="para_script_return_error">Running this script returns the
    following error:</para>

    <screen>...11: error: type mismatch;
 found   : List[Any]
 required: List[String]
val list: List[String] = makeList()
                          ^</screen>

    <para id="para_we_intended_for_makelist_to_">We intended for
    <literal>makeList</literal> to return a <literal>List[String]</literal>,
    but when <literal>strings.length</literal> equals zero, we returned
    <literal>List(0)</literal>, incorrectly &#x201C;assuming&#x201D; that this expression is
    the correct way to create an empty list. In fact, we returned a
    <literal>List[Int]</literal> with one element, <literal>0</literal>. We
    should have returned <literal>List()</literal>. Since the
    <literal>else</literal> expression returns a
    <literal>List[String]</literal>, the result of
    <literal>strings.toList</literal>, the inferred return type for the method
    is the closest common supertype of <literal>List[Int]</literal> and
    <literal>List[String]</literal>, which is <literal>List[Any]</literal>.
    Note that the compilation error doesn&#x2019;t occur in the function definition.
    We only see it when we attempt to assign the value returned from
    <literal>makeList</literal> to a <literal>List[String]</literal>
    variable.</para>

    <para id="para_in_this_case_fixing_the_bug_i">In this case, fixing the bug
    is the solution. Alternatively, when there isn&#x2019;t a bug, it may be that the
    compiler just needs the &#x201C;help&#x201D; of an explicit return type declaration.
    Investigate the method that appears to return the unexpected type. In our
    experience, you often find that you modified that method (or another one
    in the call path) in such a way that the compiler now infers a more
    general return type than necessary. Add the explicit return type in this
    case.</para>

    <para id="para_declare_method_returns">Another way to prevent these
    problems is to always declare return types for methods, especially when
    defining methods for a public API. Let&#x2019;s revisit our
    <literal>StringUtil</literal> example and see why explicit declarations
    are a good idea (adapted from <link linkend="Smith2009a" xrefstyle="select:nopage">[Smith2009a]</link>).</para>

    <para id="para_imagine_that_we_extend_our_na">Here is our
    <literal>StringUtil</literal> &#x201C;API&#x201D; again with a new method,
    <literal>toCollection</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/string-util-v3.scala
// Version 3 of "StringUtil" (for all versions of Scala).

object StringUtil {
  def joiner(strings: List[String], separator: String): String =
    strings.mkString(separator)

  def joiner(strings: List[String]): String = strings.mkString(" ")

  def toCollection(string: String) = string.split(' ')
}</programlisting>

    <para id="para_the_pairsstringtomap_method_">The
    <literal>toCollection</literal> method splits a string on spaces and
    returns an <literal>Array</literal> containing the substrings. The return
    type is inferred, which is a potential problem, as we will see. The method
    is somewhat contrived, but it will illustrate our point. Here is a client
    of <literal role="keep-together">StringUtil</literal> that uses this
    method:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/string-util-client.scala

import StringUtil._

object StringUtilClient {
  def main(args: Array[String]) = {
    args foreach { s =&gt; toCollection(s).foreach { x =&gt; println(x) } }
  }
}</programlisting>

    <?dbfo-need height=”1in”
?>

    <para id="para_if_you_compile_these_files_yo">If you compile these files
    with <literal>scala</literal>, you can run the client as follows:</para>

    <screen>$ scala -cp ... StringUtilClient "Programming Scala"
Programming
Scala</screen>

    <note id="para_cp_current_dir">
      <para>For the <literal>-cp ...</literal> class path argument, use the
      directory where <literal>scalac</literal> wrote the class files, which
      defaults to the current directory (i.e., use <literal role="keep-together">-cp .</literal>). If you used the build process in
      the downloaded code examples, the class files are written to the
      <filename>build</filename> directory (using <literal>scalac -d build
      ...</literal>). In this case, use <literal>-cp build</literal>.</para>
    </note>

    <para id="para_everything_is_fine_at_this_poi">Everything is fine at this
    point, but now imagine that the code base has grown. <literal role="keep-together">StringUtil</literal> and its clients are now built
    separately and bundled into different JARs. Imagine also that the
    maintainers of <literal>StringUtil</literal> decide to return a
    <literal>List</literal> instead of the default:</para>

    <programlisting linenumbering="unnumbered">object StringUtil {
  ...

  def toCollection(string: String) = string.split(' ').toList  // changed!
}</programlisting>

    <para id="para_you_recompile_stringutil_and">The only difference is the
    final call to <literal>toList</literal> that converts the computed
    <literal>Array</literal> to a <literal>List</literal>. You recompile
    <literal>StringUtil</literal> and redeploy its JAR. Then you run the same
    client, <emphasis>without</emphasis> recompiling it first:</para>

    <screen>$ scala -cp ... StringUtilClient "Programming Scala"
java.lang.NoSuchMethodError: StringUtil$.toCollection(...
  at StringUtilClient$$anonfun$main$1.apply(string-util-client.scala:6)
  at StringUtilClient$$anonfun$main$1.apply(string-util-client.scala:6)
...</screen>

    <para id="para_what_happened_when_the_client">What happened? When the
    client was compiled, <literal>StringUtil.toCollection</literal> returned
    an <literal>Array</literal>. Then <literal>toCollection</literal> was
    changed to return <literal>List</literal>. In both versions, the method
    return value was inferred. Therefore, the client should have been
    recompiled, too.</para>

    <para id="para_however_had_an_explicit_retur">However, had an explicit
    return type of <literal>Seq</literal> been declared, which is a parent for
    both <literal>Array</literal> and <literal>List</literal>, then the
    implementation change would not have forced a recompilation of the
    client.</para>

    <note id="para_note_when_developing_apis_tha">
      <para>When developing APIs that are built separately from their clients,
      declare method return types explicitly and use the most general return
      type you can. This is especially important when APIs declare
      <emphasis>abstract</emphasis> methods (see, e.g., <xref linkend="Traits"/>).</para>
    </note>

    <para id="para_another_scenario_to_watch_for_">There is another scenario
    to watch for when using declarations of collections like <literal role="keep-together">val map = Map()</literal>, as in the following
    example:</para>

    <programlisting linenumbering="unnumbered">val map = Map()

map.update("book", "Programming Scala")</programlisting>

    <screen>... 3: error: type mismatch;
&#xA0;found &#xA0;&#xA0;: java.lang.String("book")
&#xA0;required: Nothing
map.update("book", "Programming Scala")
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;^</screen>

    <para id="para_what_happened_the__type_param">What happened? The
    <emphasis>type parameters</emphasis> of the generic type
    <literal>Map</literal> were inferred as <literal role="keep-together">[Nothing,Nothing]</literal> when the map was created.
    (We&#x2019;ll discuss <literal>Nothing</literal> in <xref linkend="ScalaTypeHierarchy"/>, but its name is suggestive!) We attempted
    to insert an incompatible key-value pair of types
    <literal>String</literal> and <literal>String</literal>. Call it a
    <literal>Map</literal> to nowhere! The solution is to parameterize the
    initial map declaration, e.g., <literal>val map = Map[String,
    String]()</literal>, or to specify initial values so that the map
    parameters are inferred, e.g., <literal>val map = Map("Programming" &#x2192;
    "Scala")</literal>.</para>

    <para id="para_finally_there_is_a_subtle_beh">Finally, there is a subtle
    behavior with inferred return types that can cause unexpected and baffling
    results (see <link linkend="ScalaTips" xrefstyle="select:nopage">[ScalaTips]</link>). Consider the following
    example <literal>scala</literal> session:</para>

    <screen>scala&gt; def double(i: Int) { 2 * i }
double: (Int)Unit

scala&gt; println(double(2))
()</screen>

    <para id="para_why_did_the_second_command_pri">Why did the second command
    print <literal>()</literal> instead of <literal>4</literal>? Look
    carefully at what the <literal>scala</literal> interpreter said the first
    command returned: <literal>double (Int)Unit</literal>. We defined a method
    named <literal>double</literal> that takes an <literal>Int</literal>
    argument and returns <literal>Unit</literal>. The method doesn&#x2019;t return an
    <literal>Int</literal> as we would expect.</para>

    <para id="para_the_cause_of_this_unexpected_b">The cause of this
    unexpected behavior is a missing equals sign in the method definition.
    Here is the definition we actually intended:<indexterm>
        <primary>= (equals sign)</primary>

        <secondary sortas="method definitions">in method
        definitions</secondary>

        <tertiary>missing</tertiary>
      </indexterm></para>

    <screen>scala&gt; def double(i: Int) = { 2 * i }
double: (Int)Int

scala&gt; println(double(2))
4</screen>

    <para id="para_note_the_equals_sign_before_th">Note the equals sign before
    the body of <literal>double</literal>. Now, the output says we have
    defined <literal>double</literal> to return an <literal>Int</literal> and
    the second command does what we expect it to do.</para>

    <para id="para_methods_with_without_equals">There is a reason for this
    behavior. Scala regards a method with the equals sign before the body as a
    function definition and a function always returns a value in functional
    programming. On the other hand, when Scala sees a method body without the
    leading equals sign, it assumes the programmer intended the method to be a
    &#x201C;procedure&#x201D; <phrase role="keep-together">definition</phrase>, meant for
    performing side effects only with the return value
    <literal>Unit</literal>. In practice, it is more likely that the
    programmer simply forgot to insert the equals sign!</para>

    <warning id="para_warning_when_the_return_type_">
      <para>When the return type of a method is inferred and you don&#x2019;t use an
      equals sign before the opening parenthesis for the method body, Scala
      infers a <literal>Unit</literal> return type, even when the last
      expression in the method is a value of another type.</para>
    </warning>

    <para id="para_by_the_way_the_that_was_">By the way, where did that
    <literal>()</literal> come from that was printed before we fixed the bug?
    It is actually the real name of the <emphasis>singleton</emphasis>
    instance of the <literal>Unit</literal> type! (This name is a functional
    programming convention.)<indexterm class="endofrange" startref="cg02_returntype"/><indexterm class="endofrange" startref="ch02_datatypesinfer"/><indexterm class="endofrange" startref="ch02_typeinfer"/></para>
  </sect1>

  <sect1 id="Literals">
    <title>Literals</title>

    <para id="para_often_a_new_object_is_initial">Often, a new object is
    initialized with a <emphasis>literal</emphasis> value, such as
    <literal>val book = "Programming Scala"</literal>. Let&#x2019;s discuss the kinds
    of literal values supported by Scala. Here, we&#x2019;ll limit ourselves to
    lexical syntax literals. We&#x2019;ll cover literal syntax for functions (used as
    <emphasis>values</emphasis>, not member methods), tuples, and certain
    types like <literal>Lists</literal> and <literal>Maps</literal> as we come
    to them.<indexterm class="startofrange" id="ch02_literals">
        <primary>literals</primary>
      </indexterm></para>

    <sect2 id="IntegerLiterals">
      <title>Integer Literals</title>

      <para id="para_integer_literals_can_be_expres">Integer literals can be
      expressed in decimal, hexadecimal, or octal. The details are summarized
      in <xref linkend="integer-literals-table"/>.<indexterm>
          <primary>octal integer literals</primary>
        </indexterm><indexterm>
          <primary>hexadecimal integer literals</primary>
        </indexterm><indexterm>
          <primary>decimal integer literals</primary>
        </indexterm><indexterm>
          <primary>integer literals</primary>
        </indexterm><indexterm>
          <primary>literals</primary>

          <secondary>integer</secondary>
        </indexterm></para>

      <table id="integer-literals-table">
        <title>Integer literals</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth=".75in"/>

          <colspec colnum="2" colwidth="2.75in"/>

          <colspec colnum="3" colwidth=".75in"/>

          <thead valign="top">
            <row>
              <entry>Kind</entry>

              <entry>Format</entry>

              <entry>Examples</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para>Decimal</para></entry>

              <entry><para>0 <emphasis>or</emphasis> a nonzero digit followed
              by zero or more digits (0&#x2013;9)</para></entry>

              <entry><para>0, 1, 321</para></entry>
            </row>

            <row>
              <entry><para>Hexadecimal</para></entry>

              <entry><para>0x followed by one or more hexadecimal digits (0&#x2013;9,
              A&#x2013;F, a&#x2013;f)</para></entry>

              <entry><para>0xFF, 0x1a3b</para></entry>
            </row>

            <row>
              <entry><para>Octal</para></entry>

              <entry><para>0 followed by one or more octal digits
              (0&#x2013;7)</para></entry>

              <entry><para>013, 077</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_for_long_literals_it_is_nec">For <literal>Long</literal>
      literals, it is necessary to append the <literal>L</literal> or
      <literal>l</literal> character at the end of the literal. Otherwise, an
      <literal>Int</literal> is used. The valid values for an integer literal
      are bounded by the type of the variable to which the value will be
      assigned. <xref linkend="integer-boundaries-table"/> defines the
      limits, which are inclusive.</para>

      <table id="integer-boundaries-table">
        <title>Ranges of allowed values for integer literals (boundaries are
        inclusive)</title>

        <tgroup cols="3">
          <colspec colnum="1" colwidth="1.42in"/>

          <colspec colnum="2" colwidth="1.42in"/>

          <colspec colnum="3" colwidth="1.42in"/>

          <thead valign="top">
            <row>
              <entry>Target type</entry>

              <entry>Minimum (inclusive)</entry>

              <entry>Maximum (inclusive)</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>Long</literal></para></entry>

              <entry><para>&#x2212;2<superscript>63</superscript></para></entry>

              <entry><para>2<superscript>63</superscript> &#x2212; 1</para></entry>
            </row>

            <row>
              <entry><para><literal>Int</literal></para></entry>

              <entry><para>&#x2212;2<superscript>31</superscript></para></entry>

              <entry><para>2<superscript>31</superscript> &#x2212; 1</para></entry>
            </row>

            <row>
              <entry><para><literal>Short</literal></para></entry>

              <entry><para>&#x2212;2<superscript>15</superscript></para></entry>

              <entry><para>2<superscript>15</superscript> &#x2212; 1</para></entry>
            </row>

            <row>
              <entry><para><literal>Char</literal></para></entry>

              <entry><para>0</para></entry>

              <entry><para>2<superscript>16</superscript> &#x2212; 1</para></entry>
            </row>

            <row>
              <entry><para><literal>Byte</literal></para></entry>

              <entry><para>&#x2212;2<superscript>7</superscript></para></entry>

              <entry><para>2<superscript>7</superscript> &#x2212; 1</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_a_compile_time_error_occurs_if">A compile-time error
      occurs if an integer literal number is specified that is outside these
      ranges, as in the following examples:</para>

      <screen>scala &gt; val i = 12345678901234567890
&lt;console&gt;:1: error: integer number too large
       val i = 12345678901234567890
scala&gt; val b: Byte = 128
&lt;console&gt;:4: error: type mismatch;
 found   : Int(128)
 required: Byte
       val b: Byte = 128
                     ^

scala&gt; val b: Byte = 127
b: Byte = 127</screen>
    </sect2>

    <sect2 id="FloatingPointLiterals">
      <title>Floating-Point Literals</title>

      <para id="para_floating_point_literals_are_ex">Floating-point literals
      are expressions with zero or more digits, followed by a <phrase role="keep-together">period</phrase> (<literal>.</literal>), followed by
      zero or more digits. If there are no digits before the period, i.e., the
      number is less than 1.0, then there must be one or more digits after the
      period. For <literal>Float</literal> literals, append the
      <literal>F</literal> or <literal>f</literal> character at the end of the
      literal. Otherwise, a <literal role="keep-together">Double</literal> is
      assumed. You can optionally append a <literal>D</literal> or
      <literal>d</literal> for a <literal role="keep-together">Double</literal>.<indexterm>
          <primary>floating-point literals</primary>
        </indexterm><indexterm>
          <primary>literals</primary>

          <secondary>floating-point</secondary>
        </indexterm></para>

      <para id="para_floating_point_literals_can_be">Floating-point literals
      can be expressed with or without exponentials. The format of the
      exponential part is <literal>e</literal> or <literal>E</literal>,
      followed by an optional <literal>+</literal> or <literal>-</literal>,
      followed by one or more digits.<indexterm>
          <primary>exponentials with floating-point literals</primary>
        </indexterm></para>

      <para id="para_here_are_some_example_floating">Here are some example
      floating-point literals:</para>

      <programlisting linenumbering="unnumbered">0.
.0
0.0
3.
3.14
.14
0.14
3e5
3E5
3.E5
3.e5
3.e+5
3.e-5
3.14e-5
3.14e-5f
3.14e-5F
3.14e-5d
3.14e-5D</programlisting>

      <para id="para__float_consists_of_all_ieee_7"><literal>Float</literal>
      consists of all IEEE 754 32-bit, single-precision binary floating-point
      values. <literal>Double</literal> consists of all IEEE 754 64-bit,
      double-precision binary floating-point values.</para>

      <warning id="para_warning_to_avoid_parsing_ambi">
        <para>To avoid parsing ambiguities, you must have at least one space
        after a floating-point literal, if it is followed by a token that
        starts with a letter. Also, the expression
        <literal>1.toString</literal> returns the integer value
        <literal>1</literal> as a string, while <literal>1. toString</literal>
        uses the <emphasis>operator notation</emphasis> to invoke
        <literal>toString</literal> on the floating-point literal
        <literal>1.</literal>.</para>
      </warning>
    </sect2>

    <sect2 id="BooleanLiterals">
      <title>Boolean Literals</title>

      <para id="para_the_boolean_literals_are_true">The boolean literals are
      <literal>true</literal> and <literal>false</literal>. The type of the
      variable to which they are assigned will be inferred to be
      <literal>Boolean</literal>:<indexterm>
          <primary>literals</primary>

          <secondary>boolean</secondary>
        </indexterm><indexterm>
          <primary>boolean literals</primary>
        </indexterm></para>

      <screen>scala&gt; val b1 = true
b1: Boolean = true

scala&gt; val b2 = false
b2: Boolean = false</screen>
    </sect2>

    <sect2 id="CharacterLiterals">
      <title>Character Literals</title>

      <para id="para_a_character_literal_is_either_">A character literal is
      either a printable Unicode character or an escape sequence, written
      between single quotes. A character with a Unicode value between 0 and
      255 may also be represented by an octal escape, i.e., a backslash
      (<literal>\</literal>) followed by a sequence of up to three octal
      characters. It is a compile-time error if a backslash character in a
      character or string literal does not start a valid escape
      sequence.<indexterm>
          <primary>" " (quotation marks, double)</primary>

          <secondary>escaping in character literals</secondary>
        </indexterm><indexterm>
          <primary>\ (backslash)</primary>

          <secondary sortas="character escape sequences">in character escape
          sequences</secondary>
        </indexterm><indexterm>
          <primary>' ' (quotation marks, single)</primary>

          <secondary>enclosing character literals</secondary>
        </indexterm><indexterm>
          <primary>Unicode characters</primary>
        </indexterm><indexterm>
          <primary>literals</primary>

          <secondary>character</secondary>
        </indexterm><indexterm>
          <primary>character literals</primary>
        </indexterm></para>

      <para id="para_character_literal_examples_">Here are some
      examples:</para>

      <programlisting linenumbering="unnumbered">'A'
'\u0041'  // 'A' in Unicode
'\n'
'\012'    // '\n' in octal
'\t'</programlisting>

      <para id="para_the_valid_escape_sequences_are">The valid escape
      sequences are shown in <xref linkend="char-escape-sequences-table"/>.</para>

      <table id="char-escape-sequences-table">
        <title>Character escape sequences</title>

        <tgroup cols="3">
          <thead valign="top">
            <row>
              <entry>Sequence</entry>

              <entry>Unicode</entry>

              <entry>Meaning</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>\b</literal></para></entry>

              <entry><para><literal>\u0008</literal></para></entry>

              <entry><para>Backspace (BS)</para></entry>
            </row>

            <row>
              <entry><para><literal>\t</literal></para></entry>

              <entry><para><literal>\u0009</literal></para></entry>

              <entry><para>Horizontal tab (HT)</para></entry>
            </row>

            <row>
              <entry><para><literal>\n</literal></para></entry>

              <entry><para><literal>\u000a</literal></para></entry>

              <entry><para>Line feed (LF)</para></entry>
            </row>

            <row>
              <entry><para><literal>\f</literal></para></entry>

              <entry><para><literal>\u000c</literal></para></entry>

              <entry><para>Form feed (FF)</para></entry>
            </row>

            <row>
              <entry><para><literal>\r</literal></para></entry>

              <entry><para><literal>\u000d</literal></para></entry>

              <entry><para>Carriage return (CR)</para></entry>
            </row>

            <row>
              <entry><para><literal>\"</literal></para></entry>

              <entry><para><literal>\u0022</literal></para></entry>

              <entry><para>Double quote (<literal>"</literal>)</para></entry>
            </row>

            <row>
              <entry><para><literal>\&#x2019;</literal></para></entry>

              <entry><para><literal>\u0027</literal></para></entry>

              <entry><para>Single quote (<literal>&#x2019;</literal>)</para></entry>
            </row>

            <row>
              <entry><para><literal>\\</literal></para></entry>

              <entry><para><literal>\u0009</literal></para></entry>

              <entry><para>Backslash (<literal>\</literal>)</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 id="StringLiterals">
      <title>String Literals</title>

      <para id="para_a_string_literal_is_a_sequence">A string literal is a
      sequence of characters enclosed in double quotes or
      <emphasis>triples</emphasis> of double quotes, i.e.,
      <literal>"""..."""</literal>.<indexterm>
          <primary>" " (quotation marks, double)</primary>

          <secondary>enclosing string literals</secondary>
        </indexterm><indexterm>
          <primary>string literals</primary>
        </indexterm><indexterm>
          <primary>literals</primary>

          <secondary>string</secondary>
        </indexterm></para>

      <para id="para_for_string_literals_in_double_">For string literals in
      double quotes, the allowed characters are the same as the character
      literals. However, if a double quote <literal>"</literal> character
      appears in the string, it must be &#x201C;<phrase role="keep-together">escaped</phrase>&#x201D; with a <literal>\</literal>
      character. Here are some examples:<indexterm>
          <primary>\ (backslash)</primary>

          <secondary>escaping double quotes in string literals</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">"Programming\nScala"
"He exclaimed, \"Scala is great!\""
"First\tSecond"</programlisting>

      <para id="para_the_string_literals_bounded_by">The string literals
      bounded by triples of double quotes are also called
      <emphasis>multi-line</emphasis> string literals. These strings can cover
      several lines; the line feeds will be part of the string. They can
      include any characters, including one or two double quotes together, but
      not three together. They are useful for strings with
      <literal>\</literal> characters that don&#x2019;t form valid Unicode or escape
      sequences, like the valid sequences listed in <xref linkend="char-escape-sequences-table"/>. Regular expressions are a
      typical example, which we&#x2019;ll discuss in <xref linkend="RoundingOutTheEssentials"/>. However, if escape <phrase role="keep-together">sequences</phrase> appear, they aren&#x2019;t
      interpreted.<indexterm>
          <primary>" " (quotation marks, double)</primary>

          <secondary>triples of double quotes, bounding multi-line string
          literals</secondary>
        </indexterm></para>

      <para id="para_3quote_string_literal_examples_">Here are three example
      strings:</para>

      <programlisting linenumbering="unnumbered">"""Programming\nScala"""
"""He exclaimed, "Scala is great!" """
"""First line\n
Second line\t

Fourth line"""</programlisting>

      <para id="para_note_trailing_quotes">Note that we had to add a space
      before the trailing <literal>"""</literal> in the second example to
      prevent a parse error. Trying to escape the second <literal>"</literal>
      that ends the <literal>"Scala is great!"</literal> quote, i.e.,
      <literal>"Scala is great!\"</literal>, doesn&#x2019;t work.</para>

      <para id="para_copy_and_past_these_strings_in">Copy and paste these
      strings into the <literal>scala</literal> interpreter. Do the same for
      the previous string examples. How are they interpreted
      differently?</para>
    </sect2>

    <sect2 id="SymbolLiterals">
      <title>Symbol Literals</title>

      <para id="para_scala_supports_symbols_which_">Scala supports symbols,
      which are <emphasis>interned</emphasis> strings, meaning that two
      symbols with the same &#x201C;name&#x201D; (i.e., the same character sequence) will
      actually refer to the same object in memory. Symbols are used less often
      in Scala than in some other languages, like Ruby, Smalltalk, and Lisp.
      They are useful as map keys instead of strings.<indexterm>
          <primary>interned strings</primary>
        </indexterm><indexterm>
          <primary>symbol literals</primary>
        </indexterm><indexterm>
          <primary>literals</primary>

          <secondary>symbol</secondary>
        </indexterm></para>

      <para id="para_a_symbol_literal_is_a_single_q">A symbol literal is a
      single quote (<literal>'</literal>), followed by a letter, followed by
      zero or more digits and letters. Note that an expression like
      <literal>'1</literal> is invalid, because the compiler thinks it is an
      incomplete character literal.</para>

      <para id="para_a_symbol_literal_id_is_a_sh">A symbol literal
      <literal>'</literal><replaceable>id</replaceable> is a shorthand for the
      expression <literal>scala.Symbol("id")</literal>.<indexterm>
          <primary>' ' (quotation marks, single)</primary>

          <secondary sortas="symbol literals">in symbol literals</secondary>
        </indexterm></para>

      <note id="para_note_if_you_want_to_create_a_">
        <para>If you want to create a symbol that contains whitespace, use
        e.g., <literal>scala.Symbol(" Programming Scala ")</literal>. All the
        whitespace is preserved.<indexterm class="endofrange" startref="ch02_literals"/></para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="TheTroubleWithTuples">
    <title>Tuples</title>

    <para id="para_how_many_times_have_you_wanted">How many times have you
    wanted to return <emphasis>two</emphasis> or more values from a method? In
    many languages, like Java, you only have a few options, none of which is
    very appealing. You could pass in parameters to the method that will be
    modified for all or some of the &#x201C;return&#x201D; values, which is ugly. Or you
    could declare some small &#x201C;structural&#x201D; class that holds the two or more
    values, then return an instance of that class.<indexterm>
        <primary>tuples</primary>
      </indexterm></para>

    <para id="para_scala_supports__tuples__a_gr">Scala, supports
    <emphasis>tuples</emphasis>, a grouping of two or more items, usually
    created with the literal syntax of a comma-separated list of the items
    inside parentheses, e.g., <literal>(x1, x2, ...)</literal>. The types of
    the <literal>x</literal><subscript>i</subscript> elements are unrelated to
    each other; you can mix and match types. These literal &#x201C;groupings&#x201D; are
    instantiated as <literal>scala.TupleN</literal> instances, where
    <literal>N</literal> is the number of items in the tuple. The Scala API
    defines separate <literal>TupleN</literal> classes for
    <literal>N</literal> between 1 and 22, inclusive. Tuple instances are
    immutable, <emphasis>first-class</emphasis> values, so you can assign them
    to variables, pass them as values, and return them from methods.</para>

    <para id="para_the_following_example_demonstr">The following example
    demonstrates the use of tuples:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/tuple-example-script.scala

def tupleator(x1: Any, x2: Any, x3: Any) = (x1, x2, x3)

val t = tupleator("Hello", 1, 2.3)
println( "Print the whole tuple: " + t )
println( "Print the first item:  " + t._1 )
println( "Print the second item: " + t._2 )
println( "Print the third item:  " + t._3 )

val (t1, t2, t3) = tupleator("World", '!', 0x22)
println( t1 + " " + t2 + " " + t3 )</programlisting>

    <para id="para_running2">Running this script with <literal>scala</literal>
    produces the following output:</para>

    <screen>Print the whole tuple: (Hello,1,2.3)
Print the first item:  Hello
Print the second item: 1
Print the third item:  2.3
World ! 34</screen>

    <para id="para_tupleator">The <literal>tupleator</literal> method simply
    returns a &#x201C;3-tuple&#x201D; with the input arguments. The first statement that
    uses this method assigns the returned tuple to a single variable
    <literal>t</literal>. The next four statements print <literal>t</literal>
    in various ways. The first print statement calls
    <literal>Tuple3.toString</literal>, which wraps parentheses around the
    item list. The following three statements print each item in
    <literal>t</literal> separately. The expression <literal>t._N</literal>
    retrieves the <literal>N</literal> item, starting at 1,
    <emphasis>not</emphasis> 0 (this choice follows functional programming
    conventions).</para>

    <para id="para_tupleator_one_lhs">The last two lines show that we can use
    a tuple expression on the lefthand side of the assignment. We declare
    three <literal>val</literal>s&#x2014;<literal>t1</literal>,
    <literal>t2</literal>, and <literal>t3</literal>&#x2014;to hold the individual
    items in the tuple. In essence, the tuple items are extracted
    automatically.</para>

    <para id="para_notice_how_we_mixed_types_in_t">Notice how we mixed types
    in the tuples. You can see the types more clearly if you use the
    interactive mode of the <literal>scala</literal> command, which we
    introduced in <xref linkend="IntroducingScala"/>.</para>

    <para id="para_try_typing_in_val_t_hello">Invoke the
    <literal>scala</literal> command with no script argument. At the
    <literal>scala&gt;</literal> prompt, enter <literal role="keep-together">val t = ("Hello",1,2.3)</literal> and see that you
    get the following result, which shows you the type of each element in the
    tuple:</para>

    <screen>scala&gt; val t = ("Hello",1,2.3)
t: (java.lang.String, Int, Double) = (Hello,1,2.3)</screen>

    <para id="para_it_s_worth_noting_that_there_s">It&#x2019;s worth noting that
    there&#x2019;s more than one way to define a tuple. We&#x2019;ve been using the more
    common parenthesized syntax, but you can also use the arrow operator
    between two values, as well as special factory methods on the
    tuple-related classes:<indexterm>
        <primary>-&gt; (right arrow) operator</primary>
      </indexterm></para>

    <screen>scala&gt; 1 -&gt; 2
res0: (Int, Int) = (1,2)

scala&gt; Tuple2(1, 2)
res1: (Int, Int) = (1,2)

scala&gt; Pair(1, 2)
res2: (Int, Int) = (1,2)</screen>
  </sect1>

  <sect1 id="OptionSomeNone">
    <title>Option, Some, and None: Avoiding nulls</title>

    <para id="para_we_ll_discuss_the_standard_typ">We&#x2019;ll discuss the standard
    type hierarchy for Scala in <xref linkend="ScalaTypeHierarchy"/>.
    However, three useful classes to understand now are the
    <literal>Option</literal> class and its two subclasses,
    <literal>Some</literal> and <literal>None</literal>.<indexterm class="startofrange" id="ch02_nullsavoid">
        <primary>nulls</primary>

        <secondary>avoiding using Option, Some, and None classes</secondary>
      </indexterm><indexterm>
        <primary>None class</primary>
      </indexterm><indexterm>
        <primary>Some class</primary>
      </indexterm><indexterm class="startofrange" id="ch02_Optionclass">
        <primary>Option class</primary>
      </indexterm></para>

    <para id="para_most_languages_have_a_special_">Most languages have a
    special keyword or object that&#x2019;s assigned to reference variables when
    there&#x2019;s nothing else for them to refer to. In Java, this is
    <literal>null</literal>; in Ruby, it&#x2019;s <literal>nil</literal>. In Java,
    <literal>null</literal> is a keyword, not an object, and thus it&#x2019;s illegal
    to call any methods on it. But this is a confusing choice on the language
    designer&#x2019;s part. Why return a keyword when the programmer expects an
    object?</para>

    <para id="para_to_be_more_consistent_with_the">To be more consistent with
    the goal of making everything an object, as well as to conform with
    functional programming conventions, Scala encourages you to use the
    <literal>Option</literal> type for variables and function return values
    when they may or may not refer to a value. When there is no value, use
    <literal>None</literal>, an <literal>object</literal> that is a subclass
    of <literal>Option</literal>. When there is a value, use
    <literal>Some</literal>, which wraps the value. <literal>Some</literal> is
    also a subclass of <literal>Option</literal>.<indexterm>
        <primary>return type for methods</primary>

        <secondary>using Option, Some, and None types</secondary>
      </indexterm></para>

    <note id="para_note_none_is_declared_as_an">
      <para><literal>None</literal> is declared as an
      <literal>object</literal>, not a <literal>class</literal>, because we
      really only need one instance of it. In that sense, it&#x2019;s like the
      <literal>null</literal> keyword, but it is a real object with
      methods.</para>
    </note>

    <para id="para_you_can_see_option_some_">You can see
    <literal>Option</literal>, <literal>Some</literal>, and
    <literal>None</literal> in action in the following example, where we
    create a map of state capitals in the United States:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/state-capitals-subset-script.scala

val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Juneau",
  // ...
  "Wyoming" -&gt; "Cheyenne")

println( "Get the capitals wrapped in Options:" )
println( "Alabama: " + stateCapitals.get("Alabama") )
println( "Wyoming: " + stateCapitals.get("Wyoming") )
println( "Unknown: " + stateCapitals.get("Unknown") )

println( "Get the capitals themselves out of the Options:" )
println( "Alabama: " + stateCapitals.get("Alabama").get )
println( "Wyoming: " + stateCapitals.get("Wyoming").getOrElse("Oops!") )
println( "Unknown: " + stateCapitals.get("Unknown").getOrElse("Oops2!") )</programlisting>

    <para id="para_the_convenient_gt_syntax_">The convenient
    <literal>-&gt;</literal> syntax for defining name-value pairs to
    initialize a <literal>Map</literal> will be discussed in <xref linkend="PredefObject"/>. For now, we want to focus on the two groups of
    <literal>println</literal> statements, where we show what happens when you
    retrieve the values from the map. If you run this script with the
    <literal>scala</literal> command, you&#x2019;ll get the following output:</para>

    <screen>Get the capitals wrapped in Options:
Alabama: Some(Montgomery)
Wyoming: Some(Cheyenne)
Unknown: None
Get the capitals themselves out of the Options:
Alabama: Montgomery
Wyoming: Cheyenne
Unknown: Oops2!</screen>

    <para id="para_the_first_group_of_println_s">The first group of
    <literal>println</literal> statements invoke <literal>toString</literal>
    implicitly on the instances returned by <literal>get</literal>. We are
    calling <literal>toString</literal> on <literal>Some</literal> or
    <literal>None</literal> instances because the values returned by
    <literal>Map.get</literal> are automatically wrapped in a
    <literal>Some</literal>, when there is a value in the map for the
    specified key. Note that the Scala library doesn&#x2019;t store the
    <literal>Some</literal> in the map; it wraps the value in a
    <literal>Some</literal> upon retrieval. Conversely, when we ask for a map
    entry that doesn&#x2019;t exist, the <literal>None</literal> object is returned,
    rather than <literal>null</literal>. This occurred in the last
    <literal>println</literal> of the three.</para>

    <para id="para_the_second_group_of_println_">The second group of
    <literal>println</literal> statements goes a step further. After calling
    <literal>Map.get</literal>, they call <literal>get</literal> or
    <literal>getOrElse</literal> on each <literal>Option</literal> instance to
    retrieve the value it contains. <literal>Option.get</literal> requires
    that the <literal>Option</literal> is not empty&#x2014;that is, the
    <literal>Option</literal> instance must actually be a
    <literal>Some</literal>. In this case, <literal>get</literal> returns the
    value wrapped by the <literal>Some</literal>, as demonstrated in the
    <literal>println</literal> where we print the capital of Alabama. However,
    if the <literal>Option</literal> <phrase role="keep-together">is
    actually</phrase> <literal>None</literal>, then
    <literal>None.get</literal> throws a
    <literal>NoSuchElementException</literal>.</para>

    <para id="para_we_also_show_the_alternative_m">We also show the
    alternative method, <literal>getOrElse</literal>, in the last two
    <literal>println</literal> statements. This method returns either the
    value in the <literal>Option</literal>, if it is a <literal>Some</literal>
    instance, or it returns the second argument we passed to
    <literal>getOrElse</literal>, if it is a <literal>None</literal> instance.
    In other words, the second argument to <literal>getOrElse</literal>
    functions as the default return value.</para>

    <para id="para_we_ll_discuss_the_merits_of_al">So,
    <literal>getOrElse</literal> is the more defensive of the two methods. It
    avoids a potential thrown exception. We&#x2019;ll discuss the merits of
    alternatives like <literal>get</literal> versus
    <literal>getOrElse</literal> in <xref linkend="ExceptionsAndTheAlternatives"/>.</para>

    <para id="para_note_that_because_the_map_get">Note that because the
    <literal>Map.get</literal> method returns an <literal>Option</literal>, it
    automatically documents the fact that there may not be an item matching
    the specified key. The map handles this situation by returning a
    <literal>None</literal>. Most languages would return
    <literal>null</literal> (or the equivalent) when there is no &#x201C;real&#x201D; value
    to return. You learn from experience to expect a possible
    <literal>null</literal>. Using <literal>Option</literal> makes the
    behavior more explicit in the method signature, so it&#x2019;s more
    self-documenting.</para>

    <para id="para_also_thanks_to_scala_s_static">Also, thanks to Scala&#x2019;s
    static typing, you can&#x2019;t make the mistake of attempting to call a method
    on a value that might actually be <literal>null</literal>. While this
    mistake is easy to do in Java, it won&#x2019;t compile in Scala because you must
    first extract the value from the <literal>Option</literal>. So, the use of
    <literal>Option</literal> strongly encourages more resilient
    programming.</para>

    <para id="para_because_scala_runs_on_the_jvm_">Because Scala runs on the
    JVM and .NET and because it must interoperate with other libraries, Scala
    has to support <literal>null</literal>. Still, you should avoid using
    <literal>null</literal> in your code. Tony Hoare, who invented the null
    reference in 1965 while working on an object-oriented language called
    ALGOL W, called its invention his &#x201C;billion dollar mistake&#x201D; (see <link linkend="Hoare2009" xrefstyle="select:nopage">[Hoare2009]</link>). Don&#x2019;t
    contribute to that figure.</para>

    <para id="para_so_how_would_you_write_a_func">So, how would you write a
    method that returns an <literal>Option</literal>? Here is a possible
    implementation of <literal>get</literal> that could be used by a concrete
    subclass of <literal>Map</literal> (<literal>Map.get</literal> itself is
    <emphasis>abstract</emphasis>). For a more sophisticated version, see the
    implementation of <literal>get</literal> in
    <literal>scala.col&#x2060;lection.immutable.HashMap</literal> in the Scala
    library source code distribution:</para>

    <programlisting linenumbering="unnumbered">def get(key: A): Option[B] = {
  if (contains(key))
    new Some(getValue(key))
  else
    None
}</programlisting>

    <para id="para_the_contains_method_is_also_">The
    <literal>contains</literal> method is also defined for
    <literal>Map</literal>. It returns <literal>true</literal> if the map
    contains a value for the specified key. The <literal>getValue</literal>
    method is intended to be an internal method that retrieves the value from
    the underlying storage, whatever it is.</para>

    <para id="para_note_how_the_value_returned_by">Note how the value returned
    by <literal>getValue</literal> is wrapped in a <literal>Some[B]</literal>,
    where the type <literal>B</literal> is inferred. However, if the call to
    <literal>contains(key)</literal> returns <literal>false</literal>, then
    the <literal>object None</literal> is returned.</para>

    <para id="para_you_can_use_this_same_idiom_wh">You can use this same idiom
    when your methods return an <literal>Option</literal>. We&#x2019;ll explore other
    uses for <literal>Option</literal> in subsequent sections. Its pervasive
    use in Scala code makes it an important concept to grasp.<indexterm class="endofrange" startref="ch02_Optionclass"/><indexterm class="endofrange" startref="ch02_nullsavoid"/></para>
  </sect1>

  <sect1 id="Packages">
    <title>Organizing Code in Files and Namespaces</title>

    <para id="para_scala_adopts_the_package_conce">Scala adopts the package
    concept that Java uses for namespaces, but Scala offers a more flexible
    syntax. Just as file names don&#x2019;t have to match the type names, the package
    structure does not have to match the directory structure. So, you can
    define packages in files independent of their &#x201C;physical&#x201D;
    location.<indexterm>
        <primary>Java</primary>

        <secondary>package concept for namespaces</secondary>
      </indexterm><indexterm>
        <primary>packages</primary>
      </indexterm><indexterm>
        <primary>namespaces</primary>
      </indexterm><indexterm>
        <primary>code, organizing in files and namespaces</primary>
      </indexterm></para>

    <para id="para_the_following_example_defines_">The following example
    defines a class <literal>MyClass</literal> in a package
    <literal>com.example.mypkg</literal> using the conventional Java
    syntax:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/package-example1.scala

package com.example.mypkg

class MyClass {
  // ...
}</programlisting>

    <para id="para_the_next_example_shows_a_contr">The next example shows a
    contrived example that defines packages using the nested package syntax in
    Scala, which is similar to the <literal>namespace</literal> syntax in C#
    and the use of <literal>modules</literal> as namespaces in Ruby:<indexterm>
        <primary>namespaces</primary>

        <secondary>relationship to Scala&#x2019;s nested package syntax</secondary>
      </indexterm><indexterm>
        <primary>packages</primary>

        <secondary>defining using nested package syntax in Scala</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/package-example2.scala

package com {
  package example {
    package pkg1 {
      class Class11 {
        def m = "m11"
      }
      class Class12 {
        def m = "m12"
      }
    }

    package pkg2 {
      class Class21 {
        def m = "m21"
        def makeClass11 = {
          new pkg1.Class11
        }
        def makeClass12 = {
          new pkg1.Class12
        }
      }
    }

    package pkg3.pkg31.pkg311 {
      class Class311 {
        def m = "m21"
      }
    }
  }
}</programlisting>

    <para id="para_two_packages_pkg1_and_pkg2_">Two packages,
    <literal>pkg1</literal> and <literal>pkg2</literal>, are defined under the
    <literal>com.example</literal> package. A total <phrase role="keep-together">of three classes</phrase> are defined between the two
    packages. The <literal>makeClass11</literal> and <literal role="keep-together">makeClass12</literal> methods in
    <literal>Class21</literal> illustrate how to reference a type in the
    &#x201C;sibling&#x201D; <phrase role="keep-together">package,
    <literal>pkg1</literal></phrase>. You can also reference these classes by
    their full paths, <literal role="keep-together">com.example.pkg1.Class11</literal> and
    <literal>com.example.pkg1.Class12</literal>, respectively.</para>

    <para id="para_the_package_pkg3_pkg31_pkg311">The package
    <literal>pkg3.pkg31.pkg311</literal> shows that you can &#x201C;chain&#x201D; several
    packages together in one clause. It is not necessary to use a separate
    <literal>package</literal> clause for each package.</para>

    <para id="para_following_the_conventions_of_j">Following the conventions
    of Java, the root package for Scala&#x2019;s library classes is named
    <literal>scala</literal>.<indexterm>
        <primary>packages</primary>

        <secondary>root package for Scala library classes</secondary>
      </indexterm></para>

    <warning id="para_note_scala_does_not_allow_pac">
      <para>Scala does not allow package declarations in scripts that are
      executed directly with the <literal>scala</literal> interpreter. The
      reason has to do with the way the interpreter converts statements in
      scripts to valid Scala code <phrase role="keep-together">before
      compiling</phrase> to byte code. See <xref linkend="CommandLineToolScala"/> for more details.</para>
    </warning>
  </sect1>

  <sect1 id="Importing">
    <title>Importing Types and Their Members</title>

    <para id="para_to_use_declarations_in_package">To use declarations in
    packages, you have to import them, just as you do in Java and similarly
    for other languages. However, compared to Java, Scala greatly expands your
    options. The following example illustrates several ways to import Java
    types:<indexterm>
        <primary>members</primary>

        <secondary>importing</secondary>
      </indexterm><indexterm>
        <primary>import statements</primary>

        <secondary>importing Java types and their members</secondary>
      </indexterm><indexterm>
        <primary>Java</primary>

        <secondary>importation of data types into Scala</secondary>
      </indexterm><indexterm>
        <primary>data types</primary>

        <secondary>importing types and their members</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/import-example1.scala

import java.awt._
import java.io.File
import java.io.File._
import java.util.{Map, HashMap}</programlisting>

    <para id="para_you_can_import_all_types_in_a_">You can import all types in
    a package, using the underscore (&#x2009;<literal>_</literal>&#x2009;) as a wildcard, as
    shown on the first line. You can also import individual Scala or Java
    types, as shown on the second line.<indexterm>
        <primary>_ (underscore)</primary>

        <secondary>wildcard character in Scala</secondary>
      </indexterm></para>

    <para id="para_star_vs_underscore">Java uses the &#x201C;star&#x201D; character
    (<literal>*</literal>) as the wildcard for matching all types in a package
    or all static members of a type when doing &#x201C;static imports.&#x201D; In Scala,
    this character is allowed in method names, so <literal>_</literal> is used
    as a wildcard, as we saw previously.</para>

    <para id="para_as_shown_on_the_third_line_yo">As shown on the third line,
    you can import all the static methods and fields in Java types. If
    <literal>java.io.File</literal> were actually a Scala
    <literal>object</literal>, as discussed previously, then this line would
    import the fields and methods from the object.</para>

    <para id="para_finally_you_can_selectively_i">Finally, you can selectively
    import just the types you care about. On the fourth line, we import just
    the <literal>java.util.Map</literal> and
    <literal>java.util.HashMap</literal> types from the
    <literal>java.util</literal> package. Compare this one-line import
    statement with the two-line import statements we used in our first example
    in <xref linkend="InferringTypes"/>. They are <phrase role="keep-together">functionally</phrase> equivalent.</para>

    <para id="para_the_next_example_shows_more_ad">The next example shows more
    advanced options for import statements:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/import-example2-script.scala

def writeAboutBigInteger() = {

  import java.math.BigInteger.{
    ONE =&gt; _,
    TEN,
    ZERO =&gt; JAVAZERO }

  // ONE is effectively undefined
  // println( "ONE: "+ONE )
  println( "TEN: "+TEN )
  println( "ZERO: "+JAVAZERO )
}

writeAboutBigInteger()</programlisting>

    <para id="para_this_example_demonstrates_two_">This example demonstrates
    two features. First, we can put import statements almost anywhere we want,
    not just at the top of the file, as required by Java. This feature allows
    us to scope the imports more narrowly. For example, we can&#x2019;t reference the
    imported <literal>BigInteger</literal> definitions outside the scope of
    the method. Another advantage of this feature is that it puts an import
    statement closer to where the imported items are actually used.</para>

    <para id="para_the_second_feature_shown_is_th">The second feature shown is
    the ability to <emphasis>rename</emphasis> imported items. First, the
    <literal>java.math.BigInteger.ONE</literal> constant is renamed to the
    underscore wildcard. This effectively makes it invisible and unavailable
    to the importing scope. This is a useful technique when you want to import
    everything <emphasis>except</emphasis> a few particular items.</para>

    <para id="para_next_the_java_math_bigintege">Next, the
    <literal>java.math.BigInteger.TEN</literal> constant is imported without
    renaming, so it can be referenced simply as <literal>TEN</literal>.</para>

    <para id="para_finally_the_java_math_bigint">Finally, the
    <literal>java.math.BigInteger.ZERO</literal> constant is given the &#x201C;alias&#x201D;
    <literal>JAVAZERO</literal>.</para>

    <para id="para_renaming_is_useful_if_you_want">Aliasing is useful if you
    want to give the item a more convenient name or you want to avoid
    ambiguities with other items in scope that have the same name.</para>

    <sect2 id="ImportsAreRelative">
      <title>Imports are Relative</title>

      <para id="para_there_s_one_other_important_th">There&#x2019;s one other
      important thing to know about imports: they are
      <emphasis>relative</emphasis>. Note the comments for the following
      imports:<indexterm>
          <primary>import statements</primary>

          <secondary>relative path used in</secondary>
        </indexterm><indexterm>
          <primary>relative imports</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/relative-imports.scala
import scala.collection.mutable._
import collection.immutable._         // Since "scala" is already imported
import _root_.scala.collection.jcl._  // full path from real "root"
package scala.actors {
  import remote._                     // We're in the scope of "scala.actors"
}</programlisting>

      <para id="para_this_is_useful_for_importing_f">Note that the last import
      statement nested in the <literal>scala.actor</literal> package scope is
      relative to that scope.</para>

      <para id="para_the_scalawiki_has_other_ex">The <link linkend="ScalaWiki" xrefstyle="select:nopage">[ScalaWiki]</link> has other examples at
      <ulink url="http://scala.sygneca.com/faqs/language#how-do-i-import"/>.</para>

      <para id="para_it_s_fairly_rare_that_you_ll_h">It&#x2019;s fairly rare that
      you&#x2019;ll have problems with relative imports, but the problem with this
      convention is that they sometimes cause surprises, especially if you are
      accustomed to languages like Java, where imports are absolute. If you
      get a mystifying compiler error that a package wasn&#x2019;t found, check that
      the statement is properly relative to the last import statement or add
      the <literal>_root_.</literal> prefix. Also, you might see an IDE or
      other tool insert an <literal>import _root_...</literal> statement in
      your code. Now you know what it means.</para>

      <warning id="para_warning_remember_that_import_">
        <para>Remember that import statements are relative, not absolute. To
        create an absolute path, start with <literal>_root_</literal>.</para>
      </warning>
    </sect2>
  </sect1>

  <sect1 id="AbstractTypesAndParameterizedTypes">
    <title>Abstract Types And Parameterized Types</title>

    <para id="para_we_mentioned_in_atasteofscal">We mentioned in <xref linkend="ATasteOfScala"/> that Scala supports <emphasis>parameterized
    types</emphasis>, which are very similar to <emphasis>generics</emphasis>
    in Java. (We could use the two terms interchangeably, but it&#x2019;s more common
    to use &#x201C;parameterized types&#x201D; in the Scala community and &#x201C;generics&#x201D; in the
    Java community.) The most obvious difference is in the syntax, where Scala
    uses square brackets (<literal>[...]</literal>), while Java uses angle
    brackets (<literal>&lt;...&gt;</literal>).<indexterm>
        <primary>generics</primary>

        <secondary>Java</secondary>
      </indexterm><indexterm>
        <primary>[ ] (square brackets)</primary>

        <secondary>use with parameterized types</secondary>
      </indexterm><indexterm>
        <primary>parameterized types</primary>
      </indexterm><indexterm>
        <primary>data types</primary>

        <secondary>parameterized types</secondary>
      </indexterm></para>

    <para id="para_for_example_a_list_of_strings">For example, a list of
    strings would be declared as follows:</para>

    <programlisting linenumbering="unnumbered">val languages: List[String] = ...</programlisting>

    <para id="para_there_are_other_important_diff">There are other important
    differences with Java&#x2019;s generics, which we&#x2019;ll explore in <xref linkend="ParameterizedTypes"/>.</para>

    <para id="para_for_now_we_ll_mention_one_oth">For now, we&#x2019;ll mention one
    other useful detail that you&#x2019;ll encounter before we can explain it in
    depth in <xref linkend="ScalasTypeSystem"/>. If you look at the
    declaration of <literal>scala.List</literal> in the Scaladocs, you&#x2019;ll see
    that the declaration is written as <literal>... class List[+A]</literal>.
    The <literal>+</literal> in front of the <literal>A</literal> means that
    <literal>List[B]</literal> is a <emphasis>subtype</emphasis> of
    <literal>List[A]</literal> for any <literal>B</literal> that is a subtype
    of <literal>A</literal>. If there is a <literal>-</literal> in front of a
    type parameter, then the relationship goes the other way;
    <literal>Foo[B]</literal> would be a <emphasis>supertype</emphasis> of
    <literal>Foo[A]</literal>, if the declaration is
    <literal>Foo[-A]</literal>.<indexterm>
        <primary>List class</primary>

        <secondary>declaration</secondary>
      </indexterm></para>

    <para id="para_scala_supports_another_type_ab">Scala supports another type
    abstraction mechanism called <emphasis>abstract types</emphasis>, used in
    many <emphasis>functional programming</emphasis> languages, such as
    Haskell. Abstract types were also considered for inclusion in Java when
    generics were adopted. We want to introduce them now because you&#x2019;ll see
    many examples of them before we dive into their details in <xref linkend="ScalasTypeSystem"/>. For a very detailed comparison of these two
    mechanisms, see <link linkend="Bruce1998" xrefstyle="select:nopage">[Bruce1998]</link>.<indexterm>
        <primary>data types</primary>

        <secondary>abstract</secondary>
      </indexterm><indexterm>
        <primary>abstract types</primary>
      </indexterm></para>

    <para id="para_abstract_types_can_be_applied_">Abstract types can be
    applied to many of the same design problems for which parameterized types
    are used. However, while the two mechanisms overlap, they are not
    redundant. Each has strengths and weaknesses for certain design
    problems.</para>

    <?dbfo-need height=”1in”
?>

    <para id="para_here_is_an_example_that_uses_a">Here is an example that
    uses an abstract type:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/abstract-types-script.scala

import java.io._

abstract class BulkReader {
  type In
  val source: In
  def read: String
}

class StringBulkReader(val source: String) extends BulkReader {
  type In = String
  def read = source
}

class FileBulkReader(val source: File) extends BulkReader {
  type In = File
  def read = {
    val in = new BufferedInputStream(new FileInputStream(source))
    val numBytes = in.available()
    val bytes = new Array[Byte](numBytes)
    in.read(bytes, 0, numBytes)
    new String(bytes)
  }
}

println( new StringBulkReader("Hello Scala!").read )
println( new FileBulkReader(new File("abstract-types-script.scala")).read )</programlisting>

    <para id="para_running_1">Running this script with
    <literal>scala</literal> produces the following output:</para>

    <screen>Hello Scala!
import java.io._

abstract class BulkReader {
...</screen>

    <para id="para_the_bulkreader__abstract__cl">The
    <literal>BulkReader</literal> <emphasis>abstract</emphasis> class declares
    three abstract members: a <literal>type</literal> named
    <literal>In</literal>, a <literal>val</literal> field
    <literal>source</literal>, and a <literal>read</literal> method. As in
    Java, instances in Scala can only be created from
    <emphasis>concrete</emphasis> classes, which must have definitions for all
    members.<indexterm>
        <primary>classes</primary>

        <secondary>abstract</secondary>
      </indexterm></para>

    <para id="para_the_derived_classes_stringbu">The derived classes,
    <literal>StringBulkReader</literal> and <literal>FileBulkReader</literal>,
    provide concrete definitions for these abstract members. We&#x2019;ll cover the
    details of class declarations in <xref linkend="BasicObjectOrientedProgramming"/> and the particulars of
    overriding member declarations in <xref linkend="OverridingMembers"/> in
    <xref linkend="AdvancedObjectOrientedProgramming"/>.</para>

    <para id="para_for_now_note_that_the_type_">For now, note that the
    <literal>type</literal> field works very much like a type parameter in a
    parameterized type. In fact, we could rewrite this example as follows,
    where we show only what would be different:</para>

    <programlisting linenumbering="unnumbered">abstract class BulkReader[In] {
  val source: In
  ...
}

class StringBulkReader(val source: String) extends BulkReader[String] {...}

class FileBulkReader(val source: File) extends BulkReader[File] {...}</programlisting>

    <para id="para_just_as_for_parameterized_type">Just as for parameterized
    types, if we define the <literal>In</literal> type to be
    <literal>String</literal>, then the <literal>source</literal> field must
    also be defined as a <literal>String</literal>. Note that the
    <literal>StringBulkReader</literal>&#x2019;s <literal>read</literal> method
    simply returns the <literal>source</literal> field, while the
    <literal>FileBulkReader</literal>&#x2019;s <literal>read</literal> method reads
    the contents of the file.</para>

    <para id="para_as_demonstrated_by_bruce1998">As demonstrated by <link linkend="Bruce1998" xrefstyle="select:nopage">[Bruce1998]</link>,
    parameterized types tend to be best for collections, which is how they are
    most often used in Java code, whereas abstract types are most useful for
    type &#x201C;families&#x201D; and other type scenarios.</para>

    <para id="para_we_ll_explore_the_details_of_s">We&#x2019;ll explore the details
    of Scala&#x2019;s abstract types in <xref linkend="ScalasTypeSystem"/>. For
    example, we&#x2019;ll see how to constrain the possible concrete types that can
    be used.</para>
  </sect1>

  <sect1 id="ReservedWords">
    <title>Reserved Words</title>

    <para id="para_reserved_words_table_lists_the_reserved_words"><xref linkend="reserved-words-table"/> lists the reserved words in Scala, which
    we sometimes call &#x201C;keywords,&#x201D; and briefly describes how they are used (see
    <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>).<indexterm>
        <primary>reserved words</primary>

        <secondary>listing of reserved words in Scala</secondary>
      </indexterm></para>

    <table id="reserved-words-table">
      <title>Reserved words</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Word</entry>

            <entry>Description</entry>

            <entry>See &#x2026;</entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal>abstract</literal></para></entry>

            <entry><para>Makes a declaration abstract. Unlike Java, the
            keyword is usually not required for abstract
            members.</para></entry>

            <entry><para><xref linkend="ClassBasics"/></para></entry>
          </row>

          <row>
            <entry><para><literal>case</literal></para></entry>

            <entry><para>Start a case clause in a match
            expression.</para></entry>

            <entry><para><xref linkend="PatternMatching"/></para></entry>
          </row>

          <row>
            <entry><para><literal>catch</literal></para></entry>

            <entry><para>Start a clause for catching thrown
            exceptions.</para></entry>

            <entry><para><xref linkend="TryCatchFinally"/></para></entry>
          </row>

          <row>
            <entry><para><literal>class</literal></para></entry>

            <entry><para>Start a class declaration.</para></entry>

            <entry><para><xref linkend="ClassBasics"/></para></entry>
          </row>

          <row>
            <entry><para><literal>def</literal></para></entry>

            <entry><para>Start a method declaration.</para></entry>

            <entry><para><xref linkend="MethodDeclarationsAndDefinitions"/></para></entry>
          </row>

          <row>
            <entry><para><literal>do</literal></para></entry>

            <entry><para>Start a <literal>do...while</literal>
            loop.</para></entry>

            <entry><para><xref linkend="OtherLoopingConstructs"/></para></entry>
          </row>

          <row>
            <entry><para><literal>else</literal></para></entry>

            <entry><para>Start an <literal>else</literal> clause for an
            <literal>if</literal> clause.</para></entry>

            <entry><para><xref linkend="IfStatements"/></para></entry>
          </row>

          <row>
            <entry><para><literal>extends</literal></para></entry>

            <entry><para>Indicates that the class or trait that follows is the
            parent type of the class or trait being declared.</para></entry>

            <entry><para><xref linkend="ParentClasses"/></para></entry>
          </row>

          <row>
            <entry><para><literal>false</literal></para></entry>

            <entry><para><literal>Boolean</literal>
            <emphasis>false</emphasis>.</para></entry>

            <entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry>
          </row>

          <row>
            <entry><para><literal>final</literal></para></entry>

            <entry><para>Applied to a class or trait to prohibit deriving
            child types from it. Applied to a member to prohibit overriding it
            in a derived class or trait.</para></entry>

            <entry><para><xref linkend="FinalDeclarations"/></para></entry>
          </row>

          <row>
            <entry><para><literal>finally</literal></para></entry>

            <entry><para>Start a clause that is executed after the
            corresponding <literal>try</literal> clause, whether or not an
            exception is thrown by the <literal>try</literal>
            clause.</para></entry>

            <entry><para><xref linkend="TryCatchFinally"/></para></entry>
          </row>

          <row>
            <entry><para><literal>for</literal></para></entry>

            <entry><para>Start a <literal>for</literal> comprehension
            (loop).</para></entry>

            <entry><para><xref linkend="ForComprehensions"/></para></entry>
          </row>

          <row>
            <entry><para><literal>forSome</literal></para></entry>

            <entry><para>Used in <emphasis>existential type</emphasis>
            declarations to <phrase role="keep-together">constrain</phrase>
            the allowed <phrase role="keep-together">concrete</phrase> types
            that can be used.</para></entry>

            <entry><para><xref linkend="ExistentialTypes"/></para></entry>
          </row>

          <row>
            <entry><para><literal>if</literal></para></entry>

            <entry><para>Start an <literal>if</literal> clause.</para></entry>

            <entry><para><xref linkend="IfStatements"/></para></entry>
          </row>

          <row>
            <entry><para><literal>implicit</literal></para></entry>

            <entry><para>Marks a method as eligible to be used as an
            <emphasis>implicit</emphasis> type converter. Marks a method
            parameter as optional, as long as a <phrase role="keep-together">type-</phrase><phrase role="keep-together">compatible</phrase> substitute object is in
            the scope where the method is called.</para></entry>

            <entry><para><xref linkend="ImplicitConversions"/></para></entry>
          </row>

          <row>
            <entry><para><literal>import</literal></para></entry>

            <entry><para>Import one or more types or members of types into the
            current scope.</para></entry>

            <entry><para><xref linkend="Importing"/></para></entry>
          </row>

          <row>
            <entry><para><literal>lazy</literal></para></entry>

            <entry><para>Defer evaluation of a
            <literal>val</literal>.</para></entry>

            <entry><para><xref linkend="LazyVals"/></para></entry>
          </row>

          <row>
            <entry><para><literal>match</literal></para></entry>

            <entry><para>Start a pattern matching clause.</para></entry>

            <entry><para><xref linkend="PatternMatching"/></para></entry>
          </row>

          <row>
            <entry><para><literal>new</literal></para></entry>

            <entry><para>Create a new instance of a class.</para></entry>

            <entry><para><xref linkend="ClassBasics"/></para></entry>
          </row>

          <row>
            <entry><para><literal>null</literal></para></entry>

            <entry><para>Value of a reference variable that has not been
            assigned a value.</para></entry>

            <entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry>
          </row>

          <row>
            <entry><para><literal>object</literal></para></entry>

            <entry><para>Start a <emphasis>singleton</emphasis> declaration: a
            <literal>class</literal> with only one <phrase role="keep-together">instance</phrase>.</para></entry>

            <entry><para><xref linkend="ClassesAndObjects"/></para></entry>
          </row>

          <row>
            <entry><para><literal>override</literal></para></entry>

            <entry><para>Override a <emphasis>concrete</emphasis> member of a
            class or trait, as long as the original is not marked
            <literal>final</literal>.</para></entry>

            <entry><para><xref linkend="OverridingMembers"/></para></entry>
          </row>

          <row>
            <entry><para><literal>package</literal></para></entry>

            <entry><para>Start a package scope declaration.</para></entry>

            <entry><para><xref linkend="Packages"/></para></entry>
          </row>

          <row>
            <entry><para><literal>private</literal></para></entry>

            <entry><para>Restrict visibility of a declaration.</para></entry>

            <entry><para><xref linkend="VisibilityRules"/></para></entry>
          </row>

          <row>
            <entry><para><literal>protected</literal></para></entry>

            <entry><para>Restrict visibility of a declaration.</para></entry>

            <entry><para><xref linkend="VisibilityRules"/></para></entry>
          </row>

          <row>
            <entry><para><literal>requires</literal></para></entry>

            <entry><para>Deprecated. Was used for <emphasis>self
            typing</emphasis>.</para></entry>

            <entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry>
          </row>

          <row>
            <entry><para><literal>return</literal></para></entry>

            <entry><para>Return from a function.</para></entry>

            <entry><para><xref linkend="ATasteOfScala"/></para></entry>
          </row>

          <row>
            <entry><para><literal>sealed</literal></para></entry>

            <entry><para>Applied to a parent class to require all directly
            derived <phrase role="keep-together">classes to be
            declared</phrase> in the same source file.</para></entry>

            <entry><para><xref linkend="CaseClasses"/></para></entry>
          </row>

          <row>
            <entry><para><literal>super</literal></para></entry>

            <entry><para>Analogous to <literal>this</literal>, but binds to
            the parent type.</para></entry>

            <entry><para><xref linkend="OverridingMethods"/></para></entry>
          </row>

          <row>
            <entry><para><literal>this</literal></para></entry>

            <entry><para>How an object refers to itself. The method name for
            <emphasis>auxiliary con&#x2060;structors</emphasis>.</para></entry>

            <entry><para><xref linkend="ClassBasics"/></para></entry>
          </row>

          <row>
            <entry><para><literal>throw</literal></para></entry>

            <entry><para>Throw an exception.</para></entry>

            <entry><para><xref linkend="TryCatchFinally"/></para></entry>
          </row>

          <row>
            <entry><para><literal>trait</literal></para></entry>

            <entry><para>A <emphasis>mixin module</emphasis> that adds
            additional state and behavior to an <phrase role="keep-together">instance</phrase> of a class.</para></entry>

            <entry><para><xref linkend="Traits"/></para></entry>
          </row>

          <row>
            <entry><para><literal>try</literal></para></entry>

            <entry><para>Start a block that may throw an
            exception.</para></entry>

            <entry><para><xref linkend="TryCatchFinally"/></para></entry>
          </row>

          <row>
            <entry><para><literal>true</literal></para></entry>

            <entry><para><literal>Boolean</literal>
            <emphasis>true</emphasis>.</para></entry>

            <entry><para><xref linkend="ScalaTypeHierarchy"/></para></entry>
          </row>

          <row>
            <entry><para><literal>type</literal></para></entry>

            <entry><para>Start a <emphasis>type</emphasis>
            declaration.</para></entry>

            <entry><para><xref linkend="AbstractTypesAndParameterizedTypes"/></para></entry>
          </row>

          <row>
            <entry><para><literal>val</literal></para></entry>

            <entry><para>Start a read-only &#x201C;variable&#x201D;
            declaration.</para></entry>

            <entry><para><xref linkend="VariableDeclarationsAndDefinitions"/></para></entry>
          </row>

          <row>
            <entry><para><literal>var</literal></para></entry>

            <entry><para>Start a read-write variable
            declaration.</para></entry>

            <entry><para><xref linkend="VariableDeclarationsAndDefinitions"/></para></entry>
          </row>

          <row>
            <entry><para><literal>while</literal></para></entry>

            <entry><para>Start a <literal>while</literal> loop.</para></entry>

            <entry><para><xref linkend="OtherLoopingConstructs"/></para></entry>
          </row>

          <row>
            <entry><para><literal>with</literal></para></entry>

            <entry><para>Include the trait that follows in the class being
            declared or the object being instantiated.</para></entry>

            <entry><para><xref linkend="Traits"/></para></entry>
          </row>

          <row>
            <entry><para><literal>yield</literal></para></entry>

            <entry><para>Return an element in a <literal>for</literal>
            comprehension that becomes part of a sequence.</para></entry>

            <entry><para><xref linkend="Yielding"/></para></entry>
          </row>

          <row>
            <entry><para><literal>_</literal></para></entry>

            <entry><para>A placeholder, used in imports, function literals,
            etc.</para></entry>

            <entry><para><emphasis>Many</emphasis></para></entry>
          </row>

          <row>
            <entry><para><literal>:</literal></para></entry>

            <entry><para>Separator between identifiers and type
            annotations.</para></entry>

            <entry><para><xref linkend="ATasteOfScala"/></para></entry>
          </row>

          <row>
            <entry><para><literal>=</literal></para></entry>

            <entry><para>Assignment.</para></entry>

            <entry><para><xref linkend="ATasteOfScala"/></para></entry>
          </row>

          <row>
            <entry><para><literal>=&gt;</literal></para></entry>

            <entry><para>Used in <emphasis>function literals</emphasis> to
            separate the argument list from the function body.</para></entry>

            <entry><para><xref linkend="FunctionLiteralsAndClosures"/></para></entry>
          </row>

          <row>
            <entry><para><literal>&lt;-</literal></para></entry>

            <entry><para>Used in <literal>for</literal> comprehensions in
            <emphasis>generator</emphasis> expressions.</para></entry>

            <entry><para><xref linkend="ForComprehensions"/></para></entry>
          </row>

          <row>
            <entry><para><literal>&lt;:</literal></para></entry>

            <entry><para>Used in <emphasis>parameterized</emphasis> and
            <emphasis>abstract type</emphasis> declarations to <phrase role="keep-together">constrain</phrase> the allowed
            types.</para></entry>

            <entry><para><xref linkend="TypeBounds"/></para></entry>
          </row>

          <row>
            <entry><para><literal>&lt;%</literal></para></entry>

            <entry><para>Used in <emphasis>parameterized</emphasis> and
            <emphasis>abstract type</emphasis> &#x201C;view bounds&#x201D; <phrase role="keep-together">declarations</phrase>.</para></entry>

            <entry><para><xref linkend="TypeBounds"/></para></entry>
          </row>

          <row>
            <entry><para><literal>&gt;:</literal></para></entry>

            <entry><para>Used in <emphasis>parameterized</emphasis> and
            <emphasis>abstract type</emphasis> declarations to <phrase role="keep-together">constrain</phrase> the allowed
            types.</para></entry>

            <entry><para><xref linkend="TypeBounds"/></para></entry>
          </row>

          <row>
            <entry><para><literal>#</literal></para></entry>

            <entry><para>Used in <emphasis>type
            projections.</emphasis></para></entry>

            <entry><para><xref linkend="PathDependentTypes"/></para></entry>
          </row>

          <row>
            <entry><para><literal>@</literal></para></entry>

            <entry><para>Marks an
            <emphasis>annotation.</emphasis></para></entry>

            <entry><para><xref linkend="Annotations"/></para></entry>
          </row>

          <row>
            <entry><para><literal>&#x21D2;</literal></para></entry>

            <entry><para>(Unicode \u21D2) Same as =&gt;.</para></entry>

            <entry><para><xref linkend="FunctionLiteralsAndClosures"/></para></entry>
          </row>

          <row>
            <entry><para><literal>&#x2190;</literal></para></entry>

            <entry><para>(Unicode \u2190) Same as &lt;-.</para></entry>

            <entry><para><xref linkend="ForComprehensions"/></para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_no_break_and_continue">Notice that <literal>break</literal>
    and <literal>continue</literal> are not listed. These control keywords
    don&#x2019;t exist in Scala. Instead, Scala encourages you to use functional
    programming idioms that are usually more succinct and less error-prone.
    We&#x2019;ll discuss alternative approaches when we discuss
    <literal>for</literal> loops (see <xref linkend="GeneratorExpressions"/>).<indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary>&lt;- (left-arrow) operator, generators</secondary>
      </indexterm><indexterm>
        <primary>@ (at sign)</primary>

        <secondary>marking annotations</secondary>
      </indexterm><indexterm>
        <primary># (pound sign)</primary>

        <secondary>use in type projections</secondary>
      </indexterm><indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary>&gt;:, constraining allowed types in parameterized and
        abstract type declarations</secondary>
      </indexterm><indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary>&lt;% indicating view bound in type declaration</secondary>
      </indexterm><indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary>&lt;:, use in parameterized and abstract type
        declarations</secondary>
      </indexterm><indexterm>
        <primary>= (equals sign)</primary>

        <secondary>=&gt; in function literals</secondary>
      </indexterm><indexterm>
        <primary>= (equals sign)</primary>

        <secondary>assignment operator</secondary>
      </indexterm><indexterm>
        <primary>: (colon)</primary>

        <secondary>separator between identifiers and type
        annotations</secondary>
      </indexterm><indexterm>
        <primary>_ (underscore)</primary>

        <secondary>placeholder in imports, function literals, etc.</secondary>
      </indexterm></para>

    <para id="para_some_java_methods_use_names_th">Some Java methods use names
    that are reserved by Scala, for example,
    <literal>java.util.Scan&#x2060;ner.match</literal>. To avoid a compilation error,
    surround the name with single back quotes, e.g.,
    <literal>java.util.Scanner.&#x2035;match&#x2035;</literal>.</para>
  </sect1>

  <sect1 id="_recap_and_what_8217_s_next_2">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_covered_several_ways_that_s">We covered several ways
    that Scala&#x2019;s syntax is concise, flexible, and productive. We also
    described many Scala features. In the next chapter, we will round out some
    Scala essentials before we dive into Scala&#x2019;s support for object-oriented
    programming and functional programming.</para>
  </sect1>
</chapter>
  <chapter id="RoundingOutTheEssentials">
  <title>Rounding Out the Essentials</title>

  <para id="para_before_we_dive_into_scala_s_su">Before we dive into Scala&#x2019;s
  support for object-oriented and functional programming, let&#x2019;s finish our
  discussion of the essential features you&#x2019;ll use in most of your
  programs.</para>

  <sect1 id="_operator_operator">
    <title>Operator? Operator?</title>

    <para id="para_an_important_fundamental_conce">An important fundamental
    concept in Scala is that all operators are actually methods. Consider this
    most basic of examples:<indexterm>
        <primary>methods</primary>

        <secondary>operators as</secondary>
      </indexterm><indexterm>
        <primary>operators</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/one-plus-two-script.scala

1 + 2</programlisting>

    <para id="para_that_plus_sign_between_the_num">That plus sign between the
    numbers? It&#x2019;s a method. First, Scala allows non-<phrase role="keep-together">alphanumeric</phrase> method names. You can call
    methods <literal>+</literal>, <literal>-</literal>, <literal>$</literal>,
    or whatever you desire. Second, this expression is identical to <literal>1
    .+(2)</literal>. (We put a space after the <literal>1</literal> because
    <literal>1.</literal> would be interpreted as a
    <literal>Double</literal>.) When a method takes one argument, Scala lets
    you drop both the period and the parentheses, so the method invocation
    looks like an operator invocation. This is called &#x201C;infix&#x201D; notation, where
    the operator is between the instance and the argument. We&#x2019;ll find out more
    about this shortly.<indexterm>
        <primary>operator notation</primary>

        <secondary>infix operator notation</secondary>
      </indexterm><indexterm>
        <primary>methods</primary>

        <secondary>operators as</secondary>

        <tertiary>infix notation</tertiary>
      </indexterm><indexterm>
        <primary>symbols</primary>

        <secondary sortas="method names">in method names and other
        identifiers</secondary>
      </indexterm><indexterm>
        <primary>infix notation</primary>
      </indexterm><indexterm>
        <primary>( ) (parentheses)</primary>

        <secondary sortas="method invocations">in method invocations,
        dropping</secondary>
      </indexterm></para>

    <para id="para_similarly_a_method_with_no_ar">Similarly, a method with no
    arguments can be invoked without the period. This is called &#x201C;postfix&#x201D;
    notation.<indexterm>
        <primary>. (dot)</primary>

        <secondary>omitting in method calls</secondary>
      </indexterm><indexterm>
        <primary>postfix notation</primary>
      </indexterm></para>

    <para id="para_ruby_and_smalltalk_programmers">Ruby and Smalltalk
    programmers should now feel right at home. As users of those languages
    know, these simple rules have far-reaching benefits when it comes to
    creating programs that flow naturally and elegantly.</para>

    <para id="para_here_is_a_summary_of_the_rules">So, what characters can you
    use in identifiers? Here is a summary of the rules for identifiers, used
    for method and type names, variables, etc. For the precise details, see
    <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>. Scala allows all the
    printable ASCII characters, such as letters, digits, the underscore
    (&#x2009;<literal>_</literal>&#x2009;), and the dollar sign (<literal>$</literal>), with
    the exceptions of the &#x201C;parenthetical&#x201D; characters&#x2014;<literal>(</literal>,
    <literal>)</literal>, <literal>[</literal>, <literal>]</literal>,
    <literal>{</literal>, and <literal>}</literal>&#x2014;and the &#x201C;delimiter&#x201D;
    characters&#x2014;<literal>`</literal>, <literal>&#x2019;</literal>,
    <literal>'</literal>, <literal>"</literal>, <literal>.</literal>,
    <literal>;</literal>, and <literal>,</literal>. Scala allows the other
    characters between \u0020&#x2013;\u007F that are not in the sets just shown, such
    as mathematical symbols and &#x201C;other&#x201D; symbols. These remaining characters
    are called <emphasis>operator characters</emphasis>, and they include
    characters such as <literal>/</literal>, <literal>&lt;</literal>,
    etc.<indexterm>
        <primary>characters</primary>

        <secondary>used in identifiers</secondary>
      </indexterm><indexterm>
        <primary>identifiers, characters allowed in</primary>
      </indexterm><indexterm>
        <primary>operator characters</primary>
      </indexterm></para>

    <variablelist id="para_identifier_rules">
      <varlistentry id="varlistentry-reserved-words-can-8217-t-be-used">
        <term>Reserved words can&#x2019;t be used</term>

        <listitem>
          <para>As in most languages, you can&#x2019;t reuse reserved words for
          identifiers. We listed the reserved words in <xref linkend="ReservedWords"/>. Recall that some of them are
          combinations of operator and punctuation characters. For example, a
          single underscore (&#x2009;<literal>_</literal>&#x2009;) is a reserved
          word!<indexterm>
              <primary>_ (underscore)</primary>

              <secondary>reserved word</secondary>
            </indexterm><indexterm>
              <primary>reserved words</primary>

              <secondary>not allowed in identifiers</secondary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-plain-identifiers-combinations-of-letters-digits-8216-8217-8216-_-8217-and-operators">
        <term>Plain identifiers&#x2014;combinations of letters, digits,
        <literal>$</literal>, <literal>_</literal>, and operators</term>

        <listitem>
          <para>Like Java and many languages, a <emphasis>plain
          identifier</emphasis> can begin with a letter or underscore,
          followed by more letters, digits, underscores, and dollar signs.
          Unicode-equivalent characters are also allowed. However, like Java,
          Scala reserves the dollar sign for internal use, so you shouldn&#x2019;t
          use it in your own identifiers. After an <phrase role="keep-together">underscore</phrase>, you can have either
          letters and digits <emphasis>or</emphasis> a sequence of operator
          characters. The underscore is important. It tells the compiler to
          treat all the characters up to the next whitespace as part of the
          identifier. For example, <literal>val xyz_++= = 1</literal> assigns
          the variable <literal>xyz_++=</literal> the value
          <literal>1</literal>, while the expression <literal>val xyz++= =
          1</literal> won&#x2019;t compile because the &#x201C;identifier&#x201D; could also be
          interpreted as <literal>xyz ++=</literal>, which looks like an
          attempt to append something to <literal>xyz</literal>. Similarly, if
          you have operator characters after the underscore, you can&#x2019;t mix
          them with letters and digits. This restriction prevents ambiguous
          expressions like this: <literal>abc_=123</literal>. Is that an
          identifier <literal>abc_=123</literal> or an assignment of the value
          <literal>123</literal> to <literal>abc_</literal>?<indexterm>
              <primary>_ (underscore)</primary>

              <secondary>in identifiers</secondary>
            </indexterm><indexterm>
              <primary>$ (dollar sign) in identifiers</primary>
            </indexterm><indexterm>
              <primary>plain identifiers</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-plain-identifiers-operators">
        <term>Plain identifiers&#x2014;operators</term>

        <listitem>
          <para>If an identifier begins with an operator character, the rest
          of the characters must be operator characters.<indexterm>
              <primary>operator characters</primary>

              <secondary>in identifiers</secondary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-8220-back-quote-8221-literals">
        <term>&#x201C;Back-quote&#x201D; literals</term>

        <listitem>
          <para>An identifier can also be an arbitrary string (subject to
          platform limitations) between two back quote characters, e.g.,
          <literal>val `this is a valid identifier` = "Hello
          World!"</literal>. Recall that this syntax is also the way to invoke
          a method on a Java or .NET class when the method&#x2019;s name is identical
          to a Scala reserved word, e.g.,
          <literal>java.net.Proxy.&#x2035;type&#x2035;()</literal>.<indexterm>
              <primary>Java</primary>

              <secondary>invoking method name identical to Scala reserved
              word</secondary>
            </indexterm><indexterm>
              <primary sortas="NET">.NET</primary>

              <secondary>invoking method name identical to Scala reserved
              word</secondary>
            </indexterm><indexterm>
              <primary>`` (back quotes) in literals</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-pattern-matching-identifiers">
        <term>Pattern matching identifiers</term>

        <listitem>
          <para>In pattern matching expressions, tokens that begin with a
          lowercase letter are parsed as <emphasis>variable
          identifiers</emphasis>, while tokens that begin with an uppercase
          letter are parsed as <emphasis>constant identifiers</emphasis>. This
          restriction prevents some ambiguities because of the very succinct
          variable syntax that is used, e.g., no <literal>val</literal>
          keyword is present.<indexterm>
              <primary>constant identifiers</primary>
            </indexterm><indexterm>
              <primary>pattern matching identifiers</primary>
            </indexterm><indexterm>
              <primary>variable identifiers</primary>
            </indexterm></para>
        </listitem>
      </varlistentry>
    </variablelist>

    <sect2 id="para_pattern_matching_identifiers_">
      <title>Syntactic Sugar</title>

      <para id="para_once_you_know_that_all_operato">Once you know that all
      operators are methods, it&#x2019;s easier to reason about unfamiliar Scala
      code. You don&#x2019;t have to worry about special cases when you see new
      operators. When working with Actors in <xref linkend="ATasteOfConcurrency"/>, you may have noticed that we used an
      exclamation point (<literal>!</literal>) to send a message to an Actor.
      Now you know that the <literal>!</literal> is just another method, as
      are the other handy shortcut operators you can use to talk to Actors.
      Similarly, Scala&#x2019;s XML library provides the <literal>\</literal> and
      <literal>\\</literal> operators to dive into document structures. These
      are just methods on the <literal>scala.xml.NodeSeq</literal>
      class.<indexterm>
          <primary>Actors</primary>

          <secondary>shortcut operators used with</secondary>
        </indexterm><indexterm>
          <primary>NodeSeq class, \ and \\ methods</primary>
        </indexterm><indexterm>
          <primary>\ (backslash)</primary>

          <secondary>\ and \\ operators for document structures</secondary>
        </indexterm><indexterm>
          <primary>! (exclamation point)</primary>

          <secondary>! method, sending messages to Actors</secondary>
        </indexterm></para>

      <para id="para_this_flexible_method_naming_gi">This flexible method
      naming gives you the power to write libraries that feel like a natural
      extension of Scala itself. You could write a new math library with
      numeric types that accept all the usual mathematical operators, like
      addition and subtraction. You could write a new concurrent messaging
      layer that behaves just like Actors. The possibilities are constrained
      only by Scala&#x2019;s method naming limitations.</para>

      <caution id="para_caution_just_because_you__can">
        <para>Just because you <emphasis>can</emphasis> doesn&#x2019;t mean you
        <emphasis>should</emphasis>. When designing your own libraries and
        APIs in Scala, keep in mind that obscure punctuational operators are
        hard for programmers to remember. Overuse of these can contribute a
        &#x201C;line noise&#x201D; quality of unreadability to your code. Stick to
        conventions and err on the side of spelling method names out when a
        shortcut doesn&#x2019;t come readily to mind.</para>
      </caution>
    </sect2>
  </sect1>

  <sect1 id="_methods_without_parentheses_and_dots">
    <title>Methods Without Parentheses and Dots</title>

    <para id="para_to_facilitate_a_variety_of_rea">To facilitate a variety of
    readable programming styles, Scala is flexible about the use of
    parentheses in methods. If a method takes no parameters, you can define it
    without parentheses. Callers must invoke the method without parentheses.
    If you add empty parentheses, then callers may optionally add parentheses.
    For example, the <literal>size</literal> method for
    <literal>List</literal> has no parentheses, so you write <literal>List(1,
    2, 3).size</literal>. If you try <literal>List(1, 2, 3).size()</literal>,
    you&#x2019;ll get an error. However, the <literal>length</literal> method for
    <literal role="keep-together">java.lang.String</literal> does have
    parentheses in its definition, but Scala lets you write both
    <literal>"hello".length()</literal> and
    <literal>"hello".length</literal>.<indexterm>
        <primary>methods</primary>

        <secondary sortas="parentheses and dots">without parentheses and
        dots</secondary>
      </indexterm></para>

    <para id="para_the_convention_in_the_scala_co">The convention in the Scala
    community is to omit parentheses when calling a method that has no
    <emphasis>side effects</emphasis>. So, asking for the size of a sequence
    is fine without parentheses, but defining a method that transforms the
    elements in the sequence should be written with parentheses. This
    convention signals a potentially tricky method for users of your
    code.<indexterm>
        <primary>. (dot)</primary>

        <secondary>omitting in method calls</secondary>
      </indexterm><indexterm>
        <primary>( ) (parentheses)</primary>

        <secondary>omitting in method invocations</secondary>
      </indexterm></para>

    <para id="para_it_s_also_possible_to_omit_the">It&#x2019;s also possible to omit
    the dot (period) when calling a parameterless method or one that takes
    only one argument. With this in mind, our <literal>List(1, 2,
    3).size</literal> example could be written as:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/no-dot-script.scala

List(1, 2, 3) size</programlisting>

    <para id="para_neat_but_confusing_when_does">Neat, but confusing. When
    does this syntactical flexibility become useful? When chaining method
    calls together into expressive, self-explanatory &#x201C;sentences&#x201D; of
    code:</para>

    <?dbfo-need height=”1in”
?>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/no-dot-better-script.scala

def isEven(n: Int) = (n % 2) == 0

List(1, 2, 3, 4) filter isEven foreach println</programlisting>

    <para id="para_as_you_might_guess_running_th">As you might guess, running
    this produces the following output:</para>

    <screen>2
4</screen>

    <para id="para_scala_s_liberal_approach_to_pa">Scala&#x2019;s liberal approach to
    parentheses and dots on methods provides one building block for writing
    <emphasis>Domain-Specific Languages</emphasis>. We&#x2019;ll learn more about
    them after a brief discussion of operator precedence.</para>

    <sect2 id="_precedence_rules">
      <title>Precedence Rules</title>

      <para id="para_so_if_an_expression_like_2_0">So, if an expression like
      <literal>2.0 * 4.0 / 3.0 * 5.0</literal> is actually a series of method
      calls on <literal>Double</literal>s, what are the <emphasis>operator
      precedence</emphasis> rules? Here they are in order from lowest to
      highest precedence (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>):<indexterm>
          <primary>methods</primary>

          <secondary sortas="parentheses and dots">without parentheses and
          dots</secondary>

          <tertiary>operator precedence</tertiary>
        </indexterm><indexterm>
          <primary>% (percent sign)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>/ (slash)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>* (asterisk)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>- (minus sign)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>+ (plus sign)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>: (colon)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>! (exclamation point)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>= (equals sign)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>&lt; &gt; (angle brackets)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>&amp; (ampersand)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>^ (caret)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>| (vertical bar)</primary>

          <secondary>operator precedence</secondary>
        </indexterm><indexterm>
          <primary>precedence, operator</primary>
        </indexterm><indexterm>
          <primary>operator precedence</primary>
        </indexterm></para>

      <orderedlist>
        <listitem>
          <para><emphasis>All letters</emphasis></para>
        </listitem>

        <listitem>
          <para><literal>|</literal></para>
        </listitem>

        <listitem>
          <para><literal>^</literal></para>
        </listitem>

        <listitem>
          <para><literal>&amp;</literal></para>
        </listitem>

        <listitem>
          <para><literal>&lt; &gt;</literal></para>
        </listitem>

        <listitem>
          <para><literal>= !</literal></para>
        </listitem>

        <listitem>
          <para><literal>:</literal></para>
        </listitem>

        <listitem>
          <para><literal>+ -</literal></para>
        </listitem>

        <listitem>
          <para><literal>* / %</literal></para>
        </listitem>

        <listitem>
          <para><emphasis>All other special characters</emphasis></para>
        </listitem>
      </orderedlist>

      <para id="para_characters_on_the_same_line_ha">Characters on the same
      line have the same precedence. An exception is <literal>=</literal> when
      used for assignment, when it has the lowest precedence.</para>

      <para id="para_since_042_and_have_the_sa">Since * and / have the same
      precedence, the two lines in the following <literal>scala</literal>
      session behave the same:</para>

      <programlisting linenumbering="unnumbered">scala&gt; 2.0 * 4.0 / 3.0 * 5.0
res2: Double = 13.333333333333332

scala&gt; (((2.0 * 4.0) / 3.0) * 5.0)
res3: Double = 13.333333333333332</programlisting>

      <para id="para_in_a_sequence_of_left_associat">In a sequence of
      left-associative method invocations, they simply bind in left-to-right
      order. &#x201C;Left-associative&#x201D; you say? In Scala, any method with a name that
      ends with a colon <literal>:</literal> actually binds to the
      <emphasis>right</emphasis>, while all other methods bind to the left.
      For example, you can prepend an element to a <literal>List</literal>
      using the <literal>::</literal> method (called &#x201C;cons,&#x201D; short for
      &#x201C;constructor&#x201D;):<indexterm>
          <primary>right-associative method invocations</primary>
        </indexterm><indexterm>
          <primary>: (colon)</primary>

          <secondary>:: (constructor) method</secondary>

          <tertiary>prepending to a list</tertiary>
        </indexterm><indexterm>
          <primary>: (colon)</primary>

          <secondary>methods ending in, right-associative
          invocation</secondary>
        </indexterm><indexterm>
          <primary>left-associative method invocations</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">scala&gt; val list = List('b', 'c', 'd')
list: List[Char] = List(b, c, d)

scala&gt; 'a' :: list
res4: List[Char] = List(a, b, c, d)</programlisting>

      <para id="para_the_second_expression_is_equiv">The second expression is
      equivalent to <literal>list.::(<replaceable>a</replaceable>)</literal>.
      In a sequence of right-associative method invocations, they bind from
      right to left. What about a mixture of left-binding and right-binding
      expressions?</para>

      <programlisting linenumbering="unnumbered">scala&gt; 'a' :: list ++ List('e', 'f')
res5: List[Char] = List(a, b, c, d, e, f)</programlisting>

      <para>(The <literal>++</literal> method appends two lists.) In this
      case, <literal>list</literal> is added to the
      <literal>List(<replaceable>e</replaceable>,
      <replaceable>f</replaceable>)</literal>, then
      <literal><replaceable>a</replaceable></literal> is prepended to create
      the final list. It&#x2019;s usually better to add parentheses to remove any
      potential uncertainty.<indexterm>
          <primary>+ (plus sign)</primary>

          <secondary>++ method, appending to lists</secondary>
        </indexterm></para>

      <tip id="para_tip_any_method_whose_name_end">
        <para>Any method whose name ends with a <literal>:</literal> binds to
        the <emphasis>right</emphasis>, not the
        <emphasis>left</emphasis>.</para>
      </tip>

      <para>Finally, note that when you use the <literal>scala</literal>
      command, either interactively or with scripts, it may appear that you
      can define &#x201C;global&#x201D; variables and methods outside of types. This is
      actually an illusion; the interpreter wraps all definitions in an
      anonymous type before generating JVM or .NET CLR byte code.</para>
    </sect2>
  </sect1>

  <sect1 id="_domain_specific_languages">
    <title>Domain-Specific Languages</title>

    <para id="para_domain_specific_languages_or_"><emphasis>Domain-Specific
    Languages</emphasis>, or DSLs, provide a convenient syntactical means for
    expressing goals in a given problem domain. For example, SQL provides just
    enough of a programming language to handle the problems of working with
    databases, making it a Domain-Specific Language.<indexterm>
        <primary>DSLs (Domain-Specific Languages)</primary>
      </indexterm></para>

    <para id="para_while_some_dsls_like_sql_are_s">While some DSLs like SQL
    are self-contained, it&#x2019;s become popular to implement DSLs as subsets of
    full-fledged programming languages. This allows programmers to leverage
    the entirety of the host language for edge cases that the DSL does not
    cover, and saves the work of writing lexers, parsers, and the other
    building blocks of a language.<indexterm>
        <primary>BDD (Behavior-Driven Development)</primary>
      </indexterm><indexterm>
        <primary>Specs library</primary>
      </indexterm></para>

    <para id="para_scala_s_rich_flexible_syntax_">Scala&#x2019;s rich, flexible
    syntax makes writing DSLs a breeze. Consider this example of a style of
    test writing called <emphasis>Behavior-Driven Development</emphasis> (see
    <link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>) using the
    Specs library (see <xref linkend="ScalaSpecs"/>):</para>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/specs-script.scala

"nerd finder" should {
  "identify nerds from a List" in {
    val actors = List("Rick Moranis", "James Dean", "Woody Allen")
    val finder = new NerdFinder(actors)
    finder.findNerds mustEqual List("Rick Moranis", "Woody Allen")
  }
}</programlisting>

    <para id="para_notice_how_much_this_code_read">Notice how much this code
    reads like English: &#x201C;This should test that in the following scenario,&#x201D;
    &#x201C;This value must equal that value,&#x201D; and so forth. This example uses the
    <phrase role="keep-together">superb</phrase> Specs library, which
    effectively provides a DSL for the Behavior-Driven Development testing and
    engineering methodology. By making maximum use of Scala&#x2019;s liberal syntax
    and rich methods, Specs test suites are readable even by
    non-developers.</para>

    <para id="para_this_is_just_a_taste_of_the_po">This is just a taste of the
    power of DSLs in Scala. We&#x2019;ll see other examples later and learn how to
    write our own as we get more advanced (see <xref linkend="DomainSpecificLanguages"/>).</para>
  </sect1>

  <sect1 id="IfStatements">
    <title>Scala if Statements</title>

    <para id="para_even_the_most_familiar_languag">Even the most familiar
    language features are supercharged in Scala. Let&#x2019;s have a look at the
    lowly <literal>if</literal> statement. As in most every language, Scala&#x2019;s
    <literal>if</literal> evaluates a conditional expression, then proceeds to
    a block if the result is <literal>true</literal>, or branches to an
    alternate block if the result is <literal>false</literal>. A simple
    example:<indexterm>
        <primary>if statements</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/if-script.scala

if (2 + 2 == 5) {
  println("Hello from 1984.")
} else if (2 + 2 == 3) {
    println("Hello from Remedial Math class?")
} else {
  println("Hello from a non-Orwellian future.")
}</programlisting>

    <para id="para_what_s_different_in_scala_is_t">What&#x2019;s different in Scala
    is that <literal>if</literal> and almost all other statements are actually
    expressions themselves. So, we can assign the result of an
    <literal>if</literal> expression, as shown here:<indexterm>
        <primary>expressions</primary>

        <secondary>if statements as</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/assigned-if-script.scala

val configFile = new java.io.File("~/.myapprc")

val configFilePath = if (configFile.exists()) {
  configFile.getAbsolutePath()
} else {
  configFile.createNewFile()
  configFile.getAbsolutePath()
}</programlisting>

    <para id="para_note_that_if_statements_are_">Note that
    <literal>if</literal> statements are expressions, meaning they have
    values. In this example, the value <literal>configFilePath</literal> is
    the result of an <literal>if</literal> expression that handles the case of
    a configuration file not existing internally, then returns the absolute
    path to that file. This value can now be reused throughout an application,
    and the <literal>if</literal> expression won&#x2019;t be reevaluated when the
    value is used.</para>

    <para id="para_because_if_statements_are_ex">Because <literal>if</literal>
    statements are expressions in Scala, there is no need for the special-case
    ternary conditional expressions that exist in C-derived languages. You
    won&#x2019;t see <literal>x ? doThis() : doThat()</literal> in Scala. Scala
    provides a mechanism that&#x2019;s just as powerful and more readable.<indexterm>
        <primary>else clause (if statements)</primary>
      </indexterm></para>

    <para id="para_what_if_we_forget_the_els">What if we omit the
    <literal>else</literal> clause in the previous example? Typing the code in
    the <literal>scala</literal> interpreter will tell us what happens:</para>

    <programlisting linenumbering="unnumbered">scala&gt; val configFile = new java.io.File("~/.myapprc")
configFile: java.io.File = ~/.myapprc

scala&gt; val configFilePath = if (configFile.exists()) {
     |   configFile.getAbsolutePath()
     | }
configFilePath: Unit = ()

scala&gt;</programlisting>

    <para id="para_note_that_configfilepath_is_">Note that
    <literal>configFilePath</literal> is now <literal>Unit</literal>. (It was
    <literal>String</literal> before.) The type inference picks a type that
    works for all outcomes of the <literal>if</literal> expression.
    <literal>Unit</literal> is the only possibility, since no value is one
    possible outcome.</para>
  </sect1>

  <sect1 id="ForComprehensions">
    <title>Scala for Comprehensions</title>

    <para id="para_another_familiar_control_struc">Another familiar control
    structure that&#x2019;s particularly feature-rich in Scala is the
    <literal>for</literal> loop, referred to in the Scala community as a
    <literal>for</literal> <emphasis>comprehension</emphasis> or
    <literal>for</literal> <emphasis>expression</emphasis>. This corner of the
    language deserves at least one fancy name, because it can do some great
    party tricks.<indexterm class="startofrange" id="ch03_loopsfor">
        <primary>loops</primary>

        <secondary>for loops or comprehensions</secondary>
      </indexterm><indexterm>
        <primary>expressions</primary>

        <secondary>for expression</secondary>
      </indexterm><indexterm class="startofrange" id="ch03_forcomps">
        <primary>for comprehensions</primary>
      </indexterm></para>

    <para id="para_comprehension_description">Actually, the term
    <literal>comprehension</literal> comes from functional programming. It
    expresses the idea that we are traversing a set of some kind,
    &#x201C;comprehending&#x201D; what we find, and computing something new from
    it.<indexterm>
        <primary>comprehensions</primary>
      </indexterm></para>

    <sect2 id="_a_dog_simple_example">
      <title>A Dog-Simple Example</title>

      <para id="para_let_s_start_with_a_basic_for_">Let&#x2019;s start with a basic
      <literal>for</literal> expression:<indexterm>
          <primary>for comprehensions</primary>

          <secondary>simple example</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/basic-for-script.scala

val dogBreeds = List("Doberman", "Yorkshire Terrier", "Dachshund",
                     "Scottish Terrier", "Great Dane", "Portuguese Water Dog")

for (breed &lt;- dogBreeds)
  println(breed)</programlisting>

      <para id="para_as_you_might_guess_this_code_">As you might guess, this
      code says, &#x201C;For every element in the list <literal>dogBreeds</literal>,
      create a temporary variable called <literal>breed</literal> with the
      value of that element, then print it.&#x201D; Think of the
      <literal>&lt;-</literal> operator as an arrow directing elements of a
      collection, one by one, to the scoped variable by which we&#x2019;ll refer to
      them inside the <literal>for</literal> expression. The left-arrow
      operator is called a <emphasis>generator</emphasis>, so named because
      it&#x2019;s <emphasis>generating</emphasis> individual values from a collection
      for use in an expression.<indexterm>
          <primary>&lt; &gt; (angle brackets)</primary>

          <secondary>&lt;- (left-arrow) operator, generators</secondary>
        </indexterm><indexterm>
          <primary>arrow operator (&lt;-)</primary>
        </indexterm><indexterm>
          <primary>generators</primary>

          <secondary>&lt;- (left-arrow) operator</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="_filtering">
      <title>Filtering</title>

      <para id="para_what_if_we_want_to_get_more_gr">What if we want to get
      more granular? Scala&#x2019;s <literal>for</literal> expressions allow for
      <emphasis>filters</emphasis> that let us specify which elements of a
      collection we want to work with. So to find all terriers in our list of
      dog breeds, we could modify the previous example to the
      following:<indexterm>
          <primary>filtering</primary>

          <secondary sortas="for expressions">in for expressions</secondary>
        </indexterm><indexterm>
          <primary>for comprehensions</primary>

          <secondary>filters in</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/filtered-for-script.scala

for (breed &lt;- dogBreeds
  if breed.contains("Terrier")
) println(breed)</programlisting>

      <para id="para_to_add_more_than_one_filter_to">To add more than one
      filter to a <literal>for</literal> expression, separate the filters with
      semicolons:<indexterm>
          <primary>; (semicolon)</primary>

          <secondary>separators in for expression</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/double-filtered-for-script.scala

for (breed &lt;- dogBreeds
  if breed.contains("Terrier");
  if !breed.startsWith("Yorkshire")
) println(breed)</programlisting>

      <para id="para_you_ve_now_found_all_the_terri">You&#x2019;ve now found all the
      terriers that don&#x2019;t hail from Yorkshire, and hopefully learned just how
      useful filters can be in the process.</para>
    </sect2>

    <sect2 id="Yielding">
      <title>Yielding</title>

      <para id="para_what_if_rather_than_printing_">What if, rather than
      printing your filtered collection, you needed to hand it off to <phrase role="keep-together">another</phrase> part of your program? The
      <literal>yield</literal> keyword is your ticket to generating new
      <phrase role="keep-together">collections</phrase> with
      <literal>for</literal> expressions. In the following example, note that
      we&#x2019;re wrapping up the <literal>for</literal> expression in curly braces,
      as we would when defining any block:<indexterm>
          <primary>{ } (curly braces)</primary>

          <secondary>enclosing for expressions</secondary>
        </indexterm><indexterm>
          <primary>for comprehensions</primary>

          <secondary>yielding collections</secondary>
        </indexterm><indexterm>
          <primary>yield keyword</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/yielding-for-script.scala

val filteredBreeds = for {
  breed &lt;- dogBreeds
  if breed.contains("Terrier")
  if !breed.startsWith("Yorkshire")
} yield breed</programlisting>

      <tip id="para_tip_for_expressions_may_be_">
        <para><literal>for</literal> expressions may be defined with
        parentheses or curly braces, but using curly braces means you don&#x2019;t
        have to separate your filters with semicolons. Most of the time,
        you&#x2019;ll prefer using curly braces when you have more than one filter,
        assignment, etc.</para>
      </tip>

      <para id="para_every_time_through_the_for_e">Every time through the
      <literal>for</literal> expression, the filtered result is yielded as a
      value named <literal>breed</literal>. These results accumulate with
      every run, and the resulting collection is assigned to the value
      <literal>filteredBreeds</literal> (as we did with <literal>if</literal>
      statements earlier). The type of the collection resulting from a
      <literal>for-yield</literal> expression is inferred from the type of the
      collection being iterated over. In this case,
      <literal>filteredBreeds</literal> is of type
      <literal>List[String]</literal>, since it is a subset of the
      <literal>dogBreeds</literal> list, which is also of type
      <literal>List[String]</literal>.</para>
    </sect2>

    <sect2 id="_expanded_scope">
      <title>Expanded Scope</title>

      <para id="para_one_final_useful_feature_of_sc">One final useful feature
      of Scala&#x2019;s <literal>for</literal> comprehensions is the ability to
      define variables inside the first part of your <literal>for</literal>
      expressions that can be used in the latter part. This is best
      illustrated with an example:<indexterm>
          <primary>variables</primary>

          <secondary>expanded scope in for expressions</secondary>
        </indexterm><indexterm>
          <primary>scope</primary>

          <secondary>expanded variable scope in for comprehensions</secondary>
        </indexterm><indexterm>
          <primary>for comprehensions</primary>

          <secondary>expanded variable scope</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/scoped-for-script.scala

for {
  breed &lt;- dogBreeds
  upcasedBreed = breed.toUpperCase()
} println(upcasedBreed)</programlisting>

      <para id="para_note_that_without_declaring_u">Note that without
      declaring <literal>upcasedBreed</literal> as a <literal>val</literal>,
      you can reuse it within the body of your <literal>for</literal>
      expression. This approach is ideal for transforming elements in a
      collection as you loop through them.</para>

      <para id="para_finally_in_optionsandforcom">Finally, in <xref linkend="OptionsAndForComprehensions"/>, we&#x2019;ll see how using
      <literal>Options</literal> with <literal>for</literal> comprehensions
      can greatly reduce code size by eliminating unnecessary &#x201C;null&#x201D; and
      &#x201C;missing&#x201D; checks.<indexterm class="endofrange" startref="ch03_loopsfor"/><indexterm class="endofrange" startref="ch03_forcomps"/></para>
    </sect2>
  </sect1>

  <sect1 id="OtherLoopingConstructs">
    <title>Other Looping Constructs</title>

    <para>Scala provides several other looping constructs.</para>

    <sect2 id="_scala_while_loops">
      <title>Scala while Loops</title>

      <para id="para_familiar_in_many_languages_th">Familiar in many
      languages, the <literal>while</literal> loop executes a block of code as
      long as a condition is true. For example, the following code prints out
      a complaint once a day until the next Friday the 13th has
      arrived:<indexterm>
          <primary>while loops</primary>
        </indexterm><indexterm>
          <primary>loops</primary>

          <secondary>while</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/while-script.scala
// WARNING: This script runs for a LOOOONG time!

import java.util.Calendar

def isFridayThirteen(cal: Calendar): Boolean = {
  val dayOfWeek = cal.get(Calendar.DAY_OF_WEEK)
  val dayOfMonth = cal.get(Calendar.DAY_OF_MONTH)

  // Scala returns the result of the last expression in a method
  (dayOfWeek == Calendar.FRIDAY) &amp;&amp; (dayOfMonth == 13)
}

while (!isFridayThirteen(Calendar.getInstance())) {
  println("Today isn't Friday the 13th. Lame.")
  // sleep for a day
  Thread.sleep(86400000)
}</programlisting>

      <para id="para_you_can_find_a_table_of_the_co"><xref linkend="conditional-operators"/> later in this chapter shows the
      conditional operators that work in <literal>while</literal>
      loops.</para>
    </sect2>

    <sect2 id="_scala_do_while_loops">
      <title>Scala do-while Loops</title>

      <para id="para_like_the_while_loop_above_a">Like the
      <literal>while</literal> loop, a <literal>do-while</literal> loop
      executes some code while a conditional expression is true. The only
      difference that a <literal>do-while</literal> checks to see if the
      condition is true <emphasis>after</emphasis> running the block. To count
      up to 10, we could write this:<indexterm>
          <primary>loops</primary>

          <secondary>do-while</secondary>
        </indexterm><indexterm>
          <primary>do-while loops</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/do-while-script.scala

var count = 0

do {
  count += 1
  println(count)
} while (count &lt; 10)</programlisting>

      <para id="para_as_it_turns_out_there_s_a_mor">As it turns out, there&#x2019;s a
      more elegant way to loop through collections in Scala, as we&#x2019;ll see in
      the next section.</para>
    </sect2>

    <sect2 id="GeneratorExpressions">
      <title>Generator Expressions</title>

      <para id="para_remember_the_arrow_operator_">Remember the arrow operator
      (<literal>&lt;-</literal>) from the discussion about
      <literal>for</literal> loops? We can put it to work here, too. Let&#x2019;s
      clean up the <literal>do-while</literal> example just shown:<indexterm>
          <primary>&lt; &gt; (angle brackets)</primary>

          <secondary>&lt;- (left-arrow) operator, generators</secondary>
        </indexterm><indexterm>
          <primary>loops</primary>

          <secondary>generator expressions in</secondary>
        </indexterm><indexterm>
          <primary>generator expressions</primary>
        </indexterm><indexterm>
          <primary>arrow operator (&lt;-)</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/generator-script.scala

for (i &lt;- 1 to 10) println(i)</programlisting>

      <para>Yup, that&#x2019;s all that&#x2019;s necessary. This clean one-liner is possible
      because of Scala&#x2019;s <literal>RichInt</literal> class. An
      <emphasis>implicit conversion</emphasis> is invoked by the compiler to
      convert the <literal>1</literal>, an <literal>Int</literal>, into a
      <literal>RichInt</literal>. (We&#x2019;ll discuss these conversions in <xref linkend="ScalaTypeHierarchy"/> and in <xref linkend="ImplicitConversions"/>.) <literal>RichInt</literal> defines a
      <literal>to</literal> method that takes another integer and returns an
      instance of <literal>Range.Inclusive</literal>. That is,
      <literal>Inclusive</literal> is a nested class in the
      <literal>Range</literal> <emphasis>companion object</emphasis> (a
      concept we introduced briefly in <xref linkend="IntroducingScala"/>;
      see <xref linkend="AdvancedObjectOrientedProgramming"/> for details).
      This subclass of the <emphasis>class</emphasis> <literal>Range</literal>
      inherits a number of methods for working with sequences and iterable
      data structures, including those necessary to use it in a
      <literal>for</literal> loop.<indexterm>
          <primary>sequences</primary>

          <secondary>Range.Inclusive class</secondary>
        </indexterm><indexterm>
          <primary>Range.Inclusive class</primary>
        </indexterm><indexterm>
          <primary>RichInt class</primary>
        </indexterm><indexterm>
          <primary>implicit conversions</primary>

          <secondary>Int into RichInt</secondary>
        </indexterm></para>

      <para id="para_by_the_way_if_you_wanted_to_c">By the way, if you wanted
      to count from 1 up to but not including 10, you could use
      <literal>until</literal> instead of <literal>to</literal>. For example:
      <literal>for (i &lt;- 0 until 10)</literal>.</para>

      <para id="para_this_should_paint_a_clearer_pi">This should paint a
      clearer picture of how Scala&#x2019;s internal libraries compose to form
      easy-to-use language constructs.</para>

      <note id="para_note_when_working_with_loops_">
        <para>When working with loops in most languages, you can
        <literal>break</literal> out of a loop or <literal>continue</literal>
        the iterations. Scala doesn&#x2019;t have either of these statements, but
        when writing idiomatic Scala code, they&#x2019;re not necessary. Use
        conditional expressions to test if a loop should continue, or make use
        of recursion. Better yet, filter your collections ahead of time to
        eliminate complex conditions within your loops. However, because of
        demand for it, Scala version 2.8 includes support for
        <literal>break</literal>, implemented as a library method, rather than
        a built-in <literal>break</literal> keyword.<indexterm>
            <primary>break method</primary>
          </indexterm></para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="_conditional_operators">
    <title>Conditional Operators</title>

    <para id="para_scala_borrows_most_of_the_cond">Scala borrows most of the
    conditional operators from Java and its predecessors. You&#x2019;ll find the ones
    listed in <xref linkend="conditional-operators"/> in
    <literal>if</literal> statements, <literal>while</literal> loops, and
    everywhere else conditions apply.<indexterm>
        <primary>! (exclamation point)</primary>

        <secondary>!= (not equal) operator</secondary>
      </indexterm><indexterm>
        <primary>equals operator (==)</primary>
      </indexterm><indexterm>
        <primary>= (equals sign)</primary>

        <secondary>== (equals) operator</secondary>
      </indexterm><indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary>&lt; (less than) operator</secondary>
      </indexterm><indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary>&gt; (greater than) operator</secondary>
      </indexterm><indexterm>
        <primary>and operator (&amp;&amp;)</primary>
      </indexterm><indexterm>
        <primary>or operator (||)</primary>
      </indexterm><indexterm>
        <primary>| (vertical bar)</primary>

        <secondary>|| (or) operator</secondary>
      </indexterm><indexterm>
        <primary>&amp; (ampersand)</primary>

        <secondary>&amp;&amp; (and) operator</secondary>
      </indexterm><indexterm>
        <primary>operators</primary>

        <secondary>conditional</secondary>
      </indexterm><indexterm>
        <primary>conditional operators</primary>
      </indexterm></para>

    <table id="conditional-operators">
      <title>Conditional operators</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Operator</entry>

            <entry>Operation</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal>&amp;&amp;</literal></para></entry>

            <entry><para>and</para></entry>

            <entry><para>The values on the left and right of the operator are
            true. The righthand side is <emphasis>only</emphasis> evaluated if
            the lefthand side is <emphasis>true</emphasis>.</para></entry>
          </row>

          <row>
            <entry><para><literal>||</literal></para></entry>

            <entry><para>or</para></entry>

            <entry><para>At least one of the values on the left or right is
            true. The righthand side is <emphasis>only</emphasis> evaluated if
            the lefthand side is <emphasis>false</emphasis>.</para></entry>
          </row>

          <row>
            <entry><para><literal>&gt;</literal></para></entry>

            <entry><para>greater than</para></entry>

            <entry><para>The value on the left is greater than the value on
            the right.</para></entry>
          </row>

          <row>
            <entry><literal>&gt;=</literal></entry>

            <entry>greater than or equals</entry>

            <entry>The value on the left is greater than or equal to the value
            on the right.</entry>
          </row>

          <row>
            <entry><para><literal>&lt;</literal></para></entry>

            <entry><para>less than</para></entry>

            <entry><para>The value on the left is less than the value on the
            right.</para></entry>
          </row>

          <row>
            <entry><literal>&lt;=</literal></entry>

            <entry>less than or equals</entry>

            <entry>The value on the left is less than or equal to the value on
            the right.</entry>
          </row>

          <row>
            <entry><para><literal>==</literal></para></entry>

            <entry><para>equals</para></entry>

            <entry><para>The value on the left is the same as the value on the
            right.</para></entry>
          </row>

          <row>
            <entry><para><literal>!=</literal></para></entry>

            <entry><para>not equal</para></entry>

            <entry><para>The value on the left is not the same as the value on
            the right.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_note_that_and_are_">Note that <literal>&amp;&amp;</literal>
    and <literal>||</literal> are &#x201C;short-circuiting&#x201D; operators. They stop
    evaluating expressions as soon as the answer is known.<indexterm>
        <primary>short-circuiting operators (&amp;&amp; and ||)</primary>
      </indexterm></para>

    <para id="para_we_ll_discuss_object_equality_">We&#x2019;ll discuss object
    equality in more detail in <xref linkend="EqualityOfObjects"/>. For
    example, we&#x2019;ll see that <literal>==</literal> has a different meaning in
    Scala versus Java. Otherwise, these operators should all be familiar, so
    let&#x2019;s move on to something new and exciting.</para>
  </sect1>

  <sect1 id="PatternMatching">
    <title>Pattern Matching</title>

    <para id="para_an_idea_borrowed_from_function">An idea borrowed from
    functional languages, <emphasis>pattern matching</emphasis> is a powerful
    yet concise way to make a programmatic choice between multiple conditions.
    Pattern matching is the familiar <literal>case</literal> statement from
    your favorite C-like language, but on steroids. In the typical
    <literal>case</literal> statement you&#x2019;re limited to matching against
    values of ordinal types, yielding trivial expressions like this: &#x201C;In the
    case that <literal>i</literal> is 5, print a message; in the case that
    <literal>i</literal> is 6, exit the program.&#x201D; With Scala&#x2019;s pattern
    matching, your cases can include types, wildcards, sequences, regular
    expressions, and even deep inspections of an object&#x2019;s variables.<indexterm class="startofrange" id="ch03_patternmatching">
        <primary>pattern matching</primary>
      </indexterm></para>

    <sect2 id="ASimpleMatch">
      <title>A Simple Match</title>

      <para id="para_to_begin_with_let_s_simulate_">To begin with, let&#x2019;s
      simulate flipping a coin by matching the value of a boolean:<indexterm>
          <primary>pattern matching</primary>

          <secondary>simple match of boolean values</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-boolean-script.scala

val bools = List(true, false)

for (bool &lt;- bools) {
  bool match {
    case true =&gt; println("heads")
    case false =&gt; println("tails")
    case _ =&gt; println("something other than heads or tails (yikes!)")
  }
}</programlisting>

      <para id="para_it_looks_just_like_a_c_style_">It looks just like a
      C-style <literal>case</literal> statement, right? The only difference is
      the last <literal>case</literal> with the underscore
      (&#x2009;<literal>_</literal>&#x2009;) wildcard. It matches anything not defined in
      the cases above it, so it serves the same purpose as the
      <literal>default</literal> keyword in Java and C#
      <literal>switch</literal> statements.<indexterm>
          <primary>case statements</primary>

          <secondary>pattern matching versus</secondary>
        </indexterm></para>

      <para id="para_pattern_matching_is__eager__t">Pattern matching is
      <emphasis>eager</emphasis>; the first match wins. So, if you try to put
      a <literal>case _</literal> clause before any other
      <literal>case</literal> clauses, the compiler will throw an &#x201C;unreachable
      code&#x201D; error on the next clause, because nothing will get past the
      default clause!<indexterm>
          <primary>_ (underscore)</primary>

          <secondary>wildcard character in Scala</secondary>
        </indexterm><indexterm>
          <primary>cases in pattern matching</primary>

          <secondary>unreachable case</secondary>
        </indexterm><indexterm>
          <primary>eager matching</primary>
        </indexterm></para>

      <tip id="para_tip_use_case___for_the_defa">
        <para>Use <literal>case _</literal> for the default, &#x201C;catch-all&#x201D;
        match.</para>
      </tip>

      <para id="para_what_if_we_want_to_work_with_m">What if we want to work
      with matches as variables?</para>
    </sect2>

    <sect2 id="VariablesInMatches">
      <title>Variables in Matches</title>

      <para id="para_in_this_example_we_assign_the">In the following example,
      we assign the wildcard case to a variable called
      <literal>otherNum&#x2060;ber</literal>, then print it in the subsequent
      expression. If we generate a 7, we&#x2019;ll extol that number&#x2019;s virtues.
      Otherwise, we&#x2019;ll curse fate for making us suffer an unlucky
      number:<indexterm>
          <primary>variables</primary>

          <secondary sortas="matches">in matches</secondary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary>variables in matches</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-variable-script.scala

import scala.util.Random

val randomInt = new Random().nextInt(10)

randomInt match {
  case 7 =&gt; println("lucky seven!")
  case otherNumber =&gt; println("boo, got boring ol' " + otherNumber)
}</programlisting>
    </sect2>

    <sect2 id="MatchingOnType">
      <title>Matching on Type</title>

      <para id="para_these_simple_examples_don_t_ev">These simple examples
      don&#x2019;t even begin to scratch the surface of Scala&#x2019;s pattern matching
      features. Let&#x2019;s try matching based on type:<indexterm>
          <primary>data types</primary>

          <secondary>pattern matching on type</secondary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary sortas="type">on type</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-type-script.scala

val sundries = List(23, "Hello", 8.5, 'q')

for (sundry &lt;- sundries) {
  sundry match {
    case i: Int =&gt; println("got an Integer: " + i)
    case s: String =&gt; println("got a String: " + s)
    case f: Double =&gt; println("got a Double: " + f)
    case other =&gt; println("got something else: " + other)
  }
}</programlisting>

      <para id="para_here_we_pull_each_element_out_">Here we pull each element
      out of a <literal>List</literal> of <literal>Any</literal> type of
      element, in this case containing a <literal>String</literal>, a
      <literal>Double</literal>, an <literal>Int</literal>, and a
      <literal>Char</literal>. For the first three of those types, we let the
      user know specifically which type we got and what the value was. When we
      get something else (the <literal>Char</literal>), we just let the user
      know the value. We could add further elements to the list of other types
      and they&#x2019;d be caught by the <literal>other</literal> wildcard
      case.</para>
    </sect2>

    <sect2 id="MatchingOnSequences">
      <title>Matching on Sequences</title>

      <para id="para_since_working_in_scala_often_m">Since working in Scala
      often means working with sequences, wouldn&#x2019;t it be handy to be able to
      match against the length and contents of lists and arrays? The following
      example does just that, testing two lists to see if they contain four
      elements, the second of which is the integer
      <literal>3</literal>:<indexterm>
          <primary>pattern matching</primary>

          <secondary sortas="sequences">on sequences</secondary>
        </indexterm><indexterm>
          <primary>sequences</primary>

          <secondary>matching on</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-seq-script.scala

val willWork = List(1, 3, 23, 90)
val willNotWork = List(4, 18, 52)
val empty = List()

for (l &lt;- List(willWork, willNotWork, empty)) {
  l match {
    case List(_, 3, _, _) =&gt; println("Four elements, with the 2nd being '3'.")
    case List(_*) =&gt; println("Any other list with 0 or more elements.")
  }
}</programlisting>

      <para id="para_in_the_second_case_of_we_ve_">In the second
      <literal>case</literal> we&#x2019;ve used a special wildcard pattern to match a
      <literal>List</literal> of any size, even zero elements, and any element
      values. You can use this pattern at the end of any sequence match to
      remove length as a condition.<indexterm>
          <primary>: (colon)</primary>

          <secondary>:: (constructor) method</secondary>

          <tertiary>extracting head and tail of list</tertiary>
        </indexterm></para>

      <para id="para_recall_that_we_mentioned_the_">Recall that we mentioned
      the &#x201C;cons&#x201D; method for <literal>List</literal>, <literal>::</literal>.
      The expression <literal>a :: list</literal> prepends
      <literal>a</literal> to a list. You can also use this operator to
      extract the head and tail of a list:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-list-script.scala

val willWork = List(1, 3, 23, 90)
val willNotWork = List(4, 18, 52)
val empty = List()

def processList(l: List[Any]): Unit = l match {
  case head :: tail =&gt;
    format("%s ", head)
    processList(tail)
  case Nil =&gt; println("")
}

for (l &lt;- List(willWork, willNotWork, empty)) {
  print("List: ")
  processList(l)
}</programlisting>

      <para id="para_the_processlist_method_match">The
      <literal>processList</literal> method matches on the
      <literal>List</literal> argument l. It may look strange to start the
      method definition like the following:</para>

      <programlisting linenumbering="unnumbered">def processList(l: List[Any]): Unit = l match {
  ...
}</programlisting>

      <para id="para_hopefully_hiding_the_details_w">Hopefully hiding the
      details with the ellipsis makes the meaning a little clearer. The
      <literal>processList</literal> method is actually one statement that
      crosses several lines.</para>

      <para id="para_it_first_matches_on_head_05">It first matches on
      <literal>head :: tail</literal>, where <literal>head</literal> will be
      assigned the first element in the list and <literal>tail</literal> will
      be assigned the rest of the list. That is, we&#x2019;re extracting the head and
      tail from the list using <literal>::</literal>. When this case matches,
      it prints the <literal>head</literal> and calls
      <literal>processList</literal> recursively to process the tail.</para>

      <para id="para_the_second_case_matches_the_em">The second case matches
      the empty list, <literal>Nil</literal>. It prints an end of line and
      terminates the recursion.</para>
    </sect2>

    <sect2 id="MatchingOnTuples">
      <title>Matching on Tuples (and Guards)</title>

      <para id="para_alternately_if_we_just_wanted">Alternately, if we just
      wanted to test that we have a tuple of two items, we could do a tuple
      match:<indexterm>
          <primary>tuples</primary>

          <secondary>pattern matching on</secondary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary>matching on tuples and guards</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-tuple-script.scala

val tupA = ("Good", "Morning!")
val tupB = ("Guten", "Tag!")

for (tup &lt;- List(tupA, tupB)) {
  tup match {
    case (thingOne, thingTwo) if thingOne == "Good" =&gt;
        println("A two-tuple starting with 'Good'.")
    case (thingOne, thingTwo) =&gt;
        println("This has two things: " + thingOne + " and " + thingTwo)
  }
}</programlisting>

      <para id="para_in_the_second_case_in_this_e">In the second
      <literal>case</literal> in this example, we&#x2019;ve extracted the values
      inside the tuple to scoped variables, then reused these variables in the
      resulting expression.</para>

      <para id="para_in_the_first_case_we_ve_added_">In the first case we&#x2019;ve
      added a new concept: <emphasis>guards</emphasis>. The
      <literal>if</literal> condition after the tuple is a guard. The guard is
      evaluated when matching, but only extracting any variables in the
      preceding part of the case. Guards provide additional granularity when
      constructing cases. In this example, the only difference between the two
      patterns is the guard expression, but that&#x2019;s enough for the compiler to
      differentiate them.<indexterm>
          <primary>cases in pattern matching</primary>
        </indexterm><indexterm>
          <primary>guards, pattern matching on</primary>
        </indexterm></para>

      <tip id="para_tip_the_cases_in_a_pattern_ma">
        <simpara>Recall that the cases in a pattern match are evaluated in
        order. For example, if your first case is broader than your second
        case, the second case will never be reached. (Unreachable cases will
        cause a compiler error.) You may include a &#x201C;default&#x201D; case at the end
        of a pattern match, either using the underscore wildcard character or
        a meaningfully named variable. When using a variable, it should have
        no explicit type or it should be declared as <literal>Any</literal>,
        so it can match anything. On the other hand, try to design your code
        to avoid a catch-all clause by ensuring it only receives specific
        items that are expected.</simpara>
      </tip>
    </sect2>

    <sect2 id="MatchingOnCaseClasses">
      <title>Matching on Case Classes</title>

      <para id="para_finally_let_s_try_a__deep_mat">Let&#x2019;s try a <emphasis>deep
      match</emphasis>, examining the contents of objects in our pattern
      match:<indexterm>
          <primary>objects</primary>

          <secondary>deep matching on contents</secondary>
        </indexterm><indexterm>
          <primary>case classes</primary>

          <secondary>pattern matching on</secondary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary sortas="case classes">on case classes</secondary>
        </indexterm><indexterm>
          <primary>deep matching</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-deep-script.scala

case class Person(name: String, age: Int)

val alice = new Person("Alice", 25)
val bob = new Person("Bob", 32)
val charlie = new Person("Charlie", 32)

for (person &lt;- List(alice, bob, charlie)) {
  person match {
    case Person("Alice", 25) =&gt; println("Hi Alice!")
    case Person("Bob", 32) =&gt; println("Hi Bob!")
    case Person(name, age) =&gt;
      println("Who are you, " + age + " year-old person named " + name + "?")
  }
}</programlisting>

      <para id="para_poor_charlie_gets_the_cold_sho">Poor Charlie gets the
      cold shoulder, as we can see in the output:</para>

      <screen>Hi Alice!
Hi Bob!
Who are you, 32 year-old person named Charlie?</screen>

      <?dbfo-need height=”1in”
?>

      <para id="para_we_first_define_a__case_class_">We first define a
      <emphasis>case class</emphasis>, a special type of class that we&#x2019;ll
      learn more about in <xref linkend="CaseClasses"/>. For now, it will
      suffice to say that a case class allows for very terse construction of
      simple objects with some predefined methods. Our <phrase role="keep-together">pattern</phrase> match then looks for Alice and Bob
      by inspecting the values passed to the <phrase role="keep-together">constructor</phrase> of the
      <literal>Person</literal> case class. Charlie falls through to the
      catch-all case; even though he has the same <literal>age</literal> value
      as Bob, we&#x2019;re matching on the <literal>name</literal> property as
      well.<indexterm>
          <primary>case classes</primary>

          <secondary>defining for pattern matching</secondary>
        </indexterm></para>

      <para id="para_this_type_pattern_match_become">This type of pattern
      match becomes extremely useful when working with Actors, as we&#x2019;ll see
      later on. Case classes are frequently sent to Actors as messages, and
      deep pattern matching on an object&#x2019;s contents is a convenient way to
      &#x201C;parse&#x201D; those messages.</para>
    </sect2>

    <sect2 id="MatchingOnRegularExpressions">
      <title>Matching on Regular Expressions</title>

      <para id="para_regular_expressions_are_conven">Regular expressions are
      convenient for extracting data from strings that have an informal
      structure, but are not &#x201C;structured data&#x201D; (that is, in a format like XML
      or JSON, for example). Commonly referred to as
      <emphasis>regexes</emphasis>, regular expressions are a feature of
      nearly all modern programming languages. They provide a terse syntax for
      specifying complex matches, one that is typically translated into a
      state machine behind the scenes for optimum performance.<indexterm>
          <primary>pattern matching</primary>

          <secondary sortas="regular expressions">on regular
          expressions</secondary>
        </indexterm><indexterm>
          <primary>regular expressions</primary>

          <secondary>matching on</secondary>
        </indexterm></para>

      <para id="para_regexes_in_scala_should_contai">Regexes in Scala should
      contain no surprises if you&#x2019;ve used them in other programming languages.
      Let&#x2019;s see an example:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-regex-script.scala

val BookExtractorRE = """Book: title=([^,]+),\s+authors=(.+)""".r
val MagazineExtractorRE = """Magazine: title=([^,]+),\s+issue=(.+)""".r

val catalog = List(
  "Book: title=Programming Scala, authors=Dean Wampler, Alex Payne",
  "Magazine: title=The New Yorker, issue=January 2009",
  "Book: title=War and Peace, authors=Leo Tolstoy",
  "Magazine: title=The Atlantic, issue=February 2009",
  "BadData: text=Who put this here??"
)

for (item &lt;- catalog) {
  item match {
    case BookExtractorRE(title, authors) =&gt;
      println("Book \"" + title + "\", written by " + authors)
    case MagazineExtractorRE(title, issue) =&gt;
      println("Magazine \"" + title + "\", issue " + issue)
    case entry =&gt; println("Unrecognized entry: " + entry)
  }
}</programlisting>

      <para id="para_this_example_starts_with_two_r">We start with two regular
      expressions, one for records of books and another for records of
      magazines. Calling <literal>.r</literal> on a string turns it into a
      regular expression; we use raw (triple-quoted) strings here to avoid
      having to double-escape backslashes. Should you find the
      <literal>.r</literal> transformation method on strings unclear, you can
      also define regexes by creating new instances of the
      <literal>Regex</literal> class, as in: <literal>new
      Regex("""\W""")</literal>.<indexterm>
          <primary>raw strings in regular expression pattern
          matching</primary>
        </indexterm></para>

      <para id="para_notice_that_each_of_our_regexe">Notice that each of our
      regexes defines two <emphasis>capture groups</emphasis>, connoted by
      parentheses. Each group captures the value of a single field in the
      record, such as a book&#x2019;s title or author. Regexes in Scala translate
      those capture groups to <emphasis>extractors</emphasis>. Every match
      sets a field to the captured result; every miss is set to
      <literal>null</literal>.<indexterm>
          <primary>extractors</primary>

          <secondary>translating regular expression capture groups
          to</secondary>
        </indexterm><indexterm>
          <primary>( ) (parentheses)</primary>

          <secondary>capture groups in regular expressions</secondary>
        </indexterm><indexterm>
          <primary>capture groups, defining in regular expressions</primary>
        </indexterm></para>

      <para id="para_the_case_clauses_look_similar_">What does this mean in
      practice? If the text fed to the regular expression matches, <literal role="keep-together">case BookExtractorRE(title, authors)</literal> will
      assign the first capture group to <literal>title</literal> and the
      second to <literal>authors</literal>. We can then use those values on
      the righthand side of the <literal>case</literal> clause, as we have in
      the previous example. The variable names <literal>title</literal> and
      <literal>author</literal> within the extractor are arbitrary; matches
      from capture groups are simply <phrase role="keep-together">assigned</phrase> from left to right, and you can
      call them whatever you&#x2019;d like.</para>

      <para id="para_that_s_regexes_in_scala_in_nut">That&#x2019;s regexes in Scala
      in nutshell. The <literal>scala.util.matching.Regex</literal> class
      supplies several handy methods for finding and replacing matches in
      strings, both all occurrences of a match and just the first occurrence,
      so be sure to make use of them.<indexterm>
          <primary>Regex class</primary>
        </indexterm></para>

      <para id="para_we_won_t_cover_the_details_of_">What we won&#x2019;t cover in
      this section is the details of writing regular expressions. Scala&#x2019;s
      <literal>Regex</literal> class uses the underlying platform&#x2019;s regular
      expression APIs (that is, Java&#x2019;s or .NET&#x2019;s). Consult references on those
      APIs for the hairy details, as they may be subtly different from the
      regex support in your language of choice.<indexterm>
          <primary sortas="NET">.NET</primary>

          <secondary>regular expressions</secondary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>regular expressions</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="BindingNestedVariablesInCaseClauses">
      <title>Binding Nested Variables in Case Clauses</title>

      <para id="para_finally_lets_bind_inner_variables">Sometimes you want to
      bind a variable to an object enclosed in a match, where you are also
      specifying match criteria on the nested object. Suppose we modify a
      previous example so we&#x2019;re matching on the key-value pairs from a map.
      We&#x2019;ll store our same <literal>Person</literal> objects as the values and
      use an employee ID as the key. We&#x2019;ll also add another attribute to
      <literal>Person</literal>, a <literal>role</literal> field that points
      to an instance from a type hierarchy:<indexterm>
          <primary>variables</primary>

          <secondary>binding nested variables in case clauses</secondary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary>binding nested variables in case clauses</secondary>
        </indexterm><indexterm>
          <primary>case clauses, binding nested variables in</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/match-deep-pair-script.scala

class Role
case object Manager extends Role
case object Developer extends Role

case class Person(name: String, age: Int, role: Role)

val alice = new Person("Alice", 25, Developer)
val bob = new Person("Bob", 32, Manager)
val charlie = new Person("Charlie", 32, Developer)

for (item &lt;- Map(1 -&gt; alice, 2 -&gt; bob, 3 -&gt; charlie)) {
  item match {
    case (id, p @ Person(_, _, Manager)) =&gt; format("%s is overpaid.\n", p)
    case (id, p @ Person(_, _, _)) =&gt; format("%s is underpaid.\n", p)
  }
}</programlisting>

      <para id="para_the_case_objects_are_just_si">The <literal>case
      objects</literal> are just singleton objects like we&#x2019;ve seen before, but
      with the special <literal>case</literal> behavior. We&#x2019;re most interested
      in the embedded <literal>p @ Person(...)</literal> inside the case
      clause. We&#x2019;re matching on particular kinds of <literal>Person</literal>
      objects inside the enclosing tuple. We also want to assign the
      <literal>Person</literal> to a variable <literal>p</literal>, so we can
      use it for printing:</para>

      <screen>Person(Alice,25,Developer) is underpaid.
Person(Bob,32,Manager) is overpaid.
Person(Charlie,32,Developer) is underpaid.</screen>

      <para id="para_if_we_weren_t_using_matching_c">If we weren&#x2019;t using
      matching criteria in <literal>Person</literal> itself, we could just
      write <literal>p: Person</literal>. For example, the previous
      <literal>match</literal> clause could be written this way:</para>

      <programlisting linenumbering="unnumbered">item match {
  case (id, p: Person) =&gt; p.role match {
    case Manager =&gt; format("%s is overpaid.\n", p)
    case _ =&gt; format("%s is underpaid.\n", p)
  }
}</programlisting>

      <para id="para_note_that_the_p_person_">Note that the <literal>p @
      Person(...)</literal> syntax gives us a way to flatten this nesting of
      match statements into one statement. It is analogous to using &#x201C;capture
      groups&#x201D; in a regular expression to pull out substrings we want, instead
      of splitting the string in several successive steps to extract the
      substrings we want. Use whichever technique you prefer.</para>
    </sect2>

    <sect2 id="TryCatchFinally">
      <title>Using try, catch, and finally Clauses</title>

      <para id="para_through_its_use_of_functional_">Through its use of
      functional constructs and strong typing, Scala encourages a coding style
      that lessens the need for exceptions and exception handling. But where
      Scala interacts with Java, exceptions are still prevalent.<indexterm>
          <primary>exception handling, pattern matching using try, catch, and
          finally clauses</primary>
        </indexterm><indexterm>
          <primary>try, catch, and finally clauses</primary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary>using try, catch, and finally clauses</secondary>
        </indexterm></para>

      <note id="para_note_scala_does_not_have_chec">
        <para>Scala does not have checked exceptions, like Java. Even Java&#x2019;s
        checked exceptions are treated as unchecked by Scala. There is also no
        <literal>throws</literal> clause on method declarations. However,
        there is a <literal>@throws</literal> annotation that is useful for
        Java interoperability. See the section <xref linkend="Annotations"/>.</para>
      </note>

      <para id="para_thankfully_scala_treats_excep">Thankfully, Scala treats
      exception handling as just another pattern match, allowing us to make
      smart choices when presented with a multiplicity of potential
      exceptions. Let&#x2019;s see this in action:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Rounding/try-catch-script.scala

import java.util.Calendar

val then = null
val now = Calendar.getInstance()

try {
  now.compareTo(then)
} catch {
  case e: NullPointerException =&gt; println("One was null!"); System.exit(-1)
  case unknown =&gt; println("Unknown exception " + unknown); System.exit(-1)
} finally {
  println("It all worked out.")
  System.exit(0)
}</programlisting>

      <para id="para_in_the_above_example_we_expli">In this example, we
      explicitly catch the <literal>NullPointerException</literal> thrown when
      trying to compare a <literal>Calendar</literal> instance with
      <literal>null</literal>. We also define <literal>unknown</literal> as a
      catch-all case, just to be safe. If we weren&#x2019;t hardcoding this program
      to fail, the <literal>finally</literal> block would be reached and the
      user would be informed that everything worked out just fine.</para>

      <note id="para_note_you_can_use_an_underscor">
        <para>You can use an underscore (Scala&#x2019;s standard wildcard character)
        as a placeholder to catch any type of exception (really, to match any
        case in a pattern matching expression). However, you won&#x2019;t be able to
        refer to the exception in the subsequent expression. Name the
        exception variable if you need it; for example, if you need to print
        the exception as we do in the catch-all case of the previous
        example.</para>
      </note>

      <para id="para_pattern_matching_aside_scala_">Pattern matching aside,
      Scala&#x2019;s treatment of exception handling should be familiar to those
      fluent in Java, Ruby, Python, and most other mainstream languages. And
      yes, you throw an exception by writing <literal>throw new
      MyBadException(...)</literal>. That&#x2019;s all there is to it.<indexterm>
          <primary>exceptions</primary>

          <secondary>throwing</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="ConcludingRemarksOnPatternMatching">
      <title>Concluding Remarks on Pattern Matching</title>

      <para id="para_pattern_matching_is_a_powerful">Pattern matching is a
      powerful and elegant way of extracting information from objects, when
      used appropriately. Recall from <xref linkend="IntroducingScala"/> that
      we highlighted the synergy between pattern matching and polymorphism.
      Most of the time, you want to avoid the problems of &#x201C;switch&#x201D; statements
      that know a class hierarchy, because they have to be modified every time
      the hierarchy is changed.<indexterm>
          <primary>polymorphism</primary>

          <secondary>pattern matching versus</secondary>
        </indexterm></para>

      <para id="para_in_our_drawing_actor_example_">In our drawing Actor
      example, we used pattern matching to separate different &#x201C;categories&#x201D; of
      messages, but we used polymorphism to draw the shapes sent to it. We
      could change the <literal>Shape</literal> hierarchy and the Actor code
      would not require changes.</para>

      <para id="para_pattern_matching_is_also_usefu">Pattern matching is also
      useful for the design problem where you need to get at data inside an
      object, but only in special circumstances. One of the unintended
      consequences of the <emphasis>JavaBeans</emphasis> (see <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>) specification was that
      it encouraged people to expose fields in their objects through getters
      and setters. This should <emphasis>never</emphasis> be a default
      decision. Access to &#x201C;state information&#x201D; should be encapsulated and
      exposed only in ways that make logical sense for the type, as viewed
      from the abstraction it exposes.</para>

      <para id="para_instead_consider_using_patter">Instead, consider using
      pattern matching for those &#x201C;rare&#x201D; times when you need to extract
      information in a controlled way. As we will see in <xref linkend="UnapplyMethod"/>, the pattern matching examples we have shown
      use <literal>unapply</literal> methods defined to extract information
      from instances. These methods let you extract that information while
      hiding the implementation details. In fact, the information returned by
      <literal>unapply</literal> might be a transformation of the actual
      information in the type.</para>

      <para id="para_note_be_wary_of_relying_on_a_">Finally, when designing
      pattern matching statements, be wary of relying on a default case
      clause. Under what circumstances would &#x201C;none of the above&#x201D; be the
      correct answer? It may indicate that the design should be refined so you
      know more precisely all the possible matches that might occur. We&#x2019;ll
      learn one technique that helps when we discuss
      <emphasis>sealed</emphasis> class hierarchies in <xref linkend="SealedClassHierarchies"/>.<indexterm class="endofrange" startref="ch03_patternmatching"/></para>
    </sect2>
  </sect1>

  <sect1 id="Enumerations">
    <title>Enumerations</title>

    <para id="para_remember_our_examples_above_in">Remember our examples
    involving various breeds of dog? In thinking about the types in these
    programs, we might want a top-level <literal>Breed</literal> type that
    keeps track of a number of breeds. Such a type is called an
    <emphasis>enumerated type</emphasis>, and the values it contains are
    called <emphasis>enumerations</emphasis>.<indexterm>
        <primary>enumerated types</primary>
      </indexterm><indexterm>
        <primary>enumerations</primary>
      </indexterm></para>

    <para id="para_while_enumerations_are_a_built">While enumerations are a
    built-in part of many programming languages, Scala takes a different route
    and implements them as a class in its standard library. This means there
    is no special syntax for enumerations in Scala, as in Java and C#.
    Instead, you just define an object that extends the
    <literal>Enumeration</literal> class. Hence, at the byte code level, there
    is no connection between Scala enumerations and the
    <literal>enum</literal> constructs in Java and C#.<indexterm>
        <primary>Enumeration class</primary>
      </indexterm></para>

    <para id="para_enumeration_example">Here is an example:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/enumeration-script.scala

object Breed extends Enumeration {
  val doberman = Value("Doberman Pinscher")
  val yorkie = Value("Yorkshire Terrier")
  val scottie = Value("Scottish Terrier")
  val dane = Value("Great Dane")
  val portie = Value("Portuguese Water Dog")
}

// print a list of breeds and their IDs
println("ID\tBreed")
for (breed &lt;- Breed) println(breed.id + "\t" + breed)

// print a list of Terrier breeds
println("\nJust Terriers:")
Breed.filter(_.toString.endsWith("Terrier")).foreach(println)</programlisting>

    <para id="para_when_run_you_ll_get_the_follo">When run, you&#x2019;ll get the
    following output:</para>

    <screen>ID      Breed
0       Doberman Pinscher
1       Yorkshire Terrier
2       Scottish Terrier
3       Great Dane
4       Portuguese Water Dog

Just Terriers:
Yorkshire Terrier
Scottish Terrier</screen>

    <para id="para_we_can_see_in_the_source_that_">We can see that our
    <literal>Breed</literal> enumerated type contains several variables of
    type <literal>Value</literal>, as in the following example:</para>

    <screen>val doberman = Value("Doberman Pinscher")</screen>

    <para id="para_value_method_with_name_arg_for_enumerations">Each
    declaration is actually calling a method named <literal>Value</literal>
    that takes a string argument. We use this method to assign a long-form
    breed name to each enumeration value, which is what the
    <literal>Value.toString</literal> method returned in the output.<indexterm>
        <primary>Value.toString method</primary>
      </indexterm></para>

    <para id="para_value_methods_for_enumerations">Note that there is no
    namespace collision between the type and method that both have the name
    <literal>Value</literal>. There are other overloaded versions of the
    <literal>Value</literal> method. One of them takes no arguments, another
    takes an <literal>Int</literal> ID value, and another takes both an
    <literal>Int</literal> and <literal>String</literal>. These
    <literal>Value</literal> methods return a <literal>Value</literal> object,
    and they add the value to the enumeration&#x2019;s collection of values.</para>

    <para id="para_since_scala_s_enumeration_cl">In fact, Scala&#x2019;s
    <literal>Enumeration</literal> class supports the usual methods for
    working with collections, so we can easily iterate through the breeds with
    a <literal>for</literal> loop and <literal>filter</literal> them by name.
    The output above also demonstrated that every <literal>Value</literal> in
    an enumeration is automatically assigned a numeric identifier, unless you
    call one of the <literal>Value</literal> methods where you specify your
    own ID value explicitly.</para>

    <para id="para_enumeration_no_name_values">You&#x2019;ll often want to give your
    enumeration values human-readable names, as we did here. However,
    sometimes you may not need them. Here&#x2019;s another enumeration example
    adapted from the Scaladoc entry for <literal>Enumeration</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Rounding/days-enumeration-script.scala

object WeekDay extends Enumeration {
  type WeekDay = Value
  val Mon, Tue, Wed, Thu, Fri, Sat, Sun = Value
}
import WeekDay._

def isWorkingDay(d: WeekDay) = ! (d == Sat || d == Sun)

WeekDay filter isWorkingDay foreach println</programlisting>

    <para id="para_days_enumeration_scala_output">Running this script with
    <literal>scala</literal> yields the following output:</para>

    <screen>Main$$anon$1$WeekDay(0)
Main$$anon$1$WeekDay(1)
Main$$anon$1$WeekDay(2)
Main$$anon$1$WeekDay(3)
Main$$anon$1$WeekDay(4)</screen>

    <para id="para_enumeration_no_name_tostring">When a name isn&#x2019;t assigned
    using one of the <literal>Value</literal> methods that takes a
    <literal>String</literal> argument, <literal>Value.toString</literal>
    prints the name of the type that is synthesized by the compiler, along
    with the ID value that was generated automatically.</para>

    <para id="para_note_that_we_imported_weekday">Note that we imported
    <literal>WeekDay._</literal>. This made each enumeration value
    (<literal>Mon</literal>, <literal>Tues</literal>, etc.) in scope.
    Otherwise, you would have to write <literal>WeekDay.Mon</literal>,
    <literal>WeekDay.Tues</literal>, etc.</para>

    <para id="para_also_the_import_made_the__typ">Also, the import made the
    <emphasis>type alias</emphasis>, <literal>type Weekday = Value</literal>,
    in scope, which we used as the type for the argument for the
    <literal>isWorkingDay</literal> method. If you don&#x2019;t define a type alias
    like this, then you would declare the method as <literal>def
    isWorkingDay(d: WeekDay.Value)</literal>.<indexterm>
        <primary>type alias</primary>
      </indexterm></para>

    <para id="para_enumerations_vs_objects_with_vals">Since Scala enumerations
    are just regular objects, you could use any object with
    <literal>vals</literal> to indicate different &#x201C;enumeration values.&#x201D;
    However, extending <literal>Enumeration</literal> has several advantages.
    It automatically manages the values as a collection that you can iterate
    over, etc., as in our examples. It also automatically assigns unique
    integer IDs to each value.</para>

    <para id="para_we_ll_revisit_enumerations_in_">Case classes (see <xref linkend="CaseClasses"/>) are often used instead of enumerations in Scala
    because the &#x201C;use case&#x201D; for them often involves pattern matching. We&#x2019;ll
    revisit this topic in <xref linkend="EnumerationsVsPatternMatching"/>.</para>
  </sect1>

  <sect1 id="_recap_and_what_8217_s_next_3">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_ve_covered_a_lot_of_ground_">We&#x2019;ve covered a lot of
    ground in this chapter. We learned how flexible Scala&#x2019;s syntax can be, and
    how it facilitates the creation of Domain-Specific Languages. Then we
    explored Scala&#x2019;s enhancements to looping constructs and conditional
    expressions. We experimented with different uses for pattern matching, a
    powerful improvement on the familiar <literal>case-switch</literal>
    statement. Finally, we learned how to encapsulate values in <phrase role="keep-together">enumerations</phrase>.</para>

    <para>You should now be prepared to read a fair bit of Scala code, but
    there&#x2019;s plenty more about the language to put in your tool belt. In the
    next four chapters, we&#x2019;ll explore Scala&#x2019;s approach to object-oriented
    programming, starting with <emphasis>traits</emphasis>.</para>
  </sect1>
</chapter>
  <chapter id="Traits">
  <title>Traits</title>

  <sect1 id="IntroducingTraits">
    <title>Introducing Traits</title>

    <para id="para_before_we_dive_into_object_ori">Before we dive into
    object-oriented programming, there&#x2019;s one more essential feature of Scala
    that you should get acquainted with: <emphasis>traits</emphasis>.
    Understanding the value of this feature requires a little
    backstory.<indexterm class="startofrange" id="ch04_traits">
        <primary>traits</primary>
      </indexterm></para>

    <para id="para_a_java_class_can__implement__a">In Java, a class can
    implement an arbitrary number of <emphasis>interfaces</emphasis>. This
    model is very useful for declaring that a class exposes multiple
    abstractions. Unfortunately, it has one major drawback.</para>

    <para id="para_for_many_interfaces_much_of_t">For many interfaces, much of
    the functionality can be implemented with boilerplate code that will be
    valid for all classes that use the interface. Java provides no built-in
    mechanism for defining and using such reusable code. Instead, Java
    programmers must use ad hoc conventions to reuse implementation code for a
    given interface. In the worst case, the developer just copies and pastes
    the same code into every class that needs it.</para>

    <para id="para_often_the_implementation_of_a">Often, the implementation of
    an interface has members that are unrelated (&#x201C;orthogonal&#x201D;) to the rest of
    the instance&#x2019;s members. The term <emphasis>mixin</emphasis> is often used
    for such focused and potentially reusable parts of an instance that could
    be independently maintained.<indexterm>
        <primary>mixins</primary>
      </indexterm></para>

    <para id="para_look_at_gui_text_field_class">Have a look at the following
    code for a button in a graphical user interface, which uses callbacks for
    &#x201C;clicks&#x201D;:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button-callbacks.scala

package ui

class ButtonWithCallbacks(val label: String,
    val clickedCallbacks: List[() =&gt; Unit]) extends Widget {

  require(clickedCallbacks != null, "Callback list can't be null!")

  def this(label: String, clickedCallback: () =&gt; Unit) =
    this(label, List(clickedCallback))

  def this(label: String) = {
    this(label, Nil)
    println("Warning: button has no click callbacks!")
  }

  def click() = {
    // ... logic to give the appearance of clicking a physical button ...
    clickedCallbacks.foreach(f =&gt; f())
  }
}</programlisting>

    <para id="para_there_s_a_lot_going_on_here_n">There&#x2019;s a lot going on here.
    The primary constructor takes a <literal>label</literal> argument and a
    list of <literal>callbacks</literal> that are invoked when the button&#x2019;s
    <literal>click</literal> method is invoked. We&#x2019;ll explore this class in
    greater detail in <xref linkend="BasicObjectOrientedProgramming"/>. For
    now, we want to focus on one particular problem. Not only does
    <literal>ButtonWithCallbacks</literal> handle behaviors essential to
    buttons (like clicking), it also handles notification of click events by
    invoking the callback functions. This goes against the <emphasis>Single
    Responsibility Principle</emphasis> (see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>), a means to the design goal
    of <emphasis>separation of concerns</emphasis>. We would like to separate
    the button-specific logic from the callback logic, such that each logical
    component becomes simpler, more modular, and more reusable. The callback
    logic is a good example of a <emphasis>mixin</emphasis>.<indexterm>
        <primary>Single Responsibility Principle</primary>
      </indexterm></para>

    <para id="para_this_separation_is_difficult_t">This separation is
    difficult to do in Java, even if we define an interface for the callback
    behavior. We still have to embed the implementation code in the class
    somehow, <phrase role="keep-together">compromising</phrase> modularity.
    The only other alternative is to use a specialized tool like
    <emphasis>aspect-oriented programming</emphasis> (AOP; see <link linkend="AOSD" xrefstyle="select:nopage">[AOSD]</link>), as implemented by
    AspectJ (see <link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link>), an extension of Java. AOP is
    primarily designed to separate the implementations of &#x201C;<phrase role="keep-together">pervasive</phrase>&#x201D; concerns that are repeated
    throughout an application. It seeks to modularize these concerns, yet
    enable the fine-grained &#x201C;mixing&#x201D; of their behaviors with other concerns,
    including the core domain logic of the application, either at build or
    runtime.<indexterm>
        <primary>Java</primary>

        <secondary>aspect-oriented programming, AspectJ</secondary>
      </indexterm><indexterm>
        <primary>aspect-oriented programming (AOP)</primary>
      </indexterm></para>

    <sect2 id="TraitsAsMixins">
      <title>Traits As Mixins</title>

      <para id="para_scala_provides_a_complete__mix">Scala provides a complete
      mixin solution, called <emphasis>traits</emphasis>. In our example, we
      can define the callback <emphasis>abstraction</emphasis> in a trait, as
      in a Java interface, but we can also implement the abstraction in the
      trait (or a derived trait). We can declare classes that &#x201C;mix in&#x201D; the
      trait, much the way you can declare classes that implement an interface
      in Java. However, in Scala we can even mix in traits at the same time we
      create instances. That is, we don&#x2019;t have to declare a class first that
      mixes in all the traits we want. So, Scala traits preserve separation of
      concerns while giving us the ability to compose behavior on
      demand.<indexterm class="startofrange" id="ch04_traitsmixins">
          <primary>traits</primary>

          <secondary sortas="mixins">as mixins</secondary>
        </indexterm><indexterm class="startofrange" id="ch04_mixinstraits">
          <primary>mixins</primary>

          <secondary>traits as</secondary>
        </indexterm></para>

      <para id="para_if_you_come_from_a_java_background">If you come from a
      Java background, you can think of traits as interfaces with optional
      implementations. Or, if you prefer, you can think of traits as a
      &#x201C;constrained&#x201D; form of multiple inheritance. Other languages provide
      constructs that are similar to traits, such as
      <emphasis>modules</emphasis> in Ruby, for example.</para>

      <para id="para_let_s_use_a_trait_to_separate_">Let&#x2019;s use a trait to
      separate the callback handling from the button logic. We&#x2019;ll generalize
      our approach a little bit. Callbacks are really a special case of the
      <emphasis>Observer Pattern</emphasis> (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>). So, let&#x2019;s create a trait
      that implements this pattern, and then use it to <phrase role="keep-together">handle</phrase> callback behavior. To simplify
      things, we&#x2019;ll start with a single callback that counts the number of
      button clicks.<indexterm>
          <primary>Observer Pattern</primary>
        </indexterm></para>

      <para id="para_first_let_s_simplify_our_butt">First, let&#x2019;s define a
      simple <literal>Button</literal> class:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button.scala

package ui

class Button(val label: String) extends Widget {
  def click() = {
    // Logic to give the appearance of clicking a button...
  }
}</programlisting>

      <para id="para_simplified_widget">Here is the parent class,
      <literal>Widget</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/widget.scala

package ui

abstract class Widget</programlisting>

      <para id="para_the_logic_for_managing_callbac">The logic for managing
      callbacks (i.e., the <literal>clickedCallbacks</literal> list) is
      omitted, as are the two auxiliary constructors. Only the button&#x2019;s
      <literal>label</literal> field and <literal>click</literal> method
      remain. The <literal>click</literal> method now only cares about the
      visual appearance of a &#x201C;physical&#x201D; button being clicked.
      <literal>Button</literal> has only one concern, handling the &#x201C;essence&#x201D;
      of being a button.</para>

      <para id="para_here_is_a__trait__that_impleme">Here is a trait that
      implements the logic of the <emphasis>Observer
      Pattern</emphasis>:<indexterm>
          <primary>Observer Pattern</primary>

          <secondary>trait implementing</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/observer/observer.scala

package observer

trait Subject {
  type Observer = { def receiveUpdate(subject: Any) }

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (_.receiveUpdate(this))
}</programlisting>

      <para id="para_except_for_the_trait_keyword">Except for the
      <literal>trait</literal> keyword, <literal>Subject</literal> looks like
      a normal class. <literal>Subject</literal> defines all the members it
      declares. Traits can declare <emphasis>abstract</emphasis> members,
      <emphasis>concrete</emphasis> members, or both, just as classes can (see
      <xref linkend="OverridingMembers"/> for more details). Also like
      classes, traits can contain nested trait and class definitions, and
      classes can contain nested trait definitions.<indexterm>
          <primary>trait keyword</primary>
        </indexterm></para>

      <para id="para_the_first_line_defines_a_type">The first line defines a
      <literal>type</literal> for an <literal>Observer</literal>. This is a
      <emphasis>structural type</emphasis> of the form <literal role="keep-together">{ def receiveUpdate(subject:Any) }</literal>.
      Structural types specify only the structure a type must support; you
      could think of them as &#x201C;anonymous&#x201D; types.<indexterm>
          <primary>data types</primary>

          <secondary>structural types</secondary>
        </indexterm><indexterm>
          <primary>structural types</primary>
        </indexterm></para>

      <para id="para_in_this_case_the_structural_t">In this case, the
      structural type is defined by a method with a particular signature. Any
      type that has a method with this signature can be used as an observer.
      We&#x2019;ll learn more about structural types in <xref linkend="ScalasTypeSystem"/>. If you&#x2019;re wondering why we didn&#x2019;t use
      <literal>Subject</literal> as the type of the argument, instead of
      <literal>Any</literal>, we&#x2019;ll revisit that issue in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>.</para>

      <para id="para_the_main_thing_to_notice_for_n">The main thing to notice
      for now is how this structural type minimizes the coupling between the
      <literal>Subject</literal> trait and any potential users of the
      trait.</para>

      <note id="para_note_subject_is_still_coupl">
        <para><literal>Subject</literal> is still coupled by the name of the
        method in <literal>Observer</literal> through the structural type,
        i.e., to a method named <literal>receiveUpdate</literal>. There are
        several ways we can reduce this remaining coupling. We&#x2019;ll see how in
        <xref linkend="OverridingAbstractTypes"/>.</para>
      </note>

      <para id="para_next_we_declare_a_list_of_obs">Next, we declare a list of
      observers. We make it a <literal>var</literal>, rather than a
      <literal>val</literal>, because <literal>List</literal> is immutable, so
      we must create a new list when an observer is added using the <literal role="keep-together">addObserver</literal> method.</para>

      <para id="para_we_ll_discuss_scala_list_s_m">We&#x2019;ll discuss Scala
      <literal>List</literal>s more in <xref linkend="ScalaTypeHierarchy"/>
      and also in <xref linkend="FunctionalProgramming"/>. For now, notice
      that <literal>addObserver</literal> uses the list cons &#x201C;operator&#x201D; method
      <phrase role="keep-together">(<literal>::</literal>)</phrase> to
      <emphasis>prepend</emphasis> an <literal>observer</literal> to the list
      of <literal>observers</literal>. The <literal>scala</literal> compiler
      is smart enough to turn the following statement:</para>

      <programlisting linenumbering="unnumbered">observers ::= observer</programlisting>

      <para id="para_into_this_statement_">into this statement:</para>

      <programlisting linenumbering="unnumbered">observers = observer :: observers</programlisting>

      <para id="para_note_that_we_wrote_observer_">Note that we wrote
      <literal>observer :: observers</literal>, with the existing
      <literal>observers</literal> list on the <emphasis>right</emphasis>hand
      side. Recall that any method that ends with <literal>:</literal> binds
      to the <emphasis>right</emphasis>. So, the previous statement is
      equivalent to the following statement:</para>

      <programlisting linenumbering="unnumbered">observers = observers.::(observer)</programlisting>

      <para id="para_the_notifyobservers_method_i">The
      <literal>notifyObservers</literal> method iterates through the
      <literal>observers</literal>, using the <literal>foreach</literal>
      method and calls <literal>receiveUpdate</literal> on each one. (Note
      that we are using the &#x201C;infix&#x201D; operator notation instead of
      <literal>observers.foreach</literal>.) We use the placeholder
      <literal>_</literal> to shorten the following expression:</para>

      <programlisting linenumbering="unnumbered">(obs) =&gt; obs.receiveUpdate(this)</programlisting>

      <para id="para_into_this_expression_">into this expression:</para>

      <programlisting linenumbering="unnumbered">_.receiveUpdate(this)</programlisting>

      <para id="para_this_expression_is_actually_th">This expression is
      actually the body of an &#x201C;anonymous function,&#x201D; called a
      <emphasis>function literal</emphasis> in Scala. This is similar to a
      <emphasis>lambda</emphasis> and like constructs used in many other
      languages. Function literals and the related concept of a
      <emphasis>closure</emphasis> are discussed in <xref linkend="FunctionLiteralsAndClosures"/>.<indexterm>
          <primary>function literals</primary>
        </indexterm></para>

      <para id="para_in_java_the_foreach_method_">In Java, the
      <literal>foreach</literal> method would probably take an interface, and
      you would pass an instance of a class that implements the interface
      (e.g., the way <literal>Comparable</literal> is typically used).</para>

      <para id="para_in_scala_the_list_a_foreach">In Scala, the
      <literal>List[A].foreach</literal> method expects an argument of type
      <literal>(A) =&gt; Unit</literal>, which is a function taking an
      instance of type <literal>A</literal>&#x2014;where <literal>A</literal>
      represents the type of the elements of the list
      (<literal>Observer</literal>, in this case)&#x2014;and returning
      <literal>Unit</literal> (like <literal>void</literal> in
      Java).<indexterm>
          <primary>foreach method</primary>
        </indexterm></para>

      <note id="para_note_we_chose_to_use_a_var_">
        <para>We chose to use a <literal>var</literal> with immutable
        <literal>Lists</literal> for the observers in this example. We could
        have used a <literal>val</literal> with a mutable type, like <literal role="keep-together">ListBuffer</literal>. That choice would make a
        little more sense for a real <phrase role="keep-together">application</phrase>, but we wanted to avoid the
        distraction of explaining new <phrase role="keep-together">library</phrase> classes.</para>
      </note>

      <para id="para_once_again_we_learned_a_lot_o">Once again, we learned a
      lot of Scala from a small example. Now let&#x2019;s put our <literal role="keep-together">Subject</literal> trait to use. Here is
      <literal>ObservableButton</literal>, which subclasses
      <literal>Button</literal> and mixes in <literal role="keep-together">Subject</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/observable-button.scala

package ui
import observer._

class ObservableButton(name: String) extends Button(name) with Subject {
  override def click() = {
    super.click()
    notifyObservers
  }
}</programlisting>

      <para id="para_we_start_by_importing_everythi">We start by importing
      everything in the <literal>observer</literal> package, using the
      <literal>_</literal> wildcard. <phrase role="keep-together">Actually</phrase>, we have only defined the
      <literal>Subject</literal> trait in the package.</para>

      <para id="para_the_new_class_uses_the_with_">The new class uses the
      <literal>with</literal> keyword to add the <literal>Subject</literal>
      trait to the class. <literal>ObservableButton</literal> overrides the
      <literal>click</literal> method. Using the <literal>super</literal>
      keyword (see <xref linkend="OverridingMethods"/>), it first invokes the
      &#x201C;superclass&#x201D; method, <literal role="keep-together">Button.click</literal>, and then it notifies the
      observers. Since the new <literal>click</literal> method overrides
      <literal>Button</literal>&#x2019;s concrete implementation, the
      <literal>override</literal> keyword is required.<indexterm>
          <primary>with keyword</primary>
        </indexterm><indexterm>
          <primary>override keyword</primary>
        </indexterm></para>

      <para id="para_the_with_keyword_is_analogou">The <literal>with</literal>
      keyword is analogous to Java&#x2019;s <literal>implements</literal> keyword for
      interfaces. You can specify as many traits as you want, each with its
      own <literal>with</literal> keyword.</para>

      <para id="para_a_class_can_extend_a_trait_and">A class can extend a
      trait, and a trait can extend a class. In fact, our
      <literal>Widget</literal> class earlier could have been declared to be a
      trait.<indexterm>
          <primary>extends keyword</primary>
        </indexterm></para>

      <note id="para_note_if_you_declare_a_class_t">
        <para>If you declare a class that uses one or more traits and it
        <emphasis>doesn&#x2019;t</emphasis> extend another class, you must use the
        <literal>extends</literal> keyword for the first trait listed.</para>
      </note>

      <para id="para_if_you_don_t_use_extends_for">If you don&#x2019;t use
      <literal>extends</literal> for the first trait, e.g., you write the
      following:</para>

      <programlisting linenumbering="unnumbered">// ERROR:
class ObservableButton(name: String) with Button(name) with Subject {...}</programlisting>

      <para id="para_you_ll_get_an_error_like_this_">You&#x2019;ll get an error like
      this:</para>

      <screen>... error: ';' expected but 'with' found.
       class ObservableButton(name: String) with Button(name) with Subject {...}
                                            ^</screen>

      <para id="para_the_error_should_really_say_">The error should really
      say, &#x201C;<literal>with</literal> found, but <literal>extends</literal>
      expected.&#x201D;</para>

      <para id="para_to_demonstrate_this_code_let_">To demonstrate this code,
      let&#x2019;s start with a class for observing button clicks that simply counts
      the number of clicks:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button-count-observer.scala

package ui
import observer._

class ButtonCountObserver {
  var count = 0
  def receiveUpdate(subject: Any) = count += 1
}</programlisting>

      <para id="para_finally_let_s_write_a_test_th">Finally, let&#x2019;s write a
      test that exercises all these classes. We will use the Specs library
      (discussed in <xref linkend="ScalaSpecs"/>) to write a
      <emphasis>Behavior-Driven Development</emphasis> (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>) &#x201C;specification&#x201D; that exercises
      the combined <literal>Button</literal> and <literal>Subject</literal>
      types:<indexterm>
          <primary>BDD (Behavior-Driven Development)</primary>

          <secondary>specification exercising combined Button and Subject
          types</secondary>
        </indexterm><indexterm>
          <primary>Specs library</primary>

          <secondary>using for BDD specification exercising combined Button
          and Subject types</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button-observer-spec.scala

package ui
import org.specs._
import observer._

object ButtonObserverSpec extends Specification {
  "A Button Observer" should {
    "observe button clicks" in {
      val observableButton = new ObservableButton("Okay")
      val buttonObserver = new ButtonCountObserver
      observableButton.addObserver(buttonObserver)

      for (i &lt;- 1 to 3) observableButton.click()
      buttonObserver.count mustEqual 3
    }
  }
}</programlisting>

      <para id="para_if_you_downloaded_the_code_exa">If you downloaded the
      <ulink role="orm:hideurl" url="http://oreilly.com/catalog/9780596155957/">code examples from the
      O&#x2019;Reilly site</ulink>, you can follow the directions in its
      <filename>README</filename> files for building and running the examples
      in this chapter. The output of the <literal>specs</literal> &#x201C;target&#x201D; of
      the build should include the following text:</para>

      <screen>Specification "ButtonCountObserverSpec"
  A Button Observer should
  + observe button clicks

Total for specification "ButtonCountObserverSpec":
Finished in 0 second, 10 ms
1 example, 1 expectation, 0 failure, 0 error</screen>

      <para id="para_notice_that_the_strings_a_bu">Notice that the strings
      <literal>A Button Observer should</literal> and <literal>observe button
      clicks</literal> correspond to strings in the example. The output of a
      <emphasis>Specs</emphasis> run provides a nice summary of the
      requirements for the items being tested, assuming good choices were made
      for the strings.</para>

      <para id="para_the_body_of_the_test_creates_a">The body of the test
      creates an &#x201C;Okay&#x201D; <literal>ObservableButton</literal> and a
      <literal>ButtonCountObserver</literal>, which gives the observer to the
      button. The button is clicked three times, using the
      <literal>for</literal> loop. The last line requires the observer&#x2019;s
      <literal>count</literal> to equal 3. If you are accustomed to using an
      <emphasis>XUnit</emphasis>-style TDD tool, like <literal>JUnit</literal>
      (see <link linkend="JUnit" xrefstyle="select:nopage">[JUnit]</link>) or
      <literal>ScalaTest</literal> (see <link linkend="ScalaTestTool" xrefstyle="select:nopage">[ScalaTestTool]</link> and <xref linkend="ScalaTest"/>), then the last line is equivalent to the
      following <literal>JUnit</literal> assertion:<indexterm>
          <primary>JUnit</primary>
        </indexterm><indexterm>
          <primary>TDD (Test-Driven Development)</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">assertEquals(3, buttonObserver.count)</programlisting>

      <note id="para_note_the__specs__library_see">
        <para>The Specs library (see <xref linkend="ScalaSpecs"/>) and the
        ScalaTest library (see <xref linkend="ScalaTest"/>) both support
        <emphasis>Behavior-Driven Development</emphasis> (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>), a style of
        <emphasis>Test-Driven Development</emphasis> (<link linkend="TDD" xrefstyle="select:nopage">[TDD]</link>) that emphasizes the
        &#x201C;specification&#x201D; role of tests.</para>
      </note>

      <para id="para_suppose_we_only_need_one_obse">Suppose we need only one
      <literal>ObservableButton</literal> instance? We actually don&#x2019;t have to
      declare a class that subclasses <literal>Button</literal> with
      <literal>Subject</literal>. We can incorporate the trait when we create
      the instance.</para>

      <para id="para_the_next_example_shows_a_revis">The next example shows a
      revised Specs file that instantiates a <literal>Button</literal> with
      <literal>Subject</literal> mixed in as part of the declaration:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button-observer-anon-spec.scala

package ui
import org.specs._
import observer._

object ButtonObserverAnonSpec extends Specification {
  "A Button Observer" should {
    "observe button clicks" in {
      val observableButton = new Button("Okay") with Subject {
        override def click() = {
          super.click()
          notifyObservers
        }
      }

      val buttonObserver = new ButtonCountObserver
      observableButton.addObserver(buttonObserver)

      for (i &lt;- 1 to 3) observableButton.click()
      buttonObserver.count mustEqual 3
    }
  }
}</programlisting>

      <para id="para_the_revised_declaration_of_ob">The revised declaration of
      <literal>observableButton</literal> actually creates an anonymous class
      in which we override the <literal>click</literal> method, as before. The
      main difference with creating anonymous classes in Java is that we can
      incorporate traits in this process. Java does not let you implement a
      new interface while instantiating a class.<indexterm>
          <primary>anonymous classes</primary>

          <secondary>creating</secondary>
        </indexterm><indexterm class="endofrange" startref="ch04_traitsmixins"/><indexterm class="endofrange" startref="ch04_mixinstraits"/></para>

      <para id="para_finally_note_that_the_inherit">Finally, note that the
      inheritance hierarchy for an instance can be complex if it mixes in
      traits that extend other traits, etc. We&#x2019;ll discuss the details of the
      hierarchy in <xref linkend="Linearization"/>.</para>
    </sect2>
  </sect1>

  <sect1 id="StackableTraits">
    <title>Stackable Traits</title>

    <para id="para_there_are_a_couple_of_refineme">There are a couple of
    refinements we can do to improve the reusability of our work and to make
    it easier to use more than one trait at a time, i.e., to &#x201C;stack&#x201D;
    them.<indexterm>
        <primary>traits</primary>

        <secondary>stacking</secondary>
      </indexterm></para>

    <para id="para_first_let_s_introduce_a_new_t">First, let&#x2019;s introduce a new
    trait, <literal>Clickable</literal>, an abstraction for any widget that
    responds to clicks:<indexterm>
        <primary>Clickable trait (example)</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui2/clickable.scala

package ui2

trait Clickable {
  def click()
}</programlisting>

    <note id="para_note_we_re_starting_with_a_ne">
      <para>We&#x2019;re starting with a new package, <literal>ui2</literal>, to make
      it easier to keep older and newer versions of the examples distinct in
      the downloadable code.</para>
    </note>

    <para id="para_the_clickable_trait_looks_ju">The
    <literal>Clickable</literal> trait looks just like a Java interface; it is
    completely abstract. It defines a single, abstract method,
    <literal>click</literal>. The method is abstract because it has no body.
    If <literal>Clickable</literal> were a class, we would have to add the
    <literal>abstract</literal> keyword in front of the
    <literal>class</literal> keyword. This is not necessary for traits.</para>

    <para id="para_here_is_the_refactored_button_">Here is the refactored
    button, which uses the trait:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui2/button.scala

package ui2

import ui.Widget

class Button(val label: String) extends Widget with Clickable {
  def click() = {
    // Logic to give the appearance of clicking a button...
  }
}</programlisting>

    <para id="para_this_code_is_like_java_code_th">This code is like Java code
    that implements a <literal>Clickable</literal> interface.</para>

    <para id="para_previously_when_we_defined_o">When we previously defined
    <literal>ObservableButton</literal> (in <xref linkend="TraitsAsMixins"/>), we overrode <literal>Button.click</literal>
    to notify the observers. We had to duplicate that logic in <literal role="keep-together">ButtonObserverAnonSpec</literal> when we declared
    <literal>observableButton</literal> as a <literal>Button</literal>
    instance that mixed in the <literal>Subject</literal> trait directly.
    Let&#x2019;s eliminate this duplication.</para>

    <para id="para_we_don_t_really_care_about_obs">When we refactor the code
    this way, we realize that we don&#x2019;t really care about observing buttons; we
    care about observing clicks. Here is a trait that focuses solely on
    observing <literal>Clickable</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui2/observable-clicks.scala

package ui2
import observer._

trait ObservableClicks extends Clickable with Subject {
  abstract override def click() = {
    super.click()
    notifyObservers
  }
}</programlisting>

    <para id="para_the_observableclicks_trait_e">The
    <literal>ObservableClicks</literal> trait extends
    <literal>Clickable</literal> and mixes in <literal>Subject</literal>. It
    then overrides the <literal>click</literal> method with an implementation
    that looks almost the same as the overridden method shown in <xref linkend="TraitsAsMixins"/>. The important difference is the
    <literal>abstract</literal> keyword.<indexterm>
        <primary>abstract keyword</primary>
      </indexterm><indexterm>
        <primary>ObservableClicks trait (example)</primary>
      </indexterm></para>

    <para id="para_look_closely_at_this_method_i">Look closely at this method.
    It calls <literal>super.click()</literal>, but what is
    <literal>super</literal> in this case? At this point, it could only appear
    to be <literal>Clickable</literal>, which <emphasis>declares</emphasis>
    but does not <emphasis>define</emphasis> the <literal>click</literal>
    method, or it could be <literal>Subject</literal>, which doesn&#x2019;t have a
    <literal>click</literal> method. So, <literal>super</literal> can&#x2019;t be
    bound, at least not yet.</para>

    <para id="para_in_fact_super_will_be_bound">In fact,
    <literal>super</literal> will be bound when this trait is mixed into an
    instance that defines a concrete <literal>click</literal> method, such as
    <literal>Button</literal>. Therefore, we need an
    <literal>abstract</literal> keyword on
    <literal>ObservableClicks.click</literal> to tell the compiler (and the
    reader) that <literal>click</literal> is not yet fully implemented, even
    though <literal>ObservableClicks.click</literal> has a body.</para>

    <note id="para_note_except_for_declaring_abs">
      <para>Except for declaring abstract classes, the
      <literal>abstract</literal> keyword is only required on a method in a
      trait when the method has a body, but it calls the
      <literal>super</literal> method that doesn&#x2019;t have a concrete
      implementation in <phrase role="keep-together">parents</phrase> of the
      trait.</para>
    </note>

    <para id="para_let_s_use_this_trait_with_but">Let&#x2019;s use this trait with
    <literal>Button</literal> and its concrete <literal>click</literal> method
    in a <emphasis>Specs</emphasis> test:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui2/button-clickable-observer-spec.scala

package ui2
import org.specs._
import observer._
import ui.ButtonCountObserver

object ButtonClickableObserverSpec extends Specification {
  "A Button Observer" should {
    "observe button clicks" in {
      val observableButton = new Button("Okay") with ObservableClicks
      val buttonClickCountObserver = new ButtonCountObserver
      observableButton.addObserver(buttonClickCountObserver)

      for (i &lt;- 1 to 3) observableButton.click()
      buttonClickCountObserver.count mustEqual 3
    }
  }
}</programlisting>

    <para id="para_compare_this_code_to_button_">Compare this code to
    <literal>ButtonObserverAnonSpec</literal>. We instantiate a
    <literal>Button</literal> with the <literal role="keep-together">ObservableClicks</literal> trait mixed in, but now
    there is no override of <literal>click</literal> required. Hence, this
    client of <literal>Button</literal> doesn&#x2019;t have to worry about properly
    overriding <literal>click</literal>. The hard work is already done by
    <literal>ObservableClicks</literal>. The desired behavior is
    <emphasis>composed declaratively</emphasis> when needed.</para>

    <para id="para_let_s_finish_our_example_by_ad">Let&#x2019;s finish our example by
    adding a second trait. The JavaBeans specification (see <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>)
    has the idea of &#x201C;vetoable&#x201D; events, where listeners for changes to a
    JavaBean can veto the change. Let&#x2019;s implement something similar with a
    trait that vetoes more than a set number of clicks:<indexterm>
        <primary>traits</primary>

        <secondary sortas="mixins">as mixins</secondary>

        <tertiary>vetoing click events</tertiary>
      </indexterm><indexterm>
        <primary>JavaBeans</primary>

        <secondary>vetoable events</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui2/vetoable-clicks.scala

package ui2
import observer._

trait VetoableClicks extends Clickable {
  val maxAllowed = 1  // default
  private var count = 0

  abstract override def click() = {
    if (count &lt; maxAllowed) {
      count += 1
      super.click()
    }
  }
}</programlisting>

    <para id="para_once_again_we_override_the_c">Once again, we override the
    <literal>click</literal> method. As before, the override must be declared
    <literal>abstract</literal>. The maximum allowed number of clicks defaults
    to 1. You might wonder what we mean by &#x201C;defaults&#x201D; here. Isn&#x2019;t the field
    declared to be a <literal>val</literal>? There is no constructor defined
    to initialize it to another value. We&#x2019;ll revisit these questions in <xref linkend="OverridingMembers"/>.</para>

    <para id="para_this_trait_also_declares_a_co">This trait also declares a
    <literal>count</literal> variable to keep track of the number of clicks
    seen. <phrase role="keep-together">It is declared</phrase>
    <literal>private</literal>, so it is invisible outside the trait (see
    <xref linkend="VisibilityRules"/>). The overridden
    <literal>click</literal> method increments <literal>count</literal>. It
    only calls the <literal>super.click()</literal> method if the count is
    less than or equal to the <literal>maxAllowed</literal> count.<indexterm>
        <primary>VetoableClicks trait (example)</primary>
      </indexterm></para>

    <para id="para_specs_object_for_obs_clicks">Here is a Specs object that
    demonstrates <literal>ObservableClicks</literal> and
    <literal>VetoableClicks</literal> working together. Note that a separate
    <literal>with</literal> keyword is required for each trait, as opposed to
    using one keyword and separating the names with commas, as Java does for
    <literal role="keep-together">implements</literal> clauses:<indexterm>
        <primary>ObservableClicks trait (example)</primary>

        <secondary>working with VetoableClicks trait (example)</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui2/button-clickable-observer-vetoable-spec.scala

package ui2
import org.specs._
import observer._
import ui.ButtonCountObserver

object ButtonClickableObserverVetoableSpec extends Specification {
  "A Button Observer with Vetoable Clicks" should {
    "observe only the first button click" in {
      val observableButton =
          new Button("Okay") with ObservableClicks with VetoableClicks
      val buttonClickCountObserver = new ButtonCountObserver
      observableButton.addObserver(buttonClickCountObserver)

      for (i &lt;- 1 to 3) observableButton.click()
      buttonClickCountObserver.count mustEqual 1
    }
  }
}</programlisting>

    <para id="para_the_expected_observer_count_is">The expected observer count
    is 1. The <literal>observableButton</literal> is declared as
    follows:</para>

    <programlisting linenumbering="unnumbered">new Button("Okay") with ObservableClicks with VetoableClicks</programlisting>

    <para id="para_we_can_infer_that_the_click_">We can infer that the
    <literal>click</literal> override in <literal>VetoableClicks</literal> is
    called <emphasis>before</emphasis> the <literal>click</literal> override
    in <literal>ObservableClicks</literal>. Loosely speaking, since our
    anonymous class doesn&#x2019;t define <literal>click</literal> itself, the method
    lookup proceeds <emphasis>right to left</emphasis>, as declared. It&#x2019;s
    actually more complicated than that, as we&#x2019;ll see later in <xref linkend="Linearization"/>.</para>

    <para id="para_in_the_meantime_what_happens_">In the meantime, what
    happens if we use the traits in the reverse order?</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui2/button-vetoable-clickable-observer-spec.scala

package ui2
import org.specs._
import observer._
import ui.ButtonCountObserver

object ButtonVetoableClickableObserverSpec extends Specification {
  "A Vetoable Button with Click Observer" should {
    "observe all the button clicks, even when some are vetoed" in {
      val observableButton =
          new Button("Okay") with VetoableClicks with ObservableClicks
      val buttonClickCountObserver = new ButtonCountObserver
      observableButton.addObserver(buttonClickCountObserver)

      for (i &lt;- 1 to 3) observableButton.click()
      buttonClickCountObserver.count mustEqual 3
    }
  }
}</programlisting>

    <para id="para_now_the_expected_observer_coun">Now the expected observer
    count is 3. <literal>ObservableClicks</literal> now has precedence over
    <literal>VetoableClicks</literal>, so the count of clicks is incremented,
    even when some clicks are subsequently vetoed!</para>

    <para id="para_so_the_order_of_declaration_m">So, the order of declaration
    matters, which is important to remember for preventing unexpected behavior
    when traits impact each other. Perhaps another lesson to note is that
    splitting objects into too many fine-grained traits can obscure the order
    of execution in your code!<indexterm>
        <primary>declarations</primary>

        <secondary>order of declaration, traits and</secondary>
      </indexterm></para>

    <para id="para_breaking_up_your_application_i">Breaking up your
    application into small, focused traits is a powerful way to create
    reusable, scalable abstractions and &#x201C;components.&#x201D; Complex behaviors can be
    built up through <emphasis>declarative composition</emphasis> of traits.
    We will explore this idea in greater detail in <xref linkend="ScalableAbstractions"/>.<indexterm>
        <primary>declarative composition of traits</primary>
      </indexterm></para>
  </sect1>

  <sect1 id="ConstructingTraits">
    <title>Constructing Traits</title>

    <para id="para_traits_don_t_support_auxiliary">Traits don&#x2019;t support
    auxiliary constructors, nor do they accept an argument list for the
    primary constructor, the body of a trait. Traits can extend classes or
    other traits. However, they can&#x2019;t pass arguments to the parent class
    constructor (even literal values), so traits can only extend classes that
    have a no-argument primary or auxiliary constructor.<indexterm>
        <primary>traits</primary>

        <secondary>constructing</secondary>
      </indexterm></para>

    <para id="para_however_like_classes_the_bod">However, like classes, the
    body of a trait is executed every time an instance is created that uses
    the trait, as demonstrated by the following script:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/trait-construction-script.scala

trait T1 {
  println( "  in T1: x = " + x )
  val x=1
  println( "  in T1: x = " + x )
}
trait T2 {
  println( "  in T2: y = " + y )
  val y="T2"
  println( "  in T2: y = " + y )
}

class Base12 {
  println( "  in Base12: b = " + b )
  val b="Base12"
  println( "  in Base12: b = " + b )
}
class C12 extends Base12 with T1 with T2 {
  println( "  in C12: c = " + c )
  val c="C12"
  println( "  in C12: c = " + c )
}
println( "Creating C12:" )
new C12
println( "After Creating C12" )</programlisting>

    <para id="para_running_script_oop1a">Running this script with the
    <literal>scala</literal> command yields the following output:</para>

    <screen>Creating C12:
&#xA0;&#xA0;in Base12: b = null
&#xA0;&#xA0;in Base12: b = Base12
&#xA0;&#xA0;in T1: x = 0
&#xA0;&#xA0;in T1: x = 1
&#xA0;&#xA0;in T2: y = null
&#xA0;&#xA0;in T2: y = T2
&#xA0;&#xA0;in C12: c = null
&#xA0;&#xA0;in C12: c = C12
After Creating C12</screen>

    <para>Notice the order of invocation of the class and trait constructors.
    Since the declaration of <literal>C12</literal> is <literal>extends Base12
    with T1 with T2</literal>, the order of construction for this simple class
    hierarchy is left to right, starting with the base class
    <literal>Base12</literal>, followed by the traits <literal>T1</literal>
    and <literal>T2</literal>, and ending with the <literal>C12</literal>
    constructor body. (For constructing arbitrarily <phrase role="keep-together">complex</phrase> hierarchies, see <xref linkend="Linearization"/>.)<indexterm>
        <primary>traits</primary>

        <secondary>constructing</secondary>

        <tertiary>initializing values in traits</tertiary>
      </indexterm></para>

    <para id="para_so_while_you_can_t_pass_const">So, while you can&#x2019;t pass
    construction parameters to traits, you can initialize fields with default
    values or leave them abstract. We actually saw this before in our
    <literal>Subject</literal> trait, where the
    <literal>Subject.observers</literal> field was initialized to an empty
    list.</para>

    <para id="para_if_a_field_in_a_trait_does_not">If a concrete field in a
    trait does not have a suitable default value, there is no &#x201C;fail-safe&#x201D; way
    to initialize the value. All the alternative approaches require some ad
    hoc steps by users of the trait, which is error-prone because they might
    do it wrong or forget to do it all. Perhaps the field should be left
    abstract, so that classes or other traits that use this trait are forced
    to define the value appropriately. We&#x2019;ll discuss overriding abstract and
    concrete members in detail in <xref linkend="AdvancedObjectOrientedProgramming"/>.</para>

    <para id="para_another_solution_is_to_move_th">Another solution is to move
    that field to a separate class, where the construction process can
    guarantee that the correct initialization data is supplied by the user. It
    might be that the whole trait should actually be a class instead, so you
    can define a constructor for it that initializes the field.</para>

    <sect2 id="ClassOrTrait">
      <title>Class or Trait?</title>

      <para id="para_when_considering_whether_a_c">When considering whether a
      &#x201C;concept&#x201D; should be a trait or a class, keep in mind that traits as
      mixins make the most sense for &#x201C;adjunct&#x201D; behavior. If you find that a
      particular trait is used most often as a parent of other classes, so
      that the child classes <emphasis>behave as</emphasis> the parent trait,
      then consider defining the trait as a class instead, to make this
      logical relationship more clear. (We said <emphasis>behaves
      as</emphasis>, rather than <emphasis>is a</emphasis>, because the former
      is the more precise definition of inheritance, based on the
      <emphasis>Liskov Substitution Principle</emphasis>&#x2014;see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>, for
      example.)<indexterm>
          <primary>Liskov Substitution Principle</primary>
        </indexterm><indexterm>
          <primary>inheritance</primary>

          <secondary>definition</secondary>
        </indexterm><indexterm>
          <primary>classes</primary>

          <secondary>traits versus</secondary>
        </indexterm><indexterm>
          <primary>traits</primary>

          <secondary>constructing</secondary>

          <tertiary>class or trait</tertiary>
        </indexterm></para>

      <tip id="para_tip_avoid_fields_in_traits_th">
        <para>Avoid concrete fields in traits that can&#x2019;t be initialized to
        suitable default values. Use abstract fields instead, or convert the
        trait to a class with <phrase role="keep-together">a
        constructor.</phrase> Of course, stateless traits don&#x2019;t have any
        issues with <phrase role="keep-together">initialization</phrase>.</para>
      </tip>

      <para id="para_it_s_a_general_principle_of_go">It&#x2019;s a general principle
      of good object-oriented design that an instance should always be in a
      known valid state, starting from the moment the construction process
      finishes.</para>
    </sect2>
  </sect1>

  <sect1 id="TraitsRecapAndWhatsNext">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_in_this_chapter_we_learned_ho">In this chapter, we learned
    how to use traits to encapsulate and share cross-cutting concerns between
    classes. We covered when and how to use traits, how to &#x201C;stack&#x201D; multiple
    traits, and the rules for initializing values within traits.</para>

    <para id="para_in_the_next_chapter_we_explor">In the next chapter, we
    explore how the fundamentals of object-oriented programming work in Scala.
    Even if you&#x2019;re an old hand at object-oriented programming, you&#x2019;ll want to
    read the next several chapters to understand the particulars of Scala&#x2019;s
    approach to OOP.<indexterm class="endofrange" startref="ch04_traits"/></para>
  </sect1>
</chapter>
  <chapter id="BasicObjectOrientedProgramming">
  <title>Basic Object-Oriented Programming <phrase role="keep-together">in
  Scala</phrase></title>

  <para id="para_scala_is_an_object_oriented_la">Scala is an object-oriented
  language like Java, Python, Ruby, Smalltalk, and others. If you&#x2019;re coming
  from the Java world, you&#x2019;ll notice some notable improvements over the
  limitations of Java&#x2019;s object model.<indexterm class="startofrange" id="ch05_OOP">
      <primary>object-oriented programming (OOP)</primary>
    </indexterm></para>

  <para id="para_we_assume_you_have_some_prior_">We assume you have some prior
  experience with object-oriented programming (OOP), so we will not discuss
  the basic principles here, although some common terms and concepts are
  discussed in the <xref linkend="Glossary"/>. See <link linkend="Meyer1997" xrefstyle="select:nopage">[Meyer1997]</link> for a detailed introduction to
  OOP; see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link> for a recent treatment of OOP
  principles in the context of &#x201C;agile software development&#x201D;; see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link> to learn about
  <emphasis>design patterns</emphasis>; and see <link linkend="WirfsBrock2003" xrefstyle="select:nopage">[WirfsBrock2003]</link> for a discussion of
  object-oriented design concepts.<indexterm>
      <primary>object-oriented programming (OOP)</primary>

      <secondary>classes and objects, basics of</secondary>
    </indexterm><indexterm>
      <primary>objects</primary>

      <secondary>basics of</secondary>
    </indexterm><indexterm>
      <primary>classes</primary>

      <secondary>basics of</secondary>
    </indexterm></para>

  <sect1 id="ClassBasics">
    <title>Class and Object Basics</title>

    <para id="para_let_s_review_the_basic_terms_f">Let&#x2019;s review the
    terminology of OOP in Scala.</para>

    <note id="para_note_we_saw_previously_that_s">
      <para>We saw previously that Scala has the concept of a declared
      <literal>object</literal>, <phrase role="keep-together">which we&#x2019;ll
      dig</phrase> into in <xref linkend="ClassesAndObjects"/>. We&#x2019;ll use the
      term <emphasis>instance</emphasis> to refer to a class instance
      generically, meaning either an <literal>object</literal> or an instance
      of a <literal>class</literal>, to avoid the potential for confusion
      between these two concepts.<indexterm>
          <primary>instance</primary>
        </indexterm></para>
    </note>

    <para id="para_classes_are_declared_with_a_cl">Classes are declared with
    the keyword <literal>class</literal>. We will see later that additional
    keywords can also be used, like <literal>final</literal> to prevent
    creation of <emphasis>derived</emphasis> classes and
    <literal>abstract</literal> to indicate that the class can&#x2019;t be
    instantiated, usually because it contains or inherits member declarations
    without providing concrete definitions for them.<indexterm>
        <primary>class keyword</primary>
      </indexterm></para>

    <para id="para_an_instance_can_refer_to_itsel">An instance can refer to
    itself using the <literal>this</literal> keyword, just as in Java and
    similar <phrase role="keep-together">languages</phrase>.<indexterm>
        <primary>this keyword</primary>
      </indexterm></para>

    <para id="para_following_scala_s_convention_">Following Scala&#x2019;s
    convention, we use the term <emphasis>method</emphasis> for a function
    that is tied to an instance. Some other object-oriented languages use the
    term &#x201C;member function.&#x201D; Method definitions start with the
    <literal>def</literal> keyword.<indexterm>
        <primary>methods</primary>
      </indexterm></para>

    <para id="para_like_java_but_unlike_ruby_sc">Like Java, but unlike Ruby
    and Python, Scala allows <emphasis>overloaded methods</emphasis>. Two or
    more methods can have the same name as long as their full
    <emphasis>signatures</emphasis> are unique. The
    <emphasis>signature</emphasis> includes the type name, the list of
    parameters with types, and the method&#x2019;s return value.<indexterm>
        <primary>overloaded methods</primary>
      </indexterm><indexterm>
        <primary>signature</primary>
      </indexterm></para>

    <para id="para_type_erasure_method_overloading">There is an exception to
    this rule due to <emphasis>type erasure</emphasis>, which is a feature of
    the JVM only, but is used by Scala on both the JVM and .NET platforms, to
    minimize incompatibilities. Suppose two methods are identical except that
    one takes a parameter of type <literal>List[String]</literal> while the
    other takes a parameter of type <literal>List[Int]</literal>, as
    follows:<indexterm>
        <primary>type erasure</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/type-erasure-wont-compile.scala
// WON'T COMPILE

object Foo {
  def bar(list: List[String]) = list.toString
  def bar(list: List[Int]) = list.size.toString
}</programlisting>

    <para id="para_you_ll_get_a_compilation_error">You&#x2019;ll get a compilation
    error on the second method because the two methods will have an identical
    signature after type erasure.</para>

    <warning id="para_warning_the_scala_interpret">
      <para>The <literal>scala</literal> interpreter will let you type in both
      methods. It simply drops the first version. However, if you try to load
      the previous example using the <literal>:load file</literal> command,
      you&#x2019;ll get the same error <literal>scalac</literal> raises.</para>
    </warning>

    <para id="para_we_ll_discuss_type_erasure_in_">We&#x2019;ll discuss type erasure
    in more detail in <xref linkend="ScalasTypeSystem"/>.</para>

    <para id="para_also_by_convention_we_use_the">Also by convention, we use
    the term <emphasis>field</emphasis> for a variable that is tied to an
    instance. The term <emphasis>attribute</emphasis> is often used in other
    languages (like Ruby). Note that the state of an instance is the union of
    all the values currently represented by the instance&#x2019;s fields.<indexterm>
        <primary>fields</primary>
      </indexterm><indexterm>
        <primary>attributes</primary>
      </indexterm></para>

    <para id="para_as_we_discussed_in_variabled">As we discussed in <xref linkend="VariableDeclarationsAndDefinitions"/>, read-only (&#x201C;value&#x201D;)
    fields are declared using the <literal>val</literal> keyword, and
    read-write fields are declared using the <literal>var</literal> <phrase role="keep-together">keyword</phrase>.</para>

    <para id="para_scala_also_allows__types__to_b">Scala also allows types to
    be declared in classes, as we saw in <xref linkend="AbstractTypesAndParameterizedTypes"/>.</para>

    <para id="para_we_use_the_term__member__to_re">We use the term
    <emphasis>member</emphasis> to refer to a field, method, or type in a
    generic way. Note that field and method members (but not type members)
    share the same <emphasis>namespace</emphasis>, unlike Java. We&#x2019;ll discuss
    this more in <xref linkend="UniformAccessPrinciple"/>.<indexterm>
        <primary>members</primary>
      </indexterm></para>

    <para id="para_new_instances_of_reference_types">Finally, new instances of
    <emphasis>reference types</emphasis> are created from a class using the
    <literal>new</literal> keyword, as in languages like Java and C#. Note
    that you can drop the parentheses when using a
    <emphasis>default</emphasis> constructor (i.e., one that takes no
    arguments). In some cases, literal values can be used instead, e.g.,
    <literal>val name = "Programming Scala"</literal> is equivalent to
    <literal>val name = new String("Programming Scala")</literal>.<indexterm>
        <primary>reference types</primary>
      </indexterm></para>

    <para id="para_new_instances_of_value_types">Instances of <emphasis>value
    types</emphasis> (<literal>Int</literal>, <literal>Double</literal>,
    etc.), which correspond to the primitives in languages like Java, are
    always created using literal values, e.g., <literal>1</literal>,
    <literal>3.14</literal>. In fact, there are no public constructors for
    these types, so an expression like <literal>val i = new Int(1)</literal>
    won&#x2019;t compile.<indexterm>
        <primary>primitive data types</primary>

        <secondary>instances of value types corresponding to</secondary>
      </indexterm><indexterm>
        <primary>value types</primary>
      </indexterm></para>

    <para id="para_we_ll_discuss__reference__vs_">We&#x2019;ll discuss the difference
    between reference and value types in <xref linkend="ScalaTypeHierarchy"/>.<indexterm>
        <primary>classes</primary>

        <secondary>parent</secondary>
      </indexterm><indexterm>
        <primary>object-oriented programming (OOP)</primary>

        <secondary>parent classes</secondary>
      </indexterm></para>
  </sect1>

  <sect1 id="ParentClasses">
    <title>Parent Classes</title>

    <para id="para_scala_supports__single_inherit">Scala supports single
    inheritance, not multiple inheritance. A child (or derived) class can have
    one and only one parent (or base) class. The sole exception is the root of
    the Scala class hierarchy, <literal>Any</literal>, which has no
    parent.<indexterm>
        <primary>Any class</primary>
      </indexterm><indexterm>
        <primary>parent classes</primary>
      </indexterm><indexterm>
        <primary>base classes</primary>
      </indexterm></para>

    <para id="para_here_is_a_simple_example_from_">We&#x2019;ve seen several examples
    of parent and child classes. Here are snippets of one of the first we saw,
    in <xref linkend="AbstractTypesAndParameterizedTypes"/>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/abstract-types-script.scala

import java.io._

abstract class BulkReader {
  // ...
}

class StringBulkReader(val source: String) extends BulkReader {
  // ...
}

class FileBulkReader(val source: File) extends BulkReader {
  // ...
}</programlisting>

    <para>As in Java, the keyword <literal>extends</literal> indicates the
    parent class, in this case <literal>BulkReader</literal>. In Scala,
    <literal>extends</literal> is also used when a class inherits a trait as
    its parent (even when it mixes in other traits using the
    <literal>with</literal> keyword). Also, <literal>extends</literal> is used
    when one trait is the child of another trait or class. Yes, traits can
    inherit classes.<indexterm>
        <primary>extends keyword</primary>
      </indexterm></para>

    <para id="para_if_you_don_t_extend_a_parent">If you don&#x2019;t
    <literal>extend</literal> a parent class, the default parent is
    <literal>AnyRef</literal>, a direct child class of <literal>Any</literal>.
    (We discuss the difference between <literal>Any</literal> and
    <literal>AnyRef</literal> when we discuss the Scala type hierarchy in
    <xref linkend="ScalaTypeHierarchy"/>.)</para>
  </sect1>

  <sect1 id="Constructors">
    <title>Constructors in Scala</title>

    <para id="para_scala_distinguishes_between_a_">Scala distinguishes between
    a <emphasis>primary constructor</emphasis> and zero or more
    <emphasis>auxiliary constructors</emphasis>. In Scala, the primary
    constructor is the entire body of the class. Any parameters that the
    constructor requires are listed after the class name. We&#x2019;ve seen many
    examples of this already, as in the <literal>ButtonWithCallbacks</literal>
    example we used in <xref linkend="Traits"/>:<indexterm>
        <primary>auxiliary constructors</primary>
      </indexterm><indexterm>
        <primary>primary constructor</primary>
      </indexterm><indexterm class="startofrange" id="ch05_OOPconstructors">
        <primary>object-oriented programming (OOP)</primary>

        <secondary>constructors</secondary>
      </indexterm><indexterm class="startofrange" id="ch05_constructors">
        <primary>constructors</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button-callbacks.scala

package ui

class ButtonWithCallbacks(val label: String,
    val clickedCallbacks: List[() =&gt; Unit]) extends Widget {

  require(clickedCallbacks != null, "Callback list can't be null!")

  def this(label: String, clickedCallback: () =&gt; Unit) =
    this(label, List(clickedCallback))

  def this(label: String) = {
    this(label, Nil)
    println("Warning: button has no click callbacks!")
  }

  def click() = {
    // ... logic to give the appearance of clicking a physical button ...
    clickedCallbacks.foreach(f =&gt; f())
  }
}</programlisting>

    <para id="para_the_buttonwithcallbacks_clas">The
    <literal>ButtonWithCallbacks</literal> class represents a button on a
    graphical user interface. It has a label and a list of callback functions
    that are invoked if the button is clicked. Each callback function takes no
    arguments and returns <literal>Unit</literal>. The
    <literal>click</literal> method iterates through the list of callbacks and
    invokes each one.</para>

    <para id="para__buttonwithcallbacks_defines_"><literal>ButtonWithCallbacks</literal>
    defines three constructors. The primary constructor, which is the body of
    the entire class, has a parameter list that takes a label string and a
    list of callback functions. Because each parameter is declared as a
    <literal>val</literal>, the compiler generates a private field
    corresponding to each parameter (a different internal name is used), along
    with a public reader method that has the same name as the parameter.
    &#x201C;Private&#x201D; and &#x201C;public&#x201D; have the same meaning here as in most
    object-oriented languages. We&#x2019;ll discuss the various visibility rules and
    the keywords that control them in <xref linkend="VisibilityRules"/>.</para>

    <para id="para_if_a_parameter_has_the_var_k">If a parameter has the
    <literal>var</literal> keyword, a public writer method is also generated
    with the parameter&#x2019;s name as a prefix, followed by <literal>_=</literal>.
    For example, if <literal>label</literal> were declared as a
    <literal>var</literal>, the writer method would be named
    <literal>label_=</literal> and it would take a single argument of type
    <literal>String</literal>.</para>

    <para id="para_suppress_accessors">There are times when you don&#x2019;t want the
    accessor methods to be generated automatically. In other words, you want
    the field to be <emphasis>private</emphasis>. Add the
    <literal>private</literal> keyword before the <literal>val</literal> or
    <literal>var</literal> keyword, and the accessor methods won&#x2019;t be
    generated. (See <xref linkend="VisibilityRules"/> for more
    details.)<indexterm>
        <primary>private keyword</primary>
      </indexterm></para>

    <note id="para_note_scala_doesn_t_follow_the">
      <para>For you Java programmers, Scala doesn&#x2019;t follow the JavaBeans <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>
      convention that field reader and writer methods begin with
      <literal>get</literal> and <literal>set</literal>, respectively,
      followed by the field name with the first character capitalized. We&#x2019;ll
      see why when we discuss the <emphasis>Uniform Access
      Principle</emphasis> in <xref linkend="UniformAccessPrinciple"/>.
      However, you can get JavaBeans-style <emphasis>getters</emphasis> and
      <emphasis>setters</emphasis> when you need them using the
      <literal>scala.reflect.BeanProperty</literal> annotation, as we&#x2019;ll
      discuss in <xref linkend="JavaBeanProperties"/>.</para>
    </note>

    <para id="para_when_an_instance_of_the_class_">When an instance of the
    class is created, each field corresponding to a parameter in the parameter
    list will be initialized with the parameter automatically. No constructor
    logic is required to initialize these fields, in contrast to most other
    object-oriented languages.</para>

    <para id="para_the_first_statement_in_the_cla">The first statement in the
    <literal>ButtonWithCallbacks</literal> class (i.e., the constructor) body
    is a test to ensure that a non-<literal>null</literal> list has been
    passed to the constructor. (It does allow an empty <literal>Nil</literal>
    list, however.) It uses the convenient <literal>require</literal> function
    that is imported automatically into the current scope (as we&#x2019;ll discuss in
    <xref linkend="PredefObject"/>). If the list is null,
    <literal>require</literal> will throw an exception. The
    <literal>require</literal> function and its companion
    <literal>assume</literal> are very useful for <emphasis>Design by
    Contract</emphasis> programming, as discussed in <xref linkend="DesignByContractExample"/>.</para>

    <para id="para_here_is_a_partial_specification">Here is part of a full
    specification for <literal>ButtonWithCallbacks</literal> that demonstrates
    the <literal>require</literal> statement in use:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button-callbacks-spec.scala
package ui
import org.specs._

object ButtonWithCallbacksSpec extends Specification {
  "A ButtonWithCallbacks" should {
    // ...
    "not be constructable with a null callback list" in {
      val nullList:List[() =&gt; Unit] = null
      val errorMessage =
        "requirement failed: Callback list can't be null!"
      (new ButtonWithCallbacks("button1", nullList)) must throwA(
        new IllegalArgumentException(errorMessage))
    }
  }
}</programlisting>

    <para id="para_scala_diff_pass_null">Scala even makes it difficult to pass
    <literal>null</literal> as the second parameter to the constructor; it
    won&#x2019;t type check when you compile it. However, you can assign
    <literal>null</literal> to a value, as shown. If we didn&#x2019;t have the
    <literal>must throwA(...)</literal> clause, we would see the following
    exception thrown:</para>

    <screen>java.lang.IllegalArgumentException: requirement failed: Callback list can't be null!
        at scala.Predef$.require(Predef.scala:112)
        at ui.ButtonWithCallbacks.&lt;init&gt;(button-callbacks.scala:7)
...</screen>

    <para id="para_in_this_example_two_auxiliary"><literal>ButtonWithCallbacks</literal>
    defines two auxiliary constructors for the user&#x2019;s convenience. The first
    auxiliary constructor accepts a label and a single callback. It calls the
    primary constructor, passing the label and a new <literal>List</literal>
    to wrap the single callback.</para>

    <para id="para_the_second_auxiliary_construct">The second auxiliary
    constructor accepts just a label. It calls the primary constructor with
    <literal>Nil</literal> (which represents an empty <literal>List</literal>
    object). The constructor then prints a warning message that there are no
    callbacks, since lists are immutable and there is no way to replace the
    callback list <literal>val</literal> with a new one.</para>

    <para id="para_in_order_to_avoid_potential_in">To avoid infinite
    recursion, Scala requires each auxiliary constructor to invoke another
    constructor defined before it (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). The constructor invoked
    may be either another auxiliary constructor or the primary constructor,
    and it must be the first statement in the auxiliary constructor&#x2019;s body.
    Additional processing can occur after this call, such as the warning
    message printed in our example.</para>

    <note id="para_note_that_because_all_auxiliar">
      <para>Because all auxiliary constructors eventually invoke the primary
      constructor, logic checks and other initializations done in the body
      will be performed consistently for all instances created.</para>
    </note>

    <para id="para_there_are_a_few_advantages_of_">There are a few advantages
    of Scala&#x2019;s constraints on constructors:<indexterm>
        <primary>constructors</primary>

        <secondary>constraints on, advantages and disadvantage of</secondary>
      </indexterm></para>

    <variablelist id="para_advantages_of_ctor_constraints_">
      <varlistentry id="varlistentry-elimination-of-duplication">
        <term>Elimination of duplication</term>

        <listitem>
          <para>Because auxiliary constructors invoke the primary constructor,
          potential duplication of construction logic is largely
          eliminated.</para>
        </listitem>
      </varlistentry>

      <varlistentry id="varlistentry-code-size-reduction">
        <term>Code size reduction</term>

        <listitem>
          <para>As shown in the examples, when one or more of the primary
          constructor parameters is declared as a <literal>val</literal> or a
          <literal>var</literal>, Scala automatically generates a field, the
          appropriate accessor methods (unless they are declared
          <literal>private</literal>), and the initialization logic for when
          instances are created.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para id="para_there_is_also_at_least_one_dis">There is also at least one
    disadvantage of Scala&#x2019;s constraints on constructors:</para>

    <variablelist id="para_less_flexibility_">
      <varlistentry id="varlistentry-less-flexibility">
        <term>Less flexibility</term>

        <listitem>
          <para>Sometimes it&#x2019;s just not convenient to have one constructor
          body that all constructors are forced to use. However, we find these
          circumstances to be rare. In such cases, it may simply be that the
          class has too many responsibilities and it should be refactored into
          smaller classes.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <sect2 id="CallingParentClassConstructors">
      <title>Calling Parent Class Constructors</title>

      <para id="para_the_following_example_illustra">The primary constructor
      in a derived class must invoke one of the parent class constructors,
      either the primary constructor or an auxiliary constructor. In the
      following example, a class derived from
      <literal>ButtonWithCallbacks</literal>, called
      <literal>RadioButtonWithCallbacks</literal>, invokes the primary
      <literal>ButtonWithCallbacks</literal> constructor. &#x201C;Radio&#x201D; buttons can
      be either on or off:<indexterm>
          <primary>constructors</primary>

          <secondary>parent class constructors, calling</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/ui/radio-button-callbacks.scala

package ui

/**
 * Button with two states, on or off, like an old-style,
 * channel-selection button on a radio.
 */
class RadioButtonWithCallbacks(
  var on: Boolean, label: String, clickedCallbacks: List[() =&gt; Unit])
      extends ButtonWithCallbacks(label, clickedCallbacks) {

  def this(on: Boolean, label: String, clickedCallback: () =&gt; Unit) =
      this(on, label, List(clickedCallback))

  def this(on: Boolean, label: String) = this(on, label, Nil)
}</programlisting>

      <para id="para_the_primary_constructor_for_r">The primary constructor
      for <literal>RadioButtonWithCallbacks</literal> takes three parameters:
      an <literal>on</literal> state (<literal>true</literal> or
      <literal>false</literal>), a label, and a list of callbacks. It passes
      the label and list of callbacks to its parent class,
      <literal>ButtonWithCallbacks</literal>. The <literal>on</literal>
      parameter is declared as a <literal>var</literal>, so it is mutable.
      <literal>on</literal> is also the one constructor parameter unique to a
      radio button, so it is kept as an attribute of
      <literal>RadioButtonWithCallbacks</literal>.</para>

      <para id="para_for_consistency_with_its_paren">For consistency with its
      parent class, <literal>RadioButtonWithCallbacks</literal> also declares
      two auxiliary constructors. Note that they must invoke a preceding
      constructor in <literal>RadioButtonWithCallbacks</literal>, as before.
      They can&#x2019;t invoke a <literal>ButtonWithCallbacks</literal> constructor
      directly. Declaring all these constructors in each class could get
      tedious after a while, but we explored techniques in <xref linkend="Traits"/> that can eliminate repetition.<indexterm class="endofrange" startref="ch05_constructors"/><indexterm class="endofrange" startref="ch05_OOPconstructors"/></para>

      <note id="para_cant_super_class_constructor">
        <para>While <literal>super</literal> is used to invoke overridden
        methods, as in Java, it cannot be used to invoke a super class
        constructor.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="NestedClasses">
    <title>Nested Classes</title>

    <para id="para_scala_lets_you_nest_class_decl">Scala lets you nest class
    declarations, like many object-oriented languages. Suppose we want all
    <literal>Widgets</literal> to have a map of properties. These properties
    could be size, color, whether or not the widget is visible, etc. We might
    use a simple <literal>map</literal> to hold the <phrase role="keep-together">properties</phrase>, but let&#x2019;s assume that we also
    want to control access to the properties, and to perform other operations
    when they change.<indexterm>
        <primary>object-oriented programming (OOP)</primary>

        <secondary>nested classes</secondary>
      </indexterm><indexterm>
        <primary>nested classes</primary>
      </indexterm><indexterm>
        <primary>classes</primary>

        <secondary>nested</secondary>
      </indexterm></para>

    <para id="para_here_is_one_way_way_we_might_e">Here is one way we might
    expand our original <literal>Widget</literal> example from <xref linkend="TraitsAsMixins"/> to add this feature:</para>

    <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/ui/widget.scala

package ui

abstract class Widget {
  class Properties {
    import scala.collection.immutable.HashMap

    private var values: Map[String, Any] = new HashMap

    def size = values.size

    def get(key: String) = values.get(key)

    def update(key: String, value: Any) = {
      // Do some preprocessing, e.g., filtering.
      values = values.update(key, value)
      // Do some postprocessing.
    }
  }

  val properties = new Properties
}</programlisting>

    <para id="para_widget_with_properties">We added a
    <literal>Properties</literal> class that has a private, mutable reference
    to an immutable <literal>HashMap</literal>. We also added three public
    methods that retrieve the size (i.e., the number of properties defined),
    retrieve a single element in the map, and update the map with a new
    element, respectively. We might need to do additional work in the
    <literal>update</literal> method, and we&#x2019;ve indicated as much with
    comments.</para>

    <note id="para_so_scala_allows_declarations_">
      <para>You can see from the previous example that Scala allows classes to
      be declared inside one another, or &#x201C;nested.&#x201D; A nested class make sense
      when you have enough related functionality to lump together in a class,
      but the functionality is only ever going to be used by its &#x201C;outer&#x201D;
      class.</para>
    </note>

    <para id="para_so_far_we_ve_covered_how_to_d">So far, we&#x2019;ve covered how to
    declare classes, how to instantiate them, and some of the basics of
    inheritance. In the next section, we&#x2019;ll discuss visibility rules within
    classes and objects.</para>
  </sect1>

  <sect1 id="VisibilityRules">
    <title>Visibility Rules</title>

    <note id="para_for_convenience_we_ll_use_the">
      <para>For convenience, we&#x2019;ll use the word &#x201C;type&#x201D; in this section to
      refer to classes and traits generically, as opposed to referring to
      member <literal>type</literal> declarations. We&#x2019;ll include those when we
      use the term &#x201C;member&#x201D; <phrase role="keep-together">generically</phrase>,
      unless otherwise indicated.</para>
    </note>

    <para id="para_most_object_oriented_languages">Most object-oriented
    languages have constructs to constrain the visibility (or scope) of type
    and type-member declarations. These constructs support the object-oriented
    form of encapsulation, where only the essential public abstraction of a
    class or trait is exposed and implementation information is hidden from
    view.<indexterm>
        <primary>encapsulation</primary>

        <secondary>visibility rules and</secondary>
      </indexterm><indexterm class="startofrange" id="ch05_visibility">
        <primary>visibility</primary>
      </indexterm><indexterm class="startofrange" id="ch05_OOPvisibility">
        <primary>object-oriented programming (OOP)</primary>

        <secondary>visibility rules</secondary>
      </indexterm></para>

    <para id="para_you_ll_want_to_use_public_visi">You&#x2019;ll want to use public
    visibility for anything that users of your classes and objects should see
    and use. Keep in mind that the set of publicly visible members form the
    abstraction exposed by the type, along with the type&#x2019;s name
    itself.<indexterm>
        <primary>fields</primary>

        <secondary>visibility and access to</secondary>
      </indexterm></para>

    <para id="para_the_conventional_wisdom_in_obj">The conventional wisdom in
    object-oriented design is that fields should be private or protected. If
    access is required, it should happen through methods, but not everything
    should be accessible by default. The virtue of the <emphasis>Uniform
    Access Principle</emphasis> (see <xref linkend="UniformAccessPrinciple"/>) is that we can give the user the
    semantics of public field access via either a method or direct access to a
    field, whichever is appropriate for the task.<indexterm>
        <primary>Uniform Access Principle</primary>
      </indexterm></para>

    <tip id="para_tip_the_art_of_good_object_or">
      <para>The art of good object-oriented design includes defining minimal,
      clear, and cohesive public abstractions.</para>
    </tip>

    <para id="para_there_are_two_kinds_of_users">There are two kinds of
    &#x201C;users&#x201D; of a type: derived types, and code that works with instances of
    the type. Derived types usually need more access to the members of their
    parent types than users of instances do.<indexterm>
        <primary>derived types</primary>

        <secondary>access to members of parent types</secondary>
      </indexterm></para>

    <para id="para_scala_s_visibility_rules_are_s">Scala&#x2019;s visibility rules
    are similar to Java&#x2019;s, but tend to be both more consistently applied and
    more flexible. For example, in Java, if an inner class has a
    <literal>private</literal> member, the enclosing class can see it. In
    Scala, the enclosing class can&#x2019;t see a <literal>private</literal> member,
    but Scala provides another way to declare it visible to the enclosing
    class.<indexterm>
        <primary>access modifier keywords</primary>
      </indexterm></para>

    <para id="para_also_like_java_and_c_the_vis">As in Java and C#, the
    keywords that modify visibility, such as <literal>private</literal> and
    <literal role="keep-together">protected</literal>, appear at the beginning
    of declarations. You&#x2019;ll find them before the <literal>class</literal> or
    <literal>trait</literal> keywords for types, before the
    <literal>val</literal> or <literal>var</literal> for fields, and before
    the <literal>def</literal> for methods.<indexterm>
        <primary>declarations</primary>

        <secondary>visibility modifiers in</secondary>
      </indexterm><indexterm>
        <primary>protected keyword</primary>
      </indexterm><indexterm>
        <primary>private keyword</primary>
      </indexterm></para>

    <note id="para_note_you_can_also_use_an_acce">
      <para>You can also use an access modifier keyword on the primary
      constructor of a class. Put it after the type name and type parameters,
      if any, and before the argument list, as in this example: <literal>class
      Restricted[+A] pri&#x2060;vate (name: String) {...}</literal></para>
    </note>

    <para id="para_visibility_scopes_table_summarizes_the_visibility_scopes"><xref linkend="visibility-scopes-table"/> summarizes the visibility
    scopes.<indexterm>
        <primary>visibility</primary>

        <secondary>summary of visibility scopes</secondary>
      </indexterm></para>

    <table id="visibility-scopes-table">
      <title>Visibility scopes</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry>Keyword</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para>public</para></entry>

            <entry><para><emphasis>none</emphasis></para></entry>

            <entry><para>Public members and types are visible everywhere,
            across all boundaries.</para></entry>
          </row>

          <row>
            <entry><para>protected</para></entry>

            <entry><para><literal>protected</literal></para></entry>

            <entry><para>Protected members are visible to the defining type,
            to derived types, and to nested types. Protected types are visible
            only within the same package and subpackages.</para></entry>
          </row>

          <row>
            <entry><para>private</para></entry>

            <entry><para><literal>private</literal></para></entry>

            <entry><para>Private members are visible only within the defining
            type and nested types. Private types are visible only within the
            same package.</para></entry>
          </row>

          <row>
            <entry><para><phrase role="keep-together">scoped
            protected</phrase></para></entry>

            <entry><para><literal role="keep-together">protected[scope]</literal></para></entry>

            <entry><para>Visibility is limited to <literal>scope</literal>,
            which can be a package, type, or <literal>this</literal> (meaning
            the same instance, when applied to members, or the enclosing
            package, when applied to types). See the text below for
            details.</para></entry>
          </row>

          <row>
            <entry><para><phrase role="keep-together">scoped
            private</phrase></para></entry>

            <entry><para><literal role="keep-together">private[scope]</literal></para></entry>

            <entry><para>Synonymous with scoped protected visibility, except
            under inheritance (discussed below).</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_let_s_explore_these_visibility">Let&#x2019;s explore these
    visibility options in more detail. To keep things simple, we&#x2019;ll use fields
    for member examples. Method and type declarations behave the same
    way.</para>

    <note id="para_unfortunately_you_can_t_apply">
      <para>Unfortunately, you can&#x2019;t apply any of the visibility modifiers to
      packages. Therefore, a package is always public, even when it contains
      no publicly visible types.</para>
    </note>

    <sect2 id="PublicVisibility">
      <title>Public Visibility</title>

      <para id="para_any_declaration_without_a_visi">Any declaration without a
      visibility keyword is &#x201C;public,&#x201D; meaning it is visible everywhere. There
      is no <literal>public</literal> keyword in Scala. This is in contrast to
      Java, which defaults to public visibility only within the enclosing
      package (i.e., &#x201C;package private&#x201D;). Other object-oriented languages, like
      Ruby, also default to public visibility:<indexterm>
          <primary>public visibility</primary>
        </indexterm><indexterm>
          <primary>visibility</primary>

          <secondary>public</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/public.scala

package scopeA {
  class PublicClass1 {
    val publicField = 1

    class Nested {
      val nestedField = 1
    }

    val nested = new Nested
  }

  class PublicClass2 extends PublicClass1 {
    val field2  = publicField + 1
    val nField2 = new Nested().nestedField
  }
}

package scopeB {
  class PublicClass1B extends scopeA.PublicClass1

  class UsingClass(val publicClass: scopeA.PublicClass1) {
    def method = "UsingClass:" +
      " field: " + publicClass.publicField +
      " nested field: " + publicClass.nested.nestedField
  }
}</programlisting>

      <para id="para_you_can_compile_this_file_with">You can compile this file
      with <literal>scalac</literal>. It should compile without error.</para>

      <para id="para_everything_is_public_in_these_">Everything is public in
      these packages and classes. Note that
      <literal>scopeB.UsingClass</literal> can access
      <literal>scopeA.PublicClass1</literal> and its members, including the
      instance of <literal>Nested</literal> and its public field.</para>
    </sect2>

    <sect2 id="ProtectedVisibility">
      <title>Protected Visibility</title>

      <para id="para_protected_visibility_is_for_th">Protected visibility is
      for the benefit of implementers of derived types, who need a little more
      access to the details of their parent types. Any member declared with
      the <literal role="keep-together">protected</literal> keyword is visible
      only to the defining type, including other instances of the same type
      and any derived types. When applied to a type,
      <literal>protected</literal> limits visibility to the enclosing
      package.<indexterm>
          <primary>protected visibility</primary>
        </indexterm><indexterm>
          <primary>visibility</primary>

          <secondary>protected</secondary>
        </indexterm></para>

      <para id="para_java_in_contrast_makes_prote">Java, in contrast, makes
      protected members visible throughout the enclosing package. Scala
      handles this case with scoped private and protected access:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/protected-wont-compile.scala
// WON'T COMPILE

package scopeA {
  class ProtectedClass1(protected val protectedField1: Int) {
    protected val protectedField2 = 1

    def equalFields(other: ProtectedClass1) =
      (protectedField1 == other.protectedField1) &amp;&amp;
      (protectedField1 == other.protectedField1) &amp;&amp;
      (nested == other.nested)

    class Nested {
      protected val nestedField = 1
    }

    protected val nested = new Nested
  }

  class ProtectedClass2 extends ProtectedClass1(1) {
    val field1 = protectedField1
    val field2 = protectedField2
    val nField = new Nested().nestedField  // ERROR
  }

  class ProtectedClass3 {
    val protectedClass1 = new ProtectedClass1(1)
    val protectedField1 = protectedClass1.protectedField1 // ERROR
    val protectedField2 = protectedClass1.protectedField2 // ERROR
    val protectedNField = protectedClass1.nested.nestedField // ERROR
  }

  protected class ProtectedClass4

  class ProtectedClass5 extends ProtectedClass4
  protected class ProtectedClass6 extends ProtectedClass4
}

package scopeB {
  class ProtectedClass4B extends scopeA.ProtectedClass4 // ERROR
}</programlisting>

      <para id="para_when_you_compile_this_file_wit">When you compile this
      file with <literal>scalac</literal>, you get the following output. (The
      file names before the <literal>N:</literal> line numbers have been
      removed from the output to better fit the space.)</para>

      <screen>16: error: value nestedField cannot be accessed in ProtectedClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
20: error: value protectedField1 cannot be accessed in scopeA.ProtectedClass1
        val protectedField1 = protectedClass1.protectedField1
                                              ^
21: error: value protectedField2 cannot be accessed in scopeA.ProtectedClass1
        val protectedField2 = protectedClass1.protectedField2
                                              ^
22: error: value nested cannot be accessed in scopeA.ProtectedClass1
        val protectedNField = protectedClass1.nested.nestedField
                                              ^
32: error: class ProtectedClass4 cannot be accessed in package scopeA
    class ProtectedClass4B extends scopeA.ProtectedClass4
                                          ^
5 errors found</screen>

      <para id="para_the_comments_in_the_li">The <literal>// ERROR</literal>
      comments in the listing mark the lines that fail to parse.</para>

      <para id="para__protectedclass2_can_access_p"><literal>ProtectedClass2</literal>
      can access protected members of <literal>ProtectedClass1</literal>,
      since it derives from it. However, it can&#x2019;t access the protected
      <literal>nestedField</literal> in
      <literal>protectedClass1.nested</literal>. Also,
      <literal>ProtectedClass3</literal> can&#x2019;t access protected members of the
      <literal>ProtectedClass1</literal> <phrase role="keep-together">instance</phrase> it uses.</para>

      <para id="para_finally_because_protectedcla">Finally, because
      <literal>ProtectedClass4</literal> is declared
      <literal>protected</literal>, it is not visible in the
      <literal>scopeB</literal> package.</para>
    </sect2>

    <sect2 id="PrivateVisibility">
      <title>Private Visibility</title>

      <para id="para_private_visibility_is_for_comp">Private visibility
      completely hides implementation details, even from the implementers of
      derived classes. Any member declared with the <literal>private</literal>
      keyword is visible only to the defining type, including other instances
      of the same type. When applied to a type, <literal>private</literal>
      limits visibility to the enclosing package:<indexterm>
          <primary>visibility</primary>

          <secondary>private</secondary>
        </indexterm><indexterm>
          <primary>private visibility</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/private-wont-compile.scala
// WON'T COMPILE

package scopeA {
  class PrivateClass1(private val privateField1: Int) {
    private val privateField2 = 1

    def equalFields(other: PrivateClass1) =
      (privateField1 == other.privateField1) &amp;&amp;
      (privateField2 == other.privateField2) &amp;&amp;
      (nested == other.nested)

    class Nested {
      private val nestedField = 1
    }

    private val nested = new Nested
  }

  class PrivateClass2 extends PrivateClass1(1) {
    val field1 = privateField1  // ERROR
    val field2 = privateField2  // ERROR
    val nField = new Nested().nestedField // ERROR
  }

  class PrivateClass3 {
    val privateClass1 = new PrivateClass1(1)
    val privateField1 = privateClass1.privateField1 // ERROR
    val privateField2 = privateClass1.privateField2 // ERROR
    val privateNField = privateClass1.nested.nestedField // ERROR
  }

  private class PrivateClass4

  class PrivateClass5 extends PrivateClass4  // ERROR
  protected class PrivateClass6 extends PrivateClass4 // ERROR
  private class PrivateClass7 extends PrivateClass4
}

package scopeB {
  class PrivateClass4B extends scopeA.PrivateClass4  // ERROR
}</programlisting>

      <para id="para_compiling_yields1">Compiling this file yields the
      following output:</para>

      <screen>14: error: not found: value privateField1
        val field1 = privateField1
                     ^
15: error: not found: value privateField2
        val field2 = privateField2
                     ^
16: error: value nestedField cannot be accessed in PrivateClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
20: error: value privateField1 cannot be accessed in scopeA.PrivateClass1
        val privateField1 = privateClass1.privateField1
                                          ^
21: error: value privateField2 cannot be accessed in scopeA.PrivateClass1
        val privateField2 = privateClass1.privateField2
                                          ^
22: error: value nested cannot be accessed in scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
27: error: private class PrivateClass4 escapes its defining scope as part
of type scopeA.PrivateClass4
    class PrivateClass5 extends PrivateClass4
                                ^
28: error: private class PrivateClass4 escapes its defining scope as part
of type scopeA.PrivateClass4
    protected class PrivateClass6 extends PrivateClass4
                                          ^
33: error: class PrivateClass4 cannot be accessed in package scopeA
    class PrivateClass4B extends scopeA.PrivateClass4
                                        ^
9 errors found</screen>

      <para id="para_now_privateclass2_can_t_acc">Now,
      <literal>PrivateClass2</literal> can&#x2019;t access private members of its
      parent class <literal>PrivateClass1</literal>. They are completely
      invisible to the subclass, as indicated by the error messages. Nor can
      it access a private field in a <literal>Nested</literal> class.</para>

      <para id="para_just_as_for_the_case_of_prote">Just as for the case of
      <literal>protected</literal> access, <literal>PrivateClass3</literal>
      can&#x2019;t access private members of the <literal>PrivateClass1</literal>
      instance it is using. Note, however, that the
      <literal>equalFields</literal> method can access private members of the
      <literal>other</literal> instance.</para>

      <para id="para_the_declarations_of_privatecl">The declarations of
      <literal>PrivateClass5</literal> and <literal>PrivateClass6</literal>
      fail because, if allowed, they would enable
      <literal>PrivateClass4</literal> to &#x201C;escape its defining scope.&#x201D;
      However, the declaration of <literal>PrivateClass7</literal> succeeds
      because it is also declared to be private. Curiously, our previous
      example was able to declare a public class that subclassed a protected
      class without a similar error.</para>

      <para id="para_finally_just_as_for_protecte">Finally, just as for
      <literal>protected</literal> type declarations, the
      <literal>private</literal> types can&#x2019;t be subclassed outside the same
      package.</para>
    </sect2>

    <sect2 id="ScopedPrivateAndProtectedVisibility">
      <title>Scoped Private and Protected Visibility</title>

      <para id="para_scala_allows_you_to_fine_tune_">Scala allows you to
      fine-tune the scope of visibility with the scoped
      <literal>private</literal> and <literal role="keep-together">protected</literal> visibility declarations. Note
      that using <literal>private</literal> or <literal>protected</literal> in
      a scoped declaration is interchangeable, as they behave identically,
      except under inheritance when applied to members.<indexterm class="startofrange" id="ch05_protectedscope">
          <primary>protected visibility</primary>

          <secondary>scoped</secondary>
        </indexterm><indexterm class="startofrange" id="ch05_privatescoped">
          <primary>private visibility</primary>

          <secondary>scoped</secondary>
        </indexterm><indexterm class="startofrange" id="ch05_scopevisibility">
          <primary>scope</primary>

          <secondary sortas="private and protected">of private and protected
          visibility</secondary>
        </indexterm><indexterm class="startofrange" id="ch05_visibilityscoped">
          <primary>visibility</primary>

          <secondary>scoped private and protected visibility</secondary>
        </indexterm></para>

      <tip id="para_tip_while_either_choice_is_fi">
        <para>While either choice behaves the same in most scenarios, it is
        more common to see <literal>private[X]</literal> rather than
        <literal>protected[X]</literal> used in code. In the core libraries
        included with Scala, the ratio is roughly five to one.</para>
      </tip>

      <para id="para_let_s_begin_by_considering_the">Let&#x2019;s begin by
      considering the only differences in behavior between scoped private and
      scoped protected&#x2014;how they behave under inheritance when members have
      these scopes:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/scope-inheritance-wont-compile.scala
// WON'T COMPILE

package scopeA {
  class Class1 {
    private[scopeA]   val scopeA_privateField = 1
    protected[scopeA] val scopeA_protectedField = 2
    private[Class1]   val class1_privateField = 3
    protected[Class1] val class1_protectedField = 4
    private[this]     val this_privateField = 5
    protected[this]   val this_protectedField = 6
  }

  class Class2 extends Class1 {
    val field1 = scopeA_privateField
    val field2 = scopeA_protectedField
    val field3 = class1_privateField     // ERROR
    val field4 = class1_protectedField
    val field5 = this_privateField       // ERROR
    val field6 = this_protectedField
  }
}

package scopeB {
  class Class2B extends scopeA.Class1 {
    val field1 = scopeA_privateField     // ERROR
    val field2 = scopeA_protectedField
    val field3 = class1_privateField     // ERROR
    val field4 = class1_protectedField
    val field5 = this_privateField       // ERROR
    val field6 = this_protectedField
  }
}</programlisting>

      <para id="para_compiling_scoped_members_yields">Compiling this file
      yields the following output:</para>

      <screen>17: error: not found: value class1_privateField
    val field3 = class1_privateField     // ERROR
                 ^
19: error: not found: value this_privateField
    val field5 = this_privateField       // ERROR
                 ^
26: error: not found: value scopeA_privateField
    val field1 = scopeA_privateField     // ERROR
                 ^
28: error: not found: value class1_privateField
    val field3 = class1_privateField     // ERROR
                 ^
30: error: not found: value this_privateField
    val field5 = this_privateField       // ERROR
                 ^
5 errors found</screen>

      <para id="para_the_first_two_errors_inside_">The first two errors,
      inside <literal>Class2</literal>, show us that a derived class inside
      the same package can&#x2019;t reference a member that is scoped private to the
      parent class or <literal>this</literal>, but it can reference a private
      member scoped to the package (or type) that encloses both
      <literal>Class1</literal> and <literal>Class2</literal>.</para>

      <para id="para_in_contrast_for_a_derived_cla">In contrast, for a derived
      class outside the same package, it has no access to any of the scoped
      private members of <literal>Class1</literal>.</para>

      <para id="para_however_all_the_scoped_protec">However, all the scoped
      protected members are visible in both derived classes.</para>

      <para id="para_we_ll_use_private_for_our_ex">We&#x2019;ll use scoped private
      declarations for the rest of our examples and discussion, since use of
      scoped private is a little more common in the Scala library than scoped
      protected, when the previous inheritance scenarios aren&#x2019;t a
      factor.</para>

      <para id="para_first_let_s_start_with_the_mo">First, let&#x2019;s start with
      the most restrictive visibility, <literal>private[this]</literal>, as it
      affects type members:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/private-this-wont-compile.scala
// WON'T COMPILE

package scopeA {
  class PrivateClass1(private[this] val privateField1: Int) {
    private[this] val privateField2 = 1

    def equalFields(other: PrivateClass1) =
      (privateField1 == other.privateField1) &amp;&amp; // ERROR
      (privateField2 == other.privateField2) &amp;&amp;
      (nested == other.nested)

    class Nested {
      private[this] val nestedField = 1
    }

    private[this] val nested = new Nested
  }

  class PrivateClass2 extends PrivateClass1(1) {
    val field1 = privateField1  // ERROR
    val field2 = privateField2  // ERROR
    val nField = new Nested().nestedField  // ERROR
  }

  class PrivateClass3 {
    val privateClass1 = new PrivateClass1(1)
    val privateField1 = privateClass1.privateField1  // ERROR
    val privateField2 = privateClass1.privateField2  // ERROR
    val privateNField = privateClass1.nested.nestedField // ERROR
  }
}</programlisting>

      <para id="para_compiling_yields2">Compiling this file yields the
      following output:</para>

      <screen>5: error: value privateField1 is not a member of scopeA.PrivateClass1
            (privateField1 == other.privateField1) &amp;&amp;
                                    ^
14: error: not found: value privateField1
        val field1 = privateField1
                     ^
15: error: not found: value privateField2
        val field2 = privateField2
                     ^
16: error: value nestedField is not a member of PrivateClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
20: error: value privateField1 is not a member of scopeA.PrivateClass1
        val privateField1 = privateClass1.privateField1
                                          ^
21: error: value privateField2 is not a member of scopeA.PrivateClass1
        val privateField2 = privateClass1.privateField2
                                          ^
22: error: value nested is not a member of scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
7 errors found</screen>

      <note id="para_note_lines_6_8_also_won_t_par">
        <para>Lines 6&#x2013;8 also won&#x2019;t parse. Since they are part of the
        expression that started on line 5, the compiler stopped after the
        first error.</para>
      </note>

      <para id="para_the_private_this_members_ar">The
      <literal>private[this]</literal> members are only visible to the same
      instance. An instance of the same class can&#x2019;t see
      <literal>private[this]</literal> members of another instance, so the
      <literal>equalFields</literal> method won&#x2019;t parse.</para>

      <para id="para_otherwise_the_visibility_of_c">Otherwise, the visibility
      of class members is the same as <literal>private</literal> without a
      scope <phrase role="keep-together">specifier</phrase>.</para>

      <para id="para_when_declaring_a_type_with_pr">When declaring a type with
      <literal>private[this]</literal>, use of <literal>this</literal>
      effectively binds to the enclosing package, as shown here:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/private-this-pkg-wont-compile.scala
// WON'T COMPILE

package scopeA {
  private[this] class PrivateClass1

  package scopeA2 {
    private[this] class PrivateClass2
  }

  class PrivateClass3 extends PrivateClass1  // ERROR
  protected class PrivateClass4 extends PrivateClass1 // ERROR
  private class PrivateClass5 extends PrivateClass1
  private[this] class PrivateClass6 extends PrivateClass1

  private[this] class PrivateClass7 extends scopeA2.PrivateClass2 // ERROR
}

package scopeB {
  class PrivateClass1B extends scopeA.PrivateClass1 // ERROR
}</programlisting>

      <para id="para_compiling_yields3">Compiling this file yields the
      following output:</para>

      <screen>8: error: private class PrivateClass1 escapes its defining scope as part
of type scopeA.PrivateClass1
    class PrivateClass3 extends PrivateClass1
                                ^
9: error: private class PrivateClass1 escapes its defining scope as part
of type scopeA.PrivateClass1
    protected class PrivateClass4 extends PrivateClass1
                                          ^
13: error: type PrivateClass2 is not a member of package scopeA.scopeA2
    private[this] class PrivateClass7 extends scopeA2.PrivateClass2
                                                      ^
17: error: type PrivateClass1 is not a member of package scopeA
    class PrivateClass1B extends scopeA.PrivateClass1
                                        ^
four errors found</screen>

      <para id="para_in_the_same_package_attemptin">In the same package,
      attempting to declare a <literal>public</literal> or
      <literal>protected</literal> subclass fails. Only
      <literal>private</literal> and <literal>private[this]</literal>
      subclasses are allowed. Also, <literal>PrivateClass2</literal> is scoped
      to <literal>scopeA2</literal>, so you can&#x2019;t declare it outside
      <literal>scopeA2</literal>. Similarly, an attempt to declare a class in
      unrelated <literal>scopeB</literal> using
      <literal>PrivateClass1</literal> also fails.</para>

      <para id="para_hence_when_applied_to_types_">Hence, when applied to
      types, <literal>private[this]</literal> is equivalent to Java&#x2019;s
      <literal>package private</literal> visibility.</para>

      <para id="para_next_let_s_examine_type_level">Next, let&#x2019;s examine
      type-level visibility, <literal>private[T]</literal>, where
      <literal>T</literal> is a type:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/private-type-wont-compile.scala
// WON'T COMPILE

package scopeA {
  class PrivateClass1(private[PrivateClass1] val privateField1: Int) {
    private[PrivateClass1] val privateField2 = 1

    def equalFields(other: PrivateClass1) =
      (privateField1 == other.privateField1) &amp;&amp;
      (privateField2 == other.privateField2) &amp;&amp;
      (nested  == other.nested)

    class Nested {
      private[Nested] val nestedField = 1
    }

    private[PrivateClass1] val nested = new Nested
    val nestedNested = nested.nestedField   // ERROR
  }

  class PrivateClass2 extends PrivateClass1(1) {
    val field1 = privateField1  // ERROR
    val field2 = privateField2  // ERROR
    val nField = new Nested().nestedField  // ERROR
  }

  class PrivateClass3 {
    val privateClass1 = new PrivateClass1(1)
    val privateField1 = privateClass1.privateField1  // ERROR
    val privateField2 = privateClass1.privateField2  // ERROR
    val privateNField = privateClass1.nested.nestedField // ERROR
  }
}</programlisting>

      <para id="para_compiling_yields4">Compiling this file yields the
      following output:</para>

      <screen>12: error: value nestedField cannot be accessed in PrivateClass1.this.Nested
        val nestedNested = nested.nestedField
                                  ^
15: error: not found: value privateField1
        val field1 = privateField1
                     ^
16: error: not found: value privateField2
        val field2 = privateField2
                     ^
17: error: value nestedField cannot be accessed in PrivateClass2.this.Nested
        val nField = new Nested().nestedField
                                  ^
21: error: value privateField1 cannot be accessed in scopeA.PrivateClass1
        val privateField1 = privateClass1.privateField1
                                          ^
22: error: value privateField2 cannot be accessed in scopeA.PrivateClass1
        val privateField2 = privateClass1.privateField2
                                          ^
23: error: value nested cannot be accessed in scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
7 errors found</screen>

      <para id="para_a_private_privateclass1_mem">A
      <literal>private[PrivateClass1]</literal> member is visible to other
      instances, so the <literal>equalFields</literal> method now parses.
      Hence, <literal>private[T]</literal> is not as restrictive as
      <literal>private[this]</literal>. Note <phrase role="keep-together">that
      <literal>PrivateClass1</literal> can&#x2019;t</phrase> see
      <literal>Nested.nestedField</literal> because that field is declared
      <literal role="keep-together">private[Nes&#x2060;ted]</literal>.</para>

      <tip id="para_tip_when_members_of_t_are_d">
        <para>When members of <literal>T</literal> are declared
        <literal>private[T]</literal> the behavior is equivalent to
        <literal>private</literal>. It is not equivalent to
        <literal>private[this]</literal>, which is more <phrase role="keep-together">restrictive</phrase>.</para>
      </tip>

      <para id="para_what_if_we_change_the_scope_of">What if we change the
      scope of <literal>Nested.nestedField</literal> to be
      <literal>private[PrivateClass1]</literal>? Let&#x2019;s see how
      <literal>private[T]</literal> affects nested types:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/private-type-nested-wont-compile.scala
// WON'T COMPILE

package scopeA {
  class PrivateClass1 {
    class Nested {
      private[PrivateClass1] val nestedField = 1
    }

    private[PrivateClass1] val nested = new Nested
    val nestedNested = nested.nestedField
  }

  class PrivateClass2 extends PrivateClass1 {
    val nField = new Nested().nestedField   // ERROR
  }

  class PrivateClass3 {
    val privateClass1 = new PrivateClass1
    val privateNField = privateClass1.nested.nestedField // ERROR
  }
}</programlisting>

      <para id="para_compiling_yields5">Compiling this file yields the
      following output:</para>

      <screen>10: error: value nestedField cannot be accessed in PrivateClass2.this.Nested
        def nField = new Nested().nestedField
                                  ^
14: error: value nested cannot be accessed in scopeA.PrivateClass1
        val privateNField = privateClass1.nested.nestedField
                                          ^
two errors found</screen>

      <para id="para_now_nestedfield_is_visible_t">Now
      <literal>nestedField</literal> is visible to
      <literal>PrivateClass1</literal>, but it is still invisible outside of
      <literal>PrivateClass1</literal>. This is how <literal>private</literal>
      works in Java.</para>

      <para id="para_let_s_examine_scoping_using_a_">Let&#x2019;s examine scoping
      using a package name:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/private-pkg-type-wont-compile.scala
// WON'T COMPILE

package scopeA {
  private[scopeA] class PrivateClass1

  package scopeA2 {
    private [scopeA2] class PrivateClass2
    private [scopeA]  class PrivateClass3
  }

  class PrivateClass4 extends PrivateClass1
  protected class PrivateClass5 extends PrivateClass1
  private class PrivateClass6 extends PrivateClass1
  private[this] class PrivateClass7 extends PrivateClass1

  private[this] class PrivateClass8 extends scopeA2.PrivateClass2 // ERROR
  private[this] class PrivateClass9 extends scopeA2.PrivateClass3
}

package scopeB {
  class PrivateClass1B extends scopeA.PrivateClass1 // ERROR
}</programlisting>

      <para id="para_compiling_yields6">Compiling this file yields the
      following output:</para>

      <screen>14: error: class PrivateClass2 cannot be accessed in package scopeA.scopeA2
    private[this] class PrivateClass8 extends scopeA2.PrivateClass2
                                                      ^
19: error: class PrivateClass1 cannot be accessed in package scopeA
    class PrivateClass1B extends scopeA.PrivateClass1
                                        ^
two errors found</screen>

      <para id="para_note_that_privateclass2_can_">Note that
      <literal>PrivateClass2</literal> can&#x2019;t be subclassed outside of
      <literal>scopeA2</literal>, but <literal>PrivateClass3</literal> can be
      subclassed in <literal>scopeA</literal>, because it is declared
      <literal>private[scopeA]</literal>.</para>

      <para id="para_finally_let_s_look_at_the_eff">Finally, let&#x2019;s look at the
      effect of package-level scoping of type members:</para>

      <programlisting linenumbering="unnumbered">// code-examples/BasicOOP/scoping/private-pkg-wont-compile.scala
// WON'T COMPILE

package scopeA {
  class PrivateClass1 {
    private[scopeA] val privateField = 1

    class Nested {
      private[scopeA] val nestedField = 1
    }

    private[scopeA] val nested = new Nested
  }

  class PrivateClass2 extends PrivateClass1 {
    val field  = privateField
    val nField = new Nested().nestedField
  }

  class PrivateClass3 {
    val privateClass1 = new PrivateClass1
    val privateField  = privateClass1.privateField
    val privateNField = privateClass1.nested.nestedField
  }

  package scopeA2 {
    class PrivateClass4 {
      private[scopeA2] val field1 = 1
      private[scopeA]  val field2 = 2
    }
  }

  class PrivateClass5 {
    val privateClass4 = new scopeA2.PrivateClass4
    val field1 = privateClass4.field1  // ERROR
    val field2 = privateClass4.field2
  }
}

package scopeB {
  class PrivateClass1B extends scopeA.PrivateClass1 {
    val field1 = privateField   // ERROR
    val privateClass1 = new scopeA.PrivateClass1
    val field2 = privateClass1.privateField  // ERROR
  }
}</programlisting>

      <para id="para_compiling_yields7">Compiling this file yields the
      following output:</para>

      <screen>28: error: value field1 cannot be accessed in scopeA.scopeA2.PrivateClass4
        val field1 = privateClass4.field1
                                   ^
35: error: not found: value privateField
        val field1 = privateField
                     ^
37: error: value privateField cannot be accessed in scopeA.PrivateClass1
        val field2 = privateClass1.privateField
                                   ^
three errors found</screen>

      <para id="para_the_only_errors_are_when_we_at">The only errors are when
      we attempt to access members scoped to <literal>scopeA</literal> from
      the unrelated package <literal>scopeB</literal> and when we attempt to
      access a member from a nested package <literal>scopeA2</literal> that is
      scoped to that package.<indexterm class="endofrange" startref="ch05_protectedscope"/><indexterm class="endofrange" startref="ch05_privatescoped"/><indexterm class="endofrange" startref="ch05_visibilityscoped"/><indexterm class="endofrange" startref="ch05_scopevisibility"/></para>

      <tip id="para_tip_when_a_type_or_member_is_">
        <para>When a type or member is declared <literal>private[P]</literal>,
        where <literal>P</literal> is the enclosing package, then it is
        equivalent to Java&#x2019;s <literal>package private</literal>
        visibility.</para>
      </tip>
    </sect2>

    <sect2 id="FinalThoughtsVisibility">
      <title>Final Thoughts on Visibility</title>

      <para id="para_scala_visibility_declarations_">Scala visibility
      declarations are very flexible, and they behave consistently. They
      provide fine-grained control over visibility at all possible scopes,
      from the instance level (<literal role="keep-together">private[this]</literal>) up to package-level
      visibility (<literal>private[P]</literal>, for a package
      <literal>P</literal>). For example, they make it easier to create
      &#x201C;components&#x201D; with types exposed outside of the component&#x2019;s top-level
      package, while hiding implementation types and type members within the
      &#x201C;component&#x2019;s&#x201D; packages.</para>

      <para id="para_finally_we_have_observed_a_po">Finally, we have observed
      a potential &#x201C;gotcha&#x201D; with hidden members of traits.</para>

      <tip id="para_tip_be_careful_when_choosing_">
        <para>Be careful when choosing the names of members of traits. If two
        traits have a member of the same name and the traits are used in the
        same instance, a name collision will occur even if both members are
        private.</para>
      </tip>

      <para id="para_fortunately_the_parser_catche">Fortunately, the compiler
      catches this problem.<indexterm class="endofrange" startref="ch05_OOPvisibility"/><indexterm class="endofrange" startref="ch05_visibility"/></para>
    </sect2>
  </sect1>

  <sect1 id="BasicOOPRecapAndWhatsNext">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_introduced_scala_s_object_m">We introduced the basics of
    Scala&#x2019;s object model, including constructors, inheritance, nesting of
    classes, and rules for visibility.</para>

    <para id="para_in_the_next_chapter_we_round_">In the next chapter we&#x2019;ll
    explore Scala&#x2019;s more advanced OOP features, including overriding,
    companion objects, case classes, and rules for equality between
    objects.<indexterm class="endofrange"/></para>
  </sect1>
</chapter>
  <chapter id="AdvancedObjectOrientedProgramming">
  <title>Advanced Object-Oriented Programming In Scala</title>

  <para id="para_we_finish_our_survey_of_scala_">We&#x2019;ve got the basics of OOP
  in Scala under our belt, but there&#x2019;s plenty more to learn.<indexterm class="startofrange" id="ch06_OOPoverriding">
      <primary>object-oriented programming (OOP)</primary>

      <secondary>overriding members of classes and traits</secondary>
    </indexterm></para>

  <sect1 id="OverridingMembers">
    <title>Overriding Members of Classes and Traits</title>

    <para id="para_classes_and_traits_can_declare">Classes and traits can
    declare <emphasis>abstract</emphasis> members:
    <emphasis>fields</emphasis>, <emphasis>methods</emphasis>, and
    <emphasis>types</emphasis>. These members must be defined by a derived
    class or trait before an instance can be created. Most object-oriented
    languages support abstract methods, and some also support abstract fields
    and types.<indexterm>
        <primary>abstract type members</primary>
      </indexterm><indexterm class="startofrange" id="ch06_overriding">
        <primary>overriding class and trait members</primary>
      </indexterm><indexterm>
        <primary>override keyword</primary>
      </indexterm></para>

    <note id="para_note_when_overriding_a__concr">
      <para>When overriding a concrete member, Scala requires the
      <literal>override</literal> keyword. It is optional when a subtype
      defines (&#x201C;overrides&#x201D;) an abstract member. Conversely, don&#x2019;t use
      <literal>override</literal> unless you are actually overriding a
      member.</para>
    </note>

    <para id="para_requiring_the_override_keywo">Requiring the
    <literal>override</literal> keyword has several benefits:</para>

    <itemizedlist>
      <listitem>
        <para>It catches misspelled members that were intended to be
        overrides. The compiler will throw an error that the member doesn&#x2019;t
        override anything.</para>
      </listitem>

      <listitem>
        <para>It catches a potentially subtle bug that can occur if a new
        member is added to a base class where the member&#x2019;s name collides with
        an older derived class member that is unknown to the base class
        developer. That is, the derived-class member was never intended to
        override a base-class member. Because the derived class member won&#x2019;t
        have the <literal>override</literal> keyword, the compiler will throw
        an error when the new base-class member is introduced.</para>
      </listitem>

      <listitem>
        <para>Having to add the keyword reminds you to consider what members
        should or should not be overridden.</para>
      </listitem>
    </itemizedlist>

    <para id="para_java_has_an_optional_overrid">Java has an optional
    <literal>@Override</literal> annotation for methods. It helps catch errors
    of the first type (misspellings), but it can&#x2019;t help with errors of the
    second type, since using the annotation is optional.</para>

    <sect2 id="FinalDeclarations">
      <title>Attempting to Override final Declarations</title>

      <para id="para_however_if_a_declaration_incl">However, if a declaration
      includes the <literal>final</literal> keyword, then overriding the
      declaration is prohibited. In the following example, the
      <literal>fixedMethod</literal> is declared <literal>final</literal> in
      the parent class. Attempting to compile the example will result in a
      compilation error:<indexterm>
          <primary>final declarations, attempting to override</primary>
        </indexterm><indexterm>
          <primary>overriding class and trait members</primary>

          <secondary>final declarations</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/final-member-wont-compile.scala
// WON'T COMPILE.

class NotFixed {
  final def fixedMethod = "fixed"
}

class Changeable2 extends NotFixed {
  override def fixedMethod = "not fixed"   // ERROR
}</programlisting>

      <para id="para_this_constraint_applies_to_cla">This constraint applies
      to classes and traits as well as members. In this example, the class
      <literal>Fixed</literal> is declared <literal>final</literal>, so an
      attempt to derive a new type from it will also fail to compile:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/final-class-wont-compile.scala
// WON'T COMPILE.

final class Fixed {
  def doSomething = "Fixed did something!"
}

class Changeable1 extends Fixed     // ERROR</programlisting>

      <note id="para_standard_final_classes">
        <para>Some of the types in the Scala library are final, including JDK
        classes like <literal>String</literal> and all the &#x201C;value&#x201D; types
        derived from <literal>AnyVal</literal> (see <xref linkend="ScalaTypeHierarchy"/>).</para>
      </note>

      <para id="para_declarations_that_arent_final">For declarations that
      aren&#x2019;t final, let&#x2019;s examine the rules and behaviors for overriding,
      starting with methods.</para>
    </sect2>

    <sect2 id="OverridingMethods">
      <title>Overriding Abstract and Concrete Methods</title>

      <para id="para_let_s_extend_our_earlier_widg">Let&#x2019;s extend our familiar
      <literal>Widget</literal> base class with an abstract method
      <literal>draw</literal>, to support &#x201C;rendering&#x201D; the widget to a display,
      web page, etc. We&#x2019;ll also override a concrete method familiar to any
      Java programmer, <literal>toString()</literal>, using an ad hoc format.
      As before, we will use a new package, <literal>ui3</literal>.<indexterm>
          <primary>classes</primary>

          <secondary>overriding abstract and concrete methods</secondary>
        </indexterm><indexterm>
          <primary>methods</primary>

          <secondary>overriding</secondary>
        </indexterm><indexterm>
          <primary>overriding class and trait members</primary>

          <secondary>abstract and concrete methods</secondary>
        </indexterm></para>

      <note id="para_note_drawing_is_actually_a__c">
        <para>Drawing is actually a <emphasis>cross-cutting
        concern</emphasis>. The state of a <literal>Widget</literal> is one
        thing; how it is rendered on different platforms, thick clients, web
        pages, mobile devices, etc., is a separate issue. So, drawing is a
        very good candidate for a trait, especially if you want your GUI
        abstractions to be portable. However, to keep things simple, we will
        handle drawing in the <literal>Widget</literal> hierarchy
        itself.</para>
      </note>

      <para id="para_here_is_the_revised_widget_c">Here is the revised
      <literal>Widget</literal> class, with <literal>draw</literal> and
      <literal>toString</literal> methods:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/ui3/widget.scala

package ui3

abstract class Widget {
  def draw(): Unit
  override def toString() = "(widget)"
}</programlisting>

      <para id="para_the_draw_method_is_abstract_">The <literal>draw</literal>
      method is abstract because it has no body; that is, the method isn&#x2019;t
      followed by an equals sign (<literal>=</literal>), nor any text after
      it. Therefore, <literal>Widget</literal> has to be declared
      <literal>abstract</literal> (it was optional before). Each concrete
      subclass of <literal>Widget</literal> will have to implement
      <literal>draw</literal> or rely on a parent class that implements it. We
      don&#x2019;t need to return anything from <literal>draw</literal>, so its
      return value is <literal>Unit</literal>.<indexterm>
          <primary>abstract type members</primary>

          <secondary>overriding abstract methods</secondary>
        </indexterm></para>

      <para id="para_the_tostring_method_is_str">The
      <literal>toString()</literal> method is straightforward. Since
      <literal>AnyRef</literal> defines <literal>toString</literal>, the
      <literal role="keep-together">override</literal> keyword is required for
      <literal>Widget.toString</literal>.</para>

      <para id="para_here_is_the_revised_button_c">Here is the revised
      <literal>Button</literal> class, with <literal>draw</literal> and
      <literal>toString</literal> methods:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/ui3/button.scala

package ui3

class Button(val label: String) extends Widget with Clickable {

  def click() = {
    // Logic to give the appearance of clicking a button...
  }

  def draw() = {
    // Logic to draw the button on the display, web page, etc.
  }

  override def toString() =
    "(button: label=" + label + ", " + super.toString() + ")"
}</programlisting>

      <para id="para__button_implements_the_abstra"><literal>Button</literal>
      implements the abstract method <literal>draw</literal>. No
      <literal>override</literal> keyword is required. <literal role="keep-together">Button</literal> also overrides
      <literal>toString</literal>, so the <literal>override</literal> keyword
      is required. Note that <literal>super.toString</literal> is
      called.</para>

      <para id="para_the_super_keyword_is_analogo">The
      <literal>super</literal> keyword is analogous to
      <literal>this</literal>, but it binds to the parent type, which is the
      aggregation of the parent class and any mixed-in traits. The search for
      <literal>super.toString</literal> will find the &#x201C;closest&#x201D; parent type
      <literal>toString</literal>, as determined by the <phrase role="keep-together">linearization</phrase> process (see <xref linkend="Linearization"/>). In this case, since
      <literal>Clickable</literal> doesn&#x2019;t define <literal>toString</literal>,
      <literal>Widget.toString</literal> will be called.<indexterm>
          <primary>this keyword</primary>

          <secondary>super versus</secondary>
        </indexterm><indexterm>
          <primary>super keyword</primary>
        </indexterm></para>

      <tip id="para_tip_overriding_a_concrete_met">
        <para>Overriding a concrete method should be done rarely, because it
        is error-prone. Should you invoke the parent method? If so, when? Do
        you call it before doing anything else, or afterward? While the writer
        of the parent method might document the overriding constraints for the
        method, it&#x2019;s difficult to ensure that the writer of a derived class
        will honor those constraints. A much more robust approach is the
        <emphasis>Template Method Pattern</emphasis> (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>).</para>
      </tip>
    </sect2>

    <sect2 id="OverridingFields">
      <title>Overriding Abstract and Concrete Fields</title>

      <para id="para_fewer_object_oriented_language">Most object-oriented
      languages allow you to override mutable fields (<literal>var</literal>).
      Fewer OO languages allow you to define abstract fields or override
      concrete immutable fields (<literal>val</literal>). For example, it&#x2019;s
      common for a base class constructor to initialize a mutable field and
      for a derived class constructor to change its value.<indexterm>
          <primary>overriding class and trait members</primary>

          <secondary>abstract and concrete fields</secondary>
        </indexterm><indexterm>
          <primary>fields</primary>

          <secondary>overriding abstract and concrete fields</secondary>
        </indexterm></para>

      <para id="para_we_ll_discuss_overriding_field">We&#x2019;ll discuss overriding
      fields in traits and classes separately, as traits have some particular
      issues.</para>
    </sect2>

    <sect2 id="OverridingFieldsInTraits">
      <title>Overriding Abstract and Concrete Fields in Traits</title>

      <para id="para_recall_our_vetoableclicks_tr">Recall our
      <literal>VetoableClicks</literal> trait in <xref linkend="StackableTraits"/>. It defines a <literal>val</literal> named
      <literal>maxAllowed</literal> and initializes it to
      <literal>1</literal>. We would like the ability to override the value in
      a class that mixes in this trait.<indexterm class="startofrange" id="ch06_traitsoverridefields">
          <primary>traits</primary>

          <secondary>overriding members of</secondary>

          <tertiary>abstract and concrete fields</tertiary>
        </indexterm><indexterm class="startofrange" id="ch06_fieldstrait">
          <primary>fields</primary>

          <secondary>overriding abstract and concrete fields in
          traits</secondary>
        </indexterm><indexterm class="startofrange" id="ch06_overridingfieldstrait">
          <primary>overriding class and trait members</primary>

          <secondary>abstract and concrete fields</secondary>

          <tertiary>in traits</tertiary>
        </indexterm></para>

      <para id="para_unfortunately_in_the_v2_7_x_v">Unfortunately, in Scala
      version 2.7.X, it is not possible to override a <literal>val</literal>
      defined in a <emphasis>trait</emphasis>. However it is possible to
      override a <literal>val</literal> defined in a parent
      <emphasis>class</emphasis>. Version 2.8 of Scala does support overriding
      a <literal>val</literal> in a trait.</para>

      <tip id="para_tip_because_the_override_beha">
        <para>Because the override behavior for a <literal>val</literal> in a
        trait is changing, you should avoid relying on the ability to override
        it, if you are currently using Scala version 2.7.X. Use another
        approach instead.</para>
      </tip>

      <para id="para_unfortunately_the_v2_7_x_pars">Unfortunately, the version
      2.7 compiler accepts code that attempts to override a trait-defined
      <literal>val</literal>, but the override does not actually happen, as
      illustrated by this example:</para>

      <screen>// code-examples/AdvOOP/overrides/trait-val-script.scala
// DANGER! Silent failure to override a trait's "name" (V2.7.5 only).
// Works as expected in V2.8.0.

trait T1 {
  val name = "T1"
}

class Base

class ClassWithT1 extends Base with T1 {
  override val name = "ClassWithT1"
}

val c = new ClassWithT1()
println(c.name)

class ClassExtendsT1 extends T1 {
  override val name = "ClassExtendsT1"
}

val c2 = new ClassExtendsT1()
println(c2.name)</screen>

      <para id="para_if_you_run_this_script_oo1a">If you run this script with
      <literal>scala</literal> version 2.7.5, the output is the
      following:</para>

      <screen>T1
T1</screen>

      <para id="para_we_might_have_expected_the_two">Reading the script, we
      would have expected the two <literal>T1</literal> strings to be
      <literal>ClassWithT1</literal> and <literal>ClassExtendsT1</literal>,
      respectively.</para>

      <para id="para_however_if_you_run_this_scrip">However, if you run this
      script with <literal>scala</literal> version 2.8.0, you get this
      output:</para>

      <screen>ClassWithT1
ClassExtendsT1</screen>

      <caution id="para_caution_attempts_to_override_">
        <para>Attempts to override a trait-defined <literal>val</literal> will
        be accepted by the compiler, but have no effect in Scala version
        2.7.X.</para>
      </caution>

      <para id="para_there_are_two_workarounds_the">There are three
      workarounds you can use with Scala version 2.7. The first is to use some
      advanced options for <literal>scala</literal> and
      <literal>scalac</literal>. The <literal>-Xfuture</literal> option will
      enable the override behavior supported in version 2.8. The
      <literal>-Xcheckinit</literal> option will analyze your code and report
      whether the behavior change will break it. The option
      <literal>-Xexperimental</literal>, which enables many experimental
      changes, will also warn you that the <literal>val</literal> override
      <phrase role="keep-together">behavior</phrase> is different.</para>

      <para id="para_second_val_override_workaround">The second workaround is
      to make the <literal>val</literal> abstract in the trait. This forces an
      instance using the trait to assign a value. Declaring a
      <literal>val</literal> in a trait abstract is a perfectly useful design
      approach for both versions of Scala. In fact, this will be the best
      design choice, when there is no appropriate default value to assign to
      the <literal>val</literal> in the trait:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/trait-abs-val-script.scala

trait AbstractT1 {
  val name: String
}

class Base

class ClassWithAbstractT1 extends Base with AbstractT1 {
  val name = "ClassWithAbstractT1"
}

val c = new ClassWithAbstractT1()
println(c.name)

class ClassExtendsAbstractT1 extends AbstractT1 {
  val name = "ClassExtendsAbstractT1"
}

val c2 = new ClassExtendsAbstractT1()
println(c2.name)</programlisting>

      <para id="para_this_script_produces_the_outpu">This script produces the
      output that we would expect:</para>

      <screen>ClassWithAbstractT1
ClassExtendsAbstractT1</screen>

      <para id="para_so_an_abstract_val_works_fi">So, an abstract
      <literal>val</literal> works fine, <emphasis>unless</emphasis> the field
      is used in the trait body in a way that will fail until the field is
      properly initialized. Unfortunately, the proper initialization won&#x2019;t
      occur until after the trait&#x2019;s body has executed. Consider the following
      example:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/trait-invalid-init-val-script.scala
// ERROR: "value" read before initialized.

trait AbstractT2 {
  println("In AbstractT2:")
  val value: Int
  val inverse = 1.0/value      // ???
  println("AbstractT2: value = "+value+", inverse = "+inverse)
}

val c2b = new AbstractT2 {
  println("In c2b:")
  val value = 10
}
println("c2b.value = "+c2b.value+", inverse = "+c2b.inverse)</programlisting>

      <para id="para_while_it_appears_that_we_are_c">While it appears that we
      are creating an instance of the trait with <literal>new AbstractT2
      ...</literal>, we are actually using an anonymous class that implicitly
      extends the trait. This script shows what happens when
      <literal>inverse</literal> is calculated:</para>

      <screen>In AbstractT2:
AbstractT2: value = 0, inverse = Infinity
In c2b:
c2b.value = 10, inverse = Infinity</screen>

      <para id="para_as_you_might_expect_the_inve">As you might expect, the
      <literal>inverse</literal> is calculated too early. Note that a divide
      by zero exception isn&#x2019;t thrown; the compiler recognizes the value is
      infinite, but it hasn&#x2019;t actually &#x201C;tried&#x201D; the division yet!</para>

      <para id="para_the_behavior_of_this_script_is">The behavior of this
      script is actually quite subtle. As an exercise, try selectively
      removing (or commenting out) the different <literal>println</literal>
      statements, one at a time. Observe what happens to the results.
      Sometimes <literal>inverse</literal> is initialized properly! (Hint:
      remove the <literal>println("In c2b:")</literal> statement. Then try
      putting it back, but after the <literal>val value = 10</literal>
      line.)</para>

      <para id="para_what_this_experiment_really_sh">What this experiment
      really shows is that side effects (i.e., from the
      <literal>println</literal> statements) can be unexpected and subtle,
      especially during initialization. It&#x2019;s best to avoid them.</para>

      <para id="para_scala_provides_two_solutions_t">Scala provides two
      solutions to this problem: <emphasis>lazy values</emphasis>, which we
      discuss in <xref linkend="LazyVals"/>, and <emphasis>pre-initialized
      fields</emphasis>, which is demonstrated in the following refinement to
      the previous example:<indexterm>
          <primary>pre-initialized fields</primary>
        </indexterm><indexterm>
          <primary>lazy values</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/trait-pre-init-val-script.scala

trait AbstractT2 {
  println("In AbstractT2:")
  val value: Int
  val inverse = 1.0/value
  println("AbstractT2: value = "+value+", inverse = "+inverse)
}

val c2c = new {
  // Only initializations are allowed in pre-init. blocks.
  // println("In c2c:")
  val value = 10
} with AbstractT2

println("c2c.value = "+c2c.value+", inverse = "+c2c.inverse)</programlisting>

      <para id="para_we_instantiate_an_anonymous_in">We instantiate an
      anonymous inner class, initializing the <literal>value</literal> field
      in the block, before the <literal>with AbstractT2</literal> clause. This
      guarantees that <literal>value</literal> is initialized before the body
      of <literal>AbstractT2</literal> is executed, as shown when you run the
      script:</para>

      <screen>In AbstractT2:
AbstractT2: value = 10, inverse = 0.1
c2c.value = 10, inverse = 0.1</screen>

      <para id="para_also_if_you_selectively_remov">Also, if you selectively
      remove any of the <literal>println</literal> statements, you get the
      same expected and now predictable results.</para>

      <para id="para_now_let_s_consider_the_second_">Now let&#x2019;s consider the
      second workaround we described earlier, changing the declaration to
      <literal>var</literal>. This solution is more suitable if a good default
      value exists and you don&#x2019;t want to require instances that use the trait
      to always set the value. In this case, change the <literal>val</literal>
      to a <literal>var</literal>, either a public <literal>var</literal> or a
      private <literal>var</literal> hidden behind reader and writer methods.
      Either way, we can simply reassign the value in a derived trait or
      class.</para>

      <para id="para_returning_to_our_vetoableclic">Returning to our
      <literal>VetoableClicks</literal> example, here is the modified
      <literal>VetoableClicks</literal> trait that uses a public
      <literal>var</literal> for <literal>maxAllowed</literal>:</para>

      <?dbfo-need height=”1in”
?>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/ui3/vetoable-clicks.scala

package ui3
import observer._

trait VetoableClicks extends Clickable {
  var maxAllowed = 1       // default
  private var count = 0
  abstract override def click() = {
    count += 1
    if (count &lt;= maxAllowed)
      super.click()
  }
}</programlisting>

      <para id="para_here_is_a_new_specs_object">Here is a new
      <literal>specs</literal> object,
      <literal>ButtonClickableObserverVetoableSpec2</literal>, that
      demonstrates changing the value of <literal>maxAllowed</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/ui3/button-clickable-observer-vetoable2-spec.scala
package ui3

import org.specs._
import observer._
import ui.ButtonCountObserver

object ButtonClickableObserverVetoableSpec2 extends Specification {
  "A Button Observer with Vetoable Clicks" should {
    "observe only the first 'maxAllowed' clicks" in {
      val observableButton =
        new Button("Okay") with ObservableClicks with VetoableClicks {
          maxAllowed = 2
      }
      observableButton.maxAllowed mustEqual 2
      val buttonClickCountObserver = new ButtonCountObserver
      observableButton.addObserver(buttonClickCountObserver)
      for (i &lt;- 1 to 3) observableButton.click()
      buttonClickCountObserver.count mustEqual 2
    }
  }
}</programlisting>

      <para id="para_no_override_var_is_required_">No <literal>override
      var</literal> is required. We just assign a new value. Since the body of
      the trait is executed before the body of the class using it, reassigning
      the field value happens <emphasis>after</emphasis> the initial
      assignment in the trait&#x2019;s body. However, as we saw before, that
      reassignment could happen too late if the field is used in the trait&#x2019;s
      body in some calculation that will become invalid by a reassignment
      later! You can avoid this problem if you make the field private and
      define a public writer method that redoes any dependent
      calculations.</para>

      <para id="para_another_disadvantage_of_using_">Another disadvantage of
      using a <literal>var</literal> declaration is that
      <literal>maxAllowed</literal> was not intended to be writable. As we
      will see in <xref linkend="FunctionalProgramming"/>, read-only values
      have important benefits. We would prefer for
      <literal>maxAllowed</literal> to be read-only, at least after the
      construction process completes.</para>

      <para id="para_we_can_see_that_the_simple_act">We can see that the
      simple act of changing the <literal>val</literal> to a
      <literal>var</literal> causes potential problems for the maintainer of
      <literal>VetoableClicks</literal>. Control over that field is now lost.
      The maintainer must carefully consider whether or not the value will
      change and if a change will invalidate the state of the instance. This
      issue is especially pernicious in multithreaded systems (see <xref linkend="ProblemsOfSharedSynchronizedState"/>).<indexterm class="endofrange" startref="ch06_traitsoverridefields"/><indexterm class="endofrange" startref="ch06_overridingfieldstrait"/><indexterm class="endofrange" startref="ch06_fieldstrait"/></para>

      <tip id="para_tip_avoid_var_fields_when_p">
        <para>Avoid <literal>var</literal> fields when possible (in classes as
        well as traits). Consider public <literal>var</literal> fields
        especially risky.</para>
      </tip>
    </sect2>

    <sect2 id="OverridingFieldsInClasses">
      <title>Overriding Abstract and Concrete Fields in Classes</title>

      <para id="para_in_contrast_to_traits_overrid">In contrast to traits,
      overriding a <literal>val</literal> declared in a class works as
      expected. Here is an example with both a <literal>val</literal> override
      and a <literal>var</literal> reassignment in a derived class:<indexterm>
          <primary>overriding class and trait members</primary>

          <secondary>abstract and concrete fields</secondary>

          <tertiary>in classes</tertiary>
        </indexterm><indexterm>
          <primary>classes</primary>

          <secondary>overriding abstract and concrete fields in</secondary>
        </indexterm><indexterm>
          <primary>fields</primary>

          <secondary>overriding abstract and concrete fields in
          classes</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/class-field-script.scala

class C1 {
  val name = "C1"
  var count = 0
}

class ClassWithC1 extends C1 {
  override val name = "ClassWithC1"
  count = 1
}

val c = new ClassWithC1()
println(c.name)
println(c.count)</programlisting>

      <para id="para_the_override_keyword_is_requ">The
      <literal>override</literal> keyword is required for the
      <emphasis>concrete</emphasis> <literal>val</literal> field
      <literal>name</literal>, but not for the <literal>var</literal> field
      <literal>count</literal>. This is because we are changing the
      initialization of a constant (<literal>val</literal>), which is a
      &#x201C;special&#x201D; operation.</para>

      <para id="para_if_you_run_this_script_oo1b">If you run this script, the
      output is the following:</para>

      <screen>ClassWithC1
1</screen>

      <para id="para_both_fields_are_overridden_in_">Both fields are
      overridden in the derived class, as expected. Here is the same example
      modified so that both the <literal>val</literal> and the
      <literal>var</literal> are abstract in the base class:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/class-abs-field-script.scala

abstract class AbstractC1 {
  val name: String
  var count: Int
}

class ClassWithAbstractC1 extends AbstractC1 {
  val name = "ClassWithAbstractC1"
  var count = 1
}

val c = new ClassWithAbstractC1()
println(c.name)
println(c.count)</programlisting>

      <para id="para_the_override_keyword_is_not_">The
      <literal>override</literal> keyword is not required for
      <literal>name</literal> in <literal>ClassWithAbstractC1</literal>, since
      the original declaration is abstract. The output of this script is the
      following:</para>

      <screen>ClassWithAbstractC1
1</screen>

      <para id="para_it_s_important_to_emphasize_th">It&#x2019;s important to
      emphasize that <literal>name</literal> and <literal>count</literal> are
      <emphasis>abstract</emphasis> fields, not concrete fields with default
      values. A similar-looking declaration of <literal>name</literal> in a
      Java class, <literal role="keep-together">String name;</literal>, would
      declare a concrete field with the default value (<literal>null</literal>
      in this case). Java doesn&#x2019;t support abstract fields or types (as we&#x2019;ll
      discuss next), only methods.<indexterm class="startofrange" id="ch06_overrideabstracttypes">
          <primary>overriding class and trait members</primary>

          <secondary>abstract types</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="OverridingAbstractTypes">
      <title>Overriding Abstract Types</title>

      <para id="para_we_introduced_abstract_type_de">We introduced abstract
      type declarations in <xref linkend="AbstractTypesAndParameterizedTypes"/>. Recall the
      <literal>BulkReader</literal> example from that section:<indexterm class="startofrange" id="ch06_abstracttypeoverride">
          <primary>abstract types</primary>

          <secondary>overriding</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/abstract-types-script.scala

import java.io._

abstract class BulkReader {
  type In
  val source: In
  def read: String
}

class StringBulkReader(val source: String) extends BulkReader {
  type In = String
  def read = source
}

class FileBulkReader(val source: File) extends BulkReader {
  type In = File
  def read = {
    val in = new BufferedInputStream(new FileInputStream(source))
    val numBytes = in.available()
    val bytes = new Array[Byte](numBytes)
    in.read(bytes, 0, numBytes)
    new String(bytes)
  }
}

println( new StringBulkReader("Hello Scala!").read )
println( new FileBulkReader(new File("abstract-types-script.scala")).read )</programlisting>

      <para id="para_abstract_types_are_an_alternat">Abstract types are an
      alternative to parameterized types, which we&#x2019;ll explore in <xref linkend="ParameterizedTypes"/>. Like parameterized types, they provide
      an abstraction mechanism at the type level.</para>

      <para id="para_the_example_shows_how_to_decla">The example shows how to
      declare an abstract type and how to define a concrete value in derived
      classes. <literal>BulkReader</literal> declares <literal>type
      In</literal> without initializing it. The concrete derived class
      <literal>StringBulkReader</literal> provides a concrete value using
      <literal>type In = String</literal>.</para>

      <para id="para_unlike_fields_and_methods_it_">Unlike fields and methods,
      it is not possible to override a concrete <literal>type</literal>
      definition. However, the abstract declaration can constrain the allowed
      concrete type values. We&#x2019;ll learn how in <xref linkend="ScalasTypeSystem"/>.</para>

      <para id="para_finally_you_probably_noticed_">Finally, you probably
      noticed that this example also demonstrates defining an abstract field,
      using a constructor parameter, and an abstract method.</para>

      <para id="para_for_another_example_let_s_rev">For another example, let&#x2019;s
      revisit our <literal>Subject</literal> trait from <xref linkend="TraitsAsMixins"/>. The definition of the
      <literal>Observer</literal> type is a <emphasis>structural
      type</emphasis> with a method named <literal>receiveUpdate</literal>.
      Observers must have this &#x201C;structure.&#x201D; Let&#x2019;s generalize the
      implementation now, using an abstract type:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/observer/observer2.scala

package observer

trait AbstractSubject {
  type Observer

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (notify(_))

  def notify(observer: Observer): Unit
}

trait SubjectForReceiveUpdateObservers extends AbstractSubject {
  type Observer = { def receiveUpdate(subject: Any) }

  def notify(observer: Observer): Unit = observer.receiveUpdate(this)
}

trait SubjectForFunctionalObservers extends AbstractSubject {
  type Observer = (AbstractSubject) =&gt; Unit

  def notify(observer: Observer): Unit = observer(this)
}</programlisting>

      <para id="para_now_abstractsubject_declare">Now,
      <literal>AbstractSubject</literal> declares <literal>type
      Observer</literal> as abstract (implicitly, because there is no
      definition). Since the original structural type is gone, we don&#x2019;t know
      exactly how to notify an observer. So, we also added an abstract method
      <literal>notify</literal>, which a concrete class or trait will define
      as appropriate.</para>

      <para id="para_the_subjectforreceiveupdateob">The
      <literal>SubjectForReceiveUpdateObservers</literal> derived trait
      defines <literal>Observer</literal> with the same structural type we
      used in the original example, and <literal>notify</literal> simply calls
      <literal role="keep-together">receiveUpdate</literal>, as before.</para>

      <para id="para_the_subjectforfunctionalobser">The
      <literal>SubjectForFunctionalObservers</literal> derived trait defines
      <literal>Observer</literal> to be a function taking an instance of
      <literal>AbstractSubject</literal> and returning
      <literal>Unit</literal>. All <literal>notify</literal> has to do is call
      the observer function, passing the subject as the sole argument. Note
      that this implementation is similar to the approach we used in our
      original button implementation, <literal>ButtonWithCallbacks</literal>,
      where the &#x201C;callbacks&#x201D; were user-supplied functions. (See <xref linkend="IntroducingTraits"/> and a revisited version in <xref linkend="Constructors"/>.)</para>

      <para id="para_here_is_a_specification_that_e">Here is a specification
      that exercises these two variations, observing button clicks as
      before:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/observer/button-observer2-spec.scala

package ui
import org.specs._
import observer._

object ButtonObserver2Spec extends Specification {
  "An Observer watching a SubjectForReceiveUpdateObservers button" should {
    "observe button clicks" in {
      val observableButton =
        new Button(name) with SubjectForReceiveUpdateObservers {
        override def click() = {
          super.click()
          notifyObservers
        }
      }
      val buttonObserver = new ButtonCountObserver
      observableButton.addObserver(buttonObserver)
      for (i &lt;- 1 to 3) observableButton.click()
      buttonObserver.count mustEqual 3
    }
  }
  "An Observer watching a SubjectForFunctionalObservers button" should {
    "observe button clicks" in {
      val observableButton =
        new Button(name) with SubjectForFunctionalObservers {
        override def click() = {
          super.click()
          notifyObservers
        }
      }
      var count = 0
      observableButton.addObserver((button) =&gt; count += 1)
      for (i &lt;- 1 to 3) observableButton.click()
      count mustEqual 3
    }
  }
}</programlisting>

      <para id="para_first_we_exercise_subjectforr">First we exercise
      <literal>SubjectForReceiveUpdateObservers</literal>, which looks very
      similar to our earlier examples. Next we exercise
      <literal>SubjectForFunctionalObservers</literal>. In this case, we don&#x2019;t
      need another &#x201C;observer&#x201D; instance at all. We just maintain a
      <literal>count</literal> variable and pass a <emphasis>function
      literal</emphasis> to <literal>addObserver</literal> to increment the
      count (and ignore the button).</para>

      <para id="para_the_main_virtue_of_subjectfor">The main virtue of
      <literal>SubjectForFunctionalObservers</literal> is its minimalism. It
      requires no special instances, no traits defining abstractions, etc. For
      many cases, it is an ideal approach.</para>

      <para id="para__abstractsubject_is_more_reus"><literal>AbstractSubject</literal>
      is more reusable than the original definition of
      <literal>Subject</literal>, because it imposes fewer constraints on
      potential observers.</para>

      <note id="para_note_abstractsubject_illust">
        <para><literal>AbstractSubject</literal> illustrates that an
        abstraction with fewer concrete details is usually more
        reusable.</para>
      </note>

      <para id="para_but_wait_there_s_more_we_ll_">But wait, there&#x2019;s more!
      We&#x2019;ll revisit the use of abstract types and the Observer Pattern in
      <xref linkend="ScalableAbstractions"/>.<indexterm class="endofrange" startref="ch06_overrideabstracttypes"/><indexterm class="endofrange" startref="ch06_abstracttypeoverride"/></para>
    </sect2>

    <sect2 id="UniformAccessPrinciple">
      <title>When Accessor Methods and Fields Are Indistinguishable: The
      Uniform Access Principle</title>

      <para id="para_suppose_a_user_of_buttoncount">Suppose a user of
      <literal>ButtonCountObserver</literal> from <xref linkend="TraitsAsMixins"/> accesses the <literal>count</literal>
      member:<indexterm class="startofrange" id="ch06_overridemethodsfields">
          <primary>overriding class and trait members</primary>

          <secondary>accessor methods indistinguishable from
          fields</secondary>
        </indexterm><indexterm class="startofrange" id="ch06_methodsaccessor">
          <primary>methods</primary>

          <secondary>overriding accessor methods indistinguishable from
          fields</secondary>
        </indexterm><indexterm class="startofrange" id="ch06_fieldsaccessor">
          <primary>fields</primary>

          <secondary>indistinguishable from accessor methods,
          overriding</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Traits/ui/button-count-observer-script.scala

val bco = new ui.ButtonCountObserver
val oldCount = bco.count
bco.count = 5
val newCount = bco.count
println(newCount + " == 5 and " + oldCount + " == 0?")</programlisting>

      <para id="para_when_the_count_field_is_read">When the
      <literal>count</literal> field is read or written, as in this example,
      are methods called or is the field accessed directly? As originally
      declared in <literal>ButtonCountObserver</literal>, the field is
      accessed directly. However, the user doesn&#x2019;t really care. In fact, the
      following two definitions are functionally equivalent, from the
      perspective of the user:</para>

      <programlisting linenumbering="unnumbered">class ButtonCountObserver {
  var count = 0  // public field access (original definition)
  // ...
}</programlisting>

      <programlisting linenumbering="unnumbered">class ButtonCountObserver {
  private var cnt = 0  // private field
  def count = cnt      // reader method
  def count_=(newCount: Int) = cnt = newCount  // writer method
  // ...
}</programlisting>

      <para id="para_this_equivalence_in_scala_is_c">This equivalence is an
      example of the <emphasis>Uniform Access Principle</emphasis>. Clients
      read and write field values as if they are publicly accessible, even
      though in some cases they are actually calling methods. The maintainer
      of <literal>ButtonCountObserver</literal> has the freedom to change the
      implementation without forcing users to make code changes.<indexterm>
          <primary>Uniform Access Principle</primary>
        </indexterm></para>

      <para id="para_the_reader_method_in_the_secon">The reader method in the
      second version does not have parentheses. Recall that consistency in the
      use of parentheses is required if a method definition omits parentheses.
      This is only possible if the method takes no arguments. For the Uniform
      Access Principle to work, we want to define field reader methods without
      parentheses. (Contrast that with Ruby, where method parentheses are
      always optional as long as the parse is <phrase role="keep-together">unambiguous</phrase>.)<indexterm>
          <primary>( ) (parentheses)</primary>

          <secondary>omitting in method definitions</secondary>
        </indexterm></para>

      <para id="para_the_writer_method_has_the_form">The writer method has the
      format <literal>count_=(...)</literal>. As a bit of syntactic sugar, the
      compiler allows invocations of methods with this format to be written in
      either of the following ways:</para>

      <programlisting linenumbering="unnumbered">obj.field_=(newValue)
// or
obj.field = newValue</programlisting>

      <para id="para_we_named_the_private_variable_">We named the private
      variable <literal>cnt</literal> in the alternative definition. Scala
      keeps field and method names in the <emphasis>same</emphasis> namespace,
      which means we can&#x2019;t name the field <literal>count</literal> if a method
      is named <literal>count</literal>. Many languages, like Java, don&#x2019;t have
      this restriction because they keep field and method names in separate
      namespaces. However, these languages can&#x2019;t support the Uniform Access
      Principle as a result, unless they build in ad hoc support in their
      grammars or compilers.</para>

      <para id="para_object_in_member_namespace">Since member
      <literal>object</literal> definitions behave similar to fields from the
      caller&#x2019;s perspective, they are also in the same namespace as methods and
      fields. Hence, the following class would not compile:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/member-namespace-wont-compile.scala
// WON'T COMPILE

class IllegalMemberNameUse {
  def member(i: Int) = 2 * i
  val member = 2         // ERROR
  object member {        // ERROR
    def apply() = 2
  }
}</programlisting>

      <para id="para_there_is_one_other_benefit_of_">There is one other
      benefit of this namespace &#x201C;unification.&#x201D; If a parent class declares a
      parameterless method, then a subclass can override that method with a
      <literal>val</literal>. If the parent&#x2019;s method is concrete, then the
      <literal>override</literal> keyword is required:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/method-field-class-script.scala

class Parent {
  def name = "Parent"
}

class Child extends Parent {
  override val name = "Child"
}

println(new Child().name)   // =&gt; "Child"</programlisting>

      <para id="para_if_the_parent_s_method_is_abst">If the parent&#x2019;s method is
      abstract, then the <literal>override</literal> keyword is
      optional:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/abs-method-field-class-script.scala

abstract class AbstractParent {
  def name: String
}

class ConcreteChild extends AbstractParent {
  val name = "Child"
}

println(new ConcreteChild().name)   // =&gt; "Child"</programlisting>

      <para id="para_this_also_works_for_traits_if">This also works for
      traits. If the trait&#x2019;s method is concrete, we have the
      following:<indexterm>
          <primary>traits</primary>

          <secondary>overriding accessor methods indistinguishable from
          fields</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/method-field-trait-script.scala

trait NameTrait {
  def name = "NameTrait"
}

class ConcreteNameClass extends NameTrait {
  override val name = "ConcreteNameClass"
}

println(new ConcreteNameClass().name)   // =&gt; "ConcreteNameClass"</programlisting>

      <para id="para_if_the_trait_s_method_is_abstr">If the trait&#x2019;s method is
      abstract, we have the following:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/overrides/abs-method-field-trait-script.scala

trait AbstractNameTrait {
  def name: String
}

class ConcreteNameClass extends AbstractNameTrait {
  val name = "ConcreteNameClass"
}

println(new ConcreteNameClass().name)   // =&gt; "ConcreteNameClass"</programlisting>

      <para id="para_why_is_this_feature_useful_it">Why is this feature
      useful? It allows derived classes and traits to use a simple field
      access when that is sufficient, or a method call when more processing is
      required, such as lazy initialization. The same argument holds for the
      Uniform Access Principle, in general.</para>

      <para id="para_overriding_a_def_with_a_val">Overriding a
      <literal>def</literal> with a <literal>val</literal> in a subclass can
      also be handy when interoperating with Java code. Turn a getter into a
      <literal>val</literal> by placing it in the constructor. You&#x2019;ll see this
      in action in the following example, in which our Scala class
      <literal>Person</literal> implements a hypothetical
      <literal>PersonInterface</literal> from some legacy Java code:</para>

      <programlisting linenumbering="unnumbered">class Person(val getName: String) extends PersonInterface</programlisting>

      <para id="para_if_you_only_have_a_few_accesso">If you only have a few
      accessors in the Java code you&#x2019;re integrating with, this technique makes
      quick work of them.</para>

      <para id="para_what_about_overriding_a_parame">What about overriding a
      parameterless method with a <literal>var</literal>, or overriding a
      <literal>val</literal> or <literal>var</literal> with a method? These
      are not permitted because they can&#x2019;t match the behaviors of the things
      they are overriding.</para>

      <para id="para_if_you_attempt_to_use_a_var_">If you attempt to use a
      <literal>var</literal> to override a parameterless method, you get an
      error that the writer method, <literal>override name_=</literal>, is not
      overriding anything. This would also be inconsistent with a
      philosophical goal of functional programming, that a method that takes
      no parameters should always return the same result. To do otherwise
      would require side effects in the implementation, which functional
      programming tries to avoid, for reasons we will examine in <xref linkend="FunctionalProgramming"/>. Because a <literal>var</literal> is
      changeable, the no-parameter &#x201C;method&#x201D; defined in the parent type would
      no longer return the same result consistently.</para>

      <para id="para_if_you_could_override_a_val_">If you could override a
      <literal>val</literal> with a method, there would be no way for Scala to
      guarantee that the method would always return the same value, consistent
      with <literal>val</literal> semantics. That issue doesn&#x2019;t exist with a
      <literal>var</literal>, of course, but you would have to override the
      <literal>var</literal> with two methods, a reader and a writer. The
      Scala compiler doesn&#x2019;t support that substitution.<indexterm class="endofrange" startref="ch06_fieldsaccessor"/><indexterm class="endofrange" startref="ch06_methodsaccessor"/><indexterm class="endofrange" startref="ch06_overridemethodsfields"/><indexterm class="endofrange" startref="ch06_overriding"/><indexterm class="endofrange" startref="ch06_OOPoverriding"/></para>
    </sect2>
  </sect1>

  <sect1 id="CompanionObjects">
    <title>Companion Objects</title>

    <para id="para_recall_that_fields_and_methods">Recall that fields and
    methods defined in <literal>objects</literal> serve the role that class
    &#x201C;static&#x201D; fields and methods serve in languages like Java. When
    <literal>object</literal>-based fields and methods are closely associated
    with a particular <literal>class</literal>, they are normally defined in a
    <emphasis>companion object</emphasis>.<indexterm class="startofrange" id="ch06_companionobj">
        <primary>companion objects</primary>
      </indexterm><indexterm class="startofrange" id="ch06_OOPcompanionobjs">
        <primary>object-oriented programming (OOP)</primary>

        <secondary>companion objects</secondary>
      </indexterm></para>

    <para id="para_we_mentioned_companion_objects">We mentioned companion
    objects briefly in <xref linkend="IntroducingScala"/>, and we discussed
    the <literal>Pair</literal> example from the Scala library in <xref linkend="TypeLessDoMore"/>. Let&#x2019;s fill in the remaining details
    now.</para>

    <para id="para_first_recall_that_if_a_class">First, recall that if a
    <literal>class</literal> (or a <literal>type</literal> referring to a
    class) and an <literal>object</literal> are declared in the same file, in
    the same package, and with the same name, they are called a
    <emphasis>companion class</emphasis> (or <emphasis>companion
    type</emphasis>) and a <emphasis>companion object</emphasis>,
    respectively.<indexterm>
        <primary>companion classes</primary>
      </indexterm></para>

    <para id="para_there_is_no_namespace_collisio">There is no namespace
    collision when the name is reused in this way, because Scala stores the
    class name in the type namespace, while it stores the object name in the
    term namespace (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>).</para>

    <para id="para_the_two_most_interesting_metho">The two most interesting
    methods frequently defined in a companion object are
    <literal>apply</literal> and <literal>unapply</literal>.</para>

    <sect2 id="ApplyMethod">
      <title>Apply</title>

      <para id="para_scala_defines_a_form_of_syntac">Scala provides some
      syntactic sugar in the form of the <literal>apply</literal> method. When
      an instance of a class is followed by parentheses with a list of zero or
      more parameters, the compiler invokes the <literal>apply</literal>
      method for that instance. This is true for an <literal>object</literal>
      with a defined <literal>apply</literal> method (such as a companion
      object), as well as an instance of a <literal>class</literal> that
      defines an <literal>apply</literal> method.<indexterm>
          <primary>Pair class</primary>

          <secondary>apply method</secondary>
        </indexterm><indexterm class="startofrange" id="ch06_applymethod">
          <primary>apply method</primary>
        </indexterm><indexterm class="startofrange" id="ch06_companionapply">
          <primary>companion objects</primary>

          <secondary>apply method</secondary>
        </indexterm></para>

      <para id="para_in_the_case_of_an_object_a">In the case of an
      <literal>object</literal>, <literal>apply</literal> is conventionally
      used as a <emphasis>factory</emphasis> method, returning a new instance.
      This is what <literal>Pair.apply</literal> does in the Scala library.
      Here is <literal>Pair</literal> from the standard library:<indexterm>
          <primary>factory methods, apply method as</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">type Pair[+A, +B] = Tuple2[A, B]
object Pair {
  def apply[A, B](x: A, y: B) = Tuple2(x, y)
  def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}</programlisting>

      <para id="para_so_you_can_create_a_new_pair_">So, you can create a new
      <literal>Pair</literal> as follows:</para>

      <programlisting linenumbering="unnumbered">val p = Pair(1, "one")</programlisting>

      <para id="para_it_looks_like_we_are_some_how_">It looks like we are
      somehow creating a <literal>Pair</literal> instance without a
      <literal>new</literal>. Rather than calling a <literal>Pair</literal>
      constructor directly, we are actually calling
      <literal>Pair.apply</literal> (i.e., the companion object
      <literal>Pair</literal>), which then calls
      <literal>Tuple2.apply</literal> on the <literal>Tuple2</literal>
      companion object!</para>

      <tip id="para_tip_if_there_are_several_alte">
        <para>If there are several alternative constructors for a class and it
        also has a companion object, consider defining fewer constructors on
        the class and defining several overloaded <literal>apply</literal>
        methods on the companion object to handle the variations.</para>
      </tip>

      <para id="para_however_apply_is_not_limite">However,
      <literal>apply</literal> is not limited to instantiating the companion
      class. It could instead return an instance of a subclass of the
      companion class. Here is an example where we define a companion object
      <literal>Widget</literal> that uses regular expressions to parse a
      string representing a <literal>Widget</literal> subclass. When a match
      occurs, the subclass is instantiated and the new instance is
      returned:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/widget.scala

package objects

abstract class Widget {
  def draw(): Unit
  override def toString() = "(widget)"
}

object Widget {
  val ButtonExtractorRE = """\(button: label=([^,]+),\s+\(Widget\)\)""".r
  val TextFieldExtractorRE = """\(textfield: text=([^,]+),\s+\(Widget\)\)""".r

  def apply(specification: String): Option[Widget] = specification match {
    case ButtonExtractorRE(label)   =&gt; new Some(new Button(label))
    case TextFieldExtractorRE(text) =&gt; new Some(new TextField(text))
    case _ =&gt; None
  }
}</programlisting>

      <para id="para__widget_apply_receives_a_stri"><literal>Widget.apply</literal>
      receives a string &#x201C;specification&#x201D; that defines which class to
      instantiate. The string might come from a configuration file with
      widgets to create at startup, for example. The string format is the same
      format used by <literal>toString()</literal>. Regular expressions are
      defined for each type. (<emphasis>Parser combinators</emphasis> are an
      alternative. They are discussed in <xref linkend="ExternalDSLsWithCombinatorParsers"/>.)</para>

      <para id="para_the_match_expression_applies">The
      <literal>match</literal> expression applies each regular expression to
      the string. A case expression like:</para>

      <programlisting linenumbering="unnumbered">case ButtonExtractorRE(label) =&gt; new Some(new Button(label))</programlisting>

      <para id="para_means_that_the_string_is_match">means that the string is
      matched against the <literal>ButtonExtractorRE</literal> regular
      expression. If successful, it extracts the substring in the first
      capture group in the regular expression and assigns it to the variable
      <literal>label</literal>. Finally, a new <literal>Button</literal> with
      this label is created, wrapped in a <literal>Some</literal>. We&#x2019;ll learn
      how this extraction process works in the next section, <xref linkend="UnapplyMethod"/>.</para>

      <para id="para_a_similar_case_handles_textfi">A similar case handles
      <literal>TextField</literal> creation. (<literal>TextField</literal> is
      not shown. See the online code examples.) Finally, if
      <literal>apply</literal> can&#x2019;t match the string, it returns
      <literal>None</literal>.</para>

      <para id="para_specs_exercise">Here is a <literal>specs</literal>
      <literal>object</literal> that exercises
      <literal>Widget.apply</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/widget-apply-spec.scala

package objects
import org.specs._

object WidgetApplySpec extends Specification {
  "Widget.apply with a valid widget specification string" should {
    "return a widget instance with the correct fields set" in {
      Widget("(button: label=click me, (Widget))") match {
        case Some(w) =&gt; w match {
          case b:Button =&gt; b.label mustEqual "click me"
          case x =&gt; fail(x.toString())
        }
        case None =&gt; fail("None returned.")
      }
      Widget("(textfield: text=This is text, (Widget))") match {
        case Some(w) =&gt; w match {
          case tf:TextField =&gt; tf.text mustEqual "This is text"
          case x =&gt; fail(x.toString())
        }
        case None =&gt; fail("None returned.")
      }
    }
  }
  "Widget.apply with an invalid specification string" should {
    "return None" in {
      Widget("(button: , (Widget)") mustEqual None
    }
  }
}</programlisting>

      <para id="para_the_first_match_statement_impl">The first match statement
      implicitly invokes <literal>Widget.apply</literal> with the string
      <literal>"(button: label=click me, (Widget))"</literal>. If a button
      wrapped in a <literal>Some</literal> is not returned with the label
      <literal>"click me"</literal>, this test will fail. Next, a similar test
      for a <literal>TextField</literal> widget is done. The final test uses
      an invalid string and confirms that <literal>None</literal> is
      returned.</para>

      <para id="para_a_drawback_of_this_particular_">A drawback of this
      particular implementation is that we have hardcoded a dependency on each
      derived class of <literal>Widget</literal> in <literal>Widget</literal>
      itself, which breaks the <emphasis>Open-Closed Principle</emphasis> (see
      <link linkend="Meyer1997" xrefstyle="select:nopage">[Meyer1997]</link>
      and <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>). A better implementation
      would use a factory design pattern from <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>. Nevertheless, the example
      illustrates how an <literal role="keep-together">apply</literal> method
      can be used as a real factory.</para>

      <para id="para_there_is_no_requirement_for_a">There is no requirement
      for <literal>apply</literal> in an <literal>object</literal> to be used
      as a factory. Neither is there any restriction on the argument list or
      what <literal>apply</literal> returns. However, because it is so common
      to use <literal>apply</literal> in an <literal>object</literal> as a
      factory, use caution when using <literal>apply</literal> for other
      purposes, as it could confuse users. However, there are good
      counterexamples, such as the use of <literal>apply</literal> in
      Domain-Specific Languages (see <xref linkend="DomainSpecificLanguages"/>).</para>

      <para id="para_the_factory_convention_is_less">The factory convention is
      less commonly used for <literal>apply</literal> defined in classes. For
      example, in the Scala standard library, <literal>Array.apply(i:
      int)</literal> returns the element at index <literal>i</literal> in the
      array. Many of the other collections use <literal>apply</literal> in a
      similar way. So, users can write code like the following:<indexterm>
          <primary>Array class</primary>

          <secondary>apply method</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">val a = Array(1,2,3,4)
println(a(2))  // =&gt; 3</programlisting>

      <para id="para_finally_as_a_reminder_althou">Finally, as a reminder,
      although <literal>apply</literal> is handled specially by the compiler,
      it is otherwise no different from any other method. You can overload it,
      you can invoke it directly, etc.<indexterm class="endofrange" startref="ch06_companionapply"/><indexterm class="endofrange" startref="ch06_applymethod"/></para>
    </sect2>

    <sect2 id="UnapplyMethod">
      <title>Unapply</title>

      <para id="para_the_name_unapply_suggests_th">The name
      <literal>unapply</literal> suggests that it does the &#x201C;opposite&#x201D;
      operation of <literal>apply</literal>. Indeed, it is used to extract the
      constituent parts of an instance. Pattern matching uses this feature
      extensively. Hence, <literal>unapply</literal> is often defined in
      companion objects and is used to extract the field values from instances
      of the corresponding companion types. For this reason,
      <literal>unapply</literal> methods are called
      <emphasis>extractors</emphasis>.<indexterm>
          <primary>extractors</primary>

          <secondary>unapply methods</secondary>
        </indexterm><indexterm class="startofrange" id="ch06_companionunapply">
          <primary>companion objects</primary>

          <secondary>unapply method</secondary>
        </indexterm><indexterm class="startofrange" id="ch06_unapply">
          <primary>unapply method</primary>
        </indexterm></para>

      <para id="para_here_is_an_expanded_button_sc">Here is an expanded
      <literal>button.scala</literal> with a <literal>Button</literal>
      <literal>object</literal> that defines an <literal>unapply</literal>
      extractor method:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/button.scala

package objects
import ui3.Clickable

class Button(val label: String) extends Widget with Clickable {

  def click() = {
    // Logic to give the appearance of clicking a button...
  }

  def draw() = {
    // Logic to draw the button on the display, web page, etc.
  }

  override def toString() = "(button: label="+label+", "+super.toString()+")"
}

object Button {
  def unapply(button: Button) = Some(button.label)
}</programlisting>

      <para id="para__button_unapply_takes_a_singl"><literal>Button.unapply</literal>
      takes a single <literal>Button</literal> argument and returns a
      <literal>Some</literal> wrapping the <literal>label</literal> value.
      This demonstrates the protocol for <literal>unapply</literal> methods.
      They return a <literal>Some</literal> wrapping the extracted fields.
      (We&#x2019;ll see how to handle more than one field in a moment.)</para>

      <para id="para_specs_button_unapply">Here is a <literal>specs</literal>
      <literal>object</literal> that exercises
      <literal>Button.unapply</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/button-unapply-spec.scala

package objects
import org.specs._

object ButtonUnapplySpec extends Specification {
  "Button.unapply" should {
    "match a Button object" in {
      val b = new Button("click me")
      b match {
        case Button(label) =&gt;
        case _ =&gt; fail()
      }
    }
    "match a RadioButton object" in {
      val b = new RadioButton(false, "click me")
      b match {
        case Button(label) =&gt;
        case _ =&gt; fail()
      }
    }
    "not match a non-Button object" in {
      val tf = new TextField("hello world!")
      tf match {
        case Button(label) =&gt; fail()
        case _ =&gt;
      }
    }
    "extract the Button's label" in {
      val b = new Button("click me")
      b match {
        case Button(label) =&gt; label mustEqual "click me"
        case _ =&gt; fail()
      }
    }
    "extract the RadioButton's label" in {
      val rb = new RadioButton(false, "click me, too")
      rb match {
        case Button(label) =&gt; label mustEqual "click me, too"
        case _ =&gt; fail()
      }
    }
  }
}</programlisting>

      <para id="para_the_first_three_examples_in_">The first three examples
      (<literal>in</literal> clauses) confirm that
      <literal>Button.unapply</literal> is only called for actual
      <literal>Button</literal> instances or instances of derived classes,
      like <literal>RadioButton</literal>.</para>

      <para id="para_since_unapply_takes_a_butto">Since
      <literal>unapply</literal> takes a <literal>Button</literal> argument
      (in this case), the Scala runtime type checks the instance being
      matched. It then looks for a companion object with an
      <literal>unapply</literal> method and invokes that method, passing the
      instance. The default case clause <literal>case _</literal> is invoked
      for the instances that don&#x2019;t type check as compatible. The pattern
      matching process is fully type-safe.</para>

      <para id="para_the_remaining_examples_in_c">The remaining examples
      (<literal>in</literal> clauses) confirm that the correct values for the
      <literal>label</literal> are extracted. The Scala runtime automatically
      extracts the item in the <literal>Some</literal>.</para>

      <para id="para_what_about_extracting_multiple">What about extracting
      multiple fields? For a fixed set of known fields, a
      <literal>Some</literal> wrapping a <literal>Tuple</literal> is returned,
      as shown in this updated version of
      <literal>RadioButton</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/radio-button.scala

package objects

/**
 * Button with two states, on or off, like an old-style,
 * channel-selection botton on a radio.
 */
class RadioButton(val on: Boolean, label: String) extends Button(label)

object RadioButton {
  def unapply(button: RadioButton) = Some((button.on, button.label))
                 // equivalent to: = Some(Pair(button.on, button.label))
}</programlisting>

      <para id="para_a_some_wrapping_a_pair_butt">A <literal>Some</literal>
      wrapping a <literal>Pair(button.on, button.label)</literal> is returned.
      As we discuss in <xref linkend="PredefObject"/>,
      <literal>Pair</literal> is a <emphasis>type</emphasis> defined to be
      equal to <literal>Tuple2</literal>. Here is the corresponding
      <literal>specs</literal> <literal>object</literal> that tests
      it<indexterm class="endofrange" startref="ch06_unapply"/><indexterm class="endofrange" startref="ch06_companionunapply"/>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/radio-button-unapply-spec.scala

package objects
import org.specs._

object RadioButtonUnapplySpec extends Specification {
  "RadioButton.unapply" should {
    "should match a RadioButton object" in {
      val b = new RadioButton(true, "click me")
      b match {
        case RadioButton(on, label) =&gt;
        case _ =&gt; fail()
      }
    }
    "not match a Button (parent class) object" in {
      val b = new Button("click me")
      b match {
        case RadioButton(on, label) =&gt; fail()
        case _ =&gt;
      }
    }
    "not match a non-RadioButton object" in {
      val tf = new TextField("hello world!")
      tf match {
        case RadioButton(on, label) =&gt; fail()
        case _ =&gt;
      }
    }
    "extract the RadioButton's on/off state and label" in {
      val b = new RadioButton(true, "click me")
      b match {
        case RadioButton(on, label) =&gt; {
          label mustEqual "click me"
          on    mustEqual true
        }
        case _ =&gt; fail()
      }
    }
  }
}</programlisting>
    </sect2>

    <sect2 id="UnapplySeqMethod">
      <title>Apply and UnapplySeq for Collections</title>

      <para id="para_what_if_you_want_to_build_a_co">What if you want to build
      a collection from a variable argument list passed to
      <literal>apply</literal>? What if you want to extract the first few
      elements from a collection and you don&#x2019;t care about the rest of
      it?<indexterm>
          <primary>apply method</primary>

          <secondary>for collections</secondary>
        </indexterm><indexterm>
          <primary>companion objects</primary>

          <secondary>apply and unapplySeq methods for collections</secondary>
        </indexterm><indexterm>
          <primary>collections</primary>

          <secondary>apply and unapplySeq methods</secondary>
        </indexterm></para>

      <para id="para_in_this_case_you_define_appl">In this case, you define
      <literal>apply</literal> and <literal>unapplySeq</literal> (&#x201C;unapply
      sequence&#x201D;) methods. Here are those methods from Scala&#x2019;s own
      <literal>List</literal> class:<indexterm>
          <primary>List class</primary>

          <secondary>apply and unapplySeq methods</secondary>
        </indexterm><indexterm>
          <primary>unapplySeq method for collections</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">def apply[A](xs: A*): List[A] = xs.toList

def unapplySeq[A](x: List[A]): Some[List[A]] = Some(x)</programlisting>

      <para id="para_the_a_type_parameterizatio">The <literal>[A]</literal>
      type parameterization on these methods allows the
      <literal>List</literal> <literal>object</literal>, which is not
      parameterized, to construct a new <literal>List[A]</literal>. (See <xref linkend="ParameterizedTypes"/> for more details.) Most of the time, the
      type parameter will be inferred based on the context.</para>

      <para id="para_the_parameter_list_xs_a_is">The parameter list
      <literal>xs: A*</literal> is a variable argument list. Callers of
      <literal>apply</literal> can pass as many <literal>A</literal> instances
      as they want, including none. Internally, variable argument lists are
      stored in an <literal>Array[A]</literal>, which inherits the
      <literal>toList</literal> method from <literal>Iterable</literal> that
      we used here.</para>

      <tip id="para_tip_this_is_a_handy_idiom_for">
        <para>This is a handy idiom for API writers. Accepting variable
        arguments to a function can be convenient for users, and converting
        the arguments to a <literal>List</literal> is often ideal for internal
        management.</para>
      </tip>

      <para id="para_here_is_an_example_script_that">Here is an example script
      that uses <literal>List.apply</literal> implicitly:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/list-apply-example-script.scala

val list1 = List()
val list2 = List(1, 2.2, "three", 'four)
val list3 = List("1", "2.2", "three", "four")
println("1: "+list1)
println("2: "+list2)
println("3: "+list3)</programlisting>

      <para id="para_the_four_is_a__symbol__ess">The <literal>'four</literal>
      is a <emphasis>symbol</emphasis>, essentially an interned string.
      Symbols are more commonly used in Ruby, for example, where the same
      symbol would be written as <literal>:four</literal>. Symbols are useful
      for representing identities consistently.<indexterm>
          <primary>symbols</primary>
        </indexterm></para>

      <para id="para_this_script_yields_the_followi">This script yields the
      following output:</para>

      <screen>1: List()
2: List(1, 2.2, three, 'four)
3: List(1, 2.2, three, four)</screen>

      <para id="para_the_unapplyseq_method_is_tri">The
      <literal>unapplySeq</literal> method is trivial; it returns the input
      list wrapped in a <literal>Some</literal>. However, this is sufficient
      for pattern matching, as shown in this example:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/list-unapply-example-script.scala

val list = List(1, 2.2, "three", 'four)
list match {
  case List(x, y, _*) =&gt; println("x = "+x+", y = "+y)
  case _ =&gt; throw new Exception("No match! "+list)
}</programlisting>

      <para id="para_the_list_x_y___syntax_m">The <literal>List(x, y,
      _*)</literal> syntax means we will only match on a list with at least
      two elements, and the first two elements will be assigned to
      <literal>x</literal> and <literal>y</literal>. We don&#x2019;t care about the
      rest of the list. The <literal>_*</literal> matches zero or more
      remaining elements.</para>

      <para id="para_out2">The output is the following:</para>

      <screen>x = 1, y = 2.2</screen>

      <para id="para_we_ll_have_much_more_to_say_ab">We&#x2019;ll have much more to
      say about <literal>List</literal> and pattern matching in <xref linkend="ListsInFunctionalProgramming"/>.</para>
    </sect2>

    <sect2 id="CompanionObjectsAndJavaStaticMethods">
      <title>Companion Objects and Java Static Methods</title>

      <para id="para_there_is_one_more_thing_to_kno">There is one more thing
      to know about companion objects. Whenever you define a
      <literal>main</literal> method to use as the entry point for an
      application, Scala requires you to put it in an object. However, at the
      time of this writing, <literal>main</literal> methods cannot be defined
      in a companion object. Because of implementation details in the
      generated code, the JVM won&#x2019;t find the <literal>main</literal> method.
      This issue may be resolved in a future release. For now, you must define
      any <literal>main</literal> method in a <emphasis>singleton</emphasis>
      object (i.e., a &#x201C;non-companion&#x201D; object; see <link linkend="ScalaTips" xrefstyle="select:nopage">[ScalaTips]</link>). Consider the following
      example of a simple <literal>Person</literal> class and companion object
      that attempts to define <literal>main</literal>:<indexterm class="startofrange" id="ch06_Javamethods">
          <primary>Java</primary>

          <secondary>static methods, companion objects and</secondary>
        </indexterm><indexterm>
          <primary>singleton objects</primary>
        </indexterm><indexterm class="startofrange" id="ch06_methodsJavastatic">
          <primary>methods</primary>

          <secondary>Java static methods and companion objects</secondary>
        </indexterm><indexterm class="startofrange" id="ch06_companionobjsJava">
          <primary>companion objects</primary>

          <secondary>Java static methods and</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/person.scala

package objects

class Person(val name: String, val age: Int) {
  override def toString = "name: " + name + ", age: " + age
}

object Person {
  def apply(name: String, age: Int) = new Person(name, age)
  def unapply(person: Person) = Some((person.name, person.age))

  def main(args: Array[String]) = {
    // Test the constructor...
    val person = new Person("Buck Trends", 18)
    assert(person.name == "Buck Trends")
    assert(person.age  == 21)
  }
}

object PersonTest {
  def main(args: Array[String]) = Person.main(args)
}</programlisting>

      <para id="para_this_code_compiles_fine_but_i">This code compiles fine,
      but if you attempt to invoke <literal>Person.main</literal>, using
      <literal>scala -cp ... objects.Person</literal>, you get the following
      error:</para>

      <screen>java.lang.NoSuchMethodException: objects.Person.main([Ljava.lang.String;)</screen>

      <para id="para_the_objects_person_class_fil">The
      <literal>objects/Person.class</literal> file exists. If you decompile it
      with <literal>javap -classpath ... objects.Person</literal> (refer to
      <xref linkend="CommandLineToolDecompilers"/>), you can see that it
      doesn&#x2019;t contain a <literal>main</literal> method. If you decompile
      <literal>objects/Person$.class</literal>, the file for the companion
      object&#x2019;s byte code, it has a <literal>main</literal> method, but notice
      that it isn&#x2019;t declared <literal>static</literal>. So, attempting to
      invoke <literal>scala -&#x2060;cp ... objects.Person$</literal> also fails to
      find the &#x201C;static&#x201D; <literal>main</literal>:</para>

      <screen>java.lang.NoSuchMethodException: objects.Person$.main is not static</screen>

      <para id="para_the_separate__singleton__objec">The separate
      <emphasis>singleton</emphasis> object <literal>PersonTest</literal>
      defined in this example has to be used. Decompiling it with
      <literal>javap -classpath ... objects.PersonTest</literal> shows that it
      has a <literal>static main</literal> method. If you invoke it using
      <literal>scala -cp ... objects.PersonTest</literal>, the
      <literal>PersonTest.main</literal> method is invoked, which in turn
      invokes <literal>Person.main</literal>. You get an assertion error from
      the second call to <literal>assert</literal>, which is
      intentional:</para>

      <screen>java.lang.AssertionError: assertion failed
    at scala.Predef$.assert(Predef.scala:87)
    at objects.Person$.test(person.scala:15)
    at objects.PersonTest$.main(person.scala:20)
    at objects.PersonTest.main(person.scala)
    ...</screen>

      <para id="para_general_problem_with_statics_and_companions">In fact,
      this is a general issue with methods defined in companion objects that
      need to be visible to Java code as static methods. They aren&#x2019;t static in
      the byte code. You have to put these methods in singleton objects
      instead. Consider the following Java class that attempts to create a
      user with <literal>Person.apply</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/PersonUserWontCompile.java
// WON'T COMPILE

package objects;

public class PersonUserWontCompile {
  public static void main(String[] args) {
    Person buck = Person.apply("Buck Trends", 100);  // ERROR
    System.out.println(buck);
  }
}</programlisting>

      <para id="para_if_we_compile_it_after_compil">If we compile it (after
      compiling <literal>Person.scala</literal>), we get the following
      error:</para>

      <screen>$ javac -classpath ... objects/PersonUserWontCompile.java
objects/PersonUserWontCompile.java:5: cannot find symbol
symbol  : method apply(java.lang.String,int)
location: class objects.Person
        Person buck = Person.apply("Buck Trends", 100);
                            ^
1 error</screen>

      <para id="para_however_we_can_use_the_follow">However, we can use the
      following singleton object:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/person-factory.scala

package objects

object PersonFactory {
  def make(name: String, age: Int) = new Person(name, age)
}</programlisting>

      <para id="para_now_the_following_java_class_w">Now the following Java
      class will compile:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/objects/PersonUser.java

package objects;

public class PersonUser {
  public static void main(String[] args) {
    // The following line won't compile.
    // Person buck = Person.apply("Buck Trends", 100);
    Person buck = PersonFactory.make("Buck Trends", 100);
    System.out.println(buck);
  }
}</programlisting>

      <warning id="para_warning_do_not_main_methods">
        <para>Do not define <literal>main</literal> or any other method in a
        <emphasis>companion</emphasis> object that needs to be visible to Java
        code as a <literal>static</literal> method. Define it in a
        <emphasis>singleton</emphasis> object, instead.</para>
      </warning>

      <para id="para_calling_companion_object_methods_from_java">If you have
      no other choice but to call a method in a companion object from Java,
      you can explicitly create an instance of the object with
      <literal>new</literal>, since the object is a &#x201C;regular&#x201D; Java class in
      the byte code, and call the method on the instance.<indexterm class="endofrange" startref="ch06_Javamethods"/><indexterm class="startofrange" startref="ch06_companionobjsJava"/><indexterm class="endofrange" startref="ch06_methodsJavastatic"/><indexterm class="endofrange" startref="ch06_companionobj"/><indexterm class="endofrange" startref="ch06_OOPcompanionobjs"/></para>
    </sect2>
  </sect1>

  <sect1 id="CaseClasses">
    <title>Case Classes</title>

    <para id="para_in_matchingoncaseclasses_i">In <xref linkend="MatchingOnCaseClasses"/>, we briefly introduced you to
    <emphasis>case classes</emphasis>. Case classes have several useful
    features, but also some drawbacks.<indexterm class="startofrange" id="ch06_caseclasses">
        <primary>case classes</primary>
      </indexterm><indexterm class="startofrange" id="ch06_OOPcaseclasses">
        <primary>object-oriented programming (OOP)</primary>

        <secondary>case classes</secondary>
      </indexterm></para>

    <para id="para_let_s_rewrite_the_shape_exam">Let&#x2019;s rewrite the
    <literal>Shape</literal> example we used in <xref linkend="ATasteOfConcurrency"/> to use case classes. Here is the original
    implementation:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/shapes.scala

package shapes {
  class Point(val x: Double, val y: Double) {
    override def toString() = "Point(" + x + "," + y + ")"
  }

  abstract class Shape() {
    def draw(): Unit
  }

  class Circle(val center: Point, val radius: Double) extends Shape {
    def draw() = println("Circle.draw: " + this)
    override def toString() = "Circle(" + center + "," + radius + ")"
  }

  class Rectangle(val lowerLeft: Point, val height: Double, val width: Double)
        extends Shape {
    def draw() = println("Rectangle.draw: " + this)
    override def toString() =
      "Rectangle(" + lowerLeft + "," + height + "," + width + ")"
  }

  class Triangle(val point1: Point, val point2: Point, val point3: Point)
        extends Shape() {
    def draw() = println("Triangle.draw: " + this)
    override def toString() =
      "Triangle(" + point1 + "," + point2 + "," + point3 + ")"
  }
}</programlisting>

    <para id="para_here_is_the_example_rewritten_">Here is the example
    rewritten using the <literal>case</literal> keyword:<indexterm>
        <primary>case keyword</primary>

        <secondary>case class example</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-case.scala

package shapes {
  case class Point(x: Double, y: Double)

  abstract class Shape() {
    def draw(): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape() {
    def draw() = println("Circle.draw: " + this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
      extends Shape() {
    def draw() = println("Rectangle.draw: " + this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
      extends Shape() {
    def draw() = println("Triangle.draw: " + this)
  }
}</programlisting>

    <para id="para_adding_the_case_keyword_caus">Adding the
    <literal>case</literal> keyword causes the compiler to add a number of
    useful features automatically. The keyword suggests an association with
    <literal>case</literal> expressions in pattern matching. Indeed, they are
    particularly well suited for that application, as we will see.</para>

    <para id="para_first_the_parser_automaticall">First, the compiler
    automatically converts the constructor arguments into immutable fields
    (<literal>val</literal>s). The <literal>val</literal> keyword is optional.
    If you want mutable fields, use the <literal>var</literal> keyword. So,
    our constructor argument lists are now shorter.</para>

    <para id="para_second_the_parser_automatical">Second, the compiler
    automatically implements <literal>equals</literal>,
    <literal>hashCode</literal>, and <literal>toString</literal> methods to
    the class, which use the fields specified as constructor arguments. So, we
    no longer need our own <literal>toString</literal> methods. In fact, the
    generated <literal>toString</literal> methods produce the same outputs as
    the ones we implemented ourselves. Also, the body of
    <literal>Point</literal> is gone because there are no methods that we need
    to define!</para>

    <para id="para_the_following_script_uses_thes">The following script uses
    these methods that are now in the shapes:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-usage-example1-script.scala

import shapes._

val shapesList = List(
  Circle(Point(0.0, 0.0), 1.0),
  Circle(Point(5.0, 2.0), 3.0),
  Rectangle(Point(0.0, 0.0), 2, 5),
  Rectangle(Point(-2.0, -1.0), 4, 3),
  Triangle(Point(0.0, 0.0), Point(1.0, 0.0), Point(0.0, 1.0)))

val shape1 = shapesList.head  // grab the first one.
println("shape1: "+shape1+". hash = "+shape1.hashCode)
for (shape2 &lt;- shapesList) {
  println("shape2: "+shape2+". 1 == 2 ? "+(shape1 == shape2))
}</programlisting>

    <para id="para_output1">This script outputs the following:</para>

    <screen>shape1: Circle(Point(0.0,0.0),1.0). hash = 2061963534
shape2: Circle(Point(0.0,0.0),1.0). 1 == 2 ? true
shape2: Circle(Point(5.0,2.0),3.0). 1 == 2 ? false
shape2: Rectangle(Point(0.0,0.0),2.0,5.0). 1 == 2 ? false
shape2: Rectangle(Point(-2.0,-1.0),4.0,3.0). 1 == 2 ? false
shape2: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0)). 1 == 2 ? false</screen>

    <para id="para_as_we_ll_see_in_equalityofob">As we&#x2019;ll see in <xref linkend="EqualityOfObjects"/>, the <literal>==</literal> method actually
    invokes the <literal>equals</literal> method.<indexterm>
        <primary>= (equals sign)</primary>

        <secondary>== (equals) operator</secondary>
      </indexterm></para>

    <para id="para_even_outside_of_case_express">Even outside of
    <literal>case</literal> expressions, automatic generation of these three
    methods is very convenient for simple, &#x201C;structural&#x201D; classes, i.e., classes
    that contain relatively simple fields and behaviors.</para>

    <para id="para_third_when_the_case_keyword">Third, when the
    <literal>case</literal> keyword is used, the compiler automatically
    creates a <emphasis>companion object</emphasis> with an
    <literal>apply</literal> factory method that takes the same arguments as
    the <emphasis>primary</emphasis> constructor. The previous example used
    the appropriate <literal>apply</literal> methods to create the
    <literal>Points</literal>, the different <literal>Shapes</literal>, and
    also the <literal>List</literal> itself. That&#x2019;s why we don&#x2019;t need
    <literal>new</literal>; we&#x2019;re actually calling
    <literal>apply(x,y)</literal> in the <literal>Point</literal> companion
    object, for example.<indexterm>
        <primary>companion objects</primary>

        <secondary>creation for case classes</secondary>
      </indexterm><indexterm>
        <primary>constructors</primary>

        <secondary>case class</secondary>
      </indexterm></para>

    <note id="para_note_you_can_have__secondary_">
      <para>You can have <emphasis>secondary</emphasis> constructors in case
      classes, but there will be no overloaded <literal>apply</literal> method
      generated that has the same argument list. You&#x2019;ll have to use
      <literal>new</literal> to create instances with those
      constructors.</para>
    </note>

    <para id="para_the_companion_object_also_gets">The companion object also
    gets an <literal>unapply</literal> extractor method, which extracts all
    the fields of an instance in an elegant fashion. The following script
    demonstrates the extractors in pattern matching <literal>case</literal>
    statements:<indexterm>
        <primary>pattern matching</primary>

        <secondary>extractors in case statements</secondary>
      </indexterm><indexterm>
        <primary>extractors</primary>

        <secondary>use in pattern matching case statements</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-usage-example2-script.scala

import shapes._

val shapesList = List(
  Circle(Point(0.0, 0.0), 1.0),
  Circle(Point(5.0, 2.0), 3.0),
  Rectangle(Point(0.0, 0.0), 2, 5),
  Rectangle(Point(-2.0, -1.0), 4, 3),
  Triangle(Point(0.0, 0.0), Point(1.0, 0.0), Point(0.0, 1.0)))

def matchOn(shape: Shape) = shape match {
  case Circle(center, radius) =&gt;
    println("Circle: center = "+center+", radius = "+radius)
  case Rectangle(ll, h, w) =&gt;
    println("Rectangle: lower-left = "+ll+", height = "+h+", width = "+w)
  case Triangle(p1, p2, p3) =&gt;
    println("Triangle: point1 = "+p1+", point2 = "+p2+", point3 = "+p3)
  case _ =&gt;
    println("Unknown shape!"+shape)
}

shapesList.foreach { shape =&gt; matchOn(shape) }</programlisting>

    <para id="para_output2">This script outputs the following:</para>

    <screen>Circle: center = Point(0.0,0.0), radius = 1.0
Circle: center = Point(5.0,2.0), radius = 3.0
Rectangle: lower-left = Point(0.0,0.0), height = 2.0, width = 5.0
Rectangle: lower-left = Point(-2.0,-1.0), height = 4.0, width = 3.0
Triangle: point1 = Point(0.0,0.0), point2 = Point(1.0,0.0), point3 = Point(0.0,1.0)</screen>

    <sect2 id="SyntacticSugarForBinaryOperations">
      <title>Syntactic Sugar for Binary Operations</title>

      <para id="para_by_the_way_remember_in_matc">By the way, remember in
      <xref linkend="MatchingOnSequences"/> when we discussed matching on
      lists? We wrote this <literal>case</literal> expression:<indexterm>
          <primary>case classes</primary>

          <secondary>binary operations</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">def processList(l: List[Any]): Unit = l match {
  case head :: tail =&gt; ...
  ...
}</programlisting>

      <para id="para_it_turns_out_that_the_followin">It turns out that the
      following expressions are identical:</para>

      <programlisting linenumbering="unnumbered">  case head :: tail =&gt; ...
  case ::(head, tail) =&gt; ...</programlisting>

      <para id="para_we_are_using_the_companion_obj">We are using the
      companion object for the case class named <literal>::</literal>, which
      is used for non-empty lists. When used in <literal>case</literal>
      expressions, the compiler supports this special infix operator notation
      for invocations of <literal>unapply</literal>.</para>

      <para id="para_it_works_not_only_for_unapply">It works not only for
      <literal>unapply</literal> methods with two arguments, but also with one
      or more arguments. We could rewrite our <literal>matchOn</literal>
      method this way:</para>

      <programlisting linenumbering="unnumbered">def matchOn(shape: Shape) = shape match {
  case center Circle radius =&gt; ...
  case ll Rectangle (h, w) =&gt; ...
  case p1 Triangle (p2, p3) =&gt; ...
  case _ =&gt; ...
}</programlisting>

      <para id="para_for_an_unapply_that_takes_on">For an
      <literal>unapply</literal> that takes one argument, you would have to
      insert an empty set of parentheses to avoid a parsing ambiguity:</para>

      <programlisting linenumbering="unnumbered">  case arg Foo () =&gt; ...</programlisting>

      <para id="para_from_the_point_of_view_of_clar">From the point of view of
      clarity, this syntax is elegant for some cases when there are two
      arguments. For lists, <literal>head :: tail</literal> matches the
      expressions for building up lists, so there is a beautiful symmetry when
      the extraction process uses the same syntax. However, the merits of this
      syntax are less clear for other examples, especially when there are N !=
      2 arguments.</para>
    </sect2>

    <sect2 id="TheCopyMethodInScalaVersion28">
      <title>The copy Method in Scala Version 2.8</title>

      <para id="para_in_scala_version_2_8_another_">In Scala version 2.8,
      another instance method is automatically generated, called
      <literal>copy</literal>. This method is useful when you want to make a
      new instance of a case class that is identical to another instance with
      a few fields changed. Consider the following example script:<indexterm>
          <primary>case classes</primary>

          <secondary>copy method in Scala 2.8</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-usage-example3-v28-script.scala
// Scala version 2.8 only.

import shapes._

val circle1 = Circle(Point(0.0, 0.0), 2.0)
val circle2 = circle1 copy (radius = 4.0)

println(circle1)
println(circle2)</programlisting>

      <para id="para_the_second_circle_is_created_b">The second circle is
      created by copying the first and specifying a new radius. The
      <literal>copy</literal> method implementation that is generated by the
      compiler exploits the new named and default parameters in Scala version
      2.8, which we discussed in <xref linkend="MethodDefaultAndNamedArguments"/>. The generated
      implementation of <literal>Circle.copy</literal> looks roughly like the
      following:</para>

      <programlisting linenumbering="unnumbered">case class Circle(center: Point, radius: Double) extends Shape() {
  ...
  def copy(center: Point = this.center, radius: Double = this.radius) =
    new Circle(center, radius)
}</programlisting>

      <para id="para_so_default_values_are_provide">So, default values are
      provided for all the arguments to the method (only two in this case).
      When using the <literal>copy</literal> method, the user specifies by
      name only the fields that are changing. The values for the rest of the
      fields are used without having to reference them explicitly.</para>
    </sect2>

    <sect2 id="CaseClassInheritance">
      <title>Case Class Inheritance</title>

      <para id="para_did_you_notice_that_shapes_c">Did you notice that the new
      <literal>Shapes</literal> code in <xref linkend="CaseClasses"/> did not
      put the <literal>case</literal> keyword on the abstract
      <literal>Shape</literal> class? This is allowed by the compiler, but
      there are reasons for not having one case class inherit another. First,
      it can complicate field initialization. Suppose we make
      <literal>Shape</literal> a case class. Suppose we want to add a string
      field to all shapes representing an <literal>id</literal> that the user
      wants to set. It makes sense to define this field in
      <literal>Shape</literal>. Let&#x2019;s make these two changes to
      <literal>Shape</literal>:<indexterm>
          <primary>inheritance</primary>

          <secondary>case class</secondary>
        </indexterm><indexterm>
          <primary>case classes</primary>

          <secondary>inheritance</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">abstract case class Shape(id: String) {
  def draw(): Unit
}</programlisting>

      <para id="para_now_the_derived_shapes_need_to">Now the derived shapes
      need to pass the <literal>id</literal> to the <literal>Shape</literal>
      constructor. For example, <literal>Circle</literal> would become the
      following:</para>

      <programlisting linenumbering="unnumbered">case class Circle(id: String, center: Point, radius: Double) extends Shape(id){
  def draw(): Unit
}</programlisting>

      <para id="para_however_if_you_compile_this_c">However, if you compile
      this code, you&#x2019;ll get errors like the following:</para>

      <screen>... error: error overriding value id in class Shape of type String;
 value id needs `override' modifier
  case class Circle(id: String, center: Point, radius: Double) extends Shape(id){
                    ^</screen>

      <para id="para_remember_that_both_definitions">Remember that both
      definitions of <literal>id</literal>, the one in
      <literal>Shape</literal> and the one in <literal>Circle</literal>, are
      considered <literal>val</literal> field definitions! The error message
      tells us the answer; use the <literal role="keep-together">override</literal> keyword, as we discussed in
      <xref linkend="OverridingMembers"/>. So, the complete set of required
      modifications are as follows:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-case-id.scala

package shapesid {
  case class Point(x: Double, y: Double)

  abstract case class Shape(id: String) {
    def draw(): Unit
  }

  case class Circle(override val id: String, center: Point, radius: Double)
        extends Shape(id) {
    def draw() = println("Circle.draw: " + this)
  }

  case class Rectangle(override val id: String, lowerLeft: Point,
        height: Double, width: Double) extends Shape(id) {
    def draw() = println("Rectangle.draw: " + this)
  }

  case class Triangle(override val id: String, point1: Point,
        point2: Point, point3: Point) extends Shape(id) {
    def draw() = println("Triangle.draw: " + this)
  }
}</programlisting>

      <para id="para_note_that_we_also_have_to_add_">Note that we also have to
      add the <literal>val</literal> keywords. This works, but it is somewhat
      ugly.</para>

      <para id="para_a_more_ominous_problem_involve">A more ominous problem
      involves the generated <literal>equals</literal> methods. Under
      inheritance, the <literal>equals</literal> methods don&#x2019;t obey all the
      standard rules for robust object equality. We&#x2019;ll discuss those rules in
      <xref linkend="EqualityOfObjects"/>. For now, consider the following
      example:<indexterm>
          <primary>equals method</primary>

          <secondary>case class comparisons</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-case-equals-ambiguity-script.scala

import shapesid._

case class FancyCircle(name: String, override val id: String,
    override val center: Point, override val radius: Double)
      extends Circle(id, center, radius) {
  override def draw() = println("FancyCircle.draw: " + this)
}

val fc = FancyCircle("me", "circle", Point(0.0,0.0), 10.0)
val c  = Circle("circle", Point(0.0,0.0), 10.0)
format("FancyCircle == Circle? %b\n", (fc == c))
format("Circle == FancyCircle? %b\n", (c  == fc))</programlisting>

      <para id="para_if_you_run_this_script_you_ge">If you run this script,
      you get the following output:</para>

      <screen>FancyCircle == Circle? false
Circle == FancyCircle? true</screen>

      <para id="para_so_circle_equals_evaluates_">So,
      <literal>Circle.equals</literal> evaluates to <literal>true</literal>
      when given a <literal>FancyCircle</literal> with the same values for the
      <literal>Circle</literal> fields. The reverse case isn&#x2019;t true. While you
      might argue that, as far as <literal>Circle</literal> is concerned, they
      really <emphasis>are</emphasis> equal, most people would argue that this
      is a risky, &#x201C;relaxed&#x201D; interpretation of equality. It&#x2019;s true that a
      future version of Scala could generate <literal>equals</literal> methods
      for <literal>case</literal> classes that do exact type-equality
      checking.</para>

      <para id="para_so_the_conveniences_provided_">So, the conveniences
      provided by case classes sometimes lead to problems. It is best to avoid
      inheritance of one case class by another. Note that it&#x2019;s fine for a case
      class to inherit from a non-case class or trait. It&#x2019;s also fine for a
      non-case class or trait to inherit from a case class.</para>

      <para id="para_because_of_these_issues_it_is">Because of these issues,
      it is possible that case class inheritance will be deprecated and
      removed in future versions of Scala.<indexterm class="endofrange" startref="ch06_caseclasses"/><indexterm class="endofrange" startref="ch06_OOPcaseclasses"/></para>

      <warning id="para_warning_avoid_inheriting_a_ca">
        <para>Avoid inheriting a case class from another case class.</para>
      </warning>
    </sect2>
  </sect1>

  <sect1 id="EqualityOfObjects">
    <title>Equality of Objects</title>

    <para id="para_implementing_a_reliable_equali">Implementing a reliable
    equality test for instances is difficult to do correctly.
    <emphasis>Effective Java</emphasis> (<link linkend="Bloch2008" xrefstyle="select:nopage">[Bloch2008]</link>) and the Scaladoc page for
    <literal>AnyRef.equals</literal> describe the requirements for a good
    equality test. A very good description of the techniques for writing
    correct <literal>equals</literal> and <literal>hashCode</literal> methods
    can be found in <link linkend="Odersky2009" xrefstyle="select:nopage">[Odersky2009]</link>, which uses Java syntax,
    but is adapted from Chapter 28 of <emphasis>Programming in
    Scala</emphasis> (<link linkend="Odersky2008" xrefstyle="select:nopage">[Odersky2008]</link>). Consult these references
    when you need to implement your own <literal>equals</literal> and
    <literal>hashCode</literal> methods. Recall that these methods are created
    automatically for <literal>case</literal> classes.<indexterm>
        <primary>object-oriented programming (OOP)</primary>

        <secondary>equality of objects</secondary>
      </indexterm><indexterm>
        <primary>equality of objects</primary>
      </indexterm></para>

    <para id="para_here_we_focus_on_the_different">Here we focus on the
    different equality methods available in Scala and their meanings. There
    are some slight inconsistencies between the Scala specification (see <link linkend="ScalaSpec2009" role="keep-together" xrefstyle="select:nopage">[ScalaSpec2009]</link>) and the Scaladoc pages
    for the equality-related methods for <literal>Any</literal> and <literal role="keep-together">AnyRef</literal>, but the general behavior is
    clear.</para>

    <caution id="para_caution_some_of_the_equality_">
      <para>Some of the equality methods have the same names as equality
      methods in other languages, but the semantics are sometimes
      different!</para>
    </caution>

    <sect2 id="_the_equals_method">
      <title>The equals Method</title>

      <para id="para_the_equals_method_tests_for_">The
      <literal>equals</literal> method tests for <emphasis>value</emphasis>
      equality. That is, <literal>obj1 equals obj2</literal> is true if both
      <literal>obj1</literal> and <literal>obj2</literal> have the same value.
      They do not need to refer to the same instance.<indexterm>
          <primary>equals method</primary>
        </indexterm></para>

      <para id="para_hence_equals_behaves_like_t">Hence,
      <literal>equals</literal> behaves like the <literal>equals</literal>
      method in Java and the <literal>eql?</literal> method in Ruby.</para>
    </sect2>

    <sect2 id="_the_and_methods">
      <title>The == and != Methods</title>

      <para id="para_while_is_an_operator_in_m">While <literal>==</literal> is
      an operator in many languages, it is a method in Scala, defined as
      <literal>final</literal> in <literal>Any</literal>. It tests for
      <emphasis>value</emphasis> equality, like <literal>equals</literal>.
      That is, <literal>obj1 == obj2</literal> is true if both
      <literal>obj1</literal> and <literal>obj2</literal> have the same value.
      In fact, <literal>==</literal> delegates to <literal>equals</literal>.
      Here is part of the Scaladoc entry for
      <literal>Any.==</literal>:<indexterm>
          <primary>= (equals sign)</primary>

          <secondary>== (equals) method</secondary>
        </indexterm><indexterm>
          <primary>Any class</primary>

          <secondary>== (equals) method</secondary>
        </indexterm></para>

      <screen>o == arg0 is the same as o.equals(arg0).</screen>

      <para id="para_here_is_the_corresponding_part">Here is the corresponding
      part of the Scaladoc entry for <literal>AnyRef.==</literal>:<indexterm>
          <primary>AnyRef class</primary>

          <secondary>== (equals) method</secondary>
        </indexterm></para>

      <screen>o == arg0 is the same as if (o eq null) arg0 eq null else o.equals(arg0).</screen>

      <para id="para_as_you_would_expect_is_th">As you would expect,
      <literal>!=</literal> is the negation, i.e., it is equivalent to
      <literal>!(obj1 == obj2)</literal>.<indexterm>
          <primary>! (exclamation point)</primary>

          <secondary>!= (not equal) method</secondary>
        </indexterm></para>

      <para id="para_since_and_are_declar">Since <literal>==</literal> and
      <literal>!=</literal> are declared <literal>final</literal> in
      <literal>Any</literal>, you can&#x2019;t override them, but you don&#x2019;t need to,
      since they delegate to <literal>equals</literal>.<indexterm>
          <primary>Any class</primary>

          <secondary>!= (not equal) method</secondary>
        </indexterm></para>

      <note id="para_note_that_in_java_c_043">
        <para>In Java, C++, and C#, the <literal>==</literal> operator tests
        for <emphasis>reference</emphasis>, not <emphasis>value</emphasis>
        equality. In contrast, Ruby&#x2019;s <literal>==</literal> operator tests for
        <emphasis>value</emphasis> equality. Whatever language you&#x2019;re used to,
        make sure to remember that in Scala, <literal>==</literal> is testing
        for value equality.</para>
      </note>
    </sect2>

    <sect2 id="_the_ne_and_eq_methods">
      <title>The ne and eq Methods</title>

      <para id="para_the_eq_method_tests_for__ref">The <literal>eq</literal>
      method tests for <emphasis>reference</emphasis> equality. That is,
      <literal>obj1 eq obj2</literal> is true if both <literal>obj1</literal>
      and <literal>obj2</literal> point to the same location in memory. These
      methods are only defined for <literal>AnyRef</literal>.<indexterm>
          <primary>AnyRef class</primary>

          <secondary>eq and ne methods</secondary>
        </indexterm><indexterm>
          <primary>eq method (AnyRef)</primary>
        </indexterm><indexterm>
          <primary>reference types</primary>

          <secondary>testing equality</secondary>
        </indexterm></para>

      <para id="para_hence_eq_behave_like_the_">Hence, <literal>eq</literal>
      behaves like the <literal>==</literal> operator in Java, C++, and C#,
      but not <literal>==</literal> in Ruby.</para>

      <para id="para_the_ne_method_is_the_negatio">The <literal>ne</literal>
      method is the negation of <literal>eq</literal>, i.e., it is equivalent
      to <literal>!(obj1 eq obj2)</literal>.<indexterm>
          <primary>ne method (AnyRef)</primary>
        </indexterm></para>
    </sect2>

    <sect2 id="_array_equality_and_the_sameelements_method">
      <title>Array Equality and the sameElements Method</title>

      <para id="para_comparing_the_contents_of_two_">Comparing the contents of
      two <literal>Array</literal>s doesn&#x2019;t have an obvious result in
      Scala:<indexterm>
          <primary>arrays, comparing for equality</primary>
        </indexterm></para>

      <screen>scala&gt; Array(1, 2) == Array(1, 2)
res0: Boolean = false</screen>

      <para id="para_that_s_a_surprise_thankfully_">That&#x2019;s a surprise!
      Thankfully, there&#x2019;s a simple solution in the form of the <literal role="keep-together">sameElements</literal> method:<indexterm>
          <primary>Array class</primary>

          <secondary>sameElements method</secondary>
        </indexterm></para>

      <screen>scala&gt; Array(1, 2).sameElements(Array(1, 2))
res1: Boolean = true</screen>

      <para id="para_much_better_remember_to_use_">Much better. Remember to
      use <literal>sameElements</literal> when you want to test if two
      <literal>Array</literal>s contain the same elements.</para>

      <para id="para_while_this_may_seem_like_an_in">While this may seem like
      an inconsistency, encouraging an explicit test of the equality of two
      mutable data structures is a conservative approach on the part of the
      language designers. In the long run, it should save you from unexpected
      results in your <phrase role="keep-together">conditionals</phrase>.</para>
    </sect2>
  </sect1>

  <sect1 id="AdvOOPRecapAndWhatsNext">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_explored_the_fine_points_of">We explored the fine points
    of overriding members in derived classes. We learned about object
    equality, case classes, and companion classes and objects.</para>

    <para id="para_in_the_next_chapter_on_scalas_object_system">In the next
    chapter, we&#x2019;ll learn about the Scala type hierarchy&#x2014;in particular, the
    <literal role="keep-together">Predef</literal> object that includes many
    useful definitions. We&#x2019;ll also learn about Scala&#x2019;s alternative to Java&#x2019;s
    <literal>static</literal> class members and the
    <emphasis>linearization</emphasis> rules for method lookup.</para>
  </sect1>
</chapter>
  <chapter id="ScalaObjectSystem">
  <title>The Scala Object System</title>

  <sect1 id="PredefObject">
    <title>The Predef Object</title>

    <para id="para_for_your_convenience_whenever">For your convenience,
    whenever you compile code, the Scala compiler automatically imports the
    definitions in the <literal>java.lang</literal> package
    (<literal>javac</literal> does this, too). On the .NET platform, it
    imports the <literal>system</literal> package. The compiler also imports
    the definitions in the analogous Scala package, <literal>scala</literal>.
    Hence, common Java or .NET types can be used without explicitly importing
    them or fully qualifying them with the <literal>java.lang.</literal>
    prefix, in the Java case. Similarly, a number of common, Scala-specific
    types are made available without qualification, such as
    <literal>List</literal>. Where there are Java and Scala type names that
    overlap, like <literal>String</literal>, the Scala version is imported
    last, so it &#x201C;wins.&#x201D;<indexterm>
        <primary>object system (Scala)</primary>

        <secondary>Predef object</secondary>
      </indexterm><indexterm>
        <primary>Predef object</primary>
      </indexterm><indexterm class="startofrange" id="ch07_objectsys">
        <primary>object system (Scala)</primary>
      </indexterm></para>

    <para id="para_the_parser_also_automatically_">The compiler also
    automatically imports the <literal>Predef</literal> object, which defines
    or imports several useful types, objects, and functions.</para>

    <tip id="para_tip_you_can_learn_a_lot_of_sc">
      <para>You can learn a lot of Scala by viewing the source for
      <literal>Predef</literal>. It is available by clicking the &#x201C;source&#x201D; link
      in the <literal>Predef</literal> Scaladoc page, or you can download the
      full source code for Scala at <ulink url="http://www.scala-lang.org/"/>.</para>
    </tip>

    <para id="para_here_is_a_partial_list_of_the_"><xref linkend="table_7-1"/> shows a partial list of the items imported or
    defined by <literal>Predef</literal> on the Java platform.<indexterm>
        <primary>Predef object</primary>

        <secondary>items imported or defined by</secondary>
      </indexterm></para>

    <table colsep="1" frame="all" id="table_7-1" rowsep="1">
      <title>Items imported or defined by Predef</title>

      <tgroup cols="2">
        <tbody valign="top">
          <row>
            <entry><para><emphasis role="strong">Types</emphasis></para></entry>

            <entry><para><literal>Character</literal>,
            <literal>Class</literal>, <literal>Error</literal>,
            <literal>Function</literal>, <literal>Integer</literal>,
            <literal>Map</literal>, <literal>Pair</literal>,
            <literal>Runnable</literal>, <literal>Set</literal>,
            <literal>String</literal>, <literal>Throwable</literal>,
            <literal>Triple</literal>.</para></entry>
          </row>

          <row>
            <entry><para><emphasis role="strong">Exceptions</emphasis></para></entry>

            <entry><para><literal>Exception</literal>,
            <literal>ArrayIndexOutOfBoundsException</literal>,
            <literal>ClassCastException</literal>,
            <literal>IllegalArgumentException</literal>,
            <literal>IndexOutOfBoundsException</literal>,
            <literal>NoSuchElementException</literal>,
            <literal>NullPointerException</literal>,
            <literal>NumberFormatException</literal>,
            <literal>RuntimeException</literal>,
            <literal>StringIndexOutOfBoundsException</literal>,
            <literal>UnsupportedOperationException</literal>.</para></entry>
          </row>

          <row>
            <entry><para><emphasis role="strong">Values</emphasis></para></entry>

            <entry><para><literal>Map</literal>,
            <literal>Set</literal>.</para></entry>
          </row>

          <row>
            <entry><para><emphasis role="strong">Objects</emphasis></para></entry>

            <entry><para><literal>Pair</literal>,
            <literal>Triple</literal>.</para></entry>
          </row>

          <row>
            <entry><para><emphasis role="strong">Classes</emphasis></para></entry>

            <entry><para><literal>Ensuring</literal>,
            <literal>ArrowAssoc</literal>.</para></entry>
          </row>

          <row>
            <entry><para><emphasis role="strong">Methods</emphasis></para></entry>

            <entry><para>Factory methods to create
            <emphasis>tuples</emphasis>; overloaded versions of
            <literal>exit</literal>, <literal>error</literal>,
            <literal>assert</literal>, <literal>assume</literal>, and
            <literal>require</literal>; <emphasis>implicit</emphasis> type
            conversion methods; I/O methods like <literal>readLine</literal>,
            <literal>println</literal>, and <literal>format</literal>; and a
            method <literal>currentThread</literal>, which calls
            <literal>java.lang.Thread.currentThread</literal>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para__predef_declares_the_types_an"><literal>Predef</literal>
    declares the types and exceptions listed in the table using the
    <literal>type</literal> keyword. They are definitions that equal the
    corresponding <literal>scala.&lt;Type&gt;</literal> or
    <literal>java.lang.&lt;Type&gt;</literal> classes, so they behave like
    &#x201C;aliases&#x201D; or imports for the corresponding classes. For example,
    <literal>String</literal> is declared as follows:<indexterm>
        <primary>Predef object</primary>

        <secondary>declaring types and exceptions</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">type String = java.lang.String</programlisting>

    <para id="para_in_this_case_the_declaration_">In this case, the
    declaration has the same net effect as an <literal>import
    java.lang.String</literal> statement would have.</para>

    <para id="para_but_didn_t_we_just_say_that_de">But didn&#x2019;t we just say that
    definitions in <literal>java.lang</literal> are imported automatically,
    like <literal>String</literal>? The reason there is a type definition is
    to enable support for a uniform string type across all runtime
    environments. The definition is only redundant on the JVM.</para>

    <para id="para_the_type_pair_is_an_alias_">The type
    <literal>Pair</literal> is an &#x201C;alias&#x201D; for
    <literal>Tuple2</literal>:<indexterm>
        <primary>Pair class</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">type Pair[+A, +B] = Tuple2[A, B]</programlisting>

    <para id="para_as_you_would_expect_there_are">There are two type
    parameters, <literal>A</literal> and <literal>B</literal>, one for each
    item in the pair. Recall from <xref linkend="AbstractTypesAndParameterizedTypes"/> that we explained the
    meaning of the <literal>+</literal> in front of each type
    parameter.</para>

    <para id="para_suppose_we_declare_a_var_of_">Briefly, a
    <literal>Pair[A2,B2]</literal>, for some <literal>A2</literal> and
    <literal>B2</literal>, is a <emphasis>subclass</emphasis> of
    <literal>Pair[A1,B1]</literal>, for some <literal>A1</literal> and
    <literal>B1</literal>, if <literal>A2</literal> is a subtype of
    <literal>A1</literal> and <literal>B2</literal> is a subtype of
    <literal>B1</literal>. In <xref linkend="ParameterizedTypes"/>, we&#x2019;ll
    discuss <literal>+</literal> and other type qualifiers in more
    detail.<indexterm>
        <primary>Pair object</primary>
      </indexterm><indexterm>
        <primary>companion objects</primary>

        <secondary>Pair object for Pair class</secondary>
      </indexterm></para>

    <para id="para_the_pair_class_also_has_a__c">The <literal>Pair</literal>
    class also has a <emphasis>companion object</emphasis>
    <literal>Pair</literal> with an <literal>apply</literal> factory method,
    as discussed in <xref linkend="CompanionObjects"/>. Hence, we can create
    <literal>Pair</literal> instances as in this example:</para>

    <screen>val p = Pair(1, "one")</screen>

    <para id="para__pair_apply_is_called_with_th"><literal>Pair.apply</literal> is
    called with the two arguments. The types <literal>A</literal> and
    <literal>B</literal>, shown in the definition of <literal>Pair</literal>,
    are inferred. A new <literal>Tuple2</literal> instance is returned.</para>

    <para id="para__map_and_set_appear_in_both"><literal>Map</literal> and
    <literal>Set</literal> appear in both the types and values lists. In the
    values list, they are <phrase role="keep-together">assigned the</phrase>
    <emphasis>companion objects</emphasis>
    <literal>scala.collection.immutable.Map</literal> and
    <literal>scala.collection.immuta&#x2060;ble.Set</literal>, respectively. Hence,
    <literal>Map</literal> and <literal>Set</literal> in
    <literal>Predef</literal> are <emphasis>values</emphasis>, not object
    definitions, because they refer to objects defined elsewhere, whereas
    <literal>Pair</literal> and <literal>Triple</literal> are defined in
    <literal>Predef</literal> itself. The types <literal>Map</literal> and
    <literal>Set</literal> are assigned the corresponding <phrase role="keep-together">immutable</phrase> classes.<indexterm>
        <primary>companion objects</primary>

        <secondary>Map and Set</secondary>
      </indexterm><indexterm>
        <primary>Set values</primary>
      </indexterm><indexterm>
        <primary>Map values</primary>
      </indexterm><indexterm>
        <primary>ArrowAssoc class</primary>
      </indexterm></para>

    <para id="para_the_arrowassoc_class_defines">The
    <literal>ArrowAssoc</literal> class defines two methods:
    <literal>-&gt;</literal>, and the Unicode equivalent <literal>&#x2192;</literal>.
    The utility of these methods was demonstrated previously in <xref linkend="OptionSomeNone"/>, where we created a map of U.S. state
    capitals:</para>

    <programlisting linenumbering="unnumbered">val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Juneau",
  // ...
  "Wyoming" -&gt; "Cheyenne")
// ...</programlisting>

    <para id="para_the_definition_of_the_arrowas">The definition of the
    <literal>ArrowAssoc</literal> class and the <literal>Map</literal> and
    <literal>Set</literal> values in <literal>Predef</literal> make the
    convenient <literal>Map</literal> initialization syntax possible. First,
    when Scala sees <literal>Map(...)</literal> it calls the
    <literal>apply</literal> method on the <literal>Map</literal> companion
    object, just as we discussed for <literal>Pair</literal>.<indexterm>
        <primary>Set companion object</primary>
      </indexterm><indexterm>
        <primary>Map companion object</primary>
      </indexterm></para>

    <para id="para__map_apply_expects_zero_or_mo"><literal>Map.apply</literal>
    expects zero or more <literal>Pairs</literal> (e.g., <literal>(a1, b2),
    (a2, b2), ...</literal>), where each tuple holds a name and value. In the
    example, the tuple types are all inferred to be of type
    <literal>Pair[String,String]</literal>. The declaration of
    <literal>Map.apply</literal> is as follows:<indexterm>
        <primary>Map.apply method</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">object Map {
  ...
  def apply[A, B](elems : (A, B)*) : Map[A, B] = ...
}</programlisting>

    <para id="para_there_are_no_type_parameters_o">Recall that there can be no
    type parameters on the <literal>Map</literal> companion object because
    there can be only one instance. However, <literal>apply</literal> can have
    type parameters.</para>

    <para id="para_notice_the_argument_list_signa">The apply method takes a
    <emphasis>variable-length argument list</emphasis>. Internally,
    <literal>x</literal> will be a subtype of <literal>Array[X]</literal>. So,
    for <literal>Map.apply</literal>, <literal>elems</literal> is of type
    <literal>Array[(A,B)]</literal> or <literal>Array[Tuple2[A,B]]</literal>,
    if you prefer.<indexterm>
        <primary>variable-length argument lists</primary>
      </indexterm></para>

    <para id="para_so_now_that_we_know_what_map">So, now that we know what
    <literal>Map.apply</literal> expects, how do we get from <literal>a -&gt;
    b</literal> to <literal>(a, b)</literal>?<indexterm>
        <primary>implicit conversions</primary>

        <secondary>Predef.any2ArrowAssoc method</secondary>
      </indexterm></para>

    <para id="para__predef_also_defines_an__impl"><literal>Predef</literal>
    also defines an <emphasis>implicit</emphasis> type conversion method
    called <literal>any2ArrowAssoc</literal>. The compiler knows that
    <literal>String</literal> does not define a <literal>-&gt;</literal>
    method, so it looks for an <emphasis>implicit</emphasis> conversion
    <emphasis>in scope</emphasis> to a type that defines such a method, such
    as <literal>ArrowAssoc</literal>. The <literal>any2ArrowAssoc</literal>
    method performs that conversion. It has the following
    implementation:<indexterm>
        <primary>Predef object</primary>

        <secondary>any2ArrowAssoc method</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] = new ArrowAssoc(x)</programlisting>

    <para id="para_it_is_applied_to_each_item_to_">It is applied to each item
    to the left of an arrow <literal>-&gt;</literal>, e.g., the
    <literal>"Alabama"</literal> string. These strings are wrapped in
    <literal>ArrowAssoc</literal> instances, upon which the
    <literal>-&gt;</literal> method is then invoked. This method has the
    following implementation:</para>

    <programlisting linenumbering="unnumbered">class ArrowAssoc[A](x: A) {
    ...
    def -&gt; [B](y: B): Tuple2[A, B] = Tuple2(x, y)
}</programlisting>

    <para id="para_when_it_is_invoked_it_is_pass">When it is invoked, it is
    passed the string on the righthand side of the <literal>-&gt;</literal>.
    The method returns a tuple with the value, <literal>("Alabama",
    "Montgomery")</literal>, for example. In this way, each <literal>key -&gt;
    value</literal> is converted into a tuple and the resulting
    comma-separated list of tuples is passed to the
    <literal>Map.apply</literal> factory method.</para>

    <para id="para_the_description_may_sound_comp">The description may sound
    complicated at first, but the beauty of Scala is that this map
    initialization syntax is not an ad hoc language feature, such as a
    special-purpose operator <literal>-&gt;</literal> defined in the language
    grammar. Instead, this syntax is defined with normal definitions of types
    and methods, combined with a few general-purpose parsing conventions, such
    as support for <emphasis>implicits</emphasis>. Furthermore, it is all
    <emphasis>type-safe</emphasis>. You can use the same techniques to write
    your own convenient &#x201C;operators&#x201D; for mini <emphasis>Domain-Specific
    Languages</emphasis> (see <xref linkend="DomainSpecificLanguages"/>).</para>

    <para id="para__implicit__type_conversions_ar"><emphasis>Implicit</emphasis>
    type conversions are discussed in more detail in <xref linkend="ImplicitConversions"/>.</para>

    <para id="para_next_recall_from_chapter_1_th">Next, recall from <xref linkend="IntroducingScala"/> that we were able to replace calls to
    <literal role="keep-together">Console.println(...)</literal> with
    <literal>println(...)</literal>. This &#x201C;bare&#x201D; <literal>println</literal>
    method is defined in <literal role="keep-together">Predef</literal>, then
    imported <phrase role="keep-together">automatically</phrase> by the
    compiler. The definition calls the corresponding method in <literal role="keep-together">Console</literal>. Similarly, all the other I/O
    methods defined by <literal>Predef</literal>, e.g.,
    <literal>readLine</literal> and <literal role="keep-together">format</literal>, call the corresponding
    <literal>Console</literal> methods.</para>

    <para id="para_finally_the_assert_assume">Finally, the
    <literal>assert</literal>, <literal>assume</literal>, and
    <literal>require</literal> methods are each overloaded with various
    argument list options. They are used for runtime testing of boolean
    conditions. If a condition is false, an exception is thrown. The
    <literal>Ensuring</literal> class serves a similar purpose. You can use
    these features for <emphasis>Design by Contract</emphasis> programming, as
    discussed in <xref linkend="DesignByContractExample"/>.</para>

    <para id="para_for_the_full_list_of_features_">For the full list of
    features defined by <literal>Predef</literal>, see the corresponding
    Scaladoc entry in <link linkend="ScalaAPI2008" xrefstyle="select:nopage">[ScalaAPI2008]</link>.<indexterm>
        <primary>tuples</primary>

        <secondary>ways to create two-item tuple</secondary>
      </indexterm><indexterm>
        <primary>Predef object</primary>

        <secondary>documentation</secondary>
      </indexterm></para>

    <sidebar>
      <title>Four Ways to Create a Two-Item Tuple</title>

      <para id="para_we_now_know_four_ways_to_creat">We now know four ways to
      create a two-item tuple (<emphasis>twople</emphasis>?):</para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>(&#x201C;Hello&#x201D;, 3.14)</para>
        </listitem>

        <listitem>
          <para>Pair(&#x201C;Hello&#x201D;, 3.14)</para>
        </listitem>

        <listitem>
          <para>Tuple2(&#x201C;Hello&#x201D;, 3.14)</para>
        </listitem>

        <listitem>
          <para>&#x201C;Hello&#x201D; &#x2192; 3.14</para>
        </listitem>
      </orderedlist>
    </sidebar>
  </sect1>

  <sect1 id="ClassesAndObjects">
    <title>Classes and Objects: Where Are the Statics?</title>

    <para id="para_many_object_oriented_languages">Many object-oriented
    languages allow classes to have class-level constants, fields, and
    methods, called &#x201C;static&#x201D; members in Java, C#, and C++. These constants,
    fields, and methods are not associated with any
    <emphasis>instances</emphasis> of the class.<indexterm>
        <primary>static members, Scala and</primary>
      </indexterm><indexterm>
        <primary>object system (Scala)</primary>

        <secondary>classes and objects</secondary>
      </indexterm></para>

    <para id="para_an_example_of_a_class_level_fi">An example of a class-level
    field is a shared logging instance used by all instances of a class for
    logging messages. An example of a class-level constant is the default
    logging &#x201C;threshold&#x201D; level.<indexterm>
        <primary>fields</primary>

        <secondary>comparison to Java class-level</secondary>
      </indexterm></para>

    <para id="para_an_example_of_a_class_level_me">An example of a class-level
    method is a &#x201C;finder&#x201D; method that locates all instances of the class in
    some repository that match some user-specified criteria. Another example
    is a <emphasis>factory</emphasis> method, as used in one of the
    factory-related design patterns (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>).<indexterm>
        <primary>methods</primary>

        <secondary>class-level</secondary>
      </indexterm></para>

    <para id="para_in_order_to_remain_consistent_">To remain consistent with
    the goal that &#x201C;everything is an object&#x201D; in Scala, class-level fields and
    methods are not supported. Instead, Scala supports declarations of classes
    that are <emphasis>singletons</emphasis>, using the
    <literal>object</literal> keyword instead of the <literal>class</literal>
    keyword. The <literal>objects</literal> provide an object-oriented
    approach to &#x201C;static&#x201D; data and methods. Hence, Scala does not even have a
    <literal>static</literal> keyword.<indexterm>
        <primary>singletons</primary>

        <secondary>Scala classes declared as</secondary>
      </indexterm><indexterm>
        <primary>classes</primary>

        <secondary>declaration of classes as singletons</secondary>
      </indexterm></para>

    <para id="para__objects_are_instantiated_aut"><literal>Objects</literal>
    are instantiated automatically and lazily by the runtime system (see
    Section 5.4 of <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). Just as for classes and
    traits, the body of the <literal>object</literal> is the constructor, but
    since the system instantiates the object, there is no way for the user to
    specify a parameter list for the constructor, so they aren&#x2019;t supported.
    Any data defined in the object has to be initialized with default values.
    For the same reasons, auxiliary constructors can&#x2019;t be used and are not
    supported.<indexterm>
        <primary>objects</primary>

        <secondary>instantiation in Scala</secondary>
      </indexterm></para>

    <para id="para_we_ve_already_seen_some_exampl">We&#x2019;ve already seen some
    examples of objects, such as the <literal>specs</literal> objects used
    previously for tests, and the <literal>Pair</literal> type and its
    <emphasis>companion object</emphasis>, which we explored in <xref linkend="PredefObject"/>:</para>

    <programlisting linenumbering="unnumbered">type Pair[+A, +B] = Tuple2[A, B]
object Pair {
  def apply[A, B](x: A, y: B) = Tuple2(x, y)
  def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
}</programlisting>

    <para id="para_to_reference_an_object_field">To reference an object field
    or method, you use the syntax <literal>object_name.field</literal> or
    <literal>object_name.method(...)</literal>, respectively. For example,
    <literal>Pair.apply(...)</literal>. Note that this is the same syntax that
    is commonly used in languages with static fields and methods.<indexterm>
        <primary>fields</primary>

        <secondary>referencing object field</secondary>
      </indexterm><indexterm>
        <primary>methods</primary>

        <secondary>referencing object method</secondary>
      </indexterm></para>

    <tip id="para_tip_when_an_object_named_m">
      <para>When an object named <literal>MyObject</literal> is compiled to a
      class file, the class file name will be
      <literal>MyObject$.class</literal>.</para>
    </tip>

    <para id="para_the_convention_for_defining_constants">In Java and C#, the
    convention for defining constants is to use <literal>final
    static</literal> fields. (C# also has a <literal>constant</literal>
    keyword for simple fields, like <literal>ints</literal> and
    <literal>strings</literal>.) In Scala, the convention is to use
    <literal>val</literal> fields in objects.<indexterm>
        <primary>constants</primary>

        <secondary>defining</secondary>
      </indexterm></para>

    <para id="para_finally_the_convention_for_de">Finally, recall from <xref linkend="NestedClasses"/> that class definitions can be nested within
    other class definitions. This property generalizes for objects. You can
    define nested objects, traits, and classes inside other objects, traits,
    and classes.</para>

    <sect2 id="PackageObjects">
      <title>Package Objects</title>

      <para id="para_scala_version_2_8_introduces_a">Scala version 2.8
      introduces a new scoping construct called <emphasis>package
      objects</emphasis>. They are used to define types, variables, and
      methods that are visible at the level of the corresponding package. To
      understand their usefulness, let&#x2019;s see an example from Scala version 2.8
      itself. The collection library is being reorganized to refine the
      package structure and to use it more consistently (among other changes).
      The Scala team faced a dilemma. They wanted to move types to new
      packages, but avoid breaking backward compatibility. The
      <literal>package object</literal> construct provided a solution, along
      with other benefits.<indexterm>
          <primary>scope</primary>

          <secondary>package objects</secondary>
        </indexterm><indexterm>
          <primary>package objects</primary>
        </indexterm><indexterm>
          <primary>object system (Scala)</primary>

          <secondary>classes and objects</secondary>

          <tertiary>package objects</tertiary>
        </indexterm></para>

      <para id="para_for_example_the_immutable_li">For example, the immutable
      <literal>List</literal> is defined in the <literal>scala</literal>
      package in version 2.7, but it is moved to the
      <literal>scala.collection.immutable</literal> package in version 2.8.
      Despite the change, <literal>List</literal> is made visible in the
      <literal>scala</literal> package using <literal>package object
      scala</literal>, found in the
      <filename>src/library/scala/package.scala</filename> file in the version
      2.8 source code distribution. Note the file name. It&#x2019;s not required, but
      it&#x2019;s a useful convention for package objects. Here is the full package
      object definition (at the time of this writing; it could change before
      the 2.8.0 final version is released):</para>

      <programlisting linenumbering="unnumbered">package object scala {
  type Iterable[+A] = scala.collection.Iterable[A]
  val Iterable = scala.collection.Iterable

  @deprecated("use Iterable instead") type Collection[+A] = Iterable[A]
  @deprecated("use Iterable instead") val Collection = Iterable

  type Seq[+A] = scala.collection.Sequence[A]
  val Seq = scala.collection.Sequence

  type RandomAccessSeq[+A] = scala.collection.Vector[A]
  val RandomAccessSeq = scala.collection.Vector

  type Iterator[+A] = scala.collection.Iterator[A]
  val Iterator = scala.collection.Iterator

  type BufferedIterator[+A] = scala.collection.BufferedIterator[A]

  type List[+A] = scala.collection.immutable.List[A]
  val List = scala.collection.immutable.List

  val Nil = scala.collection.immutable.Nil

  type ::[A] = scala.collection.immutable.::[A]
  val :: = scala.collection.immutable.::

  type Stream[+A] = scala.collection.immutable.Stream[A]
  val Stream = scala.collection.immutable.Stream

  type StringBuilder = scala.collection.mutable.StringBuilder
  val StringBuilder = scala.collection.mutable.StringBuilder
}</programlisting>

      <para id="para_note_that_pairs_of_declaration">Note that pairs of
      declarations like <literal>type List[+] = ...</literal> and <literal>val
      List = ...</literal> are effectively &#x201C;aliases&#x201D; for the companion class
      and object, respectively. Because the contents of the
      <literal>scala</literal> package are automatically imported by the
      compiler, you can still reference all the definitions in this object in
      any scope without an explicit import statement for fully qualified
      names.</para>

      <para id="para_other_than_the_way_the_members">Other than the way the
      members in package objects are scoped, they behave just like other
      object declarations. While this example contains only
      <literal>val</literal>s and <literal>type</literal>s, you can also
      define methods, and you can subclass another class or trait and mix in
      other traits.</para>

      <para id="para_another_benefit_of_package_obj">Another benefit of
      package objects is that it provides a more succinct implementation of
      what was an awkward idiom before. Without package objects, you would
      have to put definitions in an ad hoc object inside the desired package,
      then import from the object. For example, here is how
      <literal>List</literal> would have to be handled without a package
      object:</para>

      <programlisting linenumbering="unnumbered">package scala {
  object toplevel {
    ...
    type List[+A] = scala.collection.immutable.List[A]
    val List = scala.collection.immutable.List
    ...
  }
}

...
import scala.toplevel._
...</programlisting>

      <para id="para_finally_another_benefit_of_pa">Finally, another benefit
      of package objects is the way they provide a clear separation between
      the abstractions exposed by a package and the implementations that
      should be hidden inside it. In a larger application, a package object
      could be used to expose all the public types, values, and operations
      (methods) for a &#x201C;component,&#x201D; while everything else in the package and
      nested packages could be treated as internal implementation
      details.</para>
    </sect2>
  </sect1>

  <sect1 id="SealedClassHierarchies">
    <title>Sealed Class Hierarchies</title>

    <para id="para_recall_shapes_usage_example2">Recall from <xref linkend="CaseClasses"/> that we demonstrated pattern matching with our
    <literal>Shapes</literal> hierarchy, which use case classes. We had a
    default <literal role="keep-together">case _ =&gt; ...</literal>
    expression. It&#x2019;s usually wise to have one. Otherwise, if someone defines a
    new subtype of <literal>Shape</literal> and passes it to this
    <literal>match</literal> statement, a runtime
    <literal>scala.MatchError</literal> will be thrown, because the new shape
    won&#x2019;t match the shapes covered in the match statement. However, it&#x2019;s not
    always possible to define reasonable behavior for the default
    case.<indexterm class="startofrange" id="ch07_sealedclass">
        <primary>sealed class hierarchies</primary>
      </indexterm><indexterm class="startofrange" id="ch07_classessealed">
        <primary>classes</primary>

        <secondary>sealed class hierarchies</secondary>
      </indexterm><indexterm>
        <primary>MatchError object</primary>
      </indexterm><indexterm class="startofrange" id="ch07_objectsyssealedclass">
        <primary>object system (Scala)</primary>

        <secondary>sealed class hierarchies</secondary>
      </indexterm></para>

    <para id="para_there_is_an_alternative_soluti">There is an alternative
    solution if you know that the case class hierarchy is unlikely to change
    and you can define the whole hierarchy in <emphasis>one file</emphasis>.
    In this situation, you can add the <literal>sealed</literal> keyword to
    the declaration of the common base class. When sealed, the compiler knows
    all the possible classes that could appear in the <literal>match</literal>
    expression, because all of them must be defined in the same source file.
    So, if you cover all those classes in the <literal>case</literal>
    expressions (either explicitly or through shared parent classes), then you
    can safely eliminate the default <literal>case</literal>
    expression.</para>

    <para id="para_here_is_an_example_using_the_h">Here is an example using
    the HTTP 1.1 methods (see <link linkend="HTTP11" xrefstyle="select:nopage">[HTTP1.1]</link>), which are not likely to
    change very often, so we declare a &#x201C;sealed&#x201D; set of case classes for
    them:</para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/sealed/http-script.scala

sealed abstract class HttpMethod()
case class Connect(body: String) extends HttpMethod
case class Delete (body: String) extends HttpMethod
case class Get    (body: String) extends HttpMethod
case class Head   (body: String) extends HttpMethod
case class Options(body: String) extends HttpMethod
case class Post   (body: String) extends HttpMethod
case class Put    (body: String) extends HttpMethod
case class Trace  (body: String) extends HttpMethod

def handle (method: HttpMethod) = method match {
  case Connect (body) =&gt; println("connect: " + body)
  case Delete  (body) =&gt; println("delete: "  + body)
  case Get     (body) =&gt; println("get: "     + body)
  case Head    (body) =&gt; println("head: "    + body)
  case Options (body) =&gt; println("options: " + body)
  case Post    (body) =&gt; println("post: "    + body)
  case Put     (body) =&gt; println("put: "     + body)
  case Trace   (body) =&gt; println("trace: "   + body)
}

val methods = List(
  Connect("connect body..."),
  Delete ("delete body..."),
  Get    ("get body..."),
  Head   ("head body..."),
  Options("options body..."),
  Post   ("post body..."),
  Put    ("put body..."),
  Trace  ("trace body..."))

methods.foreach { method =&gt; handle(method) }</programlisting>

    <para id="para_output3">This script outputs the following:</para>

    <screen>connect: connect body...
delete: delete body...
get: get body...
head: head body...
options: options body...
post: post body...
put: put body...
trace: trace body...</screen>

    <para id="para_no_default_case_is_necessary_">No default case is
    necessary, since we cover all the possibilities. Conversely, if you omit
    one of the classes and you don&#x2019;t provide a default case or a case for a
    shared parent class, the compiler warns you that the &#x201C;match is not
    exhaustive.&#x201D; For example, if you comment out the case for
    <literal>Put</literal>, you get this warning:</para>

    <screen>warning: match is not exhaustive!
missing combination            Put

def handle (method: HttpMethod) = method match {
...</screen>

    <para id="para_you_also_get_a_matcherror_ex">You also get a
    <literal>MatchError</literal> exception if a <literal>Put</literal>
    instance is passed to the match.</para>

    <para id="para_using_sealed_has_one_drawbac">Using
    <literal>sealed</literal> has one drawback. Every time you add or remove a
    class from the hierarchy, you have to modify the file, since the entire
    hierarchy has to be declared in the same file. This breaks the
    <emphasis>Open-Closed Principle</emphasis> (see <link linkend="Meyer1997" xrefstyle="select:nopage">[Meyer1997]</link> and <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>), which
    is a solution to the practical problem that it can be costly to modify
    existing code, retest it (and other code that uses it), and redeploy it.
    It&#x2019;s much less &#x201C;costly&#x201D; if you can extend the system by adding new derived
    types in <emphasis>separate</emphasis> source files. This is why we picked
    the HTTP method hierarchy for the example. The list of methods is very
    stable.<indexterm>
        <primary>Open-Closed Principle (OCP)</primary>
      </indexterm></para>

    <tip id="para_tip_avoid_sealed_case_class">
      <para>Avoid <literal>sealed</literal> case class hierarchies if the
      hierarchy changes frequently (for an appropriate definition of
      &#x201C;frequently&#x201D;).</para>
    </tip>

    <para id="para_finally_you_may_have_noticed_">Finally, you may have
    noticed some duplication in the example. All the concrete classes have a
    <literal>body</literal> field. Why didn&#x2019;t we put that field in the parent
    <literal>HttpMethod</literal> class? Because we decided to use case
    classes for the concrete classes, we&#x2019;ll run into the same problem with
    case class inheritance that we discussed in <xref linkend="CaseClassInheritance"/>, where we added a shared
    <literal>id</literal> field in the <literal>Shape</literal> hierarchy. We
    need the <literal>body</literal> argument for each HTTP method&#x2019;s
    constructor, yet it will be made a field of each method type
    automatically. So, we would have to use the <literal>override
    val</literal> technique we demonstrated previously.</para>

    <para id="para_we_could_remove_the_case_keywo">We could remove the case
    keywords and implement the methods and companion objects that we need.
    However, in this case, the duplication is minimal and tolerable.</para>

    <para id="para_what_if_we_want_to_use_case_cl">What if we want to use case
    classes, yet also reference the <literal>body</literal> field in
    <literal>HttpMethod</literal>? Fortunately, we know that Scala will
    generate a <literal>body</literal> reader method in every concrete
    subclass (as long as we use the name <literal>body</literal>
    consistently!). So, we can declare that method abstract in
    <literal>HttpMethod</literal>, then use it as we see fit. The following
    example demonstrates this technique:</para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/sealed/http-body-script.scala

sealed abstract class HttpMethod() {
    def body: String
    def bodyLength = body.length
}

case class Connect(body: String) extends HttpMethod
case class Delete (body: String) extends HttpMethod
case class Get    (body: String) extends HttpMethod
case class Head   (body: String) extends HttpMethod
case class Options(body: String) extends HttpMethod
case class Post   (body: String) extends HttpMethod
case class Put    (body: String) extends HttpMethod
case class Trace  (body: String) extends HttpMethod

def handle (method: HttpMethod) = method match {
  case Connect (body) =&gt; println("connect: " + body)
  case Delete  (body) =&gt; println("delete: "  + body)
  case Get     (body) =&gt; println("get: "     + body)
  case Head    (body) =&gt; println("head: "    + body)
  case Options (body) =&gt; println("options: " + body)
  case Post    (body) =&gt; println("post: "    + body)
  case Put     (body) =&gt; println("put: "     + body)
  case Trace   (body) =&gt; println("trace: "   + body)
}

val methods = List(
  Connect("connect body..."),
  Delete ("delete body..."),
  Get    ("get body..."),
  Head   ("head body..."),
  Options("options body..."),
  Post   ("post body..."),
  Put    ("put body..."),
  Trace  ("trace body..."))

methods.foreach { method =&gt;
  handle(method)
  println("body length? " + method.bodyLength)
}</programlisting>

    <para id="para_we_declared_body_abstract_in">We declared
    <literal>body</literal> abstract in <literal>HttpMethod</literal>. We
    added a simple <literal>bodyLength</literal> method that calls
    <literal>body</literal>. The loop at the end of the script calls
    <literal>bodyLength</literal>. Running this script produces the following
    output:</para>

    <screen>connect: connect body...
body length? 15
delete: delete body...
body length? 14
get: get body...
body length? 11
head: head body...
body length? 12
options: options body...
body length? 15
post: post body...
body length? 12
put: put body...
body length? 11
trace: trace body...
body length? 13</screen>

    <para id="para_as_always_every_feature_has_p">As always, every feature has
    pluses and minuses. Case classes and sealed class hierarchies have very
    useful properties, but they aren&#x2019;t suitable for all situations.<indexterm class="endofrange" startref="ch07_sealedclass"/><indexterm class="endofrange" startref="ch07_objectsyssealedclass"/><indexterm class="endofrange" startref="ch07_classessealed"/></para>
  </sect1>

  <sect1 id="ScalaTypeHierarchy">
    <title>The Scala Type Hierarchy</title>

    <para id="para_we_have_mentioned_a_number_of_">We have mentioned a number
    of types in Scala&#x2019;s type hierarchy already. Let&#x2019;s look at the general
    structure of the hierarchy, as illustrated in <xref linkend="scalas-type-hierarchy"/>.<indexterm>
        <primary>data types</primary>

        <secondary>type hierarchy in Scala</secondary>
      </indexterm><indexterm>
        <primary>object system (Scala)</primary>

        <secondary>type hierarchy</secondary>
      </indexterm></para>

    <figure float="none" id="scalas-type-hierarchy">
      <title>Scala&#x2019;s type hierarchy</title>

      <mediaobject>
        <imageobject role="print">
          <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_0701.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_0701.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para id="para_the_following_tables_discuss_t">Tables <xref linkend="any-anyval-anyref" xrefstyle="select: labelnumber"/> and <xref linkend="AnyVal-value-types" xrefstyle="select: labelnumber"/> discuss
    the types shown in <xref linkend="scalas-type-hierarchy"/>, as well as
    some other important types that aren&#x2019;t shown. Some details are omitted for
    clarity. When the underlying &#x201C;runtime&#x201D; is discussed, the points made apply
    equally to the JVM and the .NET CLR, except where noted.<indexterm>
        <primary>reference types</primary>

        <secondary>parent of, AnyRef</secondary>
      </indexterm><indexterm>
        <primary>AnyRef object</primary>
      </indexterm><indexterm>
        <primary>AnyVal object</primary>
      </indexterm><indexterm>
        <primary>Any object</primary>
      </indexterm></para>

    <table id="any-anyval-anyref">
      <title>Any, AnyVal, and AnyRef</title>

      <tgroup cols="3">
        <colspec colnum="1" colwidth=".5in"/>

        <colspec colnum="2" colwidth=".5in"/>

        <colspec colnum="3"/>

        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry><phrase role="keep-together">Parent</phrase></entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal>Any</literal></para></entry>

            <entry><para><emphasis>none</emphasis></para></entry>

            <entry><para>The root of the hierarchy. Defines a few
            <emphasis>final</emphasis> methods like <literal>==</literal>,
            <literal>!=</literal>, <literal>isInstanceOf[T]</literal> (for
            type checking), and <literal>asInstanceOf[T]</literal> (for type
            casting), as well as default versions of
            <literal>equals</literal>, <literal role="keep-together">hashCode</literal>, and
            <literal>toString</literal>, which are designed to be overridden
            by subclasses.</para></entry>
          </row>

          <row>
            <entry><para><literal role="keep-together">AnyVal</literal></para></entry>

            <entry><para><literal>Any</literal></para></entry>

            <entry><para>The parent of all <emphasis>value</emphasis> types,
            which correspond to the <emphasis>primitive</emphasis> types on
            the runtime platform, plus <literal>Unit</literal>. All the
            <literal>AnyVal</literal> instances are immutable <emphasis>value
            instances</emphasis>, and all the <literal>AnyVal</literal> types
            are <literal>abstract final</literal>. Hence, none of them can be
            instantiated with <literal>new</literal>. Rather, new instances
            are created with <emphasis>literal</emphasis> values (e.g.,
            <literal>3.14</literal> for a <literal>Double</literal>) or by
            calling methods on instances that return new
            values.</para></entry>
          </row>

          <row>
            <entry><para><literal role="keep-together">AnyRef</literal></para></entry>

            <entry><para><literal>Any</literal></para></entry>

            <entry><para>The parent of all <emphasis>reference</emphasis>
            types, including all <literal>java.*</literal> and
            <literal>scala.*</literal> types. It is equivalent to
            <literal>java.lang.Object</literal> for the JVM and
            <literal>object</literal> (<literal>System.Object</literal>) for
            the .NET runtime. Instances of reference types are created with
            <literal>new</literal>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_the__value_types__are_children">The <emphasis>value
    types</emphasis> are children of <literal>AnyVal</literal>.<indexterm>
        <primary>value types</primary>

        <secondary>listed</secondary>
      </indexterm><indexterm>
        <primary>AnyVal object</primary>

        <secondary>direct subtypes</secondary>
      </indexterm></para>

    <table id="AnyVal-value-types">
      <title>Direct subtypes of AnyVal, the value types</title>

      <tgroup cols="2">
        <colspec colnum="1" colwidth="1in"/>

        <colspec colnum="2"/>

        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry>Runtime primitive type</entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal>Boolean</literal></para></entry>

            <entry><para>Boolean (<literal>true</literal> and
            <literal>false</literal>).</para></entry>
          </row>

          <row>
            <entry><para><literal>Byte</literal></para></entry>

            <entry><para>Byte.</para></entry>
          </row>

          <row>
            <entry><para><literal>Char</literal></para></entry>

            <entry><para>Char.</para></entry>
          </row>

          <row>
            <entry><para><literal>Short</literal></para></entry>

            <entry><para>Short.</para></entry>
          </row>

          <row>
            <entry><para><literal>Int</literal></para></entry>

            <entry><para>Int.</para></entry>
          </row>

          <row>
            <entry><para><literal>Long</literal></para></entry>

            <entry><para>Long.</para></entry>
          </row>

          <row>
            <entry><para><literal>Float</literal></para></entry>

            <entry><para>Float.</para></entry>
          </row>

          <row>
            <entry><para><literal>Double</literal></para></entry>

            <entry><para>Double.</para></entry>
          </row>

          <row>
            <entry><para><literal>Unit</literal></para></entry>

            <entry><para>Serves the same role as <literal>void</literal> in
            most imperative languages. Used primarily as a function return
            value. There is only one instance of <literal>Unit</literal>,
            named <literal>()</literal>. Think of it as a tuple with zero
            items.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_all_other_types_the__referenc">All other types, the
    <emphasis>reference types</emphasis>, are children of
    <literal>AnyRef</literal>. <xref linkend="AnyRef-reference-types"/> lists
    some of the more commonly used reference types. Note that there are some
    significant differences between the version 2.7.X and 2.8
    collections.<indexterm>
        <primary>AnyRef object</primary>

        <secondary>direct and indirect subtypes</secondary>
      </indexterm><indexterm>
        <primary>reference types</primary>

        <secondary>listed</secondary>
      </indexterm></para>

    <table id="AnyRef-reference-types">
      <title>Direct and indirect subtypes of AnyRef, the reference
      types</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry><phrase role="keep-together">Parent</phrase></entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal role="keep-together">Collection[+T]</literal></para></entry>

            <entry><para><literal role="keep-together">Iterable[T]</literal></para></entry>

            <entry><para>Trait for collections of known size.</para></entry>
          </row>

          <row>
            <entry><para><literal role="keep-together">Either[+T1,
            +T2]</literal></para></entry>

            <entry><para><literal>AnyRef</literal></para></entry>

            <entry><para>Used most often as a return type when a method could
            return an instance of one of two unrelated types. For example, an
            exception or a &#x201C;successful&#x201D; result. The <literal>Either</literal>
            can be pattern matched for its <literal>Left</literal> or
            <literal>Right</literal> subtypes. (It is analogous to
            <literal>Option</literal>, with <literal>Some</literal> and
            <literal>None</literal>.) For the exception-handling idiom, it is
            conventional to use <literal>Left</literal> for the <phrase role="keep-together">exception</phrase>.</para></entry>
          </row>

          <row>
            <entry><para><phrase role="keep-together"><literal>FunctionN[-T</literal><subscript>1</subscript><literal>,
            -T</literal><subscript>2</subscript><literal>,</literal></phrase><literal><?lb ?>
            ..., -T</literal><subscript>N</subscript><literal>,
            +R]</literal></para></entry>

            <entry><para><literal>AnyRef</literal></para></entry>

            <entry><para>Trait representing a function that takes
            <literal>N</literal> arguments, each of which can have its own
            type, and returns a value of type <literal>R</literal>. (Traits
            are defined for <literal>N</literal> = 0 to 22.) The
            <emphasis>variance annotations</emphasis> (<literal>+</literal>
            and <literal>-</literal>) in front of the types will be explained
            in <xref linkend="VarianceUnderInheritance"/>.</para></entry>
          </row>

          <row>
            <entry><para><literal>Iterable[+T]</literal></para></entry>

            <entry><para><literal>AnyRef</literal></para></entry>

            <entry><para>Trait with methods for operating on collections of
            instances. Users <phrase role="keep-together">implement</phrase>
            the abstract <literal>elements</literal> method to return an
            <literal>Iterable</literal> <phrase role="keep-together">instance</phrase>.</para></entry>
          </row>

          <row>
            <entry><para><literal>List[+T]</literal></para></entry>

            <entry><para><literal>Seq[T]</literal></para></entry>

            <entry><para><literal>sealed abstract class</literal> for ordered
            collections with functional-style list semantics. It is the most
            widely used collection in Scala, so it is defined in the
            <literal>scala</literal> package, rather than one of the
            collection packages. (In Scala version2.8, it is actually defined
            in <literal>scala.col&#x2060;lection.immutable</literal> and &#x201C;aliased&#x201D; in
            <literal>package object scala</literal>). It has two subclasses,
            <literal>case object Nil</literal>, which extends
            <literal>List[Nothing]</literal> and represents an empty list, and
            <literal>case final class ::[T]</literal>, which represents a
            non-empty list, characterized by a head element and a tail list,
            which would be <literal>Nil</literal> for a one-element
            list.</para></entry>
          </row>

          <row>
            <entry><para><literal>Nothing</literal></para></entry>

            <entry><para><emphasis>All other types</emphasis></para></entry>

            <entry><para><literal>Nothing</literal> is the subtype of
            <emphasis>all</emphasis> other types. It has no instances. It is
            used primarily for defining other types in a type-safe way, such
            as the special <literal>List</literal> subtype
            <literal>Nil</literal>. See also <xref linkend="NothingAndNull"/>.</para></entry>
          </row>

          <row>
            <entry><para><literal>Null</literal></para></entry>

            <entry><para><emphasis>All reference
            types</emphasis></para></entry>

            <entry><para><literal>Null</literal> has one instance,
            <literal>null</literal>, corresponding to the runtime&#x2019;s concept of
            <literal>null</literal>.</para></entry>
          </row>

          <row>
            <entry><para><literal>Option[T]</literal></para></entry>

            <entry><para><literal>Product</literal></para></entry>

            <entry><para>Wraps an optional item. It is a <literal>sealed
            abstract</literal> type and the only allowed instances are an
            instance of its derived <literal>case class Some[T]</literal>,
            wrapping an instance of <literal>T</literal>, or its derived
            <literal>case object None</literal>, which extends
            <literal>Option[Nothing]</literal>.</para></entry>
          </row>

          <row>
            <entry><para><literal>Predef</literal></para></entry>

            <entry><para><literal>AnyRef</literal></para></entry>

            <entry><para>An <literal>object</literal> that defines and imports
            many commonly used types and methods. See <xref linkend="PredefObject"/> for details.</para></entry>
          </row>

          <row>
            <entry><para><literal>Product</literal></para></entry>

            <entry><para><literal>AnyRef</literal></para></entry>

            <entry><para>Trait with methods for determining arity and getting
            the n<superscript>th</superscript> item in a &#x201C;Cartesian product.&#x201D;
            Subtraits are defined for <literal>Product</literal>, called
            <literal role="keep-together">ProductN</literal>, for dimension
            <literal>N</literal> from 1 through 22.</para></entry>
          </row>

          <row>
            <entry><para><literal>ScalaObject</literal><indexterm>
                <primary>ScalaObject class</primary>
              </indexterm></para></entry>

            <entry><para><literal>AnyRef</literal></para></entry>

            <entry><para><emphasis>Mixin</emphasis> trait added to all Scala
            reference type instances.</para></entry>
          </row>

          <row>
            <entry><para><literal>Seq[+T]</literal></para></entry>

            <entry><para><literal role="keep-together">Collection[T]</literal></para></entry>

            <entry><para>Trait for ordered collections.</para></entry>
          </row>

          <row>
            <entry><para><literal>TupleN</literal></para></entry>

            <entry><para><literal>ProductN</literal></para></entry>

            <entry><para>Separate case classes for arity <literal>N</literal>
            = 1 through 22. Tuples support the <emphasis>literal</emphasis>
            syntax <literal>(x1, x2, ..., xN)</literal>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_besides_list_defined_in_th">Besides
    <literal>List</literal>, some of the other library collections include
    <literal>Map</literal>, <literal>Set</literal>, <literal>Queue</literal>,
    and <literal>Stack</literal>. These other collections come in two
    varieties: mutable and immutable. The immutable collections are in the
    package <literal>scala.collection.immutable</literal>, while the mutable
    collections are in <literal>scala.collection.mutable</literal>. Only an
    immutable version of <literal>List</literal> is provided; for a mutable
    list, use a <literal>ListBuffer</literal>, which can return a
    <literal>List</literal> via the <literal>toList</literal> method. <phrase role="keep-together">For Scala version</phrase> 2.8, the collections
    implementations reuse code from
    <literal>scala.col&#x2060;lec&#x2060;tion.generic</literal>. Users of the collections
    would normally not use any types defined in this package. We&#x2019;ll explore
    some of these collections in greater detail in <xref linkend="FunctionalDataStructures"/>.<indexterm>
        <primary>collections</primary>

        <secondary>mutable and immutable</secondary>
      </indexterm></para>

    <para id="para_consistent_with_its_emphasis_o">Consistent with its
    emphasis on <emphasis>functional programming</emphasis> (see <xref linkend="FunctionalProgramming"/>), Scala encourages you to use the
    immutable collections, since <literal>List</literal> is automatically
    imported and <literal>Predef</literal> defines types
    <literal>Map</literal> and <literal>Set</literal> that refer to the
    immutable versions of these collections. All other collections have to be
    imported explicitly.</para>

    <para id="para__predef_defines_a_number_of_i"><literal>Predef</literal>
    defines a number of implicit conversion methods for the value types
    (excluding <literal>Unit</literal>). There are implicit conversions to the
    corresponding <literal>scala.runtime.RichX</literal> types. For example,
    the <literal>byteWrapper</literal> method converts a
    <literal>Byte</literal> to a <literal>scala.runtime.RichByte</literal>.
    There are implicit conversions between the &#x201C;numeric&#x201D;
    types&#x2014;<literal>Byte</literal>, <literal>Short</literal>,
    <literal>Int</literal>, <literal>Long</literal>, and
    <literal>Float</literal>&#x2014;to the other types that are &#x201C;wider&#x201D; than the
    original. For example, <literal>Byte</literal> to <literal>Int</literal>,
    <literal>Int</literal> to <literal>Long</literal>, <literal>Int</literal>
    to <literal>Double</literal>, etc. Finally, there are conversions to the
    corresponding Java wrapper types, e.g., <literal>Int</literal> to
    <literal>java.lang.Integer</literal>. We discuss implicit conversions in
    more detail in <xref linkend="ImplicitConversions"/>.<indexterm>
        <primary>value types</primary>

        <secondary>implicit conversions by Predef object methods</secondary>
      </indexterm><indexterm>
        <primary>Predef object</primary>

        <secondary>implicit conversion methods for value types</secondary>
      </indexterm></para>

    <para id="para_either_example">There are several examples of
    <literal>Option</literal> elsewhere, e.g., <xref linkend="OptionSomeNone"/>. Here is a script that illustrates using an
    <literal>Either</literal> return value to handle a thrown exception or
    successful result (adapted from <ulink url="http://dcsobral.blogspot.com/2009/06/catching-exceptions.html"/>):<indexterm>
        <primary>Either object</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/typehierarchy/either-script.scala

def exceptionToLeft[T](f: =&gt; T): Either[java.lang.Throwable, T] = try {
  Right(f)
} catch {
  case ex =&gt; Left(ex)
}

def throwsOnOddInt(i: Int) = i % 2 match {
  case 0 =&gt; i
  case 1 =&gt; throw new RuntimeException(i + " is odd!")
}

for(i &lt;- 0 to 3)
  exceptionToLeft(throwsOnOddInt(i)) match {
    case Left(ex) =&gt; println("Oops, got exception " + ex.toString)
    case Right(x) =&gt; println(x)
  }</programlisting>

    <para id="para_the_exceptiontoleft_method_e">The
    <literal>exceptionToLeft</literal> method evaluates <literal>f</literal>.
    It catches a <literal>Throwable</literal> and returns it as the
    <literal>Left</literal> value or returns the normal result as the
    <literal>Right</literal> value. The <literal>for</literal> loop uses this
    method to invoke <literal>throwsOnOddInt</literal>. It pattern matches on
    the result and prints an appropriate message. The output of the script is
    the following:</para>

    <screen>0
Oops, got exception java.lang.RuntimeException: 1 is odd!
2
Oops, got exception java.lang.RuntimeException: 3 is odd!</screen>

    <para id="para_a_function__n__trait_where__">A
    <literal>FunctionN</literal> trait, where <literal>N</literal> is 0 to 22,
    is instantiated for an anonymous function with <literal>N</literal>
    arguments. So, consider the following anonymous function:<indexterm>
        <primary>FunctionN object</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">(t1: T1, ..., tN: TN) =&gt; new R(...)</programlisting>

    <para id="para_it_is_syntactic_sugar_for_the_">It is syntactic sugar for
    the following creation of an anonymous class:</para>

    <programlisting linenumbering="unnumbered">new FunctionN {
  def apply(t1: T1, ..., tN: TN): R = new R(...)

  // other methods
}</programlisting>

    <para id="para_we_ll_revisit_function__n__in">We&#x2019;ll revisit
    <literal>FunctionN</literal> in <xref linkend="VarianceUnderInheritance"/> and <xref linkend="FunctionTypes"/>.</para>
  </sect1>

  <sect1 id="Linearization">
    <title>Linearization of an Object&#x2019;s Hierarchy</title>

    <para id="para_because_of_single_inheritance_">Because of single
    inheritance, the inheritance hierarchy would be linear, if we ignored
    mixed-in traits. When traits are considered, each of which may be derived
    from other traits and classes, the inheritance hierarchy forms a directed,
    acyclic graph (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). The term
    <emphasis>linearization</emphasis> refers to the algorithm used to
    &#x201C;flatten&#x201D; this graph for the purposes of resolving method lookup
    priorities, constructor invocation order, binding of
    <literal>super</literal>, etc.<indexterm class="startofrange" id="ch07_inheritlinearization">
        <primary>inheritance</primary>

        <secondary>linearization of object hierarchy</secondary>
      </indexterm><indexterm class="startofrange" id="ch07_linearization">
        <primary>linearization of object hierarchy</primary>
      </indexterm><indexterm class="startofrange" id="ch07_ojectsyslinearization">
        <primary>object system (Scala)</primary>

        <secondary>linearization of object hierarchy</secondary>
      </indexterm></para>

    <para id="para_informally_we_saw_in_stacka">Informally, we saw in <xref linkend="StackableTraits"/> that when an instance has more than one
    trait, they bind right to left, as declared. Consider the following
    example of linearization:</para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/linearization/linearization1-script.scala

class C1 {
  def m = List("C1")
}

trait T1 extends C1 {
  override def m = { "T1" :: super.m }
}

trait T2 extends C1 {
  override def m = { "T2" :: super.m }
}

trait T3 extends C1 {
  override def m = { "T3" :: super.m }
}

class C2 extends T1 with T2 with T3 {
  override def m = { "C2" :: super.m }
}

val c2 = new C2
println(c2.m)</programlisting>

    <para id="para_running_oop2a">Running this script yields the following
    output:</para>

    <screen>List(C2, T3, T2, T1, C1)</screen>

    <para id="para_this_list_of_strings_built_up_">This list of strings built
    up by the <literal>m</literal> methods reflects the
    <emphasis>linearization</emphasis> of the inheritance hierarchy, with a
    few missing pieces we&#x2019;ll discuss shortly. We&#x2019;ll also see why C1 is at the
    end of the list. First, let&#x2019;s see what the invocation sequence of the
    constructors looks like:<indexterm>
        <primary>reference types</primary>

        <secondary>linearization algorithm for</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/linearization/linearization2-script.scala

var clist = List[String]()

class C1 {
  clist ::= "C1"
}

trait T1 extends C1 {
  clist ::= "T1"
}

trait T2 extends C1 {
  clist ::= "T2"
}

trait T3 extends C1 {
  clist ::= "T3"
}

class C2 extends T1 with T2 with T3 {
  clist ::= "C2"
}

val c2 = new C2
println(clist.reverse)</programlisting>

    <para id="para_running_oop2b">Running this script yields the following
    output:</para>

    <screen>List(C1, T1, T2, T3, C2)</screen>

    <para id="para_so_the_construction_sequence_">So, the construction
    sequence is the reverse. (We had to reverse the list on the last line,
    because the way it was constructed put the elements in the reverse order.)
    This invocation order makes sense. For proper construction to occur, the
    parent types need to be constructed before the derived types, since a
    derived type often uses fields and methods in the parent types during its
    construction process.</para>

    <para id="para_the_output_of_linearization_">The output of the first
    linearization script is actually missing three types at the end. The full
    linearization for reference types actually ends with
    <literal>ScalaObject</literal>, <literal>AnyRef</literal>, and
    <literal>Any</literal>. So the linearization for <literal>C2</literal> is
    actually:</para>

    <screen>List(C2, T3, T2, T1, C1, ScalaObject, AnyRef, Any)</screen>

    <para id="para_scala_inserts_the_scalaobject">Scala inserts the
    <literal>ScalaObject</literal> trait as the last mixin, just before
    <literal>AnyRef</literal> and <literal>Any</literal> that are the
    penultimate and ultimate parent classes of any reference type. Of course,
    these three types do not show up in the output of the scripts, because we
    used an ad hoc <literal>m</literal> method to figure out the behavior by
    building up an output string.</para>

    <para id="para_the_value_types_subclasse">The &#x201C;value types,&#x201D; subclasses of
    <literal>AnyVal</literal>, are all declared <literal>abstract
    final</literal>. The compiler manages instantiation of them. Since we
    can&#x2019;t subclass them, their linearizations are simple and
    straightforward.</para>

    <para id="para_the_linearization_defines_the_">The linearization defines
    the order in which method lookup occurs. Let&#x2019;s examine it more
    closely.</para>

    <para id="para_all_our_classes_and_traits_def">All our classes and traits
    define the method <literal>m</literal>. The one in <literal>C2</literal>
    is called first, since the instance is of that type.
    <literal>C2.m</literal> calls <literal>super.m</literal>, which resolves
    to <literal>T3.m</literal>. The search appears to be
    <emphasis>breadth-first</emphasis>, rather than
    <emphasis>depth-first</emphasis>. If it were depth-first, it would invoke
    <literal>C1.m</literal> after <literal>T3.m</literal>. Afterward,
    <literal>T3.m</literal>, <literal>T2.m</literal>, then
    <literal>T1.m</literal>, and finally <literal>C1.m</literal> are invoked.
    <literal>C1</literal> is the parent of the three traits. From which of the
    traits did we traverse to <literal>C1</literal>? Actually, it is
    breadth-first, with &#x201C;delayed&#x201D; evaluation, as we will see. Let&#x2019;s modify our
    first example and see how we got to <literal>C1</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/linearization/linearization3-script.scala

class C1 {
  def m(previous: String) = List("C1("+previous+")")
}

trait T1 extends C1 {
  override def m(p: String) = { "T1" :: super.m("T1") }
}

trait T2 extends C1 {
  override def m(p: String) = { "T2" :: super.m("T2") }
}

trait T3 extends C1 {
  override def m(p: String) = { "T3" :: super.m("T3") }
}

class C2 extends T1 with T2 with T3 {
  override def m(p: String) = { "C2" :: super.m("C2") }
}

val c2 = new C2
println(c2.m(""))</programlisting>

    <para id="para_now_we_pass_the_name_of_the_ca">Now we pass the name of the
    caller of <literal>super.m</literal> as a parameter, then
    <literal>C1</literal> prints out who called it. Running this script yields
    the following output:</para>

    <screen>List(C2, T3, T2, T1, C1(T1))</screen>

    <para id="para_it_s_the_last_one_t1_we_mi">It&#x2019;s the last one,
    <literal>T1</literal>. We might have expected <literal>T3</literal> from a
    &#x201C;na&#xEF;ve&#x201D; application of breadth-first traversal.<indexterm>
        <primary>linearization of object hierarchy</primary>

        <secondary>algorithm for reference types</secondary>
      </indexterm></para>

    <para id="para_here_is_the_actual_algorithm_f">Here is the actual
    algorithm for calculating the linearization. A more formal definition is
    given in <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>.<indexterm>
        <primary>reference types</primary>

        <secondary>linearization algorithm for</secondary>
      </indexterm></para>

    <?dbfo-need height=”1in”
?>

    <sidebar>
      <title>Linearization Algorithm for Reference Types</title>

      <orderedlist numeration="arabic">
        <listitem>
          <para>Put the actual type of the instance as the first
          element.</para>
        </listitem>

        <listitem>
          <para>Starting with the <emphasis>rightmost</emphasis> parent type
          and working <emphasis>left</emphasis>, compute the linearization of
          each type, appending its linearization to the cumulative
          linearization. (Ignore <literal>ScalaObject</literal>,
          <literal>AnyRef</literal>, and <literal>Any</literal> for
          now.)</para>
        </listitem>

        <listitem>
          <para>Working from <emphasis>left to right</emphasis>, remove any
          type if it appears again to the <emphasis>right</emphasis> of the
          current position.</para>
        </listitem>

        <listitem>
          <para>Append <literal>ScalaObject</literal>,
          <literal>AnyRef</literal>, and <literal>Any</literal>.</para>
        </listitem>
      </orderedlist>
    </sidebar>

    <para id="para_this_explains_how_we_got_to_c">This explains how we got to
    <literal>C1</literal> from <literal>T1</literal> in the previous example.
    <literal>T3</literal> and <literal>T2</literal> also have it in their
    linearizations, but they come before <literal>T1</literal>, so the
    <literal>C1</literal> terms they contributed were deleted.</para>

    <para id="para_let_s_work_through_the_algorit">Let&#x2019;s work through the
    algorithm using a slightly more involved example:</para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/linearization/linearization4-script.scala

class C1 {
  def m = List("C1")
}

trait T1 extends C1 {
  override def m = { "T1" :: super.m }
}

trait T2 extends C1 {
  override def m = { "T2" :: super.m }
}

trait T3 extends C1 {
  override def m = { "T3" :: super.m }
}

class C2A extends T2 {
  override def m = { "C2A" :: super.m }
}

class C2 extends C2A with T1 with T2 with T3 {
  override def m = { "C2" :: super.m }
}

def calcLinearization(obj: C1, name: String) = {
  val lin = obj.m ::: List("ScalaObject", "AnyRef", "Any")
  println(name + ":  " + lin)
}

calcLinearization(new C2, "C2 ")
println("")
calcLinearization(new T3 {}, "T3 ")
calcLinearization(new T2 {}, "T2 ")
calcLinearization(new T1 {}, "T1 ")
calcLinearization(new C2A, "C2A")
calcLinearization(new C1, "C1 ")</programlisting>

    <para id="para_out1">The output is the following:</para>

    <screen>C2 :  List(C2, T3, T1, C2A, T2, C1, ScalaObject, AnyRef, Any)

T3 :  List(T3, C1, ScalaObject, AnyRef, Any)
T2 :  List(T2, C1, ScalaObject, AnyRef, Any)
T1 :  List(T1, C1, ScalaObject, AnyRef, Any)
C2A:  List(C2A, T2, C1, ScalaObject, AnyRef, Any)
C1 :  List(C1, ScalaObject, AnyRef, Any)</screen>

    <para id="para_to_help_us_along_we_calculate">To help us along, we
    calculated the linearizations for the other types, and we also appended
    <literal>ScalaObject</literal>, <literal>AnyRef</literal>, and
    <literal>Any</literal> to remind ourselves that they should also be there.
    We also removed the logic to pass the caller&#x2019;s name to
    <literal>m</literal>. That caller of <literal>C1</literal> will
    <emphasis>always</emphasis> be the element to its immediate
    left.<indexterm>
        <primary>linearization of object hierarchy</primary>

        <secondary>hand calculation for C2 (example)</secondary>
      </indexterm></para>

    <para id="para_so_let_s_work_through_the_alg">So, let&#x2019;s work through the
    algorithm for <literal>C2</literal> and confirm our results. We&#x2019;ll
    suppress the <literal>ScalaObject</literal>, <literal>AnyRef</literal>,
    and <literal>Any</literal> for clarity, until the end. See <xref linkend="table_7-5"/>.</para>

    <table id="table_7-5">
      <title>Hand calculation of C2 linearization: C2 extends C2A with T1 with
      T2 with T3 {...}</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>#</entry>

            <entry><phrase role="keep-together">Linearization</phrase></entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para>1</para></entry>

            <entry><para><literal>C2</literal></para></entry>

            <entry><para>Add the type of the instance.</para></entry>
          </row>

          <row>
            <entry><para>2</para></entry>

            <entry><para><literal>C2, T3, C1</literal></para></entry>

            <entry><para>Add the linearization for <literal>T3</literal>
            (farthest on the right).</para></entry>
          </row>

          <row>
            <entry><para>3</para></entry>

            <entry><para><literal>C2, T3, C1, T2, C1</literal></para></entry>

            <entry><para>Add the linearization for
            <literal>T2</literal>.</para></entry>
          </row>

          <row>
            <entry><para>4</para></entry>

            <entry><para><literal>C2, T3, C1, T2, C1, T1,
            C1</literal></para></entry>

            <entry><para>Add the linearization for
            <literal>T1</literal>.</para></entry>
          </row>

          <row>
            <entry><para>5</para></entry>

            <entry><para><literal>C2, T3, C1, T2, C1, T1, C1, C2A, T2,
            C1</literal></para></entry>

            <entry><para>Add the linearization for
            <literal>C2A</literal>.</para></entry>
          </row>

          <row>
            <entry><para>6</para></entry>

            <entry><para><literal>C2, T3, T2, T1, C2A, T2,
            C1</literal></para></entry>

            <entry><para>Remove duplicates of <literal>C1</literal>; all but
            the <emphasis>last</emphasis>
            <literal>C1</literal>.</para></entry>
          </row>

          <row>
            <entry><para>7</para></entry>

            <entry><para><literal>C2, T3, T1, C2A, T2,
            C1</literal></para></entry>

            <entry><para>Remove duplicate <literal>T2</literal>; all but the
            <emphasis>last</emphasis> <literal>T2</literal>.</para></entry>
          </row>

          <row>
            <entry><para>8</para></entry>

            <entry><para><literal>C2, T3, T1, C2A, T2, C1, ScalaObject,<?lb ?>
            AnyRef, Any</literal></para></entry>

            <entry><para>Finish!</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_what_the_algorithm_does_is_pus">What the algorithm does is
    push any shared types to the right until they come after
    <emphasis>all</emphasis> the types that derive from them.</para>

    <para id="para_try_modifying_the_last_script_">Try modifying the last
    script with different hierarchies and see if you can reproduce the results
    using the algorithm.<indexterm class="endofrange" startref="ch07_ojectsyslinearization"/><indexterm class="endofrange" startref="ch07_linearization"/><indexterm class="endofrange" startref="ch07_inheritlinearization"/></para>

    <tip id="para_tip_overly_complex_type_hiera">
      <para>Overly complex type hierarchies can result in method lookup
      &#x201C;surprises.&#x201D; If you have to work through this algorithm to figure out
      what&#x2019;s going on, try to simplify your code.</para>
    </tip>
  </sect1>

  <?dbfo-need height=”1in”
?>

  <sect1 id="_recap_and_what_8217_s_next_4">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_have_finished_our_survey_of">We have finished our survey
    of Scala&#x2019;s object model. If you come from an <phrase role="keep-together">object-</phrase><phrase role="keep-together">oriented</phrase> language background, you now know
    enough about Scala to replace your existing object-oriented language with
    object-oriented Scala.</para>

    <para id="para_however_there_is_much_more_to">However, there is much more
    to come. Scala supports <emphasis>functional programming</emphasis>, which
    offers powerful mechanisms for addressing a number of design problems,
    such as concurrency. We&#x2019;ll see that functional programming appears to
    contradict object-oriented programming, at least on the surface. That
    said, a guiding principle behind Scala is that these two paradigms
    complement each other more than they conflict. Combined, they give you
    more options for building robust, scalable software. Scala lets you choose
    the techniques that work best for your needs.<indexterm class="endofrange" startref="ch07_objectsys"/></para>
  </sect1>
</chapter>
  <chapter id="FunctionalProgramming">
  <title>Functional Programming in Scala</title>

  <para id="para_every_decade_or_two_a_major_c">Every decade or two, a major
  computing idea goes mainstream. These ideas may have lurked in the
  background of academic computer science research, or possibly in some
  lesser-known field of industry. The transition to mainstream acceptance
  comes in response to a perceived problem for which the idea is well suited.
  Object-oriented programming, which was invented in the 1960s, went
  mainstream in the 1980s, arguably in response to the emergence of graphical
  user interfaces, for which the OOP paradigm is a natural fit.<indexterm class="startofrange" id="ch08_functional">
      <primary>functional programming</primary>
    </indexterm></para>

  <para id="para_functional_programming_appears">Functional programming
  appears to be experiencing a similar breakout. Long the topic of computer
  science research and even older than object-oriented programming, functional
  programming offers effective techniques for concurrent programming, which is
  growing in importance.</para>

  <para id="para_because_functional_programming">Because functional
  programming is less widely understood than object-oriented programming, we
  won&#x2019;t assume that you have prior experience with it. We&#x2019;ll start this
  chapter with plenty of background information. As you&#x2019;ll see, functional
  programming is not only a very effective way to approach concurrent
  programming, which we&#x2019;ll explore in depth in <xref linkend="Concurrency"/>,
  but functional programming can also improve your objects.</para>

  <para id="para_to_learn_more_about_functional">Of course, we can&#x2019;t provide
  an exhaustive introduction to functional programming. To learn more about
  it, <link linkend="OSullivan2009" xrefstyle="select:nopage">[O&#x2019;Sullivan2009]</link> has a more detailed
  introduction in the context of the Haskell language. <link linkend="Abelson1996" xrefstyle="select:nopage">[Abelson1996]</link>, <link linkend="VanRoy2004" xrefstyle="select:nopage">[VanRoy2004]</link>, and
  <link linkend="Turbak2008" xrefstyle="select:nopage">[Turbak2008]</link>
  offer thorough introductions to general programming approaches, including
  functional programming. Finally, <link linkend="Okasaki1998" xrefstyle="select:nopage">[Okasaki1998]</link> and <link linkend="Rabhi1999" xrefstyle="select:nopage">[Rabhi1999]</link> discuss functional data
  structures and algorithms in detail.<indexterm>
      <primary>functions</primary>

      <seealso>functional programming</seealso>
    </indexterm></para>

  <sect1 id="WhatIsFunctionalProgramming">
    <title>What Is Functional Programming?</title>

    <para id="para_based_on_mathematics_">Don&#x2019;t all programming languages have
    functions of some sort? Whether they are called methods, procedures, or
    <literal>GOTOs</literal>, programmers are always dealing in functions.
    <phrase role="keep-together">Functional</phrase> programming is based on
    the behavior of functions in the mathematical sense, with all the
    implications that starting point implies.<indexterm>
        <primary>functional programming</primary>

        <secondary>definition of</secondary>
      </indexterm></para>

    <sect2 id="FunctionsInMathematics">
      <title>Functions in Mathematics</title>

      <para id="para_fp_in_mathematics">In mathematics, functions have no
      <emphasis>side effects</emphasis>. Consider the classic function
      <literal>sin(x)</literal>:<indexterm>
          <primary>functional programming</primary>

          <secondary>functions in mathematics</secondary>
        </indexterm><indexterm>
          <primary>mathematics, functions in</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">y = sin(x)</programlisting>

      <para id="para_no_matter_how_much_work_y_s">No matter how much work
      <literal>sin(x)</literal> does, all the results are returned and
      assigned to <literal>y</literal>. No global state of any kind is
      modified internally by <literal>sin(x)</literal>. Hence, we say that
      such a function is free of <emphasis>side effects</emphasis>, or
      <emphasis>pure</emphasis>.</para>

      <para id="para_this_property_simplifies_enorm">This property simplifies
      enormously the challenge of analyzing, testing, and debugging a
      function. You can do these things without having to know anything about
      the context in which the function is invoked, except for any other
      functions it might call. However, you can analyze them in the same way,
      working bottom up to verify the whole &#x201C;stack.&#x201D;</para>

      <para id="para_the_obliviousness_to_the_surro">This obliviousness to the
      surrounding context is known as <emphasis>Referential
      Transparency</emphasis>. You can call such a function anywhere and be
      confident that it will always behave the same way. If no global state is
      modified, concurrent invocation of the function is straightforward and
      reliable.</para>

      <para id="para_in_functional_programming_the">In functional programming,
      you can compose functions from other functions. For example,
      <literal>tan(x) = sin(x)/cos(x)</literal>. An implication of
      composability is that functions can be treated as values. In other
      words, functions are <emphasis>first-class</emphasis>, just like data.
      You can assign functions to variables. You can pass functions to other
      functions. You can return functions as values from functions. In the
      functional paradigm, functions become a primitive type, a building block
      that&#x2019;s just as essential to the work of programming as integers or
      strings.</para>

      <para id="para_when_a_function_takes_other_fu">When a function takes
      other functions as arguments or returns a function, it is called a
      <emphasis>higher-order function</emphasis>. In mathematics, two examples
      of higher-order functions from calculus are derivation and
      integration.<indexterm>
          <primary>functions</primary>

          <secondary>higher order</secondary>
        </indexterm><indexterm>
          <primary>higher-order functions</primary>
        </indexterm></para>
    </sect2>

    <sect2 id="VariablesThatArent">
      <title>Variables that Aren&#x2019;t</title>

      <para id="para_fp_variables_are_immutable">The word &#x201C;variable&#x201D; takes on
      a new meaning in functional programming. If you come from a procedural
      or object-oriented programming background, you are accustomed to
      variables that are <emphasis>mutable</emphasis>. In functional
      programming, variables are <emphasis>immutable</emphasis>.<indexterm>
          <primary>variables</primary>

          <secondary>immutable values in functional programming</secondary>
        </indexterm><indexterm>
          <primary>functional programming</primary>

          <secondary>variables, immutable values of</secondary>
        </indexterm></para>

      <para id="para_this_is_another_consequence_of">This is another
      consequence of the mathematical orientation. In the expression
      <literal>y = sin(x)</literal>, once you pick <literal>x</literal>, then
      <literal>y</literal> is fixed. As another example, if you increment the
      integer 3 by 1, you don&#x2019;t &#x201C;modify the 3 object,&#x201D; you create a new value
      to represent 4.</para>

      <para id="para_to_be_more_precise_it_is_the_">To be more precise, it is
      the values that are immutable. Functional programming languages prevent
      you from assigning a new value to a variable that already has a
      value.</para>

      <para id="para_immutability_is_difficult_when">Immutability is difficult
      when you&#x2019;re not used to it. If you can&#x2019;t change a variable, then you
      can&#x2019;t have loop counters, for example. We&#x2019;re accustomed to objects that
      change their state when we call methods on them. Learning to think in
      immutable terms takes some effort.</para>

      <para id="para_however_immutability_has_enor">However, immutability has
      enormous benefits for concurrency. Almost all the difficulty of
      multithreaded programming lies in synchronizing access to shared,
      mutable state. If you remove mutability, then the problems essentially
      go away. It is the combination of referentially transparent functions
      and immutable values that make functional programming compelling as a
      better way to write concurrent software.</para>

      <para id="para_these_qualities_benefit_progra">These qualities benefit
      programs in other ways. Almost all the constructs we have <phrase role="keep-together">invented</phrase> in 60-odd years of computer
      programming have been attempts to manage complexity. Higher-order
      functions and referential transparency provide very flexible building
      blocks for composing programs.</para>

      <para id="para_immutability_greatly_reduces_r">Immutability greatly
      reduces regression bugs, many of which are caused by
      <emphasis>unintended</emphasis> state changes in one part of a program
      due to <emphasis>intended</emphasis> changes in another part. There are
      other contributors to such <emphasis>non-local</emphasis> effects, but
      mutability is one of the most important.</para>

      <para id="para_it_s_common_in_object_oriented">It&#x2019;s common in
      object-oriented designs to encapsulate access to data structures in
      objects. If these structures are mutable, we can&#x2019;t simply share them
      with clients. We have to add special accessor methods to control access,
      so clients can&#x2019;t modify them outside our control. These additions
      increase code size, which increases the testing and maintenance burden,
      and they increase the effort required by clients to understand the ad
      hoc features of our APIs.</para>

      <para id="para_in_contrast_when_we_have_immu">In contrast, when we have
      immutable data structures, many of these problems simply go away. We can
      provide access to collections without fear of data loss or corruption.
      Of course, the general principles of minimal coupling still apply;
      should clients care if a <literal>Set</literal> or
      <literal>List</literal> is used, as long <literal>foreach</literal> is
      available?</para>

      <para id="para_immutable_data_also_implies_th">Immutable data also
      implies that lots of copies will be made, which can be expensive.
      Functional data structures optimize for this problem (see <link linkend="Okasaki1998" xrefstyle="select:nopage">[Okasaki1998]</link>)
      and many of the built-in Scala types are efficient at creating new
      copies from existing copies.</para>

      <para id="para_we_ll_discuss_other_aspects_of">It&#x2019;s time to dive into
      the practicalities of functional programming in Scala. We&#x2019;ll discuss
      other aspects and benefits of the approach as we proceed.</para>
    </sect2>
  </sect1>

  <sect1 id="FunctionalProgrammingInScala">
    <title>Functional Programming in Scala</title>

    <para id="para_as_a_hybrid_object_functional_">As a hybrid
    object-functional language, Scala does not require functions to be pure,
    nor does it require variables to be immutable. It does, however, encourage
    you to write your code this way whenever possible. You have the freedom to
    use procedural or object-oriented techniques when and where they seem most
    appropriate.<indexterm class="startofrange" id="ch08_functionalScala">
        <primary>functional programming</primary>

        <secondary sortas="Scala">in Scala</secondary>
      </indexterm></para>

    <para id="para_if_you_think_about_what_we_sai">Though functional languages
    are all about eliminating side effects, a language that
    <emphasis>never</emphasis> allowed for side effects would be useless.
    Input and output (IO) are inherently about side effects, and IO is
    essential to all programming tasks. For this reason, all functional
    languages provide mechanisms for performing side effects in a controlled
    way.</para>

    <para id="para_scala_doesn_t_restrict_what_yo">Scala doesn&#x2019;t restrict what
    you can do, but we encourage you to use immutable values and pure
    functions and methods whenever possible. When mutability and side effects
    are necessary, pursue them in a &#x201C;principled&#x201D; way, isolated in well-defined
    modules and focused on individual tasks.</para>

    <para id="para_however_if_you_are_new_to_fun">If you&#x2019;re new to functional
    programming, keep in mind that it&#x2019;s easy to fall back to old habits. We
    encourage you to master the functional side of Scala and to learn to use
    it effectively.</para>

    <tip id="para_tip_a_function_that_returns_">
      <para>A function that returns <literal>Unit</literal> implies that the
      function has pure side effects, meaning that if it does any useful work,
      that work must be all side effects, since the function doesn&#x2019;t return
      anything.</para>
    </tip>

    <para id="para_we_ve_seen_many_examples_of_hi">We&#x2019;ve seen many examples of
    higher-order functions and composability in Scala. For example,
    <literal>List.map</literal> takes a function to transform each element of
    the list to something else:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/basics/list-map-example-script.scala

List(1, 2, 3, 4, 5) map { _ * 2 }</programlisting>

    <para id="para_recall_that_095_042_2_">Recall that <literal>_ *
    2</literal> is a <emphasis>function literal</emphasis> that is shorthand
    for <literal>i =&gt; i * 2</literal>. For each argument to the function,
    you can use <literal>_</literal> if the argument is used only once. We
    also used the infix operator notation to invoke <literal>map</literal>.
    Here&#x2019;s an example that &#x201C;reduces&#x201D; the same list by multiplying all the
    elements together:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/basics/list-reduceLeft-example-script.scala

List(1, 2, 3, 4, 5) reduceLeft { _ * _ }</programlisting>

    <para id="para_the_first_095_represents_th">The first <literal>_</literal>
    represents the argument that is accumulating the value of the reduction,
    and the second <literal>_</literal> represents the current element of the
    list.</para>

    <para id="para_by_the_way_this_example_succe">Both examples successfully
    &#x201C;looped&#x201D; through the list without the use of a mutable counter to track
    iterations. Most containers in the Scala library provide functionally pure
    iteration methods. In other cases, recursion is the preferred way to
    traverse a data structure or perform an algorithm. We&#x2019;ll return to this
    topic in <xref linkend="Recursion"/>.</para>

    <?dbfo-need height=”1in”
?>

    <sect2 id="FunctionLiteralsAndClosures">
      <title>Function Literals and Closures</title>

      <para id="para_let_s_expand_our_previous_exam">Let&#x2019;s expand our previous
      <literal>map</literal> example a bit:<indexterm>
          <primary>function literals</primary>

          <secondary>closures and</secondary>
        </indexterm><indexterm>
          <primary>functional programming</primary>

          <secondary sortas="Scala">in Scala</secondary>

          <tertiary>function literals and closures</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/basics/list-map-closure-example-script.scala

var factor = 3
val multiplier = (i:Int) =&gt; i * factor

val l1 = List(1, 2, 3, 4, 5) map multiplier

factor = 5
val l2 = List(1, 2, 3, 4, 5) map multiplier

println(l1)
println(l2)</programlisting>

      <para id="para_we_defined_a_var_factor_to">We defined a variable,
      <literal>factor</literal>, to use as the multiplication factor, and we
      pulled out the previous anonymous function into a value called
      <literal>multiplier</literal> that now uses <literal role="keep-together">factor</literal>. Then we map over a list of
      integers, as we did before. After the first call to
      <literal>map</literal>, we change <literal>factor</literal> and map
      again. Here is the output:</para>

      <screen>List(3, 6, 9, 12, 15)
List(5, 10, 15, 20, 25)</screen>

      <para id="para_even_though_multiplier_was_a">Even though
      <literal>multiplier</literal> was an immutable function value, its
      behavior changed when <literal>factor</literal> changed.</para>

      <para id="para_there_are_two__free_variables_">There are two
      <emphasis>free variables</emphasis> in <literal>multiplier</literal>:
      <literal>i</literal> and <literal>factor</literal>. One of them,
      <literal>i</literal>, is a <emphasis>formal parameter</emphasis> to the
      function. Hence, it is <emphasis>bound</emphasis> to a new value each
      time <literal>multiplier</literal> is called.</para>

      <para id="para_however_factor_is_not_a_for">However,
      <literal>factor</literal> is not a formal parameter, but a reference to
      a variable in the enclosing scope. Hence, the compiler creates a
      <emphasis>closure</emphasis> that encompasses (or &#x201C;closes over&#x201D;)
      <literal role="keep-together">multiplier</literal> and the external
      context of the unbound variables <literal>multiplier</literal>
      references, thereby binding those variables as well.<indexterm>
          <primary>closures</primary>
        </indexterm></para>

      <para id="para_this_is_why_the_behavior_of_m">This is why the behavior
      of <literal>multiplier</literal> changed after changing
      <literal>factor</literal>. It references <literal>factor</literal> and
      reads its current value each time. If a function has no external
      references, then it is trivially closed over itself. No external context
      is required.</para>
    </sect2>

    <sect2 id="PurityInsideVsOutside">
      <title>Purity Inside Versus Outside</title>

      <para id="para_if_we_called_sin_x_thousand">If we called
      <literal>sin(x)</literal> thousands of times with the same value of
      <literal>x</literal>, it would be wasteful if it calculated the same
      value every single time. Even in &#x201C;pure&#x201D; functional libraries, it is
      common to perform internal optimizations like caching previously
      computed values (sometimes called <emphasis>memoization</emphasis>).
      Caching introduces side effects, as the state of the cache is
      modified.<indexterm>
          <primary>memoization</primary>
        </indexterm></para>

      <para id="para_however_this_lack_of_purity_s">However, this lack of
      purity should be opaque to the user (except perhaps in terms of the
      performance impact). If you are designing functional libraries, ensure
      that they preserve the purity of their abstractions, including the
      behavior of referential transparency and its implications for
      concurrency.</para>

      <para id="para_you_can_see_examples_of_this_i">You can see examples of
      functional libraries with mutable internals in the Scala library. The
      methods in <literal>List</literal> often use mutable local variables for
      efficient traversal. The local variables are thread-safe, as are the
      traversals, since <literal>Lists</literal> themselves are
      immutable.<indexterm class="endofrange" startref="ch08_functionalScala"/></para>
    </sect2>
  </sect1>

  <sect1 id="Recursion">
    <title>Recursion</title>

    <para id="para_recursion_plays_a_larger_role_">Recursion plays a larger
    role in pure functional programming than in imperative programming, in
    part because of the restriction that variables are immutable. For example,
    you can&#x2019;t have loop counters, which would change on each pass through a
    loop. One way to implement looping in a purely functional way is with
    recursion.<indexterm>
        <primary>recursion</primary>

        <secondary sortas="functional programming">in functional
        programming</secondary>
      </indexterm><indexterm>
        <primary>functional programming</primary>

        <secondary>recursion</secondary>
      </indexterm></para>

    <para id="para_loop_by_recursion_example_">Calculating factorials provides
    a good example. Here is an imperative loop <phrase role="keep-together">implementation</phrase>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/recursion/factorial-loop-script.scala

def factorial_loop(i: BigInt): BigInt = {
  var result = BigInt(1)
  for (j &lt;- 2 to i.intValue)
    result *= j
  result
}

for (i &lt;- 1 to 10)
  format("%s: %s\n", i, factorial_loop(i))</programlisting>

    <para id="para_both_the_loop_counter_j_and_">Both the loop counter
    <literal>j</literal> and the <literal>result</literal> are mutable
    variables. (For simplicity, we&#x2019;re ignoring input numbers that are less
    than or equal to zero.) The output of the script is the following:</para>

    <screen>1: 1
2: 2
3: 6
4: 24
5: 120
6: 720
7: 5040
8: 40320
9: 362880
10: 3628800</screen>

    <para id="para_fact_recur1_impl">Here&#x2019;s a first pass at a recursive
    implementation:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/recursion/factorial-recur1-script.scala

def factorial(i: BigInt): BigInt = i match {
  case _ if i == 1 =&gt; i
  case _ =&gt; i * factorial(i - 1)
}

for (i &lt;- 1 to 10)
  format("%s: %s\n", i, factorial(i))</programlisting>

    <para id="para_the_output_is_the_same_but_no">The output is the same, but
    now there are no mutable variables. Recursion not only helps us avoid
    mutable variables, it is also the most natural way to express some <phrase role="keep-together">functions</phrase>, particularly mathematical
    functions. The recursive definition in our second <literal role="keep-together">factorial</literal> is structurally similar to a
    definition for factorials that you might see in a mathematics book.</para>

    <para id="para_two_potential_problems_with_re">However, there are two
    potential problems with recursion: the performance overhead of repeated
    function invocations and the risk of stack overflow.</para>

    <para id="para_performance_problems_in_a_recu">Performance problems in a
    recursive scenario can sometimes be addressed with
    <emphasis>memoization</emphasis>, but care should be taken that the space
    requirements of caching don&#x2019;t outweigh the performance benefits.</para>

    <para id="para_stack_overflow_can_be_avoided_">Stack overflow can be
    avoided by converting the recursive invocation into a loop of some kind.
    In fact, the Scala compiler can do this conversion for you for some kinds
    of recursive invocations, which we describe next.</para>
  </sect1>

  <sect1 id="TailCalls">
    <title>Tail Calls and Tail-Call Optimization</title>

    <para id="para_a_particular_kind_of_recursion">A particular kind of
    recursion is called <emphasis>tail-call</emphasis> recursion, which occurs
    when a function calls itself as its final operation. Tail-call recursion
    is very important because it is the easiest kind of recursion to optimize
    by conversion into a loop. Loops eliminate the potential of a stack
    overflow, and they improve performance by eliminating the recursive
    function call overhead. While tail recursion optimizations are not yet
    supported natively on the JVM, <literal>scalac</literal> can do
    them.<indexterm>
        <primary>functional programming</primary>

        <secondary>tail calls and tail-call optimization</secondary>
      </indexterm><indexterm>
        <primary>tail calls</primary>
      </indexterm><indexterm>
        <primary>recursion</primary>

        <secondary>tail-call</secondary>
      </indexterm></para>

    <para id="para_the_fact_example_above_is_not">However, our factorial
    example is not a tail recursion, because <literal>factorial</literal>
    calls itself and <emphasis>then</emphasis> does a multiplication with the
    results. There is a way to implement <literal>factorial</literal> in a
    tail recursive way. We actually saw an implementation in <xref linkend="NestingMethodDefinitions"/>. However, that example didn&#x2019;t use
    some constructs we&#x2019;ve learned about since, such as <literal>for</literal>
    comprehensions and pattern matching. So, here&#x2019;s a new implementation of
    <literal>factorial</literal>, calculated with tail-call recursion:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/recursion/factorial-recur2-script.scala

def factorial(i: BigInt): BigInt = {
  def fact(i: BigInt, accumulator: BigInt): BigInt = i match {
    case _ if i == 1 =&gt; accumulator
    case _ =&gt; fact(i - 1, i * accumulator)
  }
  fact(i, 1)
}

for (i &lt;- 1 to 10)
  format("%s: %s\n", i, factorial(i))</programlisting>

    <para id="fact-script-output">This script produces the same output as
    before. Now, <literal>factorial</literal> does all the work with a nested
    method, <literal>fact</literal>, that is tail recursive because it passes
    an <literal>accumulator</literal> argument to hold the computation in
    progress. This argument is computed with a multiplication
    <emphasis>before</emphasis> the recursive call to <literal>fact</literal>,
    which is now the very last thing that is done. In our previous
    implementation, this multiplication was done <emphasis>after</emphasis>
    the call to <literal>fact</literal>. When we call
    <literal>fact(1)</literal>, we simply return the accumulated value.</para>

    <para id="para_calling_fact_not_tc_10000_r">If you call our original
    non-tail recursive implementation of <literal>factorial</literal> with a
    large number&#x2014;say 10,000&#x2014;you&#x2019;ll cause a stack overflow on a typical desktop
    computer. The tail-recursive implementation works successfully, returning
    a very large number.</para>

    <para id="para_this_idiom_of_nesting_a">This idiom of nesting a
    tail-recursive function that uses an accumulator is a very useful
    technique for converting many recursive algorithms into tail recursions
    that can be optimized into loops by <literal>scalac</literal>.</para>

    <note id="para_note_the_tail_call_optimizati">
      <simpara>The tail-call optimization won&#x2019;t be applied when a method that
      calls itself might be overridden in a derived type. The method must be
      private or final, defined in an <literal>object</literal>, or nested in
      another method (like <literal>fact</literal> earlier). The new
      <literal>@tailrec</literal> annotation in version 2.8 will trigger an
      error if the compiler can&#x2019;t optimize the annotated method. (See <xref linkend="Annotations"/>.)</simpara>
    </note>

    <sect2 id="TrampolineTailCalls">
      <title>Trampoline for Tail Calls</title>

      <para id="para_trampoline_and_recursion">A
      <emphasis>trampoline</emphasis> is a loop that works through a list of
      functions, calling each one in turn. The metaphor of bouncing the
      functions off a trampoline is the source of the name.<indexterm>
          <primary>loops</primary>

          <secondary>trampoline</secondary>
        </indexterm><indexterm>
          <primary>trampolines</primary>
        </indexterm><indexterm>
          <primary>tail calls</primary>

          <secondary>trampoline for</secondary>
        </indexterm></para>

      <para id="para_consider_a_kind_of_recursion_w">Consider a kind of
      recursion where a function <literal>A</literal> doesn&#x2019;t call itself
      recursively, but instead it calls another function <literal>B</literal>,
      which calls <literal>A</literal>, which calls <literal>B</literal>, etc.
      This kind of back-and-forth recursion can also be converted into a loop
      using a trampoline. Note that trampolines impose a performance overhead,
      but they are ideal for pure functional recursions (versus an imperative
      equivalent) that would otherwise exhaust the stack.</para>

      <para id="para_scala_version_2_8_will_support">Support for this
      optimization is planned for Scala version 2.8, although it has not yet
      been implemented at the time of this writing.</para>
    </sect2>
  </sect1>

  <sect1 id="FunctionalDataStructures">
    <title>Functional Data Structures</title>

    <para id="para_list_in_fp">There are several data structures that are
    common in functional programming, most of which are containers, like
    collections. Languages like Erlang rely on very few types, while other
    functional languages provide a richer type system.<indexterm>
        <primary>functional programming</primary>

        <secondary>data structures</secondary>
      </indexterm></para>

    <para id="para_the_common_data_structures_sup">The common data structures
    support the same subset of higher-order functions for read-only traversal
    and access to the elements in the data structures. These features make
    them suitable as &#x201C;protocols&#x201D; for minimizing the coupling between
    components, while supporting data exchange.</para>

    <para id="para_in_fact_these_data_structures">In fact, these data
    structures and their operations are so useful that many languages support
    them, including those that are not considered functional languages, like
    Java and Ruby. Java doesn&#x2019;t support higher-order functions directly.
    Instead, function values have to be wrapped in objects. Ruby uses
    <literal>procs</literal> and <literal>lambdas</literal> as function
    values.</para>

    <sect2 id="ListsInFunctionalProgramming">
      <title>Lists in Functional Programming</title>

      <para id="para_lists_are_the_most_common_data">Lists are the most common
      data structure in functional programming. They are the core of the first
      functional programming language, Lisp.<indexterm>
          <primary>functional programming</primary>

          <secondary>data structures</secondary>

          <tertiary>lists</tertiary>
        </indexterm><indexterm>
          <primary>lists in functional programming</primary>
        </indexterm></para>

      <para id="para_supporting_immutability_when_">In the interest of
      immutability, a new list is created when you add an element to a list.
      It is conventional to prepend the new element to the list, as we&#x2019;ve seen
      before:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/list-script.scala

val list1 = List("Programming", "Scala")
val list2 = "People" :: "should" :: "read" :: list1
println(list2)</programlisting>

      <para id="para_because_the_095_095_ope">Because the
      <literal>::</literal> operator binds to the right, the definition of
      <literal>list2</literal> is equivalent to both of the following
      variations:</para>

      <programlisting linenumbering="unnumbered">val list2 = ("People" :: ("should" :: ("read" :: list1)))
val list2 = list1.::("read").::("should").::("People")</programlisting>

      <para id="para_in_terms_of_performance_prepe">In terms of performance,
      prepending is O(1). We&#x2019;ll see why when we dive into Scala&#x2019;s
      implementation of <literal>List</literal> in <xref linkend="ACloserLookAtLists"/>, after we have learned more about
      <emphasis>parameterized types</emphasis> in Scala.</para>

      <para id="para_unlike_some_of_the_other_colle">Unlike some of the other
      collections, Scala only defines an immutable <literal>List</literal>.
      However, it also defines some mutable list types, such as
      <literal>ListBuffer</literal> and <literal>LinkedList</literal></para>
    </sect2>

    <sect2 id="MapsInFunctionalProgramming">
      <title>Maps in Functional Programming</title>

      <para id="para_perhaps_the_second_most_common">Perhaps the second most
      common data structure is the map, referred to as a
      <emphasis>hash</emphasis> or <emphasis>dictionary</emphasis> in other
      languages, and not to be confused with the <literal>map</literal>
      function we saw earlier. Maps are used to hold pairs of keys and
      values.<indexterm>
          <primary>functional programming</primary>

          <secondary>data structures</secondary>

          <tertiary>maps</tertiary>
        </indexterm><indexterm>
          <primary>maps in functional programming</primary>
        </indexterm></para>

      <para id="para_in_the_interest_of_minimalism_">In the interest of
      minimalism, maps could be implemented with lists. Every even element in
      the list (counting from zero) could be a key, followed by the value in
      the next odd position. In practice, maps are usually implemented in
      other ways for efficiency.</para>

      <para id="para_scala_supports_the_special_ini">Scala supports the
      special initialization syntax we saw previously:</para>

      <programlisting linenumbering="unnumbered">val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Juneau",
  // ...
  "Wyoming" -&gt; "Cheyenne")</programlisting>

      <?dbfo-need height=”1in”
?>

      <para id="para_the_scala_collection_map_a_">The
      <literal>scala.collection.Map[A,+B]</literal> trait only defines methods
      for reading the <literal>Map</literal>. There are derived traits for
      immutable and mutable maps,
      <literal>scala.collection.immutable.Map[A,+B]</literal> and
      <literal>scala.collection.mutable.Map[A,B]</literal>, respectively. They
      define <literal>+</literal> and <literal>-</literal> operators for
      adding and removing elements, and <literal>++</literal> and
      <literal>--</literal> operators for adding and removing elements defined
      in <literal>Iterators</literal> of <literal>Pairs</literal>, where each
      <literal>Pair</literal> is a key-value pair.</para>

      <note id="para_note_you_might_have_noticed_t">
        <para>You might have noticed that the <literal>+</literal> does not
        appear in front of the <literal>B</literal> type parameters for
        <literal>scala.collection.mutable.Map</literal>. You&#x2019;ll see why in
        <xref linkend="VarianceOfMutableTypes"/>.</para>
      </note>
    </sect2>

    <sect2 id="SetsInFunctionalProgramming">
      <title>Sets in Functional Programming</title>

      <para id="para_sets_are_like_lists_but_they_">Sets are like lists, but
      they require each element to be unique. Sets could also be implemented
      using lists, as long as the equivalent of the list &#x201C;cons&#x201D; operator
      (<literal>::</literal>) first checks that the element doesn&#x2019;t already
      exist in the storage list. This property means that element insertion
      would be O(N) if a storage list were used, and the order of the elements
      in the set wouldn&#x2019;t necessarily match the order of &#x201C;insertion&#x201D;
      operations. In practice, sets are usually implemented with more
      efficient data structures.<indexterm>
          <primary>sets in functional programming</primary>
        </indexterm></para>

      <para id="para_just_as_for_map_the_scala_">Just as for
      <literal>Map</literal>, the <literal>scala.collection.Set[A]</literal>
      trait only defines methods for reading the <literal>Set</literal>. There
      are derived traits for immutable and mutable sets,
      <literal>scala.collection.immut&#x2060;able.Set[A]</literal> and
      <literal>scala.collection.mutable.Set[A]</literal>, respectively. They
      define <literal>+</literal> and <literal>-</literal> operators for
      adding and removing elements, and <literal>++</literal> and
      <literal>--</literal> operators for adding and removing elements defined
      in <literal>Iterators</literal> (which could be other sets, lists,
      etc.).</para>
    </sect2>

    <sect2 id="OtherDataStructuresInFunctionalProgramming">
      <title>Other Data Structures in Functional Programming</title>

      <para id="para_other_common_data_structures_">Other familiar data
      structures, like <literal>Tuples</literal> and
      <literal>Arrays</literal>, will appear in functional languages.
      Typically, they&#x2019;re used to provide some convenient feature not supported
      by a more common functional type. In most cases they could be replaced
      with lists.</para>
    </sect2>
  </sect1>

  <sect1 id="TraversingMappingFilteringFolding">
    <title>Traversing, Mapping, Filtering, Folding, and Reducing</title>

    <para id="para_fundamental_operations_in_fp">The functional collections we
    just discussed&#x2014;lists, maps, sets, as well as tuples and arrays&#x2014;all support
    several common operations based on read-only traversal. In fact, this
    uniformity can be exploited if any &#x201C;container&#x201D; type also supports these
    operations. For example, an <literal>Option</literal> contains zero or one
    elements, if it is a <literal>None</literal> or <literal>Some</literal>,
    respectively.</para>

    <sect2 id="FunctionalTraversal">
      <title>Traversal</title>

      <para id="para_the_standard_traversal_method_">The standard traversal
      method for Scala containers is <literal>foreach</literal>, which is
      defined by the <literal>Iterable</literal> traits that the containers
      mix in. It is O(N) in the number of elements. Here is an example of its
      use for lists and maps:<indexterm>
          <primary>Iterable object</primary>
        </indexterm><indexterm>
          <primary>foreach method</primary>

          <secondary>traversal operations in functional
          programming</secondary>
        </indexterm><indexterm>
          <primary>functional programming</primary>

          <secondary>traversal of data structures</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/foreach-script.scala

List(1, 2, 3, 4, 5) foreach { i =&gt; println("Int: " + i) }

val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Juneau",
  "Wyoming" -&gt; "Cheyenne")

stateCapitals foreach { kv =&gt; println(kv._1 + ": " + kv._2) }</programlisting>

      <para id="para_the_signature_of_foreach_is_">The signature of
      <literal>foreach</literal> is the following:</para>

      <programlisting linenumbering="unnumbered">trait Iterable[+A] {
  ...
  def foreach(f : (A) =&gt; Unit) : Unit = ...
  ...
}</programlisting>

      <para id="para_it_is_a_higher_order_function_"><literal>foreach</literal> is a
      higher-order function that takes a function argument: the operation to
      perform on each element. Note that for a map, <literal>A</literal> is
      actually a tuple, as shown in the example. Also,
      <literal>foreach</literal> returns <literal>Unit</literal>.
      <literal>foreach</literal> is not intended to create new collections;
      we&#x2019;ll see examples of operations that create collections shortly.</para>

      <para id="para_once_you_have_foreach_you_c">Once you have
      <literal>foreach</literal>, you can implement all the other traversal
      operations we&#x2019;ll discuss next, and more. A look at
      <literal>Iterable</literal> will show that it supports methods for
      filtering collections, finding elements that match specified criteria,
      calculating the number of elements, and so forth.</para>

      <para id="para_the_methods_we_ll_discuss_next">The methods we&#x2019;ll discuss
      next are hallmarks of functional programming: mapping, filtering,
      folding, and reducing.</para>
    </sect2>

    <sect2 id="FunctionalMapping">
      <title>Mapping</title>

      <para id="para_we_have_encountered_the_map_">We&#x2019;ve encountered the
      <literal>map</literal> method before. It returns a new collection of the
      same size as the original collection. It is also a member of
      <literal>Iterable</literal>, and its signature is:<indexterm>
          <primary>Iterable object</primary>

          <secondary>map method</secondary>
        </indexterm><indexterm>
          <primary>functional programming</primary>

          <secondary>mapping operations</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">trait Iterable[+A] {
  ...
  def map[B](f : (A) =&gt; B) : Iterable[B] = ...
  ...
}</programlisting>

      <?dbfo-need height=”1in”
?>

      <para id="para_the_passed_in_function_can_tra">The passed-in function
      (<literal>f</literal>) can transform an original element of type
      <literal>A</literal> to a new type <literal>B</literal>. Here is an
      example:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/map-script.scala

val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Juneau",
  "Wyoming" -&gt; "Cheyenne")

val lengths = stateCapitals map { kv =&gt; (kv._1, kv._2.length) }
println(lengths)</programlisting>

      <para id="para_we_convert_the_pair_string_st">This script produces the
      output <literal>ArrayBuffer((Alabama,10), (Alaska,6),
      (Wyoming,8))</literal>. That is, we convert the
      <literal>Pair[String,String]</literal> elements to an
      <literal>ArrayBuffer</literal> of <literal>Pair[String,Int]</literal>
      elements. Where did the <literal>ArrayBuffer</literal> come from? It
      turns out that <literal>Iterable.map</literal> creates and returns an
      <literal>ArrayBuffer</literal> as the new <literal>Iterable</literal>
      collection.<indexterm>
          <primary>ArrayBuffer object</primary>
        </indexterm></para>

      <para id="para_this_brings_up_a_general_confl">This brings up a general
      conflict between immutable types and object-oriented type hierarchies.
      If a base type creates a new instance on modification, how does it know
      what kind of type to create?</para>

      <para id="para_you_could_solve_this_problem_t">You could solve this
      problem two ways. First, you could have each type in the hierarchy
      override methods like <literal>map</literal> to return an instance of
      their own type. This approach is error-prone, though, as it would be
      easy to forget to override all such methods when a new type is
      added.</para>

      <para id="para_even_if_you_always_remember_to">Even if you always
      remember to override each method, you have the dilemma of how to
      implement the override. Do you call the <literal>super</literal> method
      to reuse the algorithm, then iterate through the returned instance to
      create a new instance of the correct type? That would be inefficient.
      You could copy and paste the algorithm into each override, but that
      creates issues of code bloat, maintainability, and skew.</para>

      <para id="para_there_is_an_alternative_approa">There&#x2019;s an alternative
      approach: don&#x2019;t even try. How is the new instance that is returned
      actually used? Do we really care if it has the &#x201C;wrong&#x201D; type? Keep in
      mind that all we usually care about are the low-level abstractions like
      lists, maps, and sets. In the case of functional data structures, the
      derived types we might implement using <phrase role="keep-together">object-</phrase><phrase role="keep-together">oriented</phrase> inheritance are most often
      implementation optimizations. The Scala type hierarchy for containers
      does have a few levels of abstractions at the bottom, e.g., <literal role="keep-together">Collec&#x2060;tion</literal> extends
      <literal>Iterable</literal> extends <literal>AnyRef</literal>, but above
      <literal>Collection</literal> are <literal>Seq</literal> (parent of
      <literal>List</literal>), <literal>Map</literal>,
      <literal>Set</literal>, etc.</para>

      <para id="para_however_if_you_really_need_a_">That said, if you really
      need a <literal>Map</literal>, you can create one easily enough:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/map2-script.scala

val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Juneau",
  "Wyoming" -&gt; "Cheyenne")

val map2 = stateCapitals map { kv =&gt; (kv._1, kv._2.length) }

// val lengths = Map(map2)  // ERROR: won't work
val lengths = Map[String,Int]() ++ map2

println(lengths)</programlisting>

      <para id="para_the_line_that_is_commented_out">The commented-out line
      suggests that it would be nice if you could simply pass the new
      <literal>Iterable</literal> to <literal>Map.apply</literal>, but this
      doesn&#x2019;t work. Here is the signature of
      <literal>Map.apply</literal>:<indexterm>
          <primary>Map.apply method</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">object Map {
  ...
  def apply[A, B](elems : (A, B)*) : Map[A, B] = ...
  ...
}</programlisting>

      <para id="para_it_expects_a_variable_argument">It expects a variable
      argument list, not an <literal>Iterable</literal>. However, we can
      create an empty map of the right type and then add the new
      <literal>Iterable</literal> to it, using the <literal>++</literal>
      method, which returns a new <literal>Map</literal>.</para>

      <para id="para_so_we_get_the_map_the_want_">So, we can get the
      <literal>Map</literal> we want when we must have one. While it would be
      nice if methods like <literal>map</literal> returned the same collection
      type, we saw that there is no easy way to do this. Instead, we accept
      that <literal>map</literal> and similar methods return an abstraction
      like <literal>Iterable</literal> and then rely on the specific subtypes
      to take <literal>Iterables</literal> as input arguments for populating
      the collection.</para>

      <para id="para_a_related_map_operation_is_">A related
      <literal>Map</literal> operation is <literal>flatMap</literal>, which
      can be used to &#x201C;flatten&#x201D; a hierarchical data structure, remove &#x201C;empty&#x201D;
      elements, etc. Hence, unlike <literal>map</literal>, it may not return a
      new collection of the same size as the original collection:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/flatmap-script.scala

val graph = List(
  "a", List("b1", "b2", "b3"), List("c1", List("c21", Nil, "c22"), Nil, "e")
)

def flatten(list: List[_]): List[_] = list flatMap {
  case head :: tail =&gt; head :: flatten(tail)
  case Nil =&gt; Nil
  case x =&gt; List(x)
}

println(flatten(graph))</programlisting>

      <para id="para_this_script_reduces_the_hierar">This script reduces the
      hierarchical <literal>graph</literal> to <literal>List(a, b1, b2, b3,
      c1, c21, c22, e)</literal>. Notice that the <literal>Nil</literal>
      elements have been removed. We used <literal>List[_]</literal> because
      we won&#x2019;t know what the type parameters are for any embedded lists when
      we&#x2019;re traversing the outer list, due to <emphasis>type
      erasure</emphasis>.</para>

      <para id="para_here_is_the_signature_for_fla">Here is the signature for
      <literal>flatMap</literal>, along with <literal>map</literal>, for
      comparison:</para>

      <programlisting linenumbering="unnumbered">trait Iterable[+A] {
  ...
  def map[B]    (f : (A) =&gt; B) : Iterable[B] = ...
  def flatMap[B](f : (A) =&gt; Iterable[B]) : Iterable[B]
  ...
}</programlisting>

      <para id="para_each_pass_must_return_an_iter">Each pass must return an
      <literal>Iterable[B]</literal>, not a <literal>B</literal>. After going
      through the collection, <literal>flatMap</literal> will &#x201C;flatten&#x201D; all
      those <literal>Iterables</literal> into one collection. Note that
      <literal>flatMap</literal> won&#x2019;t flatten elements beyond one level. If
      our function literal leaves nested lists intact, they won&#x2019;t be flattened
      for us.</para>
    </sect2>

    <sect2 id="FunctionalFiltering">
      <title>Filtering</title>

      <para id="para_it_is_common_to_traverse_a_col">It is common to traverse
      a collection and extract a new collection from it with elements that
      match certain criteria:<indexterm>
          <primary>filtering</primary>

          <secondary>in functional programming</secondary>
        </indexterm><indexterm>
          <primary>functional programming</primary>

          <secondary>filtering operations</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/filter-script.scala

val stateCapitals = Map(
  "Alabama" -&gt; "Montgomery",
  "Alaska"  -&gt; "Juneau",
  "Wyoming" -&gt; "Cheyenne")

val map2 = stateCapitals filter { kv =&gt; kv._1 startsWith "A" }

println( map2 )</programlisting>

      <para id="para_there_are_several_different_ki">There are several
      different kinds of methods defined in <literal>Iterable</literal> for
      filtering or otherwise returning part of the original collection
      (comments adapted from the Scaladocs):<indexterm>
          <primary>Iterable object</primary>

          <secondary>filtering methods</secondary>
        </indexterm></para>

      <screen>trait Iterable[+A] {
  ...
  // Returns this iterable without its n first elements. If this iterable
  // has less than n elements, the empty iterable is returned.
  def drop (n : Int) : Collection[A] = ...

  // Returns the longest suffix of this iterable whose first element does
  // not satisfy the predicate p.
  def dropWhile (p : (A) =&gt; Boolean) : Collection[A] = ...

  // Apply a predicate p to all elements of this iterable object and
  // return true, iff there is at least one element for which p yields true.
  def exists (p : (A) =&gt; Boolean) : Boolean = ...

  // Returns all the elements of this iterable that satisfy the predicate p.
  // The order of the elements is preserved.
  def filter (p : (A) =&gt; Boolean) : Iterable[A] = ...

  // Find and return the first element of the iterable object satisfying a
  // predicate, if any.
  def find (p : (A) =&gt; Boolean) : Option[A] = ...

  // Returns index of the first element satisying a predicate, or -1.
  def findIndexOf (p : (A) =&gt; Boolean) : Int = ...

  // Apply a predicate p to all elements of this iterable object and return
  // true, iff the predicate yields true for all elements.
  def forall (p : (A) =&gt; Boolean) : Boolean = ...

  // Returns the index of the first occurence of the specified object in
  // this iterable object.
  def indexOf [B &gt;: A](elem : B) : Int = ...

  // Partitions this iterable in two iterables according to a predicate.
  def partition (p : (A) =&gt; Boolean) : (Iterable[A], Iterable[A]) = ...

  // Checks if the other iterable object contains the same elements.
  def sameElements [B &gt;: A](that : Iterable[B]) : Boolean = ...

  // Returns an iterable consisting only over the first n elements of this
  // iterable, or else the whole iterable, if it has less than n elements.
  def take (n : Int) : Collection[A] = ...

  // Returns the longest prefix of this iterable whose elements satisfy the
  // predicate p.
  def takeWhile (p : (A) =&gt; Boolean) : Iterable[A] = ...
}</screen>

      <para id="para_types_like_map_and_set_hav">Types like
      <literal>Map</literal> and <literal>Set</literal> have additional
      methods.</para>
    </sect2>

    <sect2 id="FunctionalFoldingAndReducing">
      <title>Folding and Reducing</title>

      <para id="para_we_ll_discuss_folding_and_redu">We&#x2019;ll discuss folding and
      reducing in the same section, as they&#x2019;re similar. Both are operations
      for &#x201C;shrinking&#x201D; a collection down to a smaller collection or a single
      value.<indexterm class="startofrange" id="ch08_reducing">
          <primary>reducing data structures</primary>
        </indexterm><indexterm class="startofrange" id="ch08_folding">
          <primary>folding data structures</primary>
        </indexterm><indexterm class="startofrange" id="ch08_functionalfoldreduce">
          <primary>functional programming</primary>

          <secondary>folding and reducing operations</secondary>
        </indexterm></para>

      <para id="para_folding_starts_with_an_initial">Folding starts with an
      initial &#x201C;seed&#x201D; value and processes each element in the context of that
      value. In contrast, reducing doesn&#x2019;t start with a user-supplied initial
      value. Rather, it uses the first element as the initial value:<indexterm>
          <primary>List object</primary>

          <secondary>folding</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/foldreduce-script.scala

List(1,2,3,4,5,6) reduceLeft(_ + _)

List(1,2,3,4,5,6).foldLeft(10)(_ * _)</programlisting>

      <para id="para_this_script_reduces_the_list_o">This script reduces the
      list of integers by adding them together, returning 21. It then folds
      the same list using multiplication with a seed of 10, returning
      7,200.</para>

      <para id="para_reducing_can_t_work_on_an_empt">Reducing can&#x2019;t work on an
      empty collection, since there would be nothing to return. In this case,
      an exception is thrown. Folding on an empty collection will simply
      return the seed value.</para>

      <para id="para_folding_also_offers_more_optio">Folding also offers more
      options for the final result. Here is a &#x201C;fold&#x201D; operation that is really
      a map operation:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/foldleft-map-script.scala

List(1, 2, 3, 4, 5, 6).foldLeft(List[String]()) {
  (list, x) =&gt; ("&lt;" + x + "&gt;") :: list
}.reverse</programlisting>

      <para id="para_it_returns_list_1_2_3_">It returns
      <literal>List(&lt;1&gt;, &lt;2&gt;, &lt;3&gt;, &lt;4&gt;, &lt;5&gt;,
      &lt;6&gt;)</literal>. Note that we had to call
      <literal>reverse</literal> on the result to get back a list in the same
      order as the input list.</para>

      <para id="para_here_are_the_signatures_for_th">Here are the signatures
      for the various fold and reduce operations in
      <literal>Iterable</literal>:<indexterm>
          <primary>Iterable object</primary>

          <secondary>fold and reduce methods</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">trait Iterable[+A] {
  ...
  // Combines the elements of this iterable object together using the
  // binary function op, from left to right, and starting with the value z.
  def foldLeft [B](z : B)(op : (B, A) =&gt; B) : B

  // Combines the elements of this list together using the binary function
  // op, from right to left, and starting with the value z.
  def foldRight [B](z : B)(op : (A, B) =&gt; B) : B

  // Similar to foldLeft but can be used as an operator with the order of
  // list and zero arguments reversed. That is, z /: xs is the same as
  // xs foldLeft z
  def /: [B](z : B)(op : (B, A) =&gt; B) : B

  // An alias for foldRight. That is, xs :\ z is the same as xs foldRight z
  def :\ [B](z : B)(op : (A, B) =&gt; B) : B

  // Combines the elements of this iterable object together using the
  // binary operator op, from left to right
  def reduceLeft [B &gt;: A](op : (B, A) =&gt; B) : B

  // Combines the elements of this iterable object together using the
  // binary operator op, from right to left
  def reduceRight [B &gt;: A](op : (A, B) =&gt; B) : B</programlisting>

      <para id="para_many_people_consider_the_opera">Many people consider the
      operator forms, <literal>:\</literal> for <literal>foldRight</literal>
      and <literal>/:</literal> for <literal>foldLeft</literal>, to be a
      little too obscure and hard to remember. Don&#x2019;t forget the importance of
      communicating with your readers when writing code.<indexterm>
          <primary>: (colon)</primary>

          <secondary>:\ (foldRight) and :/ (foldLeft)</secondary>
        </indexterm></para>

      <para id="para_why_are_their_left_and_right_f">Why are there left and
      right forms of fold and reduce? For the first examples we showed, adding
      and multiplying a list of integers, they would return the same result.
      Consider a <literal>foldRight</literal> version of our last example that
      used fold to map the integers to strings:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/foldright-map-script.scala

List(1, 2, 3, 4, 5, 6).foldRight(List[String]()) {
  (x, list) =&gt; ("&lt;" + x + "&gt;") :: list
}</programlisting>

      <para id="para_this_script_produces_list_1_">This script produces
      <literal>List(&lt;1&gt;, &lt;2&gt;, &lt;3&gt;, &lt;4&gt;, &lt;5&gt;,
      &lt;6&gt;)</literal>, without having to call <literal>reverse</literal>,
      as we did before. Note also that the arguments to the function literal
      are reversed compared to the arguments for <literal>foldLeft</literal>,
      as required by the definition of <literal role="keep-together">foldRight</literal>.</para>

      <para id="para_both_foldleft_and_reducelef">Both
      <literal>foldLeft</literal> and <literal>reduceLeft</literal> process
      the elements from left to right. Here is the <literal role="keep-together">foldLeft</literal> sequence for
      <literal>List(1,2,3,4,5,6).foldLeft(10)(_ * _)</literal>:</para>

      <screen>((((((10 * 1) * 2) * 3) * 4) * 5) * 6)
((((((10) * 2) * 3) * 4) * 5) * 6)
(((((20) * 3) * 4) * 5) * 6)
((((60) * 4) * 5) * 6)
(((240) * 5) * 6)
((1200) * 6)
(7200)</screen>

      <para id="para_here_is_the_foldright_sequen">Here is the
      <literal>foldRight</literal> sequence:</para>

      <screen>(1 * (2 * (3 * (4 * (5 * (6 * 10))))))
(1 * (2 * (3 * (4 * (5 * (60))))))
(1 * (2 * (3 * (4 * (300)))))
(1 * (2 * (3 * (1200))))
(1 * (2 * (3600)))
(1 * (7200))
(7200)</screen>

      <para id="para_it_turns_out_that_foldleft_a">It turns out that
      <literal>foldLeft</literal> and <literal>reduceLeft</literal> have one
      very important advantage over their &#x201C;right-handed&#x201D; brethren: they are
      tail-call recursive, and as such they can benefit from tail-call
      optimization.<indexterm>
          <primary>recursion</primary>

          <secondary>tail-call</secondary>

          <tertiary>foldLeft and reduceLeft</tertiary>
        </indexterm><indexterm>
          <primary>tail calls</primary>

          <secondary>foldLeft and reduceLeft operations</secondary>
        </indexterm></para>

      <para id="para_if_you_stare_at_the_previous_b">If you stare at the
      previous breakdowns for multiplying the integers, you can probably see
      why they are tail-call recursive. Recall that a tail call must be the
      last operation in an iteration. For each line in the
      <literal>foldRight</literal> sequence, the outermost multiplication
      can&#x2019;t be done until the innermost multiplications all complete, so the
      operation isn&#x2019;t tail recursive.</para>

      <para id="para_in_the_following_script_the_f">In the following script,
      the first line prints 1784293664, while the second line causes a stack
      overflow:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/reduceleftright-script.scala

println((1 to 1000000) reduceLeft(_ + _))
println((1 to 1000000) reduceRight(_ + _))</programlisting>

      <para id="para_so_why_have_both_kinds_of_recu">So why have both kinds of
      recursion? If you&#x2019;re not worried about overflow, a right recursion might
      be the most natural fit for the operation you are doing. Recall that
      when we used <literal>foldLeft</literal> to map integers to strings, we
      had to reverse the result. That was easy enough to do in that case, but
      in general, the result of a left recursion might not always be easy to
      convert to the right form.<indexterm class="endofrange" startref="ch08_reducing"/><indexterm class="endofrange" startref="ch08_folding"/><indexterm class="endofrange" startref="ch08_functionalfoldreduce"/></para>
    </sect2>

    <sect2 id="OptionsAndOtherContainers">
      <title>Functional Options</title>

      <para id="para_you_ll_find_the_functional_ope">You&#x2019;ll find the
      functional operations we&#x2019;ve explored throughout the Scala library, and
      not exclusively on collection classes. The always handy
      <literal>Option</literal> container supports <literal>filter</literal>,
      <literal>map</literal>, <literal>flatMap</literal>, and other
      functionally oriented methods that are applied only if the
      <literal>Option</literal> isn&#x2019;t empty (that is, if it&#x2019;s a
      <literal>Some</literal> and not a <literal>None</literal>).<indexterm>
          <primary>functional programming</primary>

          <secondary>Options object</secondary>
        </indexterm><indexterm>
          <primary>Option class</primary>

          <secondary>functional operations on</secondary>
        </indexterm></para>

      <para id="para_let_s_see_this_in_practice_">Let&#x2019;s see this in
      practice:</para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/datastructs/option-script.scala

val someNumber = Some(5)
val noneNumber = None

for (option &lt;- List(noneNumber, someNumber)) {
  option.map(n =&gt; println(n * 5))
}</programlisting>

      <para id="para_in_this_example_we_attempt_to">In this example, we
      attempt to multiply the contents of two <literal>Options</literal> by
      five. Normally, trying to multiply a <literal>null</literal> value would
      result in an error. But because the implementation of
      <literal>map</literal> on <literal>Option</literal> only applies the
      passed-in function when it&#x2019;s non-empty, we don&#x2019;t have to worry about
      testing for the presence of a value or handling an exception when we map
      over the <literal>None</literal>.</para>

      <para id="para_functional_operations_on_opti">Functional operations on
      <literal>Options</literal> save us from extra conditional expressions or
      pattern matching. Pattern matching, though, is a powerful tool within
      the context of functional programming, as we&#x2019;ll explore in the next
      section.</para>
    </sect2>
  </sect1>

  <sect1 id="_pattern_matching">
    <title>Pattern Matching</title>

    <para id="para_fp_pattern_matching">We&#x2019;ve seen many examples of pattern
    matching throughout this book. We got our first taste in <xref linkend="ATasteOfConcurrency"/>, where we used pattern matching in our
    Actor that drew geometric shapes. We discussed pattern matching in depth
    in <xref linkend="PatternMatching"/>.<indexterm>
        <primary>polymorphism</primary>

        <secondary>pattern matching versus</secondary>
      </indexterm><indexterm>
        <primary>functional programming</primary>

        <secondary>pattern matching</secondary>
      </indexterm><indexterm>
        <primary>pattern matching</primary>

        <secondary sortas="functional programming">in functional
        programming</secondary>
      </indexterm></para>

    <para id="para_pattern_matching_is_a_fundamen">Pattern matching is a
    fundamental tool in functional programming. It&#x2019;s just as important as
    polymorphism is in object-oriented programming, although the goals of the
    two techniques are very different.</para>

    <para id="para_pattern_matching_is_an_elegant">Pattern matching is an
    elegant way to decompose objects into their constituent parts for
    processing. On the face of it, pattern matching for this purpose seems to
    violate the goal of encapsulation that objects provide. Immutability,
    though, largely rectifies this conflict. The risk that the parts of an
    object might be changed outside of the control of the enclosing object is
    avoided.</para>

    <para id="para_for_example_if_we_have_a_per">For example, if we have a
    <literal>Person</literal> class that contains a list of addresses, we
    don&#x2019;t mind exposing that list to clients if the list is immutable. They
    can&#x2019;t unexpectedly change the list.</para>

    <para id="para_however_the_other_problem_wit">However, exposing
    constituent parts potentially couples clients to the
    <emphasis>types</emphasis> of those parts. We can&#x2019;t change how the parts
    are implemented without breaking the clients. A way to minimize this risk
    is to expose the lowest-level abstractions possible. When clients access a
    person&#x2019;s addresses, do they really need to know that they are stored in a
    <literal>List</literal>, or is it sufficient to know that they are stored
    in an <literal>Iterable</literal> or <literal>Seq</literal>? If so, then
    we can change the implementation of the addresses as long as they still
    support those abstractions. Of course, we&#x2019;ve known for a long time in
    object-oriented programming that you should only couple to abstractions,
    not concrete details (for example, see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>).</para>

    <?dbfo-need height=”1in”
?>

    <para id="para_functional_pattern_matching_an">Functional pattern matching
    and object-oriented polymorphism are powerful <phrase role="keep-together">complements</phrase> to each other. We saw this in
    the Actor example in <xref linkend="ATasteOfConcurrency"/>, where we
    matched on the <literal>Shape</literal> abstraction, but called the
    polymorphic <literal>draw</literal> operation.</para>
  </sect1>

  <sect1 id="PartialFunctions">
    <title>Partial Functions</title>

    <para id="para_you_ve_seen__partially_applied">You&#x2019;ve seen
    <emphasis>partially applied</emphasis> functions, or partial functions,
    throughout this book. When you&#x2019;ve seen an underscore passed to a method,
    you&#x2019;ve probably seen partial application at work.<indexterm>
        <primary>partial functions</primary>
      </indexterm><indexterm>
        <primary>functional programming</primary>

        <secondary>partial functions</secondary>
      </indexterm></para>

    <para id="para_partial_functions_are_expressi">Partial functions are
    expressions in which not all of the arguments defined in a function are
    supplied as parameters to the function. In Scala, partial functions are
    used to bundle up a function, including its parameters and return type,
    and assign that function to a variable or pass it as an argument to
    another function.</para>

    <para id="para_this_is_a_bit_confusing_until_">This is a bit confusing
    until we see it in practice:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/partial/partial-script.scala

def concatUpper(s1: String, s2: String): String = (s1 + " " + s2).toUpperCase

val c = concatUpper _
println(c("short", "pants"))

val c2 = concatUpper("short", _: String)
println(c2("pants"))</programlisting>

    <para id="para_calling_concatupper_with_an_">Calling
    <literal>concatUpper</literal> with an underscore (&#x2009;<literal>_</literal>&#x2009;)
    turns the method into a function value. <phrase role="keep-together">In
    the first part</phrase> of the example, we&#x2019;ve assigned a partially applied
    version of <literal role="keep-together">concatUp&#x2060;per</literal> to the
    value <literal>c</literal>. We then <emphasis>apply</emphasis> it,
    implicitly calling the <literal>apply</literal> method on
    <literal>c</literal> by passing parameters to it directly. The returned
    value is then printed.</para>

    <para id="para_in_the_second_part_we_ve_spec">In the second part, we&#x2019;ve
    specified the first parameter to <literal>concatUpper</literal> but not
    the second, although we have specified the type of the second parameter.
    We&#x2019;ve assigned this variant to a second value, <literal>c2</literal>. To
    produce the same output as we saw before, we need only pass in a single
    value when we apply <literal>c2</literal>. We&#x2019;ve applied part of the
    function in the assignment to <literal>c2</literal>, and we &#x201C;fill in the
    blanks&#x201D; when we call <literal>c2</literal> on the next line.</para>

    <para id="para_we_ve_seen_partially_applied_f">We&#x2019;ve seen partially
    applied functions without the underscore syntax as well:</para>

    <programlisting linenumbering="unnumbered">List("short", "pants").map(println)</programlisting>

    <para id="para_in_this_example_println_is_">In this example,
    <literal>println</literal> is the partially applied function. It&#x2019;s applied
    when invoked by mapping over each element in the list. Because the map
    operation expects a function as an argument, we don&#x2019;t need to write
    <literal>map(println _)</literal>. The trailing underscore that turns
    <literal>println</literal> into a function value is implied, in this
    context.<indexterm>
        <primary>println function</primary>

        <secondary>partially applied (example)</secondary>
      </indexterm></para>

    <para id="para_another_way_of_thinking_of_par">Another way of thinking of
    partial functions is as functions that will inform you when you supply
    them with parameters that are out of their domain. Every partial function
    is, as you might guess, of the type <literal>PartialFunction</literal>.
    This trait defines a method <literal>orElse</literal> that takes another
    <literal>PartialFunction</literal>. Should the first partial function not
    apply, the second will be invoked.</para>

    <para id="para_again_this_is_easier_understo">Again, this is easier
    understood in practice:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/partial/orelse-script.scala

val truthier: PartialFunction[Boolean, String] = { case true =&gt; "truthful" }
val fallback: PartialFunction[Boolean, String] = { case x =&gt; "sketchy" }
val tester = truthier orElse fallback

println(tester(1 == 1))
println(tester(2 + 2 == 5))</programlisting>

    <para id="para_in_this_example_tester_is_a">In this example,
    <literal>tester</literal> is a partial function composed of two other
    partial functions, <literal>truthier</literal> and
    <literal>fallback</literal>. In the first <literal>println</literal>
    statement, <literal>truthier</literal> is executed because the partial
    function&#x2019;s internal case matches. In the second,
    <literal>fallback</literal> is executed because the value of the
    expression is outside of the domain of <literal>truthier</literal>.</para>

    <para id="para_the_case_statements_we_ve_se">The <literal>case</literal>
    statements we&#x2019;ve seen through our exploration of Scala are expanded
    internally to partially applied functions. The functions provide the
    abstract method <literal role="keep-together">isDefinedAt</literal>, a
    feature of the <literal>PartialFunction</literal> trait used to specify
    the boundaries of a partial function&#x2019;s domain:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/partial/isdefinedat-script.scala

val pantsTest: PartialFunction[String, String] = {
  case "pants" =&gt; "yes, we have pants!"
}

println(pantsTest.isDefinedAt("pants"))
println(pantsTest.isDefinedAt("skort"))</programlisting>

    <para id="para_here_our_partial_function_is_">Here, our partial function
    is a test for the string <literal>"pants"</literal>. When we inquire as to
    whether the string <literal>"pants"</literal> is defined for this
    function, the result is <literal>true</literal>. But for the string
    <literal>"skort"</literal>, the result is <literal>false</literal>. Were
    we defining our own partial function, we could provide an implementation
    of <literal>isDefinedAt</literal> that performs any arbitrary test for the
    boundaries of our function.</para>
  </sect1>

  <sect1 id="Currying">
    <title>Currying</title>

    <para id="para_just_as_you_encountered_partia">Just as you encountered
    partially applied functions before we defined them, you&#x2019;ve also seen
    <emphasis>curried</emphasis> functions. Named after mathematician Haskell
    Curry (from whom the Haskell language also get its name), currying
    transforms a function that takes multiple parameters into a chain of
    functions, each taking a single parameter.<indexterm>
        <primary>functional programming</primary>

        <secondary>currying</secondary>
      </indexterm><indexterm>
        <primary>curried functions</primary>
      </indexterm></para>

    <para id="para_in_scala_curried_functions_ar">In Scala, curried functions
    are defined with multiple parameter lists, as follows:</para>

    <programlisting linenumbering="unnumbered">def cat(s1: String)(s2: String) = s1 + s2</programlisting>

    <para id="para_of_course_we_could_define_mor">Of course, we could define
    more than two parameters on a curried function, if we like.</para>

    <para id="para_you_also_use_the_syntax_below_">We can also use the
    following syntax to define a curried function:</para>

    <programlisting linenumbering="unnumbered">def cat(s1: String) = (s2: String) =&gt; s1 + s2</programlisting>

    <para>While the previous syntax is more readable, in our estimation, using
    this syntax eliminates the requirement of a trailing underscore when
    treating the curried function as a partially applied function.</para>

    <para id="para_calling_our_curried_string_con">Calling our curried string
    concatenation function looks like this in the Scala REPL:</para>

    <screen>scala&gt; cat("foo")("bar")
res1: java.lang.String = foobar</screen>

    <para id="para_we_can_also_convert_methods_th">We can also convert methods
    that take multiple parameters into a curried form with the
    <literal>Function.curried</literal> method:<indexterm>
        <primary>Function.curried method</primary>
      </indexterm></para>

    <screen>scala&gt; def cat(s1: String, s2: String) = s1 + s2
cat: (String,String)java.lang.String

scala&gt; val curryCat = Function.curried(cat _)
curryCat: (String) =&gt; (String) =&gt; java.lang.String = &lt;function&gt;

scala&gt; cat("foo", "bar") == curryCat("foo")("bar")
res2: Boolean = true</screen>

    <para id="para_in_this_example_we_transform_">In this example, we
    transform a function that takes two arguments, <literal>cat</literal>,
    into its curried equivalent that takes multiple parameter lists. If
    <literal>cat</literal> had taken three parameters, its curried equivalent
    would take three lists of arguments, and so on. The two forms are
    functionally equivalent, as demonstrated by the equality test, but
    <literal>curryCat</literal> can now be used as the basis of a partially
    applied function as well:</para>

    <screen>scala&gt; val partialCurryCat = curryCat("foo")(_)
partialCurryCat: (String) =&gt; java.lang.String = &lt;function&gt;

scala&gt; partialCurryCat("bar")
res3: java.lang.String = foobar</screen>

    <para id="para_in_practice_the_primary_use_f">In practice, the primary use
    for currying is to specialize functions for particular types of data. You
    can start with an extremely general case, and use the curried form of a
    function to narrow down to particular cases.</para>

    <para id="para_as_a_simple_example_of_this_ap">As a simple example of this
    approach, the following code provides specialized forms of a base function
    that handles multiplication:</para>

    <programlisting linenumbering="unnumbered">def multiplier(i: Int)(factor: Int) = i * factor
val byFive = multiplier(5) _
val byTen = multiplier(10) _</programlisting>

    <para id="para_we_start_with_multiplier_wh">We start with
    <literal>multiplier</literal>, which takes two parameters: an integer, and
    another integer to multiply the first one by. We then curry two special
    cases of <literal>multiplier</literal> into function values. Note the
    trailing underscores, which indicate to the compiler that the preceding
    expression is to be curried. In particular, the wildcard underscores
    indicate that the remaining arguments (in this example, one argument) are
    unspecified.</para>

    <?dbfo-need height=”1in”
?>

    <para id="para_in_the_scala_console_we_get_p">In the Scala console, we get
    predictable output when calling our curried functions:</para>

    <screen>scala&gt; byFive(2)
res4: Int = 10

scala&gt; byTen(2)
res5: Int = 20</screen>

    <para id="para_we_ll_revisit_the_curry_meth">We&#x2019;ll revisit the
    <literal>curry</literal> method in <xref linkend="FunctionTypes"/>.</para>

    <para id="para_as_you_can_see_currying_and_p">As you can see, currying and
    partially applied functions are closely related concepts. You may see them
    referred to almost interchangeably, but what&#x2019;s important is their
    application (no pun intended).</para>
  </sect1>

  <sect1 id="Implicits">
    <title>Implicits</title>

    <para id="para_there_are_times_when_you_have_">There are times when you
    have an instance of one type and you need to use it in a context where a
    different, but perhaps a similar type is required. For the &#x201C;one-off&#x201D; case,
    you might create an instance of the required type using the state of the
    instance you already have. However, for the general case, if there are
    many such occurrences in the code, you would rather have an automated
    conversion mechanism.</para>

    <para id="para_a_similar_problem_occurs_when_">A similar problem occurs
    when you call one or more functions repeatedly and have to pass the same
    value to all the invocations. You might like a way of specifying a default
    value for that parameter, so it is not necessary to specify it explicitly
    all the time.<indexterm>
        <primary>implicit keyword</primary>
      </indexterm></para>

    <para id="para_the_scala_keyword_implicit_c">The Scala keyword
    <literal>implicit</literal> can be used to support both needs.<indexterm>
        <primary>implicit conversions</primary>

        <secondary sortas="functional programming">in functional
        programming</secondary>
      </indexterm><indexterm>
        <primary>functional programming</primary>

        <secondary>implicit conversions</secondary>
      </indexterm></para>

    <sect2 id="ImplicitConversions">
      <title>Implicit Conversions</title>

      <para id="para_consider_the_following_code_fr">Consider the following
      code fragment:</para>

      <programlisting linenumbering="unnumbered">val name: String = "scala"
println(name.capitalize.reverse)</programlisting>

      <para id="para_it_prints_the_following_">It prints the following:</para>

      <screen>alacS</screen>

      <para id="para_how_work_capitalize_string">We saw in <xref linkend="PredefObject"/> that <literal>Predef</literal> defines the
      <literal>String</literal> type to be
      <literal>java.lang.String</literal>, yet the methods
      <literal>capitalize</literal> and <literal>reverse</literal> aren&#x2019;t
      defined on <literal>java.lang.String</literal>. How did this code
      work?<indexterm>
          <primary>java.lang.String class</primary>
        </indexterm><indexterm>
          <primary>String class</primary>
        </indexterm></para>

      <para id="para_the_scala_library_defines_a_">The Scala library defines a
      &#x201C;wrapper&#x201D; class called <literal>scala.runtime.RichString</literal> that
      has these methods, and the compiler converted the
      <literal>name</literal> string to it implicitly using a special method
      defined in <literal>Predef</literal> called
      <literal>stringWrapper</literal>:<indexterm>
          <primary>wrapper classes in Scala</primary>
        </indexterm><indexterm>
          <primary>RichString class</primary>
        </indexterm><indexterm>
          <primary>Predef object</primary>

          <secondary>stringWrapper method</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">implicit def stringWrapper(x: String) = new runtime.RichString(x)</programlisting>

      <para id="para_the_implicit_keyword_tells_t">The
      <literal>implicit</literal> keyword tells the compiler it can use this
      method for an &#x201C;implicit&#x201D; conversion from a <literal>String</literal> to
      a <literal>RichString</literal>, whenever the latter is required. The
      compiler detected an attempt to call a <literal>capitalize</literal>
      method, and it determined that <literal>RichString</literal> <phrase role="keep-together">has such</phrase> a method. Then it looked within
      the current scope for an <literal>implicit</literal> method that
      converts <literal>String</literal> to <literal>RichString</literal>,
      finding <literal>stringWrapper</literal>.<indexterm>
          <primary>String class</primary>

          <secondary>implicit conversion to RichString</secondary>
        </indexterm></para>

      <para id="para_as_we_ll_see_in_viewsandview">As we&#x2019;ll see in <xref linkend="ViewsAndViewBounds"/>, these conversion methods are sometimes
      called <emphasis>views</emphasis>, in the sense that our
      <literal>stringWrapper</literal> conversion provides a view from
      <literal>String</literal> to <literal>RichString</literal>.<indexterm>
          <primary>views</primary>
        </indexterm></para>

      <para id="para__predef_defines_many_other_im"><literal>Predef</literal>
      defines many other implicit conversion methods, most of which follow the
      naming convention <literal>old2New</literal>, where
      <literal>old</literal> is the type of object available and
      <literal>New</literal> is the desired type. However, there is no
      restriction on the names of conversion methods. There are also a number
      of other <literal>Rich</literal> wrapper classes defined in the
      <literal>scala.run&#x2060;time</literal> package.<indexterm>
          <primary>wrapper classes in Scala</primary>

          <secondary>Rich wrapper classes defined in scala.runtime
          package</secondary>
        </indexterm></para>

      <para id="para_here_is_a_summary_of_the_looku">Here is a summary of the
      lookup rules used by the compiler to find and apply conversion methods.
      For more details, see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>:<indexterm>
          <primary>companion objects</primary>

          <secondary>conversion methods defined in</secondary>
        </indexterm><indexterm>
          <primary>implicit conversions</primary>

          <secondary>rules for compiler to find and use conversion
          methods</secondary>
        </indexterm></para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>No conversion will be attempted if the object and method
          combination type check successfully.</para>
        </listitem>

        <listitem>
          <para>Only methods with the <literal>implicit</literal> keyword are
          considered.</para>
        </listitem>

        <listitem>
          <para>Only implicit methods in the current scope are considered, as
          well as implicit methods defined in the <emphasis>companion
          object</emphasis> of the <emphasis>target</emphasis> type.</para>
        </listitem>

        <listitem>
          <para>Implicit methods aren&#x2019;t chained to get from the available
          type, through intermediate types, to the <literal>target</literal>
          type. Only a method that takes a single available type instance and
          returns a target type instance will be considered.</para>
        </listitem>

        <listitem>
          <para>No conversion is attempted if more than one possible
          conversion method could be applied. There must be one and only one
          possibility.</para>
        </listitem>
      </orderedlist>

      <para id="para_what_if_can_t_define_a_convers">What if you can&#x2019;t define
      a conversion method in a companion object, to satisfy the third rule,
      perhaps because you can&#x2019;t modify or create the companion object? In this
      case, define the method somewhere else and import it. Normally, you will
      define an <literal>object</literal> with just the conversion method(s)
      needed. Here is an example:<indexterm>
          <primary>implicit conversions</primary>

          <secondary>defining custom object and conversion method</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/FP/implicits/implicit-conversion-script.scala
import scala.runtime.RichString

class FancyString(val str: String)

object FancyString2RichString {
    implicit def fancyString2RichString(fs: FancyString) =
        new RichString(fs.str)
}

import FancyString2RichString._

val fs = new FancyString("scala")
println(fs.capitalize.reverse)</programlisting>

      <?dbfo-need height=”1in”
?>

      <para id="para_we_can_t_modify_richstring_o">We can&#x2019;t modify
      <literal>RichString</literal> or <literal>Predef</literal> to add an
      implicit conversion method for our custom <literal>FancyString</literal>
      class. Instead, we define an <literal>object</literal> named
      <literal>FancyString2RichString</literal> and define the conversion
      method in it. We then import the contents of this object and the
      converter gets invoked implicitly in the last line. The output of this
      script is the following:</para>

      <screen>alacS</screen>

      <para id="para_pimp_my_library">This pattern for effectively adding new
      methods to classes has been called <emphasis>Pimp My Library</emphasis>
      (see <link linkend="Odersky2006" xrefstyle="select:nopage">[Odersky2006]</link>).<indexterm>
          <primary>Pimp My Library design pattern</primary>
        </indexterm><indexterm>
          <primary>methods</primary>

          <secondary>adding new methods to classes</secondary>
        </indexterm><indexterm>
          <primary>classes</primary>

          <secondary>adding new methods to</secondary>
        </indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="ImplicitFunctionParameters">
    <title>Implicit Function Parameters</title>

    <para id="para_one_possible_mechanism_is_to_u">We saw in <xref linkend="TypeLessDoMore"/> that Scala version 2.8 adds support for
    default argument values, like you find in other languages like Ruby and
    C++. There are two other ways to achieve the same effect in all versions
    of Scala. The first is to use function currying, as we have seen. The
    second way is to define <emphasis>implicit</emphasis> values, using the
    <literal>implicit</literal> keyword.<indexterm>
        <primary>parameters</primary>

        <secondary>implicit function parameters</secondary>
      </indexterm><indexterm>
        <primary>implicit function parameters</primary>
      </indexterm><indexterm>
        <primary>functional programming</primary>

        <secondary>implicit function parameters</secondary>
      </indexterm></para>

    <para id="para_let_s_examine_how_implicit_val">Let&#x2019;s examine how implicit
    values work:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/implicits/implicit-parameter-script.scala
import scala.runtime.RichString

def multiplier(i: Int)(implicit factor: Int) {
  println(i * factor)
}

implicit val factor = 2

multiplier(2)
multiplier(2)(3)</programlisting>

    <para id="para_our_multiplier_takes_two_lists">Our multiplier takes two
    lists of parameters. The latter includes an integer value, <literal role="keep-together">factor</literal>, marked <literal>implicit</literal>.
    This keyword informs the compiler to seek the value for <literal role="keep-together">factor</literal> from the surrounding scope, if
    available, or to use whatever parameter has been explicitly supplied to
    the function.</para>

    <para id="para_we_ve_defined_our_own_factor_">We&#x2019;ve defined our own
    <literal>factor</literal> value in scope, and that value is used in the
    first call to <literal>multiplier</literal>. In the second call, we&#x2019;re
    explicitly passing in a value for <literal>factor</literal> and it
    overrides the value in the surrounding scope.</para>

    <para id="para_essentially_implicit_function">Essentially, implicit
    function parameters behave as parameters with a default value, with the
    key difference being that the value comes from the surrounding scope. Had
    our <literal>factor</literal> value resided in a class or object, we would
    have had to import it into the local scope. If the compiler can&#x2019;t
    determine the value to use for an implicit parameter, an error of &#x201C;no
    implicit argument matching parameter&#x201D; will occur.</para>

    <sect2 id="FinalThoughtsOnImplicits">
      <title>Final Thoughts on Implicits</title>

      <para id="para_implicits_can_be_perilously_cl">Implicits can be
      perilously close to &#x201C;magic.&#x201D; When used excessively, they obfuscate the
      code&#x2019;s behavior for the reader. Also, be careful about the
      implementation of a conversion method, especially if the return type is
      not explicitly declared. If a future change to the method also changes
      the return type in some subtle way, the conversion may suddenly fail to
      work. In general, implicits can cause mysterious behavior that is hard
      to debug!<indexterm>
          <primary>functional programming</primary>

          <secondary>implicits, caution with</secondary>
        </indexterm><indexterm>
          <primary>implicit function parameters</primary>

          <secondary>caution with</secondary>
        </indexterm><indexterm>
          <primary>implicit conversions</primary>

          <secondary>caution with</secondary>
        </indexterm></para>

      <para id="para_the_advantage_of_this_approach">When deciding how to
      implement &#x201C;default&#x201D; values for method arguments, a major advantage of
      using default argument values (in Scala version 2.8) is that the method
      maintainer decides what to use as the default value. The implementation
      is more straightforward and you avoid the &#x201C;magic&#x201D; of implicit methods.
      However, a disadvantage of using default argument values is that it
      might be desirable to use a different &#x201C;default&#x201D; value based on the
      context in which the method is being called. Scala version 2.8 provides
      some flexibility, as you can use an expression for an argument, not just
      a constant value. However, that flexibility might not be enough, in
      which case implicits are a very flexible and powerful
      alternative.</para>

      <tip id="para_tip_use_implicits_sparingly_a">
        <para>Use implicits sparingly and cautiously. Also, consider adding an
        explicit return type to &#x201C;non-trivial&#x201D; conversion methods.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="_call_by_name_call_by_value">
    <title>Call by Name, Call by Value</title>

    <para id="para_typically_parameters_to_funct">Typically, parameters to
    functions are <emphasis>by-value</emphasis> parameters; that is, the value
    of the parameter is determined before it is passed to the function. In
    most circumstances, this is the behavior we want and expect.<indexterm>
        <primary>by-value parameters</primary>
      </indexterm><indexterm>
        <primary>functional programming</primary>

        <secondary>call by name and call by value</secondary>
      </indexterm></para>

    <para id="para_but_what_if_we_need_to_write_a">But what if we need to
    write a function that accepts as a parameter an expression that we don&#x2019;t
    want evaluated until it&#x2019;s called within our function? For this
    circumstance, Scala offers <emphasis>by-name</emphasis> parameters.</para>

    <para id="para_a_by_name_parameter_is_specifi">A by-name parameter is
    specified by omitting the parentheses that normally accompany a function
    parameter, as follows:<indexterm>
        <primary>( ) (parentheses)</primary>

        <secondary>omitting for by-name function parameter</secondary>
      </indexterm><indexterm>
        <primary>by-name parameters</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">def myCallByNameFunction(callByNameParameter: =&gt; ReturnType)</programlisting>

    <para id="para_without_this_syntactic_shortcu">Without this syntactic
    shortcut, this method definition would look like the following:</para>

    <programlisting linenumbering="unnumbered">def myCallByNameFunction(callByNameParameter: () =&gt; ReturnType)</programlisting>

    <para id="para_and_what_s_more_we_d_have_to_">And what&#x2019;s more, we would
    have to include those unsightly, empty parentheses in every call to that
    method. Use of by-name parameters removes that requirement.<indexterm>
        <primary>while loops</primary>

        <secondary>implementing using by-name parameters and
        currying</secondary>
      </indexterm></para>

    <para id="para_we_can_use_by_name_parameters_">We can use by-name
    parameters to implement powerful looping constructs, among other things.
    Let&#x2019;s go crazy and implement our own <literal>while</literal> loop,
    throwing currying into the mix:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/overrides/call-by-name-script.scala

def whileAwesome(conditional: =&gt; Boolean)(f: =&gt; Unit) {
  if (conditional) {
    f
    whileAwesome(conditional)(f)
  }
}

var count = 0

whileAwesome(count &lt; 5) {
  println("still awesome")
  count += 1
}</programlisting>

    <para id="para_what_would_happen_if_we_remove">What would happen if we
    removed the arrow between <literal>conditional:</literal> and
    <literal>Boolean</literal>? The expression <literal>count &lt; 5</literal>
    would be evaluated to <literal>true</literal> before being passed into our
    custom <literal>while</literal> loop, and the message &#x201C;still awesome&#x201D;
    would be printed to the console indefinitely. By delaying evaluation until
    <literal>conditional</literal> is called inside our function with a
    by-name parameter, we get the behavior we expect.</para>
  </sect1>

  <sect1 id="LazyVals">
    <title>Lazy Vals</title>

    <para id="para_in_overridingfieldsintraits_">In <xref linkend="OverridingFieldsInTraits"/>, we showed several scenarios where
    the order of initialization for fields in override scenarios can be
    problematic. We discussed one solution, <emphasis>pre-initialized
    fields</emphasis>. Now we discuss the other solution we mentioned
    previously, <literal>lazy val</literal>s.<indexterm>
        <primary>fields</primary>

        <secondary>order of initialization, using lazy vals</secondary>
      </indexterm><indexterm>
        <primary>vals, lazy</primary>

        <see>lazy values</see>
      </indexterm><indexterm>
        <primary>functional programming</primary>

        <secondary>lazy vals</secondary>
      </indexterm><indexterm>
        <primary>lazy values</primary>
      </indexterm></para>

    <para id="para_here_is_ui3_vetoable_clicks_">Here is that example
    rewritten with a <literal>lazy val</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/FP/overrides/trait-lazy-init-val-script.scala

trait AbstractT2 {
  println("In AbstractT2:")
  val value: Int
  lazy val inverse = { println("initializing inverse:"); 1.0/value }
  //println("AbstractT2: value = "+value+", inverse = "+inverse)
}

val c2d = new AbstractT2 {
  println("In c2d:")
  val value = 10
}

println("Using c2d:")
println("c2d.value = "+c2d.value+", inverse = "+c2d.inverse)</programlisting>

    <para id="para_the_is_the_output_of_the_scrip">The is the output of the
    script:</para>

    <screen>In AbstractT2:
In c2d:
Using c2d:
initializing inverse:
c2d.value = 10, inverse = 0.1</screen>

    <para id="para_as_before_we_are_using_an_ano">As before, we are using an
    anonymous inner class that implicitly extends the trait. The body of the
    class, which initializes <literal>value</literal>, is evaluated
    <emphasis>after</emphasis> the trait&#x2019;s body. However, note that
    <literal>inverse</literal> is declared <literal>lazy</literal>, which
    means that the righthand side will be evaluated only when
    <literal>inverse</literal> is actually <emphasis>used</emphasis>. In this
    case, that happens in the last <literal>println</literal> statement. Only
    then is <literal>inverse</literal> initialized, using
    <literal>value</literal>, which is properly initialized at this
    point.</para>

    <para id="para_try_uncommenting_the_println_">Try uncommenting the
    <literal>println</literal> statement at the end of the
    <literal>AbstractT2</literal> body. What happens now?</para>

    <screen>In AbstractT2:
initializing inverse:
AbstractT2: value = 0, inverse = Infinity
In c2d:
Using c2d:
c2d.value = 10, inverse = Infinity</screen>

    <para id="para_this_println_forces_inverse">This
    <literal>println</literal> forces <literal>inverse</literal> to be
    evaluated inside the body of <literal>AbstractT2</literal>, before
    <literal>value</literal> is initialized by the class body, thereby
    reproducing the problem we had before.</para>

    <para id="para_this_example_raises_an_importa">This example raises an
    important point; if other <literal>val</literal>s use the <literal>lazy
    val</literal> in the same class or trait body, they should be declared
    <literal>lazy</literal>, too. Also, watch out for function calls in the
    body that use the <literal>lazy val</literal>.</para>

    <tip id="para_tip_if_a_val_is_lazy_mak">
      <para>If a <literal>val</literal> is <literal>lazy</literal>, make sure
      all uses of the <literal>val</literal> are also
      <literal>lazy</literal>!</para>
    </tip>

    <para id="para_so_how_is_a_lazy_val_differ">So, how is a <literal>lazy
    val</literal> different from a method call? In a method call, the body is
    executed <emphasis>every</emphasis> time the method is invoked. For a
    <literal>lazy val</literal>, the initialization &#x201C;body&#x201D; is evaluated only
    once, when the variable is used for the first time. This one-time
    evaluation makes little sense for a mutable field. Therefore, the
    <literal>lazy</literal> keyword is not allowed on <literal>var</literal>s.
    (They can&#x2019;t really make use of it anyway.)</para>

    <para id="para_use_lazy_val_s_for_costly_co">You can also use
    <literal>lazy val</literal>s to avoid costly initializations that you may
    not actually need and to defer initializations that slow down application
    startup. They work well in constructors, where it&#x2019;s clear to other
    programmers that all the one-time heavy lifting for initializing an
    instance is done in one place.<indexterm>
        <primary>infinite data structures</primary>

        <secondary>using lazy vals to manage</secondary>
      </indexterm></para>

    <para id="para_another_use_for_laziness_i">Another use for laziness is to
    manage potentially infinite data structures where only a manageable subset
    of the data will actually be used. In fact, mathematic notation is
    inherently lazy. When we write the Fibonacci sequence, for example, we
    might write it as an infinite sequence, something like this:</para>

    <screen>Fib = 1, 1, 2, 3, 5, 8, ...</screen>

    <para id="para_some_pure_functional_languages">Some pure functional
    languages are lazy by default, so they mimic this behavior as closely as
    possible. This can work without exhausting resources if the user never
    tries to use more than a finite subset of these values. Scala is not lazy
    by default, but it does offer support for working with infinite data
    structures. We&#x2019;ll address this topic in <xref linkend="InfiniteDataStructuresAndLaziness"/>.</para>
  </sect1>

  <sect1 id="FunctionalComponentAbstractions">
    <title>Recap: Functional Component Abstractions</title>

    <para id="para_when_object_oriented_programmi">When object-oriented
    programming went mainstream in the late &#x2019;80s and early &#x2019;90s, there was
    great hope that it would usher in an era of reusable software components.
    It didn&#x2019;t really work out that way, except in some rare cases, like the
    windowing APIs of various platforms.<indexterm>
        <primary>functional programming</primary>

        <secondary>component model and</secondary>
      </indexterm><indexterm>
        <primary>component model, functional programming and</primary>
      </indexterm><indexterm>
        <primary>object-oriented programming (OOP)</primary>

        <secondary>reusable software components and</secondary>
      </indexterm></para>

    <para id="para_why_did_this_not_happen_there">Why did this not happen?
    There are certainly many reasons, but a likely source is the fact that
    simple source or binary interoperability protocols never materialized that
    would glue these components together. The richness of object APIs was the
    very factor that undermined componentization.</para>

    <para id="para_component_models_that_have_suc">Component models that have
    succeeded are all based on very simple foundations. Integrated circuits
    (ICs) in electronics plug into buses with 2<superscript>n</superscript>
    signaling wires that are boolean, either on or off. From that very simple
    protocol, the most explosive growth of any industry in human history was
    born.</para>

    <para id="para_http_is_another_good_example_">HTTP is another good
    example. With a handful of message types and a very simple standard for
    message content, it set the stage for the Internet revolution. RESTful web
    services built on top of HTTP are also proving successful as components,
    but they are just complex enough that care is required to ensure that they
    work successfully.</para>

    <para id="para_so_is_there_hope_for_a_binary">So, is there hope for a
    binary or source-level component model? It probably won&#x2019;t be
    object-oriented, as we&#x2019;ve seen. Rather, it could be more
    functional.</para>

    <para id="para_components_should_interoperate">Components should
    interoperate by exchanging a few immutable data structures, e.g., lists
    and maps, that carry both data and &#x201C;commands.&#x201D; Such a component model
    would have the simplicity necessary for success and the richness required
    to perform real work. Notice how that sounds a lot like HTTP and
    REST.</para>

    <para id="para_in_fact_the_actor_model_has_m">In fact, the Actor model has
    many of these qualities, as we&#x2019;ll explore in the next chapter.<indexterm class="endofrange" startref="ch08_functional"/></para>
  </sect1>
</chapter>
  <chapter id="Concurrency">
  <title>Robust, Scalable Concurrency <phrase role="keep-together">with
  Actors</phrase></title>

  <sect1 id="ProblemsOfSharedSynchronizedState">
    <title>The Problems of Shared, Synchronized State</title>

    <para id="para_concurrency_isn_t_easy_as_a_p">Concurrency isn&#x2019;t easy.
    Getting a program to do more than one thing at a time has traditionally
    meant hassling with mutexes, race conditions, lock contention, and the
    rest of the unpleasant baggage that comes along with multithreading.
    Event-based concurrency models alleviate some of these concerns, but can
    turn large programs into a rat&#x2019;s nest of callback functions. No wonder,
    then, that concurrent programming is a task most programmers dread, or
    avoid altogether by retreating to multiple independent processes that
    share data externally (for example, through a database or message
    queue).<indexterm>
        <primary>concurrency</primary>

        <secondary>problems of shared, synchronized state</secondary>
      </indexterm></para>

    <para id="para_a_large_part_of_the_difficulty">A large part of the
    difficulty of concurrent programming comes down to state: how do you know
    what your multithreaded program is doing, and when? What value does a
    particular variable hold when you have 2 threads running, or 5, or 50? How
    can you guarantee that your program&#x2019;s many tendrils aren&#x2019;t clobbering one
    another in a race to take action? A thread-based concurrency paradigm
    poses more questions than it <phrase role="keep-together">answers</phrase>.</para>

    <para id="para_thankfully_scala_offers_a_rea">Thankfully, Scala offers a
    reasonable, flexible approach to concurrency that we&#x2019;ll <phrase role="keep-together">explore</phrase> in this chapter.</para>
  </sect1>

  <sect1 id="_actors">
    <title>Actors</title>

    <para id="para_though_you_may_have_heard_of_s">Though you may have heard
    of Scala and Actors in the same breath, Actors aren&#x2019;t a concept unique to
    Scala. Actors, originally intended for use in Artificial Intelligence
    research, were first put forth in 1973 (see <link linkend="Hewitt1973" xrefstyle="select:nopage">[Hewitt1973]</link> and <link linkend="Agha1987" xrefstyle="select:nopage">[Agha1987]</link>). Since then, variations on
    the idea of Actors have appeared in a number of programming languages,
    most notably in Erlang and Io. As an abstraction, Actors are general
    enough that they can be implemented as a library (as in Scala), or as the
    fundamental unit of a computational system.<indexterm class="startofrange" id="ch09_concurrentActors">
        <primary>concurrency</primary>

        <secondary>using Actors</secondary>
      </indexterm><indexterm class="startofrange" id="ch09_Actors">
        <primary>Actors</primary>
      </indexterm></para>

    <sect2 id="_actors_in_abstract">
      <title>Actors in Abstract</title>

      <para id="para_fundamentally_an_actor_is_an_">Fundamentally, an Actor is
      an object that receives messages and takes action on those messages. The
      order in which messages arrive is unimportant to an Actor, though some
      Actor implementations (such as Scala&#x2019;s) queue messages in order. An
      Actor might handle a message internally, or it might send a message to
      another Actor, or it might create another Actor to take action based on
      the message. Actors are a very high-level abstraction.<indexterm>
          <primary>Actors</primary>

          <secondary sortas="abstract">in abstract</secondary>
        </indexterm><indexterm>
          <primary>concurrency</primary>

          <secondary>using Actors</secondary>

          <tertiary>Actors in abstract</tertiary>
        </indexterm></para>

      <para id="para_unlike_traditional_object_syst">Unlike traditional object
      systems (which, you might be thinking to yourself, have many of the same
      properties we&#x2019;ve described), Actors don&#x2019;t enforce a sequence or ordering
      to their actions. This inherent eschewing of sequentiality, coupled with
      independence from shared global state, allow Actors to do their work in
      parallel. As we&#x2019;ll see later on, the judicious use of immutable data
      fits the Actor model ideally, and further aids in safe, comprehensible
      concurrent programming.</para>

      <para id="para_enough_theory_let_s_see_actor">Enough theory. Let&#x2019;s see
      Actors in action.</para>
    </sect2>
  </sect1>

  <sect1 id="_actors_in_scala">
    <title>Actors in Scala</title>

    <para id="para_at_their_most_basic_actors_in">At their most basic, Actors
    in Scala are objects that inherit from
    <literal>scala.actors.Actor</literal>:<indexterm>
        <primary>Actors</primary>

        <secondary>Actor class</secondary>
      </indexterm><indexterm>
        <primary>scala.actors.Actor class</primary>
      </indexterm><indexterm class="startofrange" id="ch09_concurrentActorsScala">
        <primary>concurrency</primary>

        <secondary>using Actors</secondary>

        <tertiary>Actors in Scala</tertiary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Concurrency/simple-actor-script.scala

import scala.actors.Actor

class Redford extends Actor {
  def act() {
    println("A lot of what acting is, is paying attention.")
  }
}

val robert = new Redford
robert.start</programlisting>

    <para id="para_as_we_can_see_in_the_above_exa">As we can see, an Actor
    defined in this way must be both instantiated and started, similar to how
    threads are handled in Java. It must also implement the abstract method
    <literal>act</literal>, which returns <literal>Unit</literal>. Once we&#x2019;ve
    started this simple Actor, the following sage advice for thespians is
    printed to the console:</para>

    <screen>A lot of what acting is, is paying attention.</screen>

    <para id="para_the_scala_actors_library_def">The
    <literal>scala.actors</literal> package contains a factory method for
    creating Actors that avoids much of the setup in the above example. We can
    import this method and other convenience methods from
    <literal>scala.actors.Actors._</literal>. Here is a factory-made
    Actor:<indexterm>
        <primary>Actors</primary>

        <secondary>factory method for creating</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/Concurrency/factory-actor-script.scala

import scala.actors.Actor
import scala.actors.Actor._

val paulNewman = actor {
  println("To be an actor, you have to be a child.")
}</programlisting>

    <para id="para_while_a_subclass_that_extends_">While a subclass that
    extends the <literal>Actor</literal> class must define
    <literal>act</literal> in order to be concrete, a factory-produced Actor
    has no such limitation. In this shorter example, the body of the method
    passed to <literal>actor</literal> is effectively promoted to the
    <literal>act</literal> method from our first example. Predictably, this
    Actor also prints a message when run. Illuminating, but we still haven&#x2019;t
    shown the essential piece of the Actors puzzle: sending messages.</para>

    <sect2 id="_sending_messages_to_actors">
      <title>Sending Messages to Actors</title>

      <para id="para_actors_can_receive_any_sort_of">Actors can receive any
      sort of object as a message, from strings of text to numeric types to
      whatever classes you&#x2019;ve cooked up in your programs. For this reason,
      Actors and pattern matching go hand in hand. An Actor should only act on
      messages of familiar types; a pattern match on the class and/or contents
      of a message is good defensive programming and increases the readability
      of Actor code:<indexterm>
          <primary>Actors</primary>

          <secondary>sending messages to</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/pattern-match-actor-script.scala

import scala.actors.Actor
import scala.actors.Actor._

val fussyActor = actor {
  loop {
    receive {
      case s: String =&gt; println("I got a String: " + s)
      case i: Int =&gt; println("I got an Int: " + i.toString)
      case _ =&gt; println("I have no idea what I just got.")
    }
  }
}

fussyActor ! "hi there"
fussyActor ! 23
fussyActor ! 3.33</programlisting>

      <para id="para_this_example_prints_the_follow">This example prints the
      following when run:</para>

      <screen>I got a String: hi there
I got an Int: 23
I have no idea what I just got.</screen>

      <para id="para_the_body_of_fussyactor_is_a_">The body of
      <literal>fussyActor</literal> is a <literal>receive</literal> method
      wrapped in a <literal>loop</literal>. <literal>loop</literal> is
      essentially a nice shortcut for <literal>while(true)</literal>; it does
      whatever is inside its block repeatedly. <literal>receive</literal>
      blocks until it gets a message of a type that will satisfy one of its
      internal pattern matching cases.</para>

      <para id="para_the_final_lines_of_this_exampl">The final lines of this
      example demonstrate use of the <literal>!</literal> (exclamation point,
      or <emphasis>bang</emphasis>) method to send messages to our Actor. If
      you&#x2019;ve ever seen Actors in Erlang, you&#x2019;ll find this syntax familiar. The
      Actor is always on the lefthand side of the bang, and the message being
      sent to said Actor is always on the right. If you need a mnemonic for
      this granule of syntactic sugar, imagine that you&#x2019;re an irate director
      shouting commands at your Actors.<indexterm>
          <primary>bang method</primary>

          <see>! (exclamation point), under Symbols</see>
        </indexterm><indexterm>
          <primary>! (exclamation point)</primary>

          <secondary>! method, sending messages to Actors</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="_the_mailbox">
      <title>The Mailbox</title>

      <para id="para_every_actor_has_a__mailbox__in">Every Actor has a
      <emphasis>mailbox</emphasis> in which messages sent to that Actor are
      queued. Let&#x2019;s see an example where we inspect the size of an Actor&#x2019;s
      mailbox:<indexterm>
          <primary>mailbox for Actors</primary>
        </indexterm><indexterm>
          <primary>Actors</primary>

          <secondary>mailbox</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/actor-mailbox-script.scala

import scala.actors.Actor
import scala.actors.Actor._

val countActor = actor {
  loop {
    react {
      case "how many?" =&gt; {
        println("I've got " + mailboxSize.toString + " messages in my mailbox.")
      }
    }
  }
}

countActor ! 1
countActor ! 2
countActor ! 3
countActor ! "how many?"
countActor ! "how many?"
countActor ! 4
countActor ! "how many?"</programlisting>

      <para id="para_this_example_produces_the_foll">This example produces the
      following output:</para>

      <screen>I've got 3 messages in my mailbox.
I've got 3 messages in my mailbox.
I've got 4 messages in my mailbox.</screen>

      <para id="para_note_that_the_first_and_second">Note that the first and
      second lines of output are identical. Because our Actor was set up
      solely to process messages of the string <literal>"how many?"</literal>,
      those messages didn&#x2019;t remain in its mailbox. Only the messages of types
      we didn&#x2019;t know about&#x2014;in this case, <literal>Int</literal>&#x2014;remained
      unprocessed.</para>

      <tip id="para_tip_keep_this_example_in_mind">
        <para>If you see an Actor&#x2019;s mailbox size ballooning unexpectedly,
        you&#x2019;re probably sending messages of a type that the Actor doesn&#x2019;t know
        about. Include a catchall case (&#x2009;<literal>_</literal>&#x2009;) when pattern
        matching messages to find out what&#x2019;s harassing your Actors.</para>
      </tip>
    </sect2>

    <sect2 id="_actors_in_depth">
      <title>Actors in Depth</title>

      <para id="para_now_that_we_ve_got_a_basic_sen">Now that we&#x2019;ve got a
      basic sense of what Actors are and how they&#x2019;re used in Scala, let&#x2019;s put
      them to work. Specifically, let&#x2019;s put them to work cutting hair. The
      <emphasis>sleeping barber problem</emphasis> (see <link linkend="SleepingBarberProblem" xrefstyle="select:nopage">[SleepingBarberProblem]</link>) is one of a
      popular set of computer science hypotheticals designed to demonstrate
      issues of concurrency and synchronization.<indexterm class="startofrange" id="ch09_sleepingbarber">
          <primary>sleeping barber problem (demonstrating Actors)</primary>
        </indexterm><indexterm class="startofrange" id="ch09_Actorsexample">
          <primary>Actors</primary>

          <secondary>example using sleeping barber problem</secondary>
        </indexterm></para>

      <para id="para_the_problem_is_this_a_hypothe">The problem is this: a
      hypothetical barber shop has just one barber with one barber chair, and
      three chairs in which customers may wait for a haircut. Without
      customers around, the barber sleeps. When a customer arrives, the barber
      wakes up to cut his hair. If the barber is busy cutting hair when a
      customer arrives, the customer sits down in an available chair. If a
      chair isn&#x2019;t available, the customer leaves.</para>

      <para id="para_strait_away_we_see_several_ob">The sleeping barber
      problem is usually solved with semaphores and mutexes, but we&#x2019;ve got
      better tools at our disposal. Straight away, we see several things to
      model as Actors: the barber is clearly one, as are the customers. The
      barbershop itself could be modeled as an Actor, too; there need not be a
      real-world parallel to verbal communication in an Actor system, even
      though we&#x2019;re sending messages.</para>

      <para id="para_let_s_start_with_the_customers">Let&#x2019;s start with the
      sleeping barber&#x2019;s customers, as they have the simplest <phrase role="keep-together">responsibilities</phrase>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/sleepingbarber/customer.scala

package sleepingbarber

import scala.actors.Actor
import scala.actors.Actor._

case object Haircut

class Customer(val id: Int) extends Actor {
  var shorn = false

  def act() = {
    loop {
      react {
        case Haircut =&gt; {
          shorn = true
          println("[c] customer " + id + " got a haircut")
        }
      }
    }
  }
}</programlisting>

      <para id="para_for_the_most_part_this_should">For the most part, this
      should look pretty familiar: we declare the package in which this code
      lives, we import code from the <literal>scala.actors</literal> package,
      and we define a class that extends <literal>Actor</literal>. There are a
      few details worth noting, however.</para>

      <para id="para_first_of_all_there_s_our_decl">First of all, there&#x2019;s our
      declaration of <literal>case object Haircut</literal>. A common pattern
      when working with Actors in Scala is to use a <literal>case
      object</literal> to represent a message without internal data. If we
      wanted to include, say, the time at which the haircut was completed,
      we&#x2019;d use a <literal>case class</literal> instead. We declare
      <literal>Haircut</literal> here because it&#x2019;s a message type that will be
      sent solely to customers.<indexterm>
          <primary>case objects</primary>
        </indexterm></para>

      <para id="para_note_as_well_that_we_re_storin">Note as well that we&#x2019;re
      storing one bit of mutable state in each <literal>Customer</literal>:
      whether or not they&#x2019;ve gotten a haircut. In their internal loop, each
      <literal>Customer</literal> waits for a <literal>Haircut</literal>
      message and, upon receipt of one, we set the <literal>shorn</literal>
      boolean to <literal>true</literal>. <literal>Customer</literal> uses the
      asynchronous <literal>react</literal> method to respond to incoming
      messages. If we needed to return the result of processing the message,
      we would use <literal>receive</literal>, but we don&#x2019;t, and in the
      process we save some memory and thread use under the hood.</para>

      <para id="para_let_s_move_on_to_the_barber_hi">Let&#x2019;s move on to the
      barber himself. Because there&#x2019;s only one barber, we could have used the
      <literal>actor</literal> factory method technique mentioned earlier to
      create him. For testing purposes, we&#x2019;ve instead defined our own
      <literal>Barber</literal> class:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/sleepingbarber/barber.scala

package sleepingbarber

import scala.actors.Actor
import scala.actors.Actor._
import scala.util.Random

class Barber extends Actor {
  private val random = new Random()

  def helpCustomer(customer: Customer) {
    if (self.mailboxSize &gt;= 3) {
      println("[b] not enough seats, turning customer " + customer.id + " away")
    } else {
      println("[b] cutting hair of customer " + customer.id)
      Thread.sleep(100 + random.nextInt(400))
      customer ! Haircut
    }
  }

  def act() {
    loop {
      react {
        case customer: Customer =&gt; helpCustomer(customer)
      }
    }
  }
}</programlisting>

      <para id="para_the_core_of_the_barber_class">The core of the
      <literal>Barber</literal> class looks very much like the
      <literal>Customer</literal>. We loop around <literal>react</literal>,
      waiting for a particular type of object. To keep that loop tight and
      readable, we call a method, <literal>helpCustomer</literal>, when a new
      <literal>Customer</literal> is sent to the barber. Within that method we
      employ a check on the mailbox size to serve as our &#x201C;chairs&#x201D; that
      customers may occupy; we could have the <literal>Barber</literal> or
      <literal>Shop</literal> classes maintain an internal
      <literal>Queue</literal>, but why bother when each Actor&#x2019;s mailbox
      already is one?</para>

      <para id="para_if_three_or_more_customers_are">If three or more
      customers are in the queue, we simply ignore that message; it&#x2019;s then
      discarded from the barber&#x2019;s mailbox. Otherwise, we simulate a
      semi-random delay (always at least 100 milliseconds) for the time it
      takes to cut a customer&#x2019;s hair, then send off a
      <literal>Haircut</literal> message to that customer. (Were we not trying
      to simulate a <phrase role="keep-together">real-world</phrase> scenario,
      we would of course remove the call to <literal>Thread.sleep()</literal>
      and allow our barber to run full tilt.)</para>

      <para id="para_next_up_we_have_a_simple_clas">Next up, we have a simple
      class to represent the barbershop itself:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/sleepingbarber/shop.scala

package sleepingbarber

import scala.actors.Actor
import scala.actors.Actor._

class Shop extends Actor {
  val barber = new Barber()
  barber.start

  def act() {
    println("[s] the shop is open")

    loop {
      react {
        case customer: Customer =&gt; barber ! customer
      }
    }
  }
}</programlisting>

      <para id="para_by_now_this_should_all_look_v">By now, this should all
      look very familiar. Each <literal>Shop</literal> creates and starts a
      new <literal>Barber</literal>, prints a message telling the world that
      the shop is open, and sits in a loop waiting for customers. When a
      <literal>Customer</literal> comes in, he&#x2019;s sent to the barber. We now
      see an unexpected benefit of Actors: they allow us to describe
      concurrent business logic in easily understood terms. &#x201C;Send the customer
      to the barber&#x201D; makes perfect sense, much more so than &#x201C;Notify the
      barber, unlock the mutex around the customer seats, increment the number
      of free seats,&#x201D; and so forth. Actors get us closer to our domain.</para>

      <para id="para_finally_we_have_a_driver_for_">Finally, we have a driver
      for our simulation:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/sleepingbarber/barbershop-simulator.scala

package sleepingbarber

import scala.actors.Actor._
import scala.collection.{immutable, mutable}
import scala.util.Random

object BarbershopSimulator {
  private val random = new Random()
  private val customers = new mutable.ArrayBuffer[Customer]()
  private val shop = new Shop()

  def generateCustomers {
    for (i &lt;- 1 to 20) {
      val customer = new Customer(i)
      customer.start()
      customers += customer
    }

    println("[!] generated " + customers.size + " customers")
  }

  // customers arrive at random intervals
  def trickleCustomers {
    for (customer &lt;- customers) {
      shop ! customer
      Thread.sleep(random.nextInt(450))
    }
  }

  def tallyCuts {
    // wait for any remaining concurrent actions to complete
    Thread.sleep(2000)

    val shornCount = customers.filter(c =&gt; c.shorn).size
    println("[!] " + shornCount + " customers got haircuts today")
  }

  def main(args: Array[String]) {
    println("[!] starting barbershop simulation")
    shop.start()

    generateCustomers
    trickleCustomers
    tallyCuts

    System.exit(0)
  }
}</programlisting>

      <para id="para_after_opening_the_shop_we_g">After &#x201C;opening the shop,&#x201D; we
      generate a number of <literal>Customer</literal> objects, assigning a
      numeric ID to each and storing the lot in an
      <literal>ArrayBuffer</literal>. Next, we &#x201C;trickle&#x201D; the customers in by
      sending them as messages to the shop and sleeping for a semi-random
      amount of time between loops. At the end of our simulated day, we tally
      up the number of customers who got haircuts by filtering out the
      customers whose internal <literal>shorn</literal> boolean was set to
      <literal>true</literal> and asking for the size of the resulting
      sequence.</para>

      <para id="para_compile_and_run_the_code_withi">Compile and run the code
      within the <literal>sleepingbarber</literal> directory as
      follows:</para>

      <screen>fsc *.scala
scala -classpath . sleepingbarber.BarbershopSimulator</screen>

      <para id="para_throughout_our_code_we_ve_pre">Throughout our code, we&#x2019;ve
      prefixed console messages with abbreviations for the classes from which
      the messages were printed. When we look at an example run of our
      simulator, it&#x2019;s easy to see where each message came from:</para>

      <screen>[!] starting barbershop simulation
[s] the shop is open
[!] generated 20 customers
[b] cutting hair of customer 1
[b] cutting hair of customer 2
[c] customer 1 got a haircut
[c] customer 2 got a haircut
[b] cutting hair of customer 3
[c] customer 3 got a haircut
[b] cutting hair of customer 4
[b] cutting hair of customer 5
[c] customer 4 got a haircut
[b] cutting hair of customer 6
[c] customer 5 got a haircut
[b] cutting hair of customer 7
[c] customer 6 got a haircut
[b] not enough seats, turning customer 8 away
[b] cutting hair of customer 9
[c] customer 7 got a haircut
[b] not enough seats, turning customer 10 away
[c] customer 9 got a haircut
[b] cutting hair of customer 11
[b] cutting hair of customer 12
[c] customer 11 got a haircut
[b] cutting hair of customer 13
[c] customer 12 got a haircut
[b] cutting hair of customer 14
[c] customer 13 got a haircut
[b] not enough seats, turning customer 15 away
[b] not enough seats, turning customer 16 away
[b] not enough seats, turning customer 17 away
[b] cutting hair of customer 18
[c] customer 14 got a haircut
[b] cutting hair of customer 19
[c] customer 18 got a haircut
[b] cutting hair of customer 20
[c] customer 19 got a haircut
[c] customer 20 got a haircut
[!] 15 customers got haircuts today</screen>

      <para id="para_you_ll_find_that_each_run_s_ou">You&#x2019;ll find that each
      run&#x2019;s output is, predictably, slightly different. Every time the barber
      takes a bit longer to cut hair than it does for several customers to
      enter, the &#x201C;chairs&#x201D; (the barber&#x2019;s mailbox queue) fill up, and new
      customers simply leave.</para>

      <para>Of course, we have to include the standard caveats that come with
      simple examples. For one, it&#x2019;s possible that our example may not be
      suitably random, particularly if random values are retrieved within a
      millisecond of one another. This is a byproduct of the way the JVM
      generates random numbers, and a good reminder to be careful about
      randomness in concurrent programs. You&#x2019;d also want to replace the
      <literal>sleep</literal> inside <literal>tallyCuts</literal> with a
      clearer signal that the various actors in the system are done doing
      their work, perhaps by making the
      <literal>BarbershopSimulation</literal> an Actor and sending it messages
      that indicate completion.</para>

      <para id="para_try_modifying_the_code_to_intr">Try modifying the code to
      introduce more customers, additional message types, <phrase role="keep-together">different</phrase> delays, or to remove the
      randomness altogether. If you&#x2019;re an experienced multithreaded
      programmer, you might try writing your own sleeping barber
      implementation just to compare and contrast. We&#x2019;re willing to bet that
      an implementation in <phrase role="keep-together">Scala</phrase> with
      Actors will be terser and easier to maintain.<indexterm class="endofrange" startref="ch09_sleepingbarber"/><indexterm class="endofrange" startref="ch09_Actorsexample"/></para>
    </sect2>

    <sect2 id="_effective_actors">
      <title>Effective Actors</title>

      <para id="para_in_order_to_get_the_most_out_o">To get the most out of
      Actors, there are few things to remember. First, note that there are
      several methods you can use to get different types of behavior out of
      your Actors. <xref linkend="actor-methods"/> should help clarify when
      to use each method.<indexterm>
          <primary>Actors</primary>

          <secondary>methods, listed</secondary>
        </indexterm></para>

      <table id="actor-methods">
        <title>Actor methods</title>

        <tgroup cols="3">
          <thead valign="top">
            <row>
              <entry><phrase role="keep-together">Method</phrase></entry>

              <entry><phrase role="keep-together">Returns</phrase></entry>

              <entry><phrase role="keep-together">Description</phrase></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>act</literal></para></entry>

              <entry><para><literal>Unit</literal></para></entry>

              <entry><para>Abstract, top-level method for an Actor. Typically
              contains one of the <phrase role="keep-together">following</phrase> methods inside
              it.</para></entry>
            </row>

            <row>
              <entry><para><literal>receive</literal></para></entry>

              <entry><para>Result of processing <phrase role="keep-together">message</phrase></para></entry>

              <entry><para>Blocks until a message of matched type is
              received.</para></entry>
            </row>

            <row>
              <entry><para><literal role="keep-together">receiveWithin</literal></para></entry>

              <entry><para>Result of processing <phrase role="keep-together">message</phrase></para></entry>

              <entry><para>Like <literal>receive</literal>, but unblocks after
              specified number of milliseconds.</para></entry>
            </row>

            <row>
              <entry><para><literal>react</literal></para></entry>

              <entry><para><literal>Nothing</literal></para></entry>

              <entry><para>Requires less overhead (threads) than
              <literal>receive</literal>.</para></entry>
            </row>

            <row>
              <entry><para><literal role="keep-together">reactWithin</literal></para></entry>

              <entry><para><literal>Nothing</literal></para></entry>

              <entry><para>Like <literal>react</literal>, but unblocks after
              specified number of milliseconds.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_typically_you_ll_want_to_use_">Typically, you&#x2019;ll want to
      use <literal>react</literal> wherever possible. If you need the results
      of processing a message (that is, you need a synchronous response from
      sending a message to an Actor), use the <literal>receiveWithin</literal>
      variant to reduce your chances of blocking indefinitely on an Actor
      that&#x2019;s gotten wedged.<indexterm>
          <primary>Actors</primary>

          <secondary>effective use of</secondary>
        </indexterm></para>

      <para>Another strategy to keep your Actor-based code asynchronous is the
      use of <emphasis>futures</emphasis>. A future is a placeholder object
      for a value that hasn&#x2019;t yet been returned from an asynchronous process.
      You can send a message to an Actor with the <literal>!!</literal>
      method; a variant of this method allows you to pass along a partial
      function that is applied to the future value. As you can see from the
      following example, retrieving a value from a <literal>Future</literal>
      is as straightforward as invoking its <literal>apply</literal> method.
      Note that retrieving a value from a <literal>Future</literal> is a
      blocking operation:<indexterm>
          <primary>! (exclamation point)</primary>

          <secondary>!! method, sending messages to Actors</secondary>
        </indexterm><indexterm>
          <primary>futures</primary>
        </indexterm></para>

      <programlisting>// code-examples/Concurrency/future-script.scala 
import scala.actors.Futures._ 

val eventually = future(5 * 42) 
println(eventually())</programlisting>

      <para id="para_each_actor_in_your_system_shou">Each Actor in your system
      should have clear responsibilities. Don&#x2019;t use Actors for <phrase role="keep-together">general-purpose</phrase>, highly stateful tasks.
      Instead, think like a director: what are the <phrase role="keep-together">distinct</phrase> roles in the &#x201C;script&#x201D; of your
      application, and what&#x2019;s the least amount of <phrase role="keep-together">information</phrase> each Actor needs to do its
      job? Give each Actor just a couple of responsibilities, and use messages
      (usually in the form of a <literal>case class</literal> or <literal>case
      object</literal>) to delegate those responsibilities to other
      Actors.</para>

      <para id="para_don_t_be_hesitant_to_copy_data">Don&#x2019;t be hesitant to copy
      data when writing Actor-centric code. The more immutable your design,
      the less likely you are to end up with unexpected state. The more you
      communicate via messages, the less you have to worry about
      synchronization. All those messages and immutable variables might appear
      to be overly costly. But, with today&#x2019;s plentiful hardware, trading
      memory overhead for clarity and predictability seems more than fair for
      most applications.</para>

      <para id="para_lastly_know_when_actors_aren_">Lastly, know when Actors
      aren&#x2019;t appropriate. Just because Actors are a great way to handle
      concurrency in Scala doesn&#x2019;t mean that they&#x2019;re the
      <emphasis>only</emphasis> way, as we&#x2019;ll see soon. Traditional threading
      and locking may better suit write-heavy critical paths for which a
      messaging approach would incur too much overhead. In our experience, you
      can use a purely Actor-based design to prototype a concurrent solution,
      then use profiling tools to suss out parts of your application that
      might benefit from a different approach.<indexterm class="endofrange" startref="ch09_concurrentActors"/><indexterm class="endofrange" startref="ch09_concurrentActorsScala"/><indexterm class="endofrange" startref="ch09_Actors"/></para>
    </sect2>
  </sect1>

  <sect1 id="_traditional_concurrency_in_scala_threading_and_events">
    <title>Traditional Concurrency in Scala: Threading and Events</title>

    <para id="para_while_actors_are_a_great_way_t">While Actors are a great
    way to handle concurrent operations, they&#x2019;re not the only way to do so in
    Scala. As Scala is interoperable with Java, the concurrency concepts that
    you may be familiar with on the JVM still apply.<indexterm>
        <primary>threading in Scala</primary>
      </indexterm><indexterm class="startofrange" id="ch09_concurrenttraditional">
        <primary>concurrency</primary>

        <secondary>traditional, using threading and events</secondary>
      </indexterm></para>

    <sect2 id="_one_off_threads">
      <title>One-Off Threads</title>

      <para id="para_for_starters_scala_provides_a">For starters, Scala
      provides a handy way to run a block of code in a new thread:<indexterm>
          <primary>threading in Scala</primary>

          <secondary>one-off threads</secondary>
        </indexterm><indexterm>
          <primary>concurrency</primary>

          <secondary>traditional, using threading and events</secondary>

          <tertiary>one-off threads</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/threads/by-block-script.scala

new Thread { println("this will run in a new thread") }</programlisting>

      <para id="para_a_similar_construct_is_availab">A similar construct is
      available in the <literal>scala.concurrent</literal> package, as a
      method on the <literal>ops</literal> object to run a block
      asynchronously with <literal>spawn</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/threads/spawn.scala

import scala.concurrent.ops._

object SpawnExample {
  def main(args: Array[String]) {
    println("this will run synchronously")

    spawn {
      println("this will run asychronously")
    }
  }
}</programlisting>
    </sect2>

    <sect2 id="_using_literal_java_util_concurrent_literal">
      <title>Using java.util.concurrent</title>

      <para id="para_if_you_re_familiar_with_the_ve">If you&#x2019;re familiar with
      the venerable <literal>java.util.concurrent</literal> package, you&#x2019;ll
      find it just as easy to use from Scala (or hard to use, depending on
      your point of view). Let&#x2019;s use <literal>Executors</literal> to create a
      pool of threads. We&#x2019;ll use the thread pool to run a simple class,
      implementing Java&#x2019;s <literal>Runnable</literal> interface for
      thread-friendly classes, that identifies which thread it&#x2019;s running
      on:<indexterm>
          <primary>concurrency</primary>

          <secondary>traditional, using threading and events</secondary>

          <tertiary>using java.util.concurrent</tertiary>
        </indexterm><indexterm>
          <primary>java.util.concurrent package</primary>
        </indexterm><indexterm>
          <primary>threading in Scala</primary>

          <secondary>using java.util.concurrent</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/Concurrency/threads/util-concurrent-script.scala

import java.util.concurrent._

class ThreadIdentifier extends Runnable {
  def run {
    println("hello from Thread " + currentThread.getId)
  }
}

val pool = Executors.newFixedThreadPool(5)

for (i &lt;- 1 to 10) {
  pool.execute(new ThreadIdentifier)
}</programlisting>

      <para id="para_as_is_standard_in_java_concurr">As is standard in Java
      concurrency, the <literal>run</literal> method is where a threaded class
      starts. Every time our <literal>pool</literal> executes a new
      <literal>ThreadIdentifier</literal>, its <literal>run</literal> method
      is invoked. A look at the output tells us that we&#x2019;re running on the five
      threads in the pool, with IDs ranging from 9 to 13:</para>

      <screen>hello from Thread 9
hello from Thread 10
hello from Thread 11
hello from Thread 12
hello from Thread 13
hello from Thread 9
hello from Thread 11
hello from Thread 10
hello from Thread 10
hello from Thread 13</screen>

      <para id="para_this_is_of_course_just_scrat">This is, of course, just
      scratching the surface of what is available in
      <literal>java.util.con&#x2060;cur&#x2060;rent</literal>. You&#x2019;ll find that your
      existing knowledge of Java&#x2019;s approach to multithreading still applies in
      Scala. What&#x2019;s more, you&#x2019;ll be able to accomplish the same tasks using
      less code, which should contribute to maintainability and
      productivity.</para>
    </sect2>

    <sect2 id="_events">
      <title>Events</title>

      <para id="para_threading_and_actors_aren_t_th">Threading and Actors
      aren&#x2019;t the only way to do concurrency. Event-based concurrency, a
      particular approach to asynchronous or <emphasis>non-blocking
      I/O</emphasis> (NIO), has become a favored way to write servers that
      need to scale to thousands of simultaneous clients. Eschewing the
      traditional one-to-one relationship of threads to clients, this model of
      concurrency exposes events that occur when particular conditions are met
      (for <phrase role="keep-together">example</phrase>, when data is
      received from a client over a network socket). Typically, the <phrase role="keep-together">programmer</phrase> will associate a callback
      method with each event that&#x2019;s relevant to her <phrase role="keep-together">program</phrase>.<indexterm class="startofrange" id="ch09_ActorsMINANagatti">
          <primary>Actors</primary>

          <secondary>using with MINA NIO and Naggati library for SMTP
          server</secondary>
        </indexterm><indexterm>
          <primary>I/O (input/output)</primary>

          <secondary>NIO (non-blocking I/O)</secondary>
        </indexterm><indexterm>
          <primary>NIO (non-blocking I/O)</primary>
        </indexterm><indexterm class="startofrange" id="ch09_events">
          <primary>events</primary>

          <secondary>using for concurrency</secondary>
        </indexterm><indexterm class="startofrange" id="ch09_concurrentevents">
          <primary>concurrency</primary>

          <secondary>traditional, using threading and events</secondary>

          <tertiary>events</tertiary>
        </indexterm></para>

      <para id="para_while_the_java_nio_package_p">While the
      <literal>java.nio</literal> package provides a variety of useful
      primitives for non-blocking <phrase role="keep-together">I/O</phrase>
      (buffers, channels, etc.), it&#x2019;s still a fair bit of work to cobble
      together an event-based concurrent program from those simple parts.
      Enter Apache MINA, built atop Java NIO and described on its home page as
      &#x201C;a network application framework which helps users develop high
      performance and high scalability network applications easily&#x201D; (see <link linkend="MINA" xrefstyle="select:nopage">[MINA]</link>).<indexterm>
          <primary>MINA (Apache)</primary>
        </indexterm><indexterm>
          <primary>Apache MINA</primary>
        </indexterm><indexterm>
          <primary>java.nio package</primary>
        </indexterm></para>

      <para id="para_while_mina_may_be_easier_to_us">While MINA may be easier
      to use than Java&#x2019;s built-in NIO libraries, we&#x2019;ve gotten used to some
      conveniences of Scala that just aren&#x2019;t available in MINA. The open
      source Naggati library (see <link linkend="Naggati" xrefstyle="select:nopage">[Naggati]</link>) adds a Scala-friendly layer
      atop MINA that, according to its author, &#x201C;makes it easy to build
      protocol filters [using a] sequential style.&#x201D; Essentially, Naggati is a
      DSL for parsing network protocols, with MINA&#x2019;s powerful NIO abilities
      under the hood.<indexterm>
          <primary>Naggati library</primary>
        </indexterm></para>

      <para id="para_let_s_use_naggati_to_write_the">Let&#x2019;s use Naggati to
      write the foundations of an SMTP email server. To keep things simple,
      we&#x2019;re only dealing with two SMTP commands: <literal>HELO</literal> and
      <literal>QUIT</literal>. The former command identifies a client, and the
      latter ends the client&#x2019;s session.<indexterm class="startofrange" id="ch09_SMTPserver">
          <primary>SMTP mail server (example)</primary>
        </indexterm></para>

      <para id="para_we_ll_drive_our_experiment_wit">We&#x2019;ll keep ourselves
      honest with a test suite, facilitated by the Specs Behavior-Driven
      Development library (see <xref linkend="ScalaSpecs"/>):</para>

      <programlisting linenumbering="unnumbered">// .../smtpd/src/test/scala/com/programmingscala/smtpd/SmtpDecoderSpec.scala

package com.programmingscala.smtpd

import java.nio.ByteOrder
import net.lag.naggati._
import org.apache.mina.core.buffer.IoBuffer
import org.apache.mina.core.filterchain.IoFilter
import org.apache.mina.core.session.{DummySession, IoSession}
import org.apache.mina.filter.codec._
import org.specs._
import scala.collection.{immutable, mutable}

object SmtpDecoderSpec extends Specification {
  private var fakeSession: IoSession = null
  private var fakeDecoderOutput: ProtocolDecoderOutput = null
  private var written = new mutable.ListBuffer[Request]

  def quickDecode(s: String): Unit = {
    Codec.decoder.decode(fakeSession, IoBuffer.wrap(s.getBytes), fakeDecoderOutput)
  }

  "SmtpRequestDecoder" should {
    doBefore {
      written.clear()
      fakeSession = new DummySession
      fakeDecoderOutput = new ProtocolDecoderOutput {
        override def flush(nextFilter: IoFilter.NextFilter, s: IoSession) = {}
        override def write(obj: AnyRef) = written += obj.asInstanceOf[Request]
      }
    }

    "parse HELO" in {
      quickDecode("HELO client.example.org\n")
      written.size mustEqual 1
      written(0).command mustEqual "HELO"
      written(0).data mustEqual "client.example.org"
    }

    "parse QUIT" in {
      quickDecode("QUIT\n")
      written.size mustEqual 1
      written(0).command mustEqual "QUIT"
      written(0).data mustEqual null
    }
  }
}</programlisting>

      <para id="para_after_setting_up_an_environmen">After setting up an
      environment for each test run, our suite exercises the two SMTP commands
      we&#x2019;re interested in. The <literal>doBefore</literal> block runs before
      each test, guaranteeing that mock session and output buffers are in a
      clean state. In each test we&#x2019;re passing a string of hypothetical client
      input to our as-yet-unimplemented <literal>Codec</literal>, then
      verifying that the resulting <literal>Request</literal> (a <literal>case
      class</literal>) contains the correct <literal>command</literal> and
      <literal>data</literal> fields. As the <literal>QUIT</literal> command
      doesn&#x2019;t require any additional information from the client, we simply
      check that <literal>data</literal> is <literal>null</literal>.</para>

      <para id="para_with_our_tests_in_place_let_s">With our tests in place,
      let&#x2019;s implement a basic codec (an encoder and decoder) for
      SMTP:<indexterm>
          <primary>SMTP mail server (example)</primary>

          <secondary>codec for SMTP</secondary>
        </indexterm><indexterm>
          <primary>codec for SMTP (example)</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// .../smtpd/src/main/scala/com/programmingscala/smtpd/Codec.scala

package com.programmingscala.smtpd

import org.apache.mina.core.buffer.IoBuffer
import org.apache.mina.core.session.{IdleStatus, IoSession}
import org.apache.mina.filter.codec._
import net.lag.naggati._
import net.lag.naggati.Steps._

case class Request(command: String, data: String)
case class Response(data: IoBuffer)

object Codec {
  val encoder = new ProtocolEncoder {
    def encode(session: IoSession, message: AnyRef, out: ProtocolEncoderOutput) = {
      val buffer = message.asInstanceOf[Response].data
      out.write(buffer)
    }

    def dispose(session: IoSession): Unit = {
      // no-op, required by ProtocolEncoder trait
    }
  }

  val decoder = new Decoder(readLine(true, "ISO-8859-1") { line =&gt;
    line.split(' ').first match {
      case "HELO" =&gt; state.out.write(Request("HELO", line.split(' ')(1))); End
      case "QUIT" =&gt; state.out.write(Request("QUIT", null)); End
      case _ =&gt; throw new ProtocolError("Malformed request line: " + line)
    }
  })
}</programlisting>

      <para id="para_we_first_define_a_request_c">We first define a
      <literal>Request</literal> <literal>case class</literal> in which to
      store request data as it arrives. Then we specify the
      <literal>encoder</literal> portion of our codec, which exists simply to
      write data out. A <literal>dispose</literal> method is defined (but not
      fleshed out) to fulfill the contract of the <literal role="keep-together">ProtocolEncoder</literal> trait.<indexterm>
          <primary>Request case class</primary>
        </indexterm></para>

      <para id="para_the_decoder_is_what_we_re_real">The decoder is what we&#x2019;re
      really interested in. <literal>readRequest</literal> reads a line, picks
      out the first word in that line, and pattern matches on it to find SMTP
      commands. In the case of a <literal>HELO</literal> command, we also grab
      the subsequent string on that line. The results are placed in a
      <literal>Request</literal> object and written out to
      <literal>state</literal>. As you might imagine, <literal>state</literal>
      stores our progress throughout the parsing process.</para>

      <para id="para_though_trivial_the_above_exam">Though trivial, the above
      example demonstrates just how easy it is to parse protocols with
      Naggati. Now that we&#x2019;ve got a working codec, let&#x2019;s combine Naggati and
      MINA with Actors to wire up a server.</para>

      <para id="para_first_a_few_lines_of_setup_gr">First, a few lines of
      setup grunt work to get things going for our SMTP server:<indexterm>
          <primary>SMTP mail server (example)</primary>

          <secondary>setup</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// .../smtpd/src/main/scala/com/programmingscala/smtpd/Main.scala

package com.programmingscala.smtpd

import net.lag.naggati.IoHandlerActorAdapter
import org.apache.mina.filter.codec.ProtocolCodecFilter
import org.apache.mina.transport.socket.SocketAcceptor
import org.apache.mina.transport.socket.nio.{NioProcessor, NioSocketAcceptor}
import java.net.InetSocketAddress
import java.util.concurrent.{Executors, ExecutorService}
import scala.actors.Actor._

object Main {
  val listenAddress = "0.0.0.0"
  val listenPort = 2525

  def setMaxThreads = {
    val maxThreads = (Runtime.getRuntime.availableProcessors * 2)
    System.setProperty("actors.maxPoolSize", maxThreads.toString)
  }

  def initializeAcceptor = {
    var acceptorExecutor = Executors.newCachedThreadPool()
    var acceptor =
      new NioSocketAcceptor(acceptorExecutor, new NioProcessor(acceptorExecutor))
    acceptor.setBacklog(1000)
    acceptor.setReuseAddress(true)
    acceptor.getSessionConfig.setTcpNoDelay(true)
    acceptor.getFilterChain.addLast("codec",
            new ProtocolCodecFilter(smtpd.Codec.encoder, smtpd.Codec.decoder))
    acceptor.setHandler(
            new IoHandlerActorAdapter(session =&gt; new SmtpHandler(session)))
    acceptor.bind(new InetSocketAddress(listenAddress, listenPort))
  }

  def main(args: Array[String]) {
    setMaxThreads
    initializeAcceptor
    println("smtpd: up and listening on " + listenAddress + ":" + listenPort)
  }
}</programlisting>

      <para id="para_to_ensure_that_we_re_getting_t">To ensure that we&#x2019;re
      getting the most out of the Actor instances in our server, we set the
      <literal>actors.maxPoolSize</literal> system property to twice the
      number of available processors on our machine. We then initialize an
      <literal>NioSocketAcceptor</literal>, a key piece of MINA machinery that
      accepts new connections from clients. The final three lines of this
      configuration are critical, as they put our codec to work, tell the
      acceptor to handle requests with a special object, and start the server
      listening for new connections on port 2525 (real SMTP servers run on the
      privileged port 25).<indexterm>
          <primary>actors.maxPoolSize system property</primary>
        </indexterm><indexterm>
          <primary>NioSocketAcceptor object</primary>
        </indexterm></para>

      <para id="para_the_aforementioned_special_obj">The aforementioned
      special object is an Actor wrapped in an
      <literal>IoHandlerActorAdapter</literal>, a bridging layer between Scala
      Actors and MINA that&#x2019;s provided by Naggati. This is the piece of our
      server that talks back to the client. Now that we know what the client
      is saying, thanks to the decoder, we actually know what to say
      back!<indexterm>
          <primary>SMTP mail server (example)</primary>

          <secondary>SmtpHandler class</secondary>
        </indexterm><indexterm>
          <primary>IOHandlerActorAdapter object</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// .../smtpd/src/main/scala/com/programmingscala/smtpd/SmtpHandler.scala

package com.programmingscala.smtpd

import net.lag.naggati.{IoHandlerActorAdapter, MinaMessage, ProtocolError}
import org.apache.mina.core.buffer.IoBuffer
import org.apache.mina.core.session.{IdleStatus, IoSession}
import java.io.IOException
import scala.actors.Actor
import scala.actors.Actor._
import scala.collection.{immutable, mutable}

class SmtpHandler(val session: IoSession) extends Actor {
  start

  def act = {
    loop {
      react {
        case MinaMessage.MessageReceived(msg) =&gt;
            handle(msg.asInstanceOf[smtpd.Request])
        case MinaMessage.SessionClosed =&gt; exit()
        case MinaMessage.SessionIdle(status) =&gt; session.close
        case MinaMessage.SessionOpened =&gt; reply("220 localhost Tapir SMTPd 0.1\n")

        case MinaMessage.ExceptionCaught(cause) =&gt; {
          cause.getCause match {
            case e: ProtocolError =&gt; reply("502 Error: " + e.getMessage + "\n")
            case i: IOException   =&gt; reply("502 Error: " + i.getMessage + "\n")
            case _                =&gt; reply("502 Error unknown\n")
          }
          session.close
        }
      }
    }
  }

  private def handle(request: smtpd.Request) = {
    request.command match {
      case "HELO" =&gt; reply("250 Hi there " + request.data + "\n")
      case "QUIT" =&gt; reply("221 Peace out girl scout\n"); session.close
    }
  }

  private def reply(s: String) = {
    session.write(new smtpd.Response(IoBuffer.wrap(s.getBytes)))
  }

}</programlisting>

      <para id="para_straight_away_we_see_the_same">Straight away, we see the
      same pattern that we saw in the Actors examples earlier in this chapter:
      looping around a <literal>react</literal> block that pattern matches on
      a limited set of cases. In <literal>SmtpHandler</literal>, all of those
      cases are <emphasis>events</emphasis> provided by MINA. For example,
      MINA will send us <literal>MinaMessage.SessionOpened</literal> when a
      client connects and <literal role="keep-together">MinaMessage.Ses&#x2060;sionClosed</literal> when a client
      disconnects.</para>

      <para id="para_the_case_we_re_most_interested">The case we&#x2019;re most
      interested in is <literal>MinaMessage.MessageReceived</literal>. We&#x2019;re
      handed a familiar <literal>Request</literal> object with each newly
      received valid message, and we can pattern match on the
      <literal>command</literal> field to take appropriate action. When the
      client says <literal>HELO</literal>, we can reply with an
      acknowledgement. When the client says <literal>QUIT</literal>, we say
      goodbye and disconnect him.<indexterm>
          <primary>MINA (Apache)</primary>

          <secondary>events provided by</secondary>
        </indexterm></para>

      <para id="para_now_that_we_ve_got_all_the_pie">Now that we&#x2019;ve got all
      the pieces in place, let&#x2019;s have a conversation with our
      server:<indexterm>
          <primary>SMTP mail server (example)</primary>

          <secondary>conversation with server</secondary>
        </indexterm></para>

      <screen>[al3x@jaya ~]$ telnet localhost 2525
Trying ::1...
Connected to localhost.
Escape character is '^]'.
220 localhost Tapir SMTPd 0.1
HELO jaya.local
250 Hi there jaya.local
QUIT
221 Peace out girl scout
Connection closed by foreign host.</screen>

      <?dbfo-need height=”1in”
?>

      <para id="para_a_brief_conversation_to_be_su">A brief conversation, to
      be sure, but our server works! Now, what happens if we throw something
      unexpected at it?</para>

      <screen>[al3x@jaya ~]$ telnet localhost 2525
Trying ::1...
Connected to localhost.
Escape character is '^]'.
220 localhost Tapir SMTPd 0.1
HELO jaya.local
250 Hi there jaya.local
BAD COMMAND
502 Error: Malformed request line: BAD COMMAND
Connection closed by foreign host.</screen>

      <para id="para_nicely_handled_good_thing_we_">Nicely handled. Good thing
      we took the time to dig out those exceptions when we received a
      <literal>MinaMessage.ExceptionCaught</literal> in our
      <literal>SmtpHandler</literal> Actor.</para>

      <para id="para_of_course_what_we_ve_built_ju">Of course, what we&#x2019;ve
      built just handles the beginning and end of a complete SMTP
      conversation. As an exercise, try filling out the rest of the commands.
      Or, to skip ahead to something very much akin to what we&#x2019;ve built here,
      check out the open source Mailslot project on GitHub (see <link linkend="Mailslot" xrefstyle="select:nopage">[Mailslot]</link>).<indexterm class="endofrange" startref="ch09_ActorsMINANagatti"/><indexterm class="endofrange" startref="ch09_SMTPserver"/><indexterm class="endofrange" startref="ch09_events"/><indexterm class="endofrange" startref="ch09_concurrentevents"/><indexterm class="endofrange" startref="ch09_concurrenttraditional"/></para>
    </sect2>
  </sect1>

  <sect1 id="_recap_and_what_s_next">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_learned_how_to_build_scalab">We learned how to build
    scalable, robust concurrent applications using Scala&#x2019;s Actor library that
    avoid the problems of traditional approaches based on synchronized access
    to shared, mutable state. We also demonstrated that Java&#x2019;s powerful
    built-in threading model is easily accessible from Scala. Finally, we
    learned how to combine Actors with the powerful MINA NIO framework and
    Naggati to develop event-driven, asynchronous network servers from the
    ground up in just a few lines of code.</para>

    <para id="para_the_next_chapter_examines_scal">The next chapter examines
    Scala&#x2019;s built-in support for working with XML.</para>
  </sect1>
</chapter>
  <chapter id="HerdingXMLInScalaDSLs">
  <title>Herding XML in Scala</title>

  <para id="para_xml_has_long_since_become_the_">XML has long since become the
  <emphasis>lingua franca</emphasis> of machine-to-machine communication on
  the Internet. The format&#x2019;s combination of human readability,
  standardization, and tool support has made working with XML an inevitability
  for programmers. Yet, writing code that deals in XML is an unpleasant chore
  in most programming languages. Scala improves this situation.<indexterm class="startofrange" id="ch10_XML">
      <primary>XML</primary>
    </indexterm></para>

  <para id="para_as_with_the_actor_library_we_l">As with the Actor
  functionality we learned about in <xref linkend="Concurrency"/>, Scala&#x2019;s
  XML support is implemented partly as a library, with some built-in syntax
  support. It feels to the programmer like an entirely natural part of the
  language. Convenient operators add a spoonful of syntactic sugar to the task
  of diving deep into complex document structures, and pattern matching
  further sweetens the deal. Outputting XML is just as pleasant.</para>

  <para id="para_unusual_in_programming_languag">Unusual in programming
  languages and particularly handy, Scala allows inline XML. Most anywhere you
  might put a string, you can put XML. This feature makes templating and
  configuration a breeze, and lets us test our use of XML without so much as
  opening a file.</para>

  <para id="para_let_s_explore_working_with_xml">Let&#x2019;s explore working with
  XML in Scala. First, we&#x2019;ll look at reading and navigating an XML document.
  Finally, we&#x2019;ll produce XML output programmatically and demonstrate uses for
  inline XML.</para>

  <sect1 id="_reading_xml">
    <title>Reading XML</title>

    <para id="para_we_ll_start_with_the_basics_h">We&#x2019;ll start with the basics:
    how to turn a string full of XML into a data structure we can work
    with:<indexterm>
        <primary>XML</primary>

        <secondary>reading</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/XML/reading/from-string-script.scala

import scala.xml._

val someXMLInAString = """
&lt;sammich&gt;
  &lt;bread&gt;wheat&lt;/bread&gt;
  &lt;meat&gt;salami&lt;/meat&gt;
  &lt;condiments&gt;
    &lt;condiment expired="true"&gt;mayo&lt;/condiment&gt;
    &lt;condiment expired="false"&gt;mustard&lt;/condiment&gt;
  &lt;/condiments&gt;
&lt;/sammich&gt;
"""

val someXML = XML.loadString(someXMLInAString)
assert(someXML.isInstanceOf[scala.xml.Elem])</programlisting>

    <para id="para_all_fine_and_well_we_ve_trans">All fine and well. We&#x2019;ve
    transformed the string into a <literal>NodeSeq</literal>, Scala&#x2019;s type for
    storing a sequence of XML nodes. Were our XML document in a file on disk,
    we could have used the <literal>loadFile</literal> method from the same
    package.<indexterm>
        <primary>NodeSeq object</primary>
      </indexterm></para>

    <para id="para_since_we_re_supplying_the_xml_">Since we&#x2019;re supplying the
    XML ourselves, we can skip the <literal>XML.loadString</literal> step and
    just assign a chunk of markup to a <literal>val</literal> or
    <literal>var</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/XML/reading/inline-script.scala

import scala.xml._

val someXML =
&lt;sammich&gt;
  &lt;bread&gt;wheat&lt;/bread&gt;
  &lt;meat&gt;salami&lt;/meat&gt;
  &lt;condiments&gt;
    &lt;condiment expired="true"&gt;mayo&lt;/condiment&gt;
    &lt;condiment expired="false"&gt;mustard&lt;/condiment&gt;
  &lt;/condiments&gt;
&lt;/sammich&gt;

assert(someXML.isInstanceOf[scala.xml.Elem])</programlisting>

    <sect2 id="_exploring_xml">
      <title>Exploring XML</title>

      <para id="para_if_we_paste_the_above_into_the">If we paste the previous
      example into the interpreter, we can explore our sandwich using some
      handy tools provided by <literal>NodeSeq</literal>:<indexterm>
          <primary>XML</primary>

          <secondary>exploring using NodeSeq tools</secondary>
        </indexterm></para>

      <screen>scala&gt; someXML \ "bread"
res2: scala.xml.NodeSeq = &lt;bread&gt;wheat&lt;/bread&gt;</screen>

      <para id="para_that_backslash_what_the_docu">That backslash&#x2014;what the
      documentation calls a <emphasis>projection function</emphasis>&#x2014;says,
      &#x201C;Find me elements named <literal>bread</literal>.&#x201D; We&#x2019;ll always get a
      <literal>NodeSeq</literal> back when using a projection function. If
      we&#x2019;re only interested in what&#x2019;s between the tags, we can use the
      <literal>text</literal> method:<indexterm>
          <primary>\ (backslash)</primary>

          <secondary>projection functions</secondary>
        </indexterm><indexterm>
          <primary>projection functions</primary>
        </indexterm></para>

      <screen>scala&gt; (someXML \ "bread").text
res3: String = wheat</screen>

      <tip id="para_tip_it_s_valid_syntax_to_say_">
        <para>It&#x2019;s valid syntax to say <literal>someXML \ "bread"
        text</literal>, without parentheses or the dot before the call to
        <literal>text</literal>. You&#x2019;ll still get the same result, but it&#x2019;s
        harder to read. Parentheses make your intent clear.</para>
      </tip>

      <para id="para_we_ve_only_inspected_the_outer">We&#x2019;ve only inspected the
      outermost layer of our sandwich. Let&#x2019;s try to get a
      <literal>NodeSeq</literal> of the condiments:</para>

      <screen>scala&gt; someXML \ "condiment"
res4: scala.xml.NodeSeq =</screen>

      <para id="para_what_went_wrong_the_funct">What went wrong? The
      <literal>\</literal> function doesn&#x2019;t descend into child elements of an
      XML structure. To do that, we use its sister function,
      <literal>\\</literal> (two backslashes):</para>

      <screen>scala&gt; someXML \\ "condiment"
res5: scala.xml.NodeSeq = &lt;condiment expired="true"&gt;mayo&lt;/condiment&gt;
  &lt;condiment expired="false"&gt;mustard&lt;/condiment&gt;</screen>

      <para id="para_much_better_we_dove_into_the_">Much better. (We split the
      single output line into two lines so it would fit on the page.) We dove
      into the structure and pulled out the two
      <literal>&lt;condiment&gt;</literal> elements. Looks like one of the
      condiments has gone bad, though. We can find out if any of the
      condiments has expired by extracting its <literal>expired</literal>
      attribute. All it takes is an <literal>@</literal> before the attribute
      name:<indexterm>
          <primary>@ (at sign)</primary>

          <secondary>extracting value of XML attributes</secondary>
        </indexterm></para>

      <screen>scala&gt; (someXML \\ "condiment")(0) \ "@expired"
res6: scala.xml.NodeSeq = true</screen>

      <para id="para_we_used_the_0_to_pick_the_">We used the
      <literal>(0)</literal> to pick the first of the two condiments that were
      returned by <literal>(someXML \\ "condiment")</literal>.</para>
    </sect2>

    <sect2 id="_looping_amp_matching_xml">
      <title>Looping and Matching XML</title>

      <para id="para_this_extracts_the__value__of_t">The previous bit of code
      extracted the <emphasis>value</emphasis> of the
      <literal>expired</literal> attribute (<literal>true</literal>, in this
      case), but it didn&#x2019;t tell us which condiment is expired. If we were
      handed an arbitrary XML sandwich, how would we identify the expired
      condiments? We can loop through the XML:<indexterm>
          <primary>loops</primary>

          <secondary>looping through and matching XML</secondary>
        </indexterm><indexterm>
          <primary>XML</primary>

          <secondary>looping and matching</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/XML/reading/for-loop-script.scala

for (condiment &lt;- (someXML \\ "condiment")) {
  if ((condiment \ "@expired").text == "true")
    println("the " + condiment.text + " has expired!")
}</programlisting>

      <para id="para_because_nodeseq_inherits_the">Because
      <literal>NodeSeq</literal> inherits the same familiar attributes that
      most Scala collection types carry, tools like <literal>for</literal>
      loops apply directly. In the example just shown, we extract the <literal role="keep-together">&lt;condiment&gt;</literal> nodes, loop over each
      of them, and test whether or not their <literal>expired</literal>
      attribute equals the string <literal>"true"</literal>. We have to
      specify that we want the <literal>text</literal> of a given <literal role="keep-together">condiment</literal>; otherwise, we&#x2019;d get a string
      representation of the entire line of XML.</para>

      <para id="para_we_can_also_use_pattern_matchi">We can also use pattern
      matching on XML structures. Cases in pattern matches can be written in
      terms of XML literals; expressions between curly braces
      (<literal>{}</literal>) escape back to standard Scala pattern matching
      syntax. To match all XML nodes in the escaped portion of a pattern
      match, use an underscore (wildcard) followed by an asterisk
      (&#x2009;<literal>_*</literal>). To bind what you&#x2019;ve matched on to a variable,
      prefix the match with the variable name and an <literal>@</literal>
      sign.<indexterm>
          <primary>pattern matching</primary>

          <secondary>using on XML structures</secondary>
        </indexterm></para>

      <para id="para_let_s_put_all_that_together_in">Let&#x2019;s put all that
      together into one example. We&#x2019;ll include the original XML document again
      so you can follow along as we pattern match on XML:</para>

      <programlisting linenumbering="unnumbered">// code-examples/XML/reading/pattern-matching-script.scala

import scala.xml._

val someXML =
&lt;sammich&gt;
  &lt;bread&gt;wheat&lt;/bread&gt;
  &lt;meat&gt;salami&lt;/meat&gt;
  &lt;condiments&gt;
    &lt;condiment expired="true"&gt;mayo&lt;/condiment&gt;
    &lt;condiment expired="false"&gt;mustard&lt;/condiment&gt;
  &lt;/condiments&gt;
&lt;/sammich&gt;

someXML match {
  case &lt;sammich&gt;{ingredients @ _*}&lt;/sammich&gt; =&gt; {
    for (cond @ &lt;condiments&gt;{_*}&lt;/condiments&gt; &lt;- ingredients)
      println("condiments: " + cond.text)
  }
}</programlisting>

      <para id="para_here_we_bind_the_contents_of_">Here, we bind the contents
      of our <literal>&lt;sammich&gt;</literal> structure (that is, what&#x2019;s
      inside the opening and closing tag) to a variable called
      <literal>ingredients</literal>. Then, as we iterate through the
      ingredients in a <literal>for</literal> loop, we assign the elements
      that are between the <literal>&lt;condiments&gt;</literal> tags to a
      temporary variable, <literal>cond</literal>. Each
      <literal>cond</literal> is printed.</para>

      <para id="para_the_same_tools_that_let_us_eas">The same tools that let
      us easily manipulate complex data structures in Scala are readily
      available for XML processing. As a readable alternative to XSLT, Scala&#x2019;s
      XML library makes reading and parsing XML a breeze. It also gives us
      equally powerful tools for writing XML, which we&#x2019;ll explore in the next
      section.</para>
    </sect2>
  </sect1>

  <sect1 id="_writing_xml">
    <title>Writing XML</title>

    <para id="para_while_some_languages_construct">While some languages
    construct XML through complex object serialization mechanisms, Scala&#x2019;s
    support for XML literals makes writing XML far simpler. Essentially, when
    you want XML, just write XML. To interpolate variables and expressions,
    escape out to Scala with curly braces, as we did in the pattern matching
    examples earlier:<indexterm>
        <primary>XML</primary>

        <secondary>writing</secondary>
      </indexterm></para>

    <screen>scala&gt; var name = "Bob"
name: java.lang.String = Bob

scala&gt; val bobXML =
     | &lt;person&gt;
     |   &lt;name&gt;{name}&lt;/name&gt;
     | &lt;/person&gt;
bobXML: scala.xml.Elem =
&lt;person&gt;
  &lt;name&gt;Bob&lt;/name&gt;
&lt;/person&gt;</screen>

    <para id="para_as_we_can_see_the_name_vari">As we can see, the
    <literal>name</literal> variable was substituted when we constructed the
    XML document assigned to <literal>bobXML</literal>. That evaluation only
    occurs once; were <literal>name</literal> subsequently redefined, the
    <literal>&lt;name&gt;</literal> element of <literal>bobXML</literal> would
    still contain the string &#x201C;Bob&#x201D;.</para>

    <sect2 id="_a_real_world_example">
      <title>A Real-World Example</title>

      <para id="para_for_a_more_complete_example_l">For a more complete
      example, let&#x2019;s say we&#x2019;re designing that favorite latter-day &#x201C;hello
      world,&#x201D; a blogging system. We&#x2019;ll start with a class to represent an
      Atom-friendly blog post:<indexterm class="startofrange" id="ch10_blogsys">
          <primary>blogging system (example)</primary>
        </indexterm><indexterm class="startofrange" id="ch10_XMLwritingexample">
          <primary>XML</primary>

          <secondary>writing</secondary>

          <tertiary>blogging system (example)</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/XML/writing/post.scala

import java.text.SimpleDateFormat
import java.util.Date

class Post(val title: String, val body: String, val updated: Date) {
  lazy val dashedDate = {
    val dashed = new SimpleDateFormat("yy-MM-dd")
    dashed.format(updated)
  }

  lazy val atomDate = {
    val rfc3339 = new SimpleDateFormat("yyyy-MM-dd'T'h:m:ss'-05:00'")
    rfc3339.format(updated)
  }

  lazy val slug = title.toLowerCase.replaceAll("\\W", "-")
  lazy val atomId  = "tag:example.com," + dashedDate + ":/" + slug
}</programlisting>

      <para id="para_beyond_the_obvious_title_and">Beyond the obvious
      <literal>title</literal> and <literal>body</literal> attributes, we&#x2019;ve
      defined several lazily loaded values in our <literal>Post</literal>
      class. These attributes will come in handy when we transmute our posts
      into an Atom feed, the standard way to syndicate blogs between computers
      on the Web. Atom documents are a flavor of XML, and a perfect
      application for demonstrating the process of outputting XML with
      Scala.<indexterm>
          <primary>lazy values</primary>

          <secondary>Post class (example)</secondary>
        </indexterm></para>

      <para id="para_we_ll_define_an_atomfeed_cla">We&#x2019;ll define an
      <literal>AtomFeed</literal> class that takes a sequence of
      <literal>Post</literal> objects as its sole argument:<indexterm>
          <primary>AtomFeed class (example)</primary>
        </indexterm><indexterm>
          <primary>blogging system (example)</primary>

          <secondary>AtomFeed class</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/XML/writing/atom-feed.scala

import scala.xml.XML

class AtomFeed(posts: Seq[Post]) {
  val feed =
  &lt;feed xmlns="http://www.w3.org/2005/Atom"&gt;
    &lt;title&gt;My Blog&lt;/title&gt;
    &lt;subtitle&gt;A fancy subtitle.&lt;/subtitle&gt;
    &lt;link href="http://example.com/"/&gt;
    &lt;link href="http://example.com/atom.xml" rel="self"/&gt;
    &lt;updated&gt;{posts(0).atomDate}&lt;/updated&gt;
    &lt;author&gt;
      &lt;name&gt;John Doe&lt;/name&gt;
      &lt;uri&gt;http://example.com/about.html&lt;/uri&gt;
    &lt;/author&gt;
    &lt;id&gt;http://example.com/&lt;/id&gt;
    {for (post &lt;- posts) yield
    &lt;entry&gt;
      &lt;title&gt;{post.title}&lt;/title&gt;
      &lt;link href={"http://example.com/" + post.slug + ".html"} rel="alternate"/&gt;
      &lt;id&gt;{post.atomId}&lt;/id&gt;
      &lt;updated&gt;{post.atomDate}&lt;/updated&gt;
      &lt;content type="html"&gt;{post.body}&lt;/content&gt;
      &lt;author&gt;
        &lt;name&gt;John Doe&lt;/name&gt;
        &lt;uri&gt;http://example.com/about.html&lt;/uri&gt;
      &lt;/author&gt;
    &lt;/entry&gt;
    }
  &lt;/feed&gt;

  def write = XML.saveFull("/tmp/atom-example.xml", feed, "UTF-8", true, null)
}</programlisting>

      <para id="para_we_re_making_heavy_use_of_the_">We&#x2019;re making heavy use of
      the ability to escape out to Scala expressions in this example. Whenever
      we need a piece of dynamic information&#x2014;for example, the date of the
      first post in the sequence, formatted for the Atom standard&#x2014;we simply
      escape out and write Scala as we normally would. In the latter half of
      the <literal>&lt;feed&gt;</literal> element, we use a
      <literal>for</literal> comprehension to <literal>yield</literal>
      successive blocks of dynamically formatted XML.<indexterm>
          <primary>for comprehensions</primary>

          <secondary>yielding successive blocks of dynamically formatted
          XML</secondary>
        </indexterm></para>

      <para id="para_the_write_method_of_atomfee">The <literal>write</literal>
      method of <literal>AtomFeed</literal> demonstrates the use of the
      <literal>saveFull</literal> method, provided by the
      <literal>scala.xml</literal> library. <literal>saveFull</literal> writes
      an XML document to disk, optionally in different encoding schemes and
      with different document type declarations. Alternately, the
      <literal>save</literal> method within the same package will make use of
      any <literal>java.io.Writer</literal> variant, should you need
      buffering, piping, etc.</para>

      <para id="para_writing_xml_with_scala_is_stra">Writing XML with Scala is
      straightforward: construct the document you need with inline XML, use
      interpolation where dynamic content is to be substituted, and make use
      of the handy convenience methods to write your completed documents to
      disk or to other output streams.<indexterm class="endofrange" startref="ch10_blogsys"/><indexterm class="endofrange" startref="ch10_XMLwritingexample"/></para>
    </sect2>
  </sect1>

  <sect1 id="_recap_and_what_s_next_2">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_xml_is_ubiquitous_in_software_">XML has become ubiquitous
    in software applications, yet few languages make working with XML a simple
    task. We learned how Scala accelerates XML development by making it easy
    to read and write XML.</para>

    <para id="para_in_the_next_chapter_we_ll_lea">In the next chapter, we&#x2019;ll
    learn how Scala provides rich support for creating your own
    Domain-Specific Languages (DSLs).<indexterm class="endofrange" startref="ch10_XML"/></para>
  </sect1>
</chapter>
  <chapter id="DomainSpecificLanguages">
  <title>Domain-Specific Languages in Scala</title>

  <para id="para_dsl_defn">A <emphasis>Domain-Specific Language</emphasis> is
  a programming language that mimics the terms, idioms, and expressions used
  among experts in the targeted domain. Code written in a DSL reads like
  structured prose for the domain. Ideally, a domain expert with little
  experience in programming can read, understand, and validate this code.
  Sometimes, a domain expert might be able to write DSL code, even if he isn&#x2019;t
  a professional programmer.<indexterm class="startofrange" id="ch11_DSLs">
      <primary>DSLs (Domain-Specific Languages)</primary>
    </indexterm></para>

  <para id="para_dsls_are_a_large_topic_we_ll_">DSLs are a large topic. We&#x2019;ll
  only touch the surface of DSLs and Scala&#x2019;s impressive support for them. For
  more information on DSLs in general, see <link linkend="Fowler2009" xrefstyle="select:nopage">[Fowler2009]</link>, <link linkend="Ford2009" xrefstyle="select:nopage">[Ford2009]</link>, and <link linkend="Deursen" xrefstyle="select:nopage">[Deursen]</link>. The basic build tool we used for
  the book&#x2019;s examples, <literal>sake</literal>, uses a DSL similar to the
  venerable <literal>make</literal> and its Ruby cousin
  <literal>rake</literal>. (See the <phrase role="keep-together">README</phrase> in the <ulink role="orm:hideurl" url="http://examples.oreilly.com/9780596155964/">code download
  archive</ulink> for details.) For other examples of Scala &#x201C;internal&#x201D; and
  &#x201C;external&#x201D; DSLs, see <link linkend="Ghosh2008a" xrefstyle="select:nopage">[Ghosh2008a]</link> and <link linkend="Ghosh2008b" xrefstyle="select:nopage">[Ghosh2008b]</link>. For some advanced work on
  DSLs using Scala, <link linkend="Hofer2008" xrefstyle="select:nopage">[Hofer2008]</link> explores polymorphic
  substitution of alternative implementations for DSL abstractions, which is
  useful for analysis, optimization, composition, etc.</para>

  <para id="para_well_crafted_dsls_offer_severa">Well-crafted DSLs offer
  several benefits:<indexterm>
      <primary>DSLs (Domain-Specific Languages)</primary>

      <secondary>benefits and drawbacks of</secondary>
    </indexterm></para>

  <variablelist id="para_dsl_benefits_">
    <varlistentry id="varlistentry-encapsulation">
      <term>Encapsulation</term>

      <listitem>
        <para>A DSL hides implementation details and exposes only those
        abstractions relevant to the domain.</para>
      </listitem>
    </varlistentry>

    <varlistentry id="varlistentry-efficiency">
      <term>Efficiency</term>

      <listitem>
        <para>Because implementation details are encapsulated, a DSL optimizes
        the effort required to write or modify code for application
        features.</para>
      </listitem>
    </varlistentry>

    <varlistentry id="varlistentry-communication">
      <term>Communication</term>

      <listitem>
        <para>A DSL helps developers understand the domain and domain experts
        to verify that the implementation meets the requirements.</para>
      </listitem>
    </varlistentry>

    <varlistentry id="varlistentry-quality">
      <term>Quality</term>

      <listitem>
        <para>A DSL minimizes the &#x201C;impedance mismatch&#x201D; between feature
        requirements, as expressed by domain experts, and the implementing
        source code, thereby minimizing potential bugs.</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para id="para_however_dsls_also_have_severa">However, DSLs also have
  several drawbacks:</para>

  <variablelist id="para_dsl_drawbacks">
    <varlistentry id="varlistentry-difficulties-of-creating-good-dsls">
      <term>Difficulties of creating good DSLs</term>

      <listitem>
        <para>Good DSLs are harder to design than traditional APIs. The latter
        tend to follow language idioms for API design, where uniformity is
        important. Even then, elegant, effective, and easy-to-use APIs are
        difficult to design. In contrast, each DSL should reflect the unique
        language idioms of its domain. The DSL designer has much greater
        latitude, which also means it is much harder to determine the &#x201C;best&#x201D;
        design choices.</para>
      </listitem>
    </varlistentry>

    <varlistentry id="varlistentry-long-term-maintenance">
      <term>Long-term maintenance</term>

      <listitem>
        <para>DSLs can require more maintenance over the long term to factor
        in domain changes. Also, new developers will require more time to
        learn how to use and maintain a DSL.</para>
      </listitem>
    </varlistentry>
  </variablelist>

  <para id="para_when_a_dsl_is_appropriate_for_">However, when a DSL is
  appropriate for an application&#x2014;e.g., when it would be used frequently to
  implement and change functionality&#x2014;a well-designed DSL can be a powerful
  tool for building flexible and robust applications.</para>

  <para id="para_dsl_two_kinds">From the implementation point of view, DSLs
  are often classified as <emphasis>internal</emphasis> and <emphasis role="keep-together">external</emphasis>.</para>

  <para id="para_an__internal__dsl_is_an_idioma">An
  <emphasis>internal</emphasis> (sometimes called
  <emphasis>embedded</emphasis>) DSL is an idiomatic way of writing code in a
  general-purpose programming language, like Scala. No special-purpose parser
  is necessary for internal DSLs. Instead, they are parsed just like any other
  code written in the language. In contrast, an <emphasis>external</emphasis>
  DSL is a custom language with its own custom grammar and parser.<indexterm>
      <primary>external DSLs</primary>
    </indexterm><indexterm>
      <primary>internal DSLs</primary>
    </indexterm></para>

  <para id="para_internal_dsls_are_easier_to_cr">Internal DSLs are easier to
  create because they don&#x2019;t require a special-purpose parser. On the other
  hand, the constraints of the underlying language limit the options for
  expressing domain concepts. External DSLs remove this constraint. You can
  design the language any way you want, as long as you can write a reliable
  parser for it. The downside of external DSLs is the requirement to write and
  use a custom parser.</para>

  <para id="para_dsls_have_been_around_a_long_time">DSLs have been around a
  long time. For example, internal DSLs written in Lisp are as old as Lisp
  itself. Interest in DSLs has surged recently, driven in part by the Ruby
  community, because they are very easy to implement in Ruby. As we&#x2019;ll see,
  Scala provides excellent support for the creation of internal and external
  DSLs.</para>

  <sect1 id="InternalDSLs">
    <title>Internal DSLs</title>

    <para id="para_create_internal_dsl">Let&#x2019;s create an internal DSL for a
    payroll application that computes an employee&#x2019;s paycheck every pay period,
    which will be two weeks long. The paycheck will include the employee&#x2019;s
    <emphasis>net</emphasis> salary, which is the <emphasis>gross</emphasis>
    salary minus the <emphasis>deductions</emphasis> for taxes, insurance
    premiums (at least in some countries), retirement fund contributions,
    etc.<indexterm class="startofrange" id="ch11_DSLinternal">
        <primary>DSLs (Domain-Specific Languages)</primary>

        <secondary>internal DSL for payroll application (example)</secondary>
      </indexterm></para>

    <para id="para_assuming_we_have_a_conventiona">To better understand the
    contrasts between code that makes use of DSLs and code that does not,
    let&#x2019;s try both techniques on the same problem. Here&#x2019;s how the paycheck
    might be calculated for two employees, without the help of a
    DSL:<indexterm class="startofrange" id="ch11_DSLinternalpayrollAPI">
        <primary>DSLs (Domain-Specific Languages)</primary>

        <secondary>internal DSL for payroll application (example)</secondary>

        <tertiary>payroll API</tertiary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/api/payroll-api-script.scala

import payroll.api._
import payroll.api.DeductionsCalculator._
import payroll._
import payroll.Type2Money._

val buck = Employee(Name("Buck", "Trends"), Money(80000))
val jane = Employee(Name("Jane", "Doe"), Money(90000))

List(buck, jane).foreach { employee =&gt;
  // Assume annual is based on 52 weeks.
  val biweeklyGross = employee.annualGrossSalary / 26.

  val deductions = federalIncomeTax(employee, biweeklyGross) +
          stateIncomeTax(employee, biweeklyGross) +
          insurancePremiums(employee, biweeklyGross) +
          retirementFundContributions(employee, biweeklyGross)

  val check = Paycheck(biweeklyGross, biweeklyGross - deductions, deductions)

  format("%s %s: %s\n", employee.name.first, employee.name.last, check)
}</programlisting>

    <para id="para_the_script_iterates_through_th">For each employee, the
    script calculates the gross pay for the pay period, the deductions, and
    the resulting net. These values are placed into a
    <literal>Paycheck</literal>, which is printed out. Before we describe the
    types we are using, notice a few things about the
    <literal>foreach</literal> loop that does the work.</para>

    <para id="para_first_it_is_noisy_for_exampl">First, it is noisy. For
    example, it mentions <literal>employee</literal> and
    <literal>biweeklyGross</literal> incessantly. A DSL will help us minimize
    that &#x201C;noise&#x201D; and focus on what&#x2019;s really going on.</para>

    <para id="para_second_notice_that_the_code_i">Second, notice that the code
    is imperative. It says &#x201C;divide this, add that,&#x201D; and so forth. We&#x2019;ll see
    that our DSLs look similar, but they are more declarative, hiding the work
    from the user.</para>

    <para id="para_here_is_the_simple_paycheck_">Here is the simple
    <literal>Paycheck</literal> class used in the script:</para>

    <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/paycheck.scala

package payroll

/** We're ignoring invalid (?) cases like a negative net
 *  when deductions exceed the gross.
 */
case class Paycheck(gross: Money, net: Money, deductions: Money) {

  def plusGross (m: Money)      = Paycheck(gross + m, net + m, deductions)
  def plusDeductions (m: Money) = Paycheck(gross,     net - m, deductions + m)
}</programlisting>

    <para id="para_an_employee_type_is_used_wh">The
    <literal>Employee</literal> type uses a <literal>Name</literal>
    type:</para>

    <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/employee.scala

package payroll

case class Name(first: String, last: String)

case class Employee(name: Name, annualGrossSalary: Money)</programlisting>

    <para id="para_the_money_type_handles_arith">The <literal>Money</literal>
    type handles arithmetic, rounding to four decimal places, etc. It ignores
    currency, except for the <literal>toString</literal> method. Proper
    financial arithmetic is notoriously difficult to do correctly for
    real-world transactions. This implementation is not perfectly accurate,
    but it&#x2019;s close enough for our purposes. <link linkend="MoneyInJava" xrefstyle="select:nopage">[MoneyInJava]</link> provides useful information
    on doing real money calculations:</para>

    <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/money.scala

package payroll
import java.math.{BigDecimal =&gt; JBigDecimal,
    MathContext =&gt; JMathContext, RoundingMode =&gt; JRoundingMode}

/** Most arithmetic is done using JBigDecimals for tighter control.
 */
class Money(val amount: BigDecimal) {

  def + (m: Money)  =
      Money(amount.bigDecimal.add(m.amount.bigDecimal))
  def - (m: Money)  =
      Money(amount.bigDecimal.subtract(m.amount.bigDecimal))
  def * (m: Money)  =
      Money(amount.bigDecimal.multiply(m.amount.bigDecimal))
  def / (m: Money)  =
      Money(amount.bigDecimal.divide(m.amount.bigDecimal,
          Money.scale, Money.jroundingMode))

  def &lt;  (m: Money)  = amount &lt;  m.amount
  def &lt;= (m: Money)  = amount &lt;= m.amount
  def &gt;  (m: Money)  = amount &gt;  m.amount
  def &gt;= (m: Money)  = amount &gt;= m.amount

  override def equals (o: Any) = o match {
    case m: Money =&gt; amount equals m.amount
    case _ =&gt; false
  }

  override def hashCode = amount.hashCode * 31

  // Hack: Must explicitly call the correct conversion: double2Double
  override def toString =
      String.format("$%.2f", double2Double(amount.doubleValue))
}

object Money {
  def apply(amount: BigDecimal)  = new Money(amount)
  def apply(amount: JBigDecimal) = new Money(scaled(new BigDecimal(amount)))
  def apply(amount: Double)      = new Money(scaled(BigDecimal(amount)))
  def apply(amount: Long)        = new Money(scaled(BigDecimal(amount)))
  def apply(amount: Int)         = new Money(scaled(BigDecimal(amount)))

  def unapply(m: Money) = Some(m.amount)

  protected def scaled(d: BigDecimal) = d.setScale(scale, roundingMode)

  val scale = 4
  val jroundingMode = JRoundingMode.HALF_UP
  val roundingMode  = BigDecimal.RoundingMode.ROUND_HALF_UP
  val context = new JMathContext(scale, jroundingMode)
}

object Type2Money {
  implicit def bigDecimal2Money(b: BigDecimal)   = Money(b)
  implicit def jBigDecimal2Money(b: JBigDecimal) = Money(b)
  implicit def double2Money(d: Double)           = Money(d)
  implicit def long2Money(l: Long)               = Money(l)
  implicit def int2Money(i: Int)                 = Money(i)
}</programlisting>

    <para id="para_note_that_it_uses_scala_bigde">Note that we use
    <literal>scala.BigDecimal</literal>, which wraps
    <literal>java.math.BigDecimal</literal>, as the storage type for financial
    figures.<indexterm>
        <primary>BigDecimal class</primary>
      </indexterm></para>

    <para id="para_the_deductions_are_calculated_">Deductions are calculated
    using four helper methods in
    <literal>payroll.api.DeductionsCal&#x2060;cu&#x2060;lator</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/api/deductions-calc.scala

package payroll.api
import payroll.Type2Money._

object DeductionsCalculator {
  def federalIncomeTax(empl: Employee, gross: Money) = gross * .25

  def stateIncomeTax(empl: Employee, gross: Money) = gross * .05

  def insurancePremiums(empl: Employee, gross: Money) = Money(500)

  def retirementFundContributions(empl: Employee, gross: Money) = gross * .10
}</programlisting>

    <para id="para_each_method_might_use_the_empl">Each method might use the
    employee information and the gross salary for the pay period. In this
    case, we use very simple algorithms based on just the gross salary, except
    for insurance premiums, which we treat as a fixed value.</para>

    <para id="para_running_payroll_api_script_">Running the script for the
    payroll API produces the following output:</para>

    <screen>(665) $ scala -cp ... payroll-api-script.scala
Buck Trends: Paycheck($3076.92,$1346.15,$1730.77)
Jane Doe: Paycheck($3461.54,$1576.92,$1884.62)</screen>

    <sect2 id="APayrollInternalDSL">
      <title>A Payroll Internal DSL</title>

      <para id="para_this_code_works_well_enough_b">The previous code works
      well enough, but suppose we wanted to show it to the Accounting
      Department to confirm that we&#x2019;re calculating paychecks correctly. Most
      likely, they would get lost in the Scala idioms. Suppose further that we
      need the ability to customize this algorithm frequently&#x2014;for example,
      because it needs to be customized for different employee types
      (salaried, hourly, etc.), or to modify the deduction calculations.
      Ideally, we would like to enable the accountants to do these
      customizations themselves, without our help.<indexterm>
          <primary>payroll internal DSL (example)</primary>
        </indexterm><indexterm class="endofrange" startref="ch11_DSLinternalpayrollAPI"/><indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>internal DSL for payroll application
          (example)</secondary>

          <tertiary>payroll internal DSL</tertiary>
        </indexterm></para>

      <para id="para_we_might_achieve_these_goals_i">We might achieve these
      goals if we can express the logic in a DSL that is sufficiently
      intuitive to an accountant. Can we morph our API example into such a
      DSL?</para>

      <para id="para_look_again_at_payroll_api_sc">Returning to the script for
      the payroll API, what if we hide most of the explicit references to
      context information, like the employee, gross salary, and deduction
      values? Consider the following text:</para>

      <screen>Rules to calculate an employee's paycheck:
  employee's gross salary for 2 weeks
  minus deductions for
    federalIncomeTax, which     is  25%  of gross
    stateIncomeTax, which       is  5%   of gross
    insurancePremiums, which    are 500. in gross's currency
    retirementFundContributions are 10%  of gross</screen>

      <para id="para_this_reads_mostly_like_normal_">This reads like normal
      English, not code. We have included some &#x201C;bubble&#x201D; words (see <link linkend="Ford2009" xrefstyle="select:nopage">[Ford2009]</link>) that aid
      readability but don&#x2019;t necessarily correspond to anything essential, such
      as <literal>to</literal>, <literal>an</literal>, <literal>is</literal>,
      <literal>for</literal>, <literal>of</literal>, and
      <literal>which</literal>. We&#x2019;ll eliminate some of these unnecessary
      words and keep others in our Scala DSL.</para>

      <para id="para_compared_to_the_version_in_p">Compared to the version in
      the payroll API script, there&#x2019;s a lot less clutter obscuring the
      essentials of the algorithm. This is because we have minimized explicit
      references to the contextual information. We only mention
      <literal>employee</literal> twice. We mention <literal>gross</literal>
      five times, but hopefully in &#x201C;intuitive&#x201D; ways.</para>

      <para id="para_there_are_many_possible_intern">There are many possible
      internal Scala DSLs we could construct that resemble this ad hoc DSL.
      Here is one of them, again in a script, which produces the same output
      as before:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/dsl/payroll-dsl-script.scala

import payroll._
import payroll.dsl._
import payroll.dsl.rules_

val payrollCalculator = rules { employee =&gt;
  employee salary_for 2.weeks minus_deductions_for { gross =&gt;
    federalIncomeTax            is  (25.  percent_of gross)
    stateIncomeTax              is  (5.   percent_of gross)
    insurancePremiums           are (500. in gross.currency)
    retirementFundContributions are (10.  percent_of gross)
  }
}

val buck = Employee(Name("Buck", "Trends"), Money(80000))
val jane = Employee(Name("Jane", "Doe"), Money(90000))

List(buck, jane).foreach { employee =&gt;
  val check = payrollCalculator(employee)
  format("%s %s: %s\n", employee.name.first, employee.name.last, check)
}</programlisting>

      <para id="para_we_ll_go_through_the_implement">We&#x2019;ll go through the
      implementation step by step, but first, let&#x2019;s summarize the features of
      Scala that allow us to implement this DSL.</para>
    </sect2>

    <sect2 id="InternalDSLs-InfixOperatorNotation">
      <title>Infix Operator Notation</title>

      <para id="para_definition_of_payrollCalculator">Consider this line in
      the definition of <literal>payrollCalculator</literal>:<indexterm>
          <primary>operator notation</primary>

          <secondary>infix operator notation</secondary>
        </indexterm><indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>internal DSL for payroll application
          (example)</secondary>

          <tertiary>infix operator notation</tertiary>
        </indexterm><indexterm>
          <primary>. (dot)</primary>

          <secondary>infix operator notation</secondary>
        </indexterm><indexterm>
          <primary>infix operator notation</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">employee salary_for 2.weeks minus_deductions_for { gross =&gt;</programlisting>

      <para id="para_this_infix_notation_is_equival">This infix notation is
      equivalent to the following less-readable form:</para>

      <programlisting linenumbering="unnumbered">employee.salary_for(2.weeks).minus_deductions_for { gross =&gt;</programlisting>

      <para id="para_you_can_see_why_we_wrote_2_we">You can see why we wrote
      <literal>2.weeks</literal> earlier, because the result of this
      expression is passed to <literal>salary_for</literal>. Without the
      period, the infix expression would be parsed as
      <literal>employee.salary_for(2).weeks...</literal>. There is no
      <literal>weeks</literal> method on <literal>Int</literal>, of course.
      We&#x2019;ll revisit this expression in a moment.</para>

      <para id="para_method_chaining_like_this_is_o">Method chaining like this
      is often implemented where each method returns <literal>this</literal>
      so you can continue calling methods on the same instance. Note that
      returning <literal>this</literal> allows those method calls to occur in
      any order. If you need to impose a specific ordering, then return an
      instance of a different type. For example, if
      <literal>minus_deductions_for</literal> must be called after
      <literal>salary_for</literal>, then <literal>salary_for</literal> should
      return a new instance.<indexterm>
          <primary>method chaining</primary>
        </indexterm></para>

      <para id="para_because_chaining_is_so_easy_w">Because chaining is so
      easy, we could have created separate methods for
      <literal>salary</literal>, <literal>for</literal>,
      <literal>minus</literal>, and <literal>deductions</literal>, allowing us
      to write the following expression:</para>

      <programlisting linenumbering="unnumbered">employee salary for 2.weeks minus deductions for { gross =&gt;</programlisting>

      <para id="para_note_that_calls_to_for_are_p">Note that calls to
      <literal>for</literal> are preceded by different calls with very
      different meanings. So, if the same instance is used throughout, it
      would have to track the &#x201C;flow&#x201D; internally. Chaining different instances
      would eliminate this problem. However, since no computations are
      actually needed between these words, we chose the simpler design where
      words are joined together, separated by <literal>_</literal>.</para>
    </sect2>

    <sect2 id="InternalDSLs-ImplicitConversions-UserDefinedTypes">
      <title>Implicit Conversions and User-Defined Types</title>

      <para id="para_int_doesnt_have_weeks_method">Returning to
      <literal>2.weeks</literal>, since <literal>Int</literal> doesn&#x2019;t have a
      <literal>weeks</literal> method, we use an implicit conversion to a
      <literal>Duration</literal> instance that wraps an
      <literal>Int</literal> specifying an amount:<indexterm>
          <primary>implicit conversions</primary>

          <secondary>in internal DSL payroll implementation</secondary>
        </indexterm><indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>internal DSL for payroll application
          (example)</secondary>

          <tertiary>implicit conversions and user-defined types</tertiary>
        </indexterm></para>

      <?dbfo-need height=”1in”
?>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/dsl/duration.scala

package payroll.dsl

case class Duration(val amount: Int) {
  /** @return the number of work days in "amount" weeks. */
  def weeks = amount * 5

  /** @return the number of work days in "amount" years. */
  def years = amount * 260
}</programlisting>

      <para id="para_the_weeks_method_multiples_t">The
      <literal>weeks</literal> method multiples that amount by 5 to return the
      corresponding amount of work days. Hence, we designed the payroll
      calculator to work with days as the unit of time. This decision is
      completely hidden behind the DSL. Should we later add support for work
      hours, it would be easy to refactor the design to use hours
      instead.</para>

      <para id="para__duration_is_one_of_the__ad_h"><literal>Duration</literal> is
      one of the ad hoc types that we designed to encapsulate the implicit
      context, to implement helper methods for the DSL, etc. We&#x2019;ll discuss the
      implicit conversion method we need in a moment.</para>
    </sect2>

    <sect2 id="InternalDSLs-Apply">
      <title>Apply Methods</title>

      <para id="para_internal_dsl_objects_use_apply">A number of the
      implementation objects use <literal>apply</literal> to invoke behavior.
      The <literal>rules</literal> object encapsulates the process of building
      the rules for payroll calculation. Its <literal>apply</literal> method
      takes a function literal, <literal>Employee =&gt;
      Paycheck</literal>.<indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>internal DSL for payroll application
          (example)</secondary>

          <tertiary>apply methods</tertiary>
        </indexterm></para>
    </sect2>

    <sect2 id="_payroll_rules_dsl_implementation">
      <title>Payroll Rules DSL Implementation</title>

      <para id="para_now_lets_explore_the_implement">Now let&#x2019;s explore the
      implementation, starting with the <literal>rules</literal> object and
      working our way down:<indexterm class="startofrange" id="ch11_DLSinternalpayrollrules">
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>internal DSL for payroll application
          (example)</secondary>

          <tertiary>payroll rules DSL implementation</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/dsl/payroll.scala

package payroll.dsl
import payroll._

object rules {

  def apply(rules: Employee =&gt; Paycheck) = new PayrollBuilderRules(rules)

  implicit def int2Duration(i: Int) = Duration(i)

  implicit def employee2GrossPayBuilder(e: Employee) =
      new GrossPayBuilder(e)

  implicit def grossPayBuilder2DeductionsBuilder(b: GrossPayBuilder)
      = new DeductionsBuilder(b)

  implicit def double2DeductionsBuilderDeductionHelper(d: Double) =
      new DeductionsBuilderDeductionHelper(d)
}

import rules._
...</programlisting>

      <para id="para_the_function_literal_argument_">The function literal
      argument for <literal>rules.apply</literal> is used to construct a
      <literal>PayrollBuilderRules</literal> that will process the specified
      rules. It is used at the very beginning of the DSL.</para>

      <programlisting linenumbering="unnumbered">val payrollCalculator = rules { employee =&gt; ...</programlisting>

      <para id="para_the_rules_object_also_define">The
      <literal>rules</literal> object also defines implicit conversions. The
      first one is used by the <literal>2.weeks</literal> expression. It
      converts <literal>2</literal> into a <literal>Duration</literal>
      instance, which we discussed previously. The other conversions are used
      later in the DSL to enable transparent conversion of
      <literal>Doubles</literal>, <literal>Employees</literal>, etc. into
      wrapper instances that we will describe shortly.</para>

      <para id="para_note_that_the_rules_object_i">Note that the
      <literal>rules</literal> object is imported so these conversions are
      visible in the rest of the current file. It will also need to be
      imported in files that use the DSL.</para>

      <para id="para_the_payrollbuilderrules_is_o">The
      <literal>PayrollBuilderRules</literal> is our first wrapper instance. It
      evaluates the function literal for the whole rule set, wrapped in a
      <literal>try/catch</literal> block:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/dsl/payroll.scala
...
class PayrollException(message: String, cause: Throwable)
    extends RuntimeException(message, cause)

protected[dsl] class PayrollBuilderRules(rules: Employee =&gt; Paycheck) {
  def apply(employee: Employee) = {
    try {
      rules(employee)
    } catch {
      case th: Throwable =&gt; new PayrollException(
        "Failed to process payroll for employee: " + employee, th)
    }
  }
}
...</programlisting>

      <para id="para_note_that_we_protected_access_">Note that we protect
      access to <literal>PayrollBuilderRules</literal>, because we don&#x2019;t want
      clients using it directly. However, we left the exception public for use
      in <literal>catch</literal> clauses. (You can decide whether or not you
      like wrapping a thrown exception in a &#x201C;domain-specific&#x201D; exception, as
      shown.)</para>

      <para id="para_note_that_we_have_to_pass_the_">Note that we have to pass
      the employee as a &#x201C;context&#x201D; instance in the function literal. We said
      that it is desirable to make the context as implicit as possible. A
      common theme in our implementation classes, like
      <literal>PayrollBuilderRules</literal>, is to hold context information
      in wrapper instances and to minimize their visibility in the DSL. An
      alternative approach would be to store context in singleton objects so
      other instances can get to them. This approach raises thread safety
      issues, unfortunately.</para>

      <para id="para_to_see_what_we_mean_concerning">To see what we mean
      concerning the context, consider the part of our script that uses the
      payroll DSL, where the deductions are specified:</para>

      <programlisting linenumbering="unnumbered">... { gross =&gt;
  federalIncomeTax            is  (25.  percent_of gross)
  stateIncomeTax              is  (5.   percent_of gross)
  insurancePremiums           are (500. in gross.currency)
  retirementFundContributions are (10.  percent_of gross)
}</programlisting>

      <para id="para_consider_the_insurance_premium">Consider the insurance
      premiums, for which a flat <literal>Money(500)</literal> is deducted.
      Why didn&#x2019;t we just write <literal>insurancePremiums are 500.</literal>,
      instead? It turns out we have to &#x201C;sneak&#x201D; the <literal>gross</literal>
      instance into the expression somehow. The name <literal>gross</literal>
      implies that it is a <literal>Money</literal> representing the
      employee&#x2019;s salary for the pay period. <emphasis>Tricksey
      DSLses!!</emphasis> It is actually another helper instance,
      <literal>DeductionsBuilder</literal>, which holds the whole paycheck,
      including the gross pay, and the employee instance. The name
      <literal>gross</literal> is used merely because it reads well in the
      places where it is used.</para>

      <para id="para_this_block_is_calculating_the_">This block is calculating
      the deductions and deducting them from the gross pay to determine the
      net pay. The <literal>gross</literal> instance handles this process.
      There is no &#x201C;communication&#x201D; between the four lines of the function
      literal. Furthermore, <literal>federalIncomeTax</literal>,
      <literal>insurancePremiums</literal>, etc. are objects with no
      connection to <literal>DeductionsBuilder</literal> (as we&#x2019;ll see
      shortly). It would be great if they could be members of
      <literal>DeductionsBuilder</literal> or perhaps some other wrapper
      instance enclosing this scope. Then each line would be a method call on
      one or the other wrapper. Unfortunately, this doesn&#x2019;t work. Hence, each
      line must specify the <literal>gross</literal> instance to maintain
      continuity. We jump through various hoops to support the syntax, yet
      allow <literal>gross</literal> to be available, as needed.</para>

      <para id="para_so_we_contrived_the_conventio">So, we contrived the
      convention that &#x201C;raw&#x201D; numbers, like the insurance deduction, have to be
      qualified by the particular currency used for the gross pay. We&#x2019;ll see
      how the expression <literal>500. in gross.currency</literal> works in a
      moment. It is something of a hack, but it reads well and it solves our
      design problem.</para>

      <para id="para_here_is_a_possible_alternative">Here is a possible
      alternative design that would have avoided the problem:</para>

      <programlisting linenumbering="unnumbered">... { builder =&gt;
  builder federalIncomeTax            (25.  percent_of gross)
  builder stateIncomeTax              (5.   percent_of gross)
  builder insurancePremiums           500.
  builder retirementFundContributions (10.  percent_of gross)
}</programlisting>

      <para id="para_now_the_fact_that_a_builder_">Now the fact that a
      <literal>builder</literal> is being used is more explicit, and
      <literal>federalIncomeTax</literal>, <literal role="keep-together">insurancePremiums</literal>, etc. are methods on
      the builder. We opted for a more readable style, with the penalty of a
      harder implementation. You&#x2019;ll sometimes hear the phrase <emphasis>fluent
      in&#x2060;ter&#x2060;face</emphasis> used to refer to DSLs that emphasize
      readability.<indexterm>
          <primary>fluent interface</primary>
        </indexterm></para>

      <para id="para_here_is_grosspaybuilder_">Here is
      <literal>GrossPayBuilder</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/dsl/payroll.scala
...
import payroll.Type2Money._

protected[dsl] class GrossPayBuilder(val employee: Employee) {

  var gross: Money = 0

  def salary_for(days: Int) = {
    gross += dailyGrossSalary(employee.annualGrossSalary) * days
    this
  }

  // Assume 260 working days: 52 weeks (including vacation) * 5 days/week.
  def weeklyGrossSalary(annual: Money) = annual / 52.0
  def dailyGrossSalary(annual: Money)  = annual / 260.0
}
...</programlisting>

      <para id="para_recall_that_rules_defines_an">Recall that
      <literal>rules</literal> defines an implicit conversion from
      <literal>Employee</literal> to this type. It is invoked by the
      expression <literal>employee salary_for</literal>, so the
      <literal>GrossPayBuilder.salary_for</literal> method can be called.
      <literal>GrossPayBuilder</literal> initializes the
      <literal>gross</literal> and appends new values to it whenever
      <literal>salary_for</literal> is called, which assumes we&#x2019;re adding
      gross pay in increments of days. Finally, <literal>salary_for</literal>
      returns <literal>this</literal> to support chaining.</para>

      <para id="para_deduction_calculation_is_most_">Deduction calculation is
      the most complex part. When <literal>minus_deductions_for</literal> is
      used in the DSL, it triggers the implicit conversion defined in
      <literal>rules</literal> from the <literal>GrossPayBuilder</literal> to
      a <literal>DeductionsBuilder</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/dsl/payroll.scala
...
protected[dsl] class DeductionsBuilder(gpb: GrossPayBuilder) {

  val employee = gpb.employee
  var paycheck: Paycheck = new Paycheck(gpb.gross, gpb.gross, 0)

  def currency = this

  def minus_deductions_for(deductionRules: DeductionsBuilder =&gt; Unit) = {
    deductionRules(this)
    paycheck
  }

  def addDeductions(amount: Money) = paycheck = paycheck plusDeductions amount

  def addDeductionsPercentageOfGross(percentage: Double) = {
    val amount = paycheck.gross * (percentage/100.)
    addDeductions(amount)
  }
}
...</programlisting>

      <para id="para__deductionsbuilder_saves_the_"><literal>DeductionsBuilder</literal>
      saves the <literal>employee</literal> from the passed-in
      <literal>GrossPayBuilder</literal>, which it doesn&#x2019;t save as a field. It
      also initializes the <literal>paycheck</literal> using the calculated
      gross pay.</para>

      <para id="para_note_that_the_currency_metho">Note that the
      <literal>currency</literal> method simply returns
      <literal>this</literal>. We don&#x2019;t need to do anything with the actual
      currency when this method is invoked. Instead, it is used to support a
      design idiom that we&#x2019;ll discuss shortly.</para>

      <para id="para_the_minus_deductions_for_doe">The
      <literal>minus_deductions_for</literal> does the important work. It
      invokes the function literal with the individual rules and then returns
      the completed <literal>Paycheck</literal> instance, which is ultimately
      what <literal>rules.apply</literal> returns.</para>

      <para id="para_our_remaining_two_methods_are_">Our remaining two methods
      are used to calculate individual deductions. They are called from
      <literal>DeductionsBuilderDeductionHelper</literal>, which we show
      now:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/dsl/payroll.scala
...
class DeductionCalculator {
  def is(builder: DeductionsBuilder) = apply(builder)
  def are(builder: DeductionsBuilder) = apply(builder)

  def apply(builder: DeductionsBuilder) = {}
}

object federalIncomeTax extends DeductionCalculator
object stateIncomeTax extends DeductionCalculator
object insurancePremiums extends DeductionCalculator
object retirementFundContributions extends DeductionCalculator

protected[dsl] class DeductionsBuilderDeductionHelper(val factor: Double) {
  def in (builder: DeductionsBuilder) = {
    builder addDeductions Money(factor)
    builder
  }
  def percent_of (builder: DeductionsBuilder) = {
    builder addDeductionsPercentageOfGross factor
    builder
  }
}</programlisting>

      <para id="para_now_we_see_that_federalincome">Now we see that
      <literal>federalIncomeTax</literal>, etc. are singleton objects. Note
      the &#x201C;synonym&#x201D; methods <literal>is</literal> and <literal>are</literal>.
      We used <literal>are</literal> for the objects with plural names, like
      <literal>insurancePre&#x2060;miums</literal>, and <literal>is</literal> for the
      singular objects, like <literal>federalIncomeTax</literal>. In fact,
      since both methods delegate to <literal>apply</literal>, they are
      effectively bubble words that the user could omit. That is, the
      following two DSL lines are equivalent:</para>

      <programlisting linenumbering="unnumbered">federalIncomeTax is (25. percent_of gross)
federalIncomeTax    (25. percent_of gross)</programlisting>

      <para id="para_the_apply_method_takes_dedu">The <literal>apply</literal>
      method takes <literal>DeductionsBuilder</literal> and does nothing with
      it! In fact, by the time <literal>apply</literal> is called, the
      deduction has already been calculated and factored into the paycheck. By
      implication, the presence of expressions like <literal>federalIncomeTax
      is</literal> are effectively syntactic sugar (at least as this DSL is
      currently implemented). They are a fancy form of comments, but at least
      they have the virtue of type checking the &#x201C;kinds&#x201D; of deductions that are
      allowed. Of course, as the implementation evolves, these instances might
      do real work.</para>

      <para id="para_to_see_why_deductioncalculato">To see why
      <literal>DeductionCalculator.apply</literal> is empty, let&#x2019;s discuss
      <literal>DeductionsBuilderDe&#x2060;duc&#x2060;tionHelper</literal>. Recall that the
      <literal>rules</literal> object has an implicit conversion method to
      convert a <literal>Double</literal> to a
      <literal>DeductionsBuilderDeductionHelper</literal>. Once we have a
      helper instance, we can call either the <literal>in</literal> method or
      the <literal>percent_of</literal> method. Every line in the deductions
      function literal exploits this instance.</para>

      <?dbfo-need height=”1in”
?>

      <para id="para_for_example_25_percent_of_">For example, <literal>(25.
      percent_of gross)</literal> is roughly equivalent to the following
      steps:</para>

      <orderedlist numeration="arabic">
        <listitem>
          <para>Call to
          <literal>rules.double2DeductionsBuilderDeductionHelper(25.)</literal>
          to create a new
          <literal>DeductionsBuilderDeductionHelper(25.)</literal></para>
        </listitem>

        <listitem>
          <para>Call to the helper&#x2019;s <literal>percent_of(gross)</literal>
          method, where <literal>gross</literal> is a
          <literal>DeductionsBuilder</literal></para>
        </listitem>

        <listitem>
          <para><literal>gross.addDeductionsPercentageOfGross(factor)</literal></para>
        </listitem>
      </orderedlist>

      <para id="para_in_other_words_we_used_deduc">In other words, we used
      <literal>DeductionsBuilderDeductionHelper</literal> to convert an
      expression of the form <literal>Double method
      DeductionsBuilder</literal> into an expression of the form <literal role="keep-together">DeductionsBuilder method2 Double</literal>.
      <literal>DeductionsBuilder</literal> accumulates each deduction into the
      paycheck we&#x2019;re building.</para>

      <para id="para_the_expression_500_in_gross_">The expression
      <literal>500. in gross.currency</literal> works almost identically.
      <literal>DeductionsBuilder.currency</literal> is effectively another
      bubble word; it simply returns <literal>this</literal>, but gives a
      readable idiom for the DSL. The <literal>in</literal> method simply
      converts the <literal>Double</literal> to a <literal>Money</literal> and
      passes it to <literal>DeductionsBuilder.addDeductions</literal>.</para>

      <para id="para_so_deductioncalculator_apply_">So
      <literal>DeductionCalculator.apply</literal> does nothing, because all
      the work is already done by the time <literal>apply</literal> is
      called.<indexterm class="endofrange" startref="ch11_DLSinternalpayrollrules"/></para>
    </sect2>

    <sect2 id="InternalDSLsFinalThoughts">
      <title>Internal DSLs: Final Thoughts</title>

      <para id="para_so_which_is_better_the_origi">So which is better, the
      original API implementation or the DSL implementation? The DSL
      implementation is complex. Like any language, testing its robustness can
      be a challenge. Users will try many combinations of expressions. They
      will probably not understand the compiler error messages that refer to
      the internals we&#x2019;ve hidden behind the DSL.<indexterm>
          <primary>internal DSLs</primary>

          <seealso>DSLs</seealso>
        </indexterm></para>

      <para id="para_also_designing__good__dsls_is">Designing a quality DSL is
      difficult. With an API, you can follow the Scala library conventions for
      types, method names, etc. However, with a DSL, you&#x2019;re trying to imitate
      the language of a new domain. It&#x2019;s hard to get it right.</para>

      <para id="para_on_the_other_hand_a_well_desi">It&#x2019;s worth the effort,
      though. A well-designed DSL minimizes the translation effort between
      requirements and code, thereby improving communications with <phrase role="keep-together">stake</phrase><phrase role="keep-together">holders</phrase> about requirements. DSLs also
      facilitate rapid feature change and hide distracting implementation
      details. As always, there is a cost/benefit analysis you should make
      when deciding whether to use a DSL.</para>

      <para id="para_assuming_you_ve_made_the_go_">Assuming you&#x2019;ve made the
      &#x201C;go&#x201D; decision, a common problem in DSL design is the <emphasis>finishing
      problem</emphasis> (see <link linkend="Ford2009" xrefstyle="select:nopage">[Ford2009]</link>). How do you know when
      you&#x2019;ve finished building up the state of an instance and it&#x2019;s ready to
      use?<indexterm>
          <primary>finishing problem (in DSL design)</primary>
        </indexterm></para>

      <para id="para_we_solved_this_problem_in_two_">We solved this problem in
      two ways. First, we nested the calculation steps in a function literal.
      As soon as <literal>rules(employee)</literal> was invoked, the paycheck
      was built to completion. Also, all the steps were evaluated &#x201C;eagerly.&#x201D;
      We didn&#x2019;t need to put in all the rules, then run them at the end. Our
      only ordering requirement was the need to calculate the gross pay first,
      since the deductions are based on it. We enforced the correct order of
      invocation using instances of different types.</para>

      <para id="para_there_are_cases_where_you_can_">There are cases in which
      you can&#x2019;t evaluate the build steps eagerly. For example, a DSL that
      builds up a SQL query string can&#x2019;t run a query after each step of the
      build process. In this case, evaluation has to wait until the query
      string is completely built.</para>

      <para id="para_in_contrast_if_your_dsl_steps">By contrast, if your DSL
      steps are stateless, chained method invocation works just fine. In this
      case, it doesn&#x2019;t matter when you stop calling chained methods. If you
      chain methods that build up state, you&#x2019;ll have to add some sort of
      <literal>done</literal> method and trust the users to always use it at
      the end.<indexterm class="endofrange" startref="ch11_DSLinternal"/></para>
    </sect2>
  </sect1>

  <sect1 id="ExternalDSLsWithCombinatorParsers">
    <title>External DSLs with Parser Combinators</title>

    <para id="para_when_you_write_a_parser_for_an">When you write a parser for
    an external DSL, you can use a parser generator tool like Antlr (see <link linkend="Antlr" xrefstyle="select:nopage">[Antlr]</link>). However, the
    Scala library includes a powerful parser combinator library that can be
    used for parsing most external DSLs that have a context-free grammar. An
    attractive feature of this library is the way it defines an internal DSL
    that makes parser definitions look very similar to familiar grammar
    notations, like EBNF (Extended Backus-Naur Form&#x2014;see <link linkend="EBNF" xrefstyle="select:nopage">[BNF]</link>).<indexterm class="startofrange" id="ch11_parsercombinators">
        <primary>parser combinators, external DSLs with</primary>
      </indexterm><indexterm>
        <primary>external DSLs</primary>

        <seealso>DSLs</seealso>
      </indexterm><indexterm>
        <primary>context-free grammars</primary>
      </indexterm><indexterm>
        <primary>EBNF (Extended Backus-Naur Form) grammar notation</primary>
      </indexterm><indexterm class="startofrange" id="ch11_DSLexternal">
        <primary>DSLs (Domain-Specific Languages)</primary>

        <secondary>external DSLs with parser combinators</secondary>
      </indexterm></para>

    <sect2 id="_about_parser_combinators">
      <title>About Parser Combinators</title>

      <para id="para_parser_combinators_are_buildin">Parser combinators are
      building blocks for parsers. Parsers that handle specific kinds of
      input&#x2014;floating-point numbers, integers, etc.&#x2014;can be combined together to
      form other parser combinators for larger expressions. A combinator
      framework makes it easy to combine parsers to handle sequential and
      alternative cases, repetition, optional terms, etc.<indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>external DSLs with parser combinators</secondary>

          <tertiary>parser combinators</tertiary>
        </indexterm></para>

      <para id="para_other_references">We&#x2019;ll learn more about parsing
      techniques and terminology as we proceed. A complete exposition of
      parsing techniques is beyond our scope, but our example should get you
      started. You can find additional examples of parsers written using
      Scala&#x2019;s parser combinator library in <link linkend="Spiewak2009b" xrefstyle="select:nopage">[Spiewak2009b]</link>, <link linkend="Ghosh2008a" xrefstyle="select:nopage">[Ghosh2008a]</link>, and
      <link linkend="Odersky2008" xrefstyle="select:nopage">[Odersky2008]</link>.</para>
    </sect2>

    <sect2 id="APayrollExternalDSL">
      <title>A Payroll External DSL</title>

      <para id="para_comb_parser_example">For our parser combinator example,
      we&#x2019;ll reuse the example we just discussed for internal DSLs. We&#x2019;ll
      modify the grammar slightly, since our external DSL does not have to be
      valid Scala syntax. Other changes will make parser construction easier.
      Here&#x2019;s an example written in the external DSL:<indexterm class="startofrange" id="ch11_parsercombpayrollext">
          <primary>parser combinators, external DSLs with</primary>

          <secondary>payroll external DSL</secondary>
        </indexterm><indexterm class="startofrange" id="ch11_payrollexternalDSL">
          <primary>payroll external DSL (example)</primary>
        </indexterm><indexterm class="startofrange" id="ch11_DSLexternalpayroll">
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>external DSLs with parser combinators</secondary>

          <tertiary>payroll external DSL</tertiary>
        </indexterm></para>

      <screen>paycheck for employee "Buck Trends" is salary for 2 weeks minus deductions for {
  federal income tax            is  25.  percent of gross,
  state income tax              is  5.   percent of gross,
  insurance premiums            are 500. in gross currency,
  retirement fund contributions are 10.  percent of gross
}</screen>

      <para id="para_compare_this_example_of_our_ex">Compare this example to
      the internal DSL we defined in <xref linkend="APayrollInternalDSL"/>:</para>

      <programlisting linenumbering="unnumbered">... = rules { employee =&gt;
  employee salary_for 2.weeks minus_deductions_for { gross =&gt;
    federalIncomeTax            is  (25.  percent_of gross)
    stateIncomeTax              is  (5.   percent_of gross)
    insurancePremiums           are (500. in gross.currency)
    retirementFundContributions are (10.  percent_of gross)
  }
}
...</programlisting>

      <para id="para_in_our_new_dsl_we_insert_a_sp">In our new DSL, we insert
      a specific employee in the script. We wouldn&#x2019;t expect a user to copy and
      paste this script for every employee. A natural extension that we won&#x2019;t
      pursue would allow the user to loop over all salaried employees in a
      database, for example.</para>

      <para id="para_other_differences_include_remo">Some of the differences
      are &#x201C;gratuitous&#x201D;; we could have used the same syntax we used previously.
      These changes include removing underscores between words in some
      expressions and expanding camel-case words into space-separated words.
      That is, we turned some single words into multi-word expressions. We
      made these changes because they will be easy to implement using parser
      combinators, but using the same multi-word expressions would have added
      a lot of complexity to the internal DSL&#x2019;s implementation.</para>

      <para id="para_we_no_longer_need_local_vari">We no longer need &#x201C;local
      variables&#x201D; like <literal>employee</literal> and
      <literal>gross</literal>. Those words still appear in the DSL, but our
      parser will keep track of the corresponding instances internally.</para>

      <para id="para_the_remaining_changes_are_punc">The remaining changes are
      punctuation. It is still convenient to surround the list of deductions
      with curly braces. We now use a comma to separate the individual
      deductions, as that will make the parser&#x2019;s job easier. We can also drop
      the parentheses we used earlier.<indexterm>
          <primary>grammars</primary>

          <secondary>EBNF notation for external payroll DSL
          grammar</secondary>
        </indexterm></para>

      <para id="para_to_see_how_closely_the__intern">To see how closely the
      internal DSL for Scala&#x2019;s parser combinator library resembles the
      context-free grammar, let&#x2019;s start with the grammar itself, written in a
      variation of EBNF. We&#x2019;ll omit commas to separate sequences, for
      clarity:<indexterm>
          <primary>EBNF (Extended Backus-Naur Form) grammar notation</primary>

          <secondary>external payroll DSL grammar</secondary>
        </indexterm></para>

      <screen>paycheck = empl gross deduct;

empl = "paycheck" "for" "employee" employeeName;

gross = "is" "salary" "for" duration;

deduct = "minus" "deductions" "for" "{" deductItems "}";

employeeName = "\"" name " " name "\"";

name = ...

duration = decimalNumber weeksDays;

weeksDays = "week" | "weeks" | "day" | "days";

deductItems = &#x190; | deductItem { "," deductItem };

deductItem = deductKind deductAmount;

deductKind = tax | insurance | retirement;

tax = fedState "income" "tax";

fedState = "federal" | "state";

insurance = "insurance" "premiums";

retirement = "retirement" "fund" "contributions";

deductAmount = percentage | amount;

percentage = toBe doubleNumber "percent" "of" "gross";

amount = toBe doubleNumber "in" "gross" "currency";

toBe = "is" | "are";

decimalNumber = ...

doubleNumber = ...</screen>

      <para id="para_we_ll_see_that_most_of_the_tok">We can see that most of
      the <emphasis>terminals</emphasis> (the literal strings
      <literal>paycheck</literal>, <literal>for</literal>,
      <literal>employee</literal>, the characters <literal>{</literal> and
      <literal>}</literal>, etc.) will be bubble words, as defined in the
      previous section. We&#x2019;ll ignore these after parsing. The &#x190; is used to
      indicate an empty production for <literal>deductItems</literal>,
      although there will rarely be no deductions!<indexterm>
          <primary>terminals</primary>
        </indexterm></para>

      <para id="para_we_didn_t_spell_out_the_detail">We didn&#x2019;t spell out the
      details for decimal numbers, double numbers, and allowed letters in the
      employee names. We simply elided those definitions. We&#x2019;ll handle the
      details later.</para>

      <para id="para_each_line_in_the_grammar_defin">Each line in the grammar
      defines a <emphasis>production rule</emphasis>. The end of the
      definition is marked with a semicolon. A
      <emphasis>nonterminal</emphasis> appears on the lefthand side of the
      equals sign. The righthand side consists of terminals (e.g., the literal
      strings and characters we just mentioned) that require no further
      parsing, other nonterminals (including possibly a <phrase role="keep-together">recursive</phrase> <phrase role="keep-together">reference</phrase> to the lefthand side
      nonterminal), and operators that express relationships between the
      items. Notice that the grammar forms have a hierarchical <phrase role="keep-together">decomposition</phrase>, although not a directed
      acyclic graph, as generally speaking these <phrase role="keep-together">grammars</phrase> can have cycles.<indexterm>
          <primary>; (semicolon)</primary>

          <secondary>ending production rule definitions</secondary>
        </indexterm><indexterm>
          <primary>nonterminals</primary>
        </indexterm><indexterm>
          <primary>production rules</primary>
        </indexterm></para>

      <para id="para_we_have_a_context_free_grammar">We have a context-free
      grammar because every production rule has a single nonterminal on the
      lefthand side of the equals sign, i.e., without any additional context
      information required to specify the production&#x2019;s applicability and
      meaning.</para>

      <para id="para_productions_like_tobe_is_">Production rules like
      <literal>toBe = "is" | "are"</literal> mean the <literal>is</literal>
      production (a terminal in this case) <emphasis>or</emphasis> the
      <literal>are</literal> production will match. This is an example of an
      <emphasis>alternative composition</emphasis>.<indexterm>
          <primary>alternative composition</primary>
        </indexterm></para>

      <para id="para_when_productions_are_separated">When productions are
      separated by white space on the righthand side of another production,
      e.g., <literal>prod1 prod2</literal>, both productions are required to
      appear sequentially for a match. (Most EBNF formats actually require a
      comma to separate these items.) Hence, these expressions are more like
      &#x201C;and&#x201D; expressions, but <emphasis>sequential composition</emphasis> is so
      common that no <literal>&amp;</literal> operator is used, the analog of
      <literal>|</literal> for alternative composition.<indexterm>
          <primary>sequential composition</primary>
        </indexterm></para>

      <para id="para_the_production_deductitem">The production rule with
      <literal>"{" deductItem { "," deductItem } "}"</literal> demonstrates
      how to specify optional (zero or more) repetitions. This expression
      matches a literal <literal>{</literal> character, followed by a
      <literal>deductItem</literal> (another production), followed by zero or
      more expressions consisting of a literal comma <literal>,</literal> and
      another <literal>deductItem</literal>, and finally ending with a literal
      <literal>}</literal> character. Sometimes an asterisk is used to
      indicate repetition zero or more times, e.g., <literal>prod *</literal>.
      For repetition at least once, <literal>prod +</literal> is sometimes
      used.<indexterm>
          <primary>+ (plus sign)</primary>

          <secondary>specifying at least one repetition in production
          rule</secondary>
        </indexterm><indexterm>
          <primary>* (asterisk)</primary>

          <secondary>zero or more repetitions in production rule</secondary>
        </indexterm></para>

      <para id="para_finally_if_we_had_optional_te">Finally, if we had
      optional items in our grammar, we would enclose them in square brackets,
      <literal>[...]</literal>. There are other kinds of composition operators
      possible (and <phrase role="keep-together">supported</phrase> in the
      Scala library), a few of which we&#x2019;ll discuss. See the <link linkend="ScalaAPI2008" role="keep-together" xrefstyle="select:nopage">[ScalaAPI2008]</link> entry for
      <literal>Parsers</literal> for more details.<indexterm class="endofrange" startref="ch11_parsercombpayrollext"/><indexterm>
          <primary>Parsers object</primary>

          <secondary>documentation of composition operators</secondary>
        </indexterm><indexterm>
          <primary>[ ] (square brackets)</primary>

          <secondary>enclosing optional items in parser grammar</secondary>
        </indexterm><indexterm class="endofrange" startref="ch11_payrollexternalDSL"/><indexterm class="endofrange" startref="ch11_DSLexternalpayroll"/></para>
    </sect2>

    <sect2 id="AScalaImplementationExternalDSLGrammar">
      <title>A Scala Implementation of the External DSL Grammar</title>

      <para id="para_here_is_the_parser_written_usi">Here is the parser
      written using Scala&#x2019;s parser combinators. At this point, we won&#x2019;t do
      anything to actually calculate an employee&#x2019;s paycheck, so we&#x2019;ll append
      <literal>V1</literal> to the class name:<indexterm class="startofrange" id="ch11_parsercombScala">
          <primary>parser combinators, external DSLs with</primary>

          <secondary>Scala implementation of external DSL grammar</secondary>
        </indexterm><indexterm class="startofrange" id="ch11_DSLsparser">
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>external DSLs with parser combinators</secondary>

          <tertiary>Scala implementation of external DSL grammar</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb-v1.scala

package payroll.pcdsl
import scala.util.parsing.combinator._
import org.specs._
import payroll._
import payroll.Type2Money._

class PayrollParserCombinatorsV1 extends JavaTokenParsers {

  def paycheck = empl ~ gross ~ deduct

  def empl = "paycheck" ~&gt; "for" ~&gt; "employee" ~&gt; employeeName

  def gross = "is" ~&gt; "salary" ~&gt; "for" ~&gt; duration

  def deduct = "minus" ~&gt; "deductions" ~&gt; "for" ~&gt; "{" ~&gt; deductItems  &lt;~ "}"

  // stringLiteral provided by JavaTokenParsers
  def employeeName = stringLiteral

  // decimalNumber provided by JavaTokenParsers
  def duration = decimalNumber ~ weeksDays

  def weeksDays = "weeks" | "week" | "days" | "day"

  def deductItems = repsep(deductItem, "," )

  def deductItem = deductKind ~&gt; deductAmount

  def deductKind = tax | insurance | retirement

  def tax = fedState &lt;~ "income" &lt;~ "tax"

  def fedState = "federal" | "state"

  def insurance = "insurance" ~&gt; "premiums"

  def retirement = "retirement" ~&gt; "fund" ~&gt; "contributions"

  def deductAmount = percentage | amount

  def percentage = toBe ~&gt; doubleNumber &lt;~ "percent" &lt;~ "of" &lt;~ "gross"

  def amount = toBe ~&gt; doubleNumber &lt;~ "in" &lt;~ "gross" &lt;~ "currency"

  def toBe = "is" | "are"

  // floatingPointNumber provided by JavaTokenParsers
  def doubleNumber = floatingPointNumber
}</programlisting>

      <para id="para_the_body_of_payrollparsercomb">The body of
      <literal>PayrollParserCombinatorsV1</literal> looks very similar to the
      grammar we defined for the DSL. Each production rule becomes a method.
      The terminating semicolon is dropped, but since the production is a
      method, it would be valid Scala to leave it in.</para>

      <para id="para_where_we_had_whitespace_betwee">Where we had whitespace
      between each production on the righthand side, we now use a combinator
      operator, either <literal>&#x223C;</literal>, <literal>&#x223C;&gt;</literal>, or
      <literal>&lt;&#x223C;</literal>. The combinator for sequential composition is
      <literal>&#x223C;</literal>, used when we want to retain for further processing
      the results produced by both productions on the left and right sides of
      the <literal>&#x223C;</literal>. For example, when processing the
      <literal>paycheck</literal> production, we want to keep all three
      results from <literal>empl</literal>, <literal>gross</literal>, and
      <literal>deduct</literal>. Hence we use two <literal>&#x223C;</literal>
      operators:<indexterm>
          <primary>sequential composition</primary>

          <secondary>combinator operators</secondary>
        </indexterm><indexterm>
          <primary>~ (tilde)</primary>

          <secondary>~, ~&gt;, and &lt;~ combinator operators</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">def paycheck = empl ~ gross ~ deduct</programlisting>

      <para id="para_we_use_another_sequential_comp">We use another sequential
      composition combinator <literal>&#x223C;&gt;</literal> when we no longer need
      the result of the production to the <emphasis>left</emphasis>. For
      example, when processing the <literal>empl</literal> production, we only
      want to keep the parse result for the last production,
      <literal>employeeName</literal>:</para>

      <programlisting linenumbering="unnumbered">def empl = "paycheck" ~&gt; "for" ~&gt; "employee" ~&gt; employeeName</programlisting>

      <para id="para_similarly_we_use_when_we">Similarly, we use
      <literal>&lt;&#x223C;</literal> when we no longer need the result for the
      production to the <emphasis>right</emphasis>. For example, when
      processing the <literal>tax</literal> production, we only want to keep
      the result of the first production, <literal>fedState</literal>:</para>

      <programlisting linenumbering="unnumbered">def tax = fedState &lt;~ "income" &lt;~ "tax"</programlisting>

      <para id="para_our_heavy_use_of_sequenti">Our heavy use of the
      <literal>&lt;&#x223C;</literal> sequential combinator in the various
      productions related to deductions indicates that we aren&#x2019;t keeping track
      of the source of each deduction, just the amount of the deduction. A
      real paycheck application would print this information, of course. Our
      aim is for simplicity. As an exercise, consider how
      <literal>PayrollParserCombi&#x2060;natorsV1</literal> and the subsequent
      refinements below would change if we tracked this information. Would you
      necessarily keep the parsed strings or track the information some other
      way?</para>

      <para id="para_the_or_case_is_expressed_w">The &#x201C;or&#x201D; case is expressed
      with the <literal>|</literal> method, just as in the grammar:<indexterm>
          <primary>| (vertical bar)</primary>

          <secondary>or case in parser grammar</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">def weeksDays = "weeks" | "week" | "days" | "day"</programlisting>

      <para id="para_the_rep_method_can_be_used_f">The <literal>rep</literal>
      method can be used for zero or more repetitions. We actually use a
      similar method, <literal>repsep</literal>, which lets us specify a
      separator, in our case a comma (<literal>,</literal>):</para>

      <programlisting linenumbering="unnumbered">def deduct = ... ~&gt; "{" ~&gt; repsep(deductItem, "," ) &lt;~ "}"</programlisting>

      <para id="para_note_that_deduct_combines_se">Note that
      <literal>deduct</literal> combines several features we have just
      described.</para>

      <para id="para_like_repetition_there_is_an_">Like repetition, there is
      an <literal>opt</literal> method for optional terms, which we aren&#x2019;t
      using.</para>

      <para id="para__payrollparsercombinatorsv1_i"><literal>PayrollParserCombinatorsV1</literal>
      inherits from <literal>JavaTokenParsers</literal>, which inherits from
      <literal>RegexParsers</literal>, which inherits from the root parser
      trait <literal>Parsers</literal>. It&#x2019;s well known that parsing
      non-trivial grammars with just regular expressions tends to break down
      pretty quickly. However, using regular expressions to parse individual
      terms inside a parsing framework can be very effective. In our example,
      we exploit the productions in <literal role="keep-together">JavaTokenParsers</literal> to parse quoted strings
      (for the employee&#x2019;s name), decimal literals, and floating-point
      literals.<indexterm>
          <primary>Parsers object</primary>
        </indexterm><indexterm>
          <primary>JavaTokenParsers</primary>
        </indexterm><indexterm>
          <primary>regular expressions</primary>

          <secondary>use in parsing</secondary>
        </indexterm></para>

      <para id="para_let_s_try_it_out_here_is_a_sp">Let&#x2019;s try it out! Here is
      a specification that exercises the parser for two cases, without and
      with deductions:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb-v1-spec.scala

package payroll.pcdsl
import scala.util.parsing.combinator._
import org.specs._
import payroll._
import payroll.Type2Money._

object PayrollParserCombinatorsV1Spec
  extends Specification("PayrollParserCombinatorsV1") {

  "PayrollParserCombinatorsV1" should {
    "parse rules when there are no deductions" in {
      val input = """paycheck for employee "Buck Trends"
                     is salary for 2 weeks minus deductions for {}"""
      val p = new PayrollParserCombinatorsV1
      p.parseAll(p.paycheck, input) match {
        case p.Success(r,_) =&gt; r.toString mustEqual
                    """(("Buck Trends"~(2~weeks))~List())"""
        case x =&gt; fail(x.toString)
      }
    }

    "calculate the gross, net, and deductions for the pay period" in {
      val input =
          """paycheck for employee "Buck Trends"
             is salary for 2 weeks minus deductions for {
               federal income tax            is  25.  percent of gross,
               state income tax              is  5.   percent of gross,
               insurance premiums            are 500. in gross currency,
               retirement fund contributions are 10.  percent of gross
             }"""
      val p = new PayrollParserCombinatorsV1
      p.parseAll(p.paycheck, input) match {
        case p.Success(r,_) =&gt; r.toString mustEqual
            """(("Buck Trends"~(2~weeks))~List(25., 5., 500., 10.))"""
        case x =&gt; fail(x.toString)
      }
    }
  }
}</programlisting>

      <para id="para_this_part_of_the_specification">This part of the
      specification shows us how to instantiate and use the parser:</para>

      <programlisting linenumbering="unnumbered">val p = new PayrollParserCombinatorsV1

p.parseAll(p.paycheck, input) match {
  case p.Success(r,_) =&gt; r.toString mustEqual "..."
  case x =&gt; fail(x.toString)
}</programlisting>

      <para id="para_the_parseall_method_is_defin">The
      <literal>parseAll</literal> method is defined in a parent class. We
      invoke the top-level production method, <literal>paycheck</literal>, and
      pass its return value as the first argument to
      <literal>parseAll</literal> and pass the string to parse as the second
      argument.</para>

      <para id="para_if_the_parsing_process_is_succ">If the parsing process is
      successful, the result of the parse is returned as an instance of type
      <literal>p.Success[+T]</literal>, a case class declared in the
      <literal>Parsers</literal> trait. Why is there a <literal>p.</literal>
      prefix? It indicates that <literal>p.Success</literal> is a
      <emphasis>path-dependent type</emphasis>, which we will discuss in <xref linkend="PathDependentTypes"/>. For now, just know that even though
      <literal>Success</literal> is defined in the <literal>Parsers</literal>
      trait, the actual type of the instance is dependent on the
      <literal>PayrollParserCombinatorsV1</literal> instance we created. In
      other words, if we had another parser, <phrase role="keep-together">say
      <literal>p2</literal> </phrase>of type <literal>MyOtherParser</literal>,
      then <literal>p2.Success[String]</literal> would be different from
      <literal role="keep-together">p.Success[String]</literal> and one could
      not be substituted for the other.<indexterm>
          <primary>path-dependent types</primary>

          <secondary>p.Success case class (example)</secondary>
        </indexterm></para>

      <para id="para_the_success_object_contains_">The
      <literal>Success</literal> instance contains two fields. The first is
      the result of the parse, an instance of type <literal>T</literal>
      (assigned to <literal>r</literal> in the <literal>case</literal>
      clause). The second is the remaining input string to parse, which will
      be empty after a successful parse (we will have parsed the whole string
      at this point). This string is assigned to <literal>_</literal>.</para>

      <para id="para_if_the_parse_fails_the_return">If the parse fails, the
      returned instance is either a <literal>p.Failure</literal> or
      <literal>p.Error</literal>, which our example handles with a generic
      <literal>case</literal> clause. Both are derived from
      <literal>p.NoSuccess</literal>, which contains fields for an error
      message and the unconsumed input at the point of failure. A
      <literal>p.Failure</literal> in a parser will trigger backtracking so
      that a retry with a different parser can be invoked by the parser
      framework, if possible. An <literal>Error</literal> result does not
      trigger backtracking and is used to signal more serious problems.</para>

      <para id="para_for_completeness_both_p_succ">For completeness, both
      <literal>p.Success</literal> and <literal>p.NoSuccess</literal> derive
      from <literal>p.ParseResult</literal>.</para>

      <para id="para_we_have_left_two_big_unanswere">We have two big
      unanswered questions: what do the production methods actually return,
      and what is the type of the result instance returned in the
      <literal>p.Success</literal>?</para>

      <para id="para_the_production_methods_themsel">The production methods
      themselves return parsers. Most of them in our example return
      <literal>p.Parser[String]</literal> (again, a path-dependent type).
      However, because the <literal>deduct</literal> method handles repetition
      (it invokes the <literal>repsep</literal> method), it actually returns a
      <literal>p.Parser[List[String]]</literal>. When this parser is used, it
      will return a <literal>List[String]</literal>, with one string
      corresponding to each match in the repetition.</para>

      <para id="para_so_our_call_to_p_parseall_p_">So, our call to
      <literal>p.parseAll(p.paycheck, input)</literal> earlier parses the
      <literal>input</literal> string using the parser returned by
      <literal>p.paycheck</literal>. That brings us to the second question:
      what is the result of a successful parse?</para>

      <para id="para_to_see_what_s_returned_compil">To see what&#x2019;s returned,
      compile the <filename>PayrollParserCombinatorsV1</filename> file listed
      at the beginning of this section and invoke the <literal>scala</literal>
      interpreter with the <literal>-cp</literal> option to include the
      directory where the class files were written (it will be
      <filename>build</filename> if you used the build process for the code
      example distribution).</para>

      <para id="para_once_in_the_interpreter_enter">Once in the interpreter,
      enter the following expressions after the <literal>scala&gt;</literal>
      prompt. (You can also find this input the
      <filename>payroll-parser-comb-script.scala</filename> file in the code
      example distribution.)</para>

      <screen>scala&gt; import scala.util.parsing.combinator._
import scala.util.parsing.combinator._

scala&gt; import payroll.pcdsl._
import payroll.pcdsl._

scala&gt; val p = new PayrollParserCombinatorsV1
p: payroll.pcdsl.PayrollParserCombinatorsV1 = \
    payroll.pcdsl.PayrollParserCombinatorsV1@79e84310

scala&gt; p.empl
res0: p.Parser[String] = Parser (~&gt;)

scala&gt; p.weeksDays
res2: p.Parser[String] = Parser (|)

scala&gt; p.doubleNumber
res3: p.Parser[String] = Parser ()

scala&gt; p.deduct
res1: p.Parser[List[String]] = Parser (&lt;~)

scala&gt; p.paycheck
res4: p.Parser[p.~[p.~[String,p.~[String,String]],List[String]]] = Parser (~)

scala&gt; p.parseAll(p.weeksDays, "weeks")
res5: p.ParseResult[String] = [1.6] parsed: weeks

scala&gt; val input = """paycheck for employee "Buck Trends"
     | is salary for 2 weeks minus deductions for {}"""
input: java.lang.String =
paycheck for employee "Buck Trends"
       is salary for 2 weeks minus deductions for {}

scala&gt; p.parseAll(p.paycheck, input)
res6: p.ParseResult[p.~[p.~[String,p.~[String,String]],List[String]]] = \
    [2.53] parsed: (("Buck Trends"~(2~weeks))~List())

scala&gt;</screen>

      <para id="para_we_import_types_we_need_and_cr">We import the necessary
      types and create a <literal>PayrollParserCombinatorsV1</literal>
      instance. Then we call several of the production methods to see what
      kind of <literal>Parser</literal> each returns. The first
      three&#x2014;<literal>empl</literal>, <literal>weeksDays</literal>, and
      <literal>doubleNumber</literal>&#x2014;return
      <literal>p.Parser[String]</literal>.</para>

      <para id="para_note_what_s_written_on_the_rig">Note what&#x2019;s written on
      the righthand side in the output for the first three parsers:
      <literal>empl</literal>, <literal>weeksDays</literal>, and
      <literal>doubleNumber</literal>. We see <literal>Parser
      (&#x223C;&gt;)</literal>, <literal>Parser (|)</literal>, and <literal>Parser
      ()</literal>, respectively. The parsers returned reflect the definitions
      of the production rules, where <literal>empl</literal> ends with a
      combinator of the form <literal>prod1 &#x223C;&gt; prod2</literal>,
      <literal>weeksDays</literal> returns a combinator of the form
      <literal>prod1 | prod2</literal>, and <literal>doubleNumber</literal>
      returns a parser for a single production.</para>

      <para id="para_because_deduct_consists_of_c">Because
      <literal>deduct</literal> consists of combinators that handle
      repetition, the parser returned by <literal>deduct</literal> is of type
      <literal>p.Parser[List[String]]</literal>, as we stated previously. The
      righthand side of the output is <literal>Parser (&lt;&#x223C;)</literal>,
      because the definition of <literal>deduct</literal> ends with
      <literal>prod1 &lt;&#x223C; prod2</literal>.</para>

      <para id="para_things_get_more_interesting_wh">Things get more
      interesting when we look at the top-level production,
      <literal>paycheck</literal>. What is
      <literal>p.Parser[p.&#x223C;[p.&#x223C;[String,p.&#x223C;[String,String]],List[String]]] =
      Parser (&#x223C;)</literal> <phrase role="keep-together">supposed</phrase> to
      mean? Well, the righthand side should be easy to understand now; the
      definition of <literal>paycheck</literal> ends in <literal>prod1 &#x223C;
      prod2</literal>. What is the type parameter for
      <literal>p.Parser</literal> on the lefthand side of the equals
      sign?</para>

      <para id="para_the_parser_trait_also_define">The
      <literal>Parsers</literal> trait also defines a case class named
      <literal>&#x223C;</literal> that represents a pair of sequential
      rules:<indexterm>
          <primary>Parsers object</primary>

          <secondary>~ case class</secondary>
        </indexterm><indexterm>
          <primary>~ (tilde)</primary>

          <secondary>case class defined by Parsers trait</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">case class ~[+a, +b](_1: a, _2: b) {
  override def toString = "("+ _1 +"~"+ _2 +")"
}</programlisting>

      <para id="para_the_actual_path_dependent_type">The actual path-dependent
      type in our example is <literal>p.&#x223C;[+a,+b]</literal>. Hence, the type
      parameter <literal>T</literal> in <literal>p.Parser[T]</literal> is
      <literal>p.&#x223C;[p.&#x223C;[String,p.&#x223C;[String,String]],List[String]]</literal>,
      which is a hierarchical tree of types.</para>

      <para id="para_let_s_break_it_down_working_o">Let&#x2019;s break it down,
      working our way inside out. Note that there are three
      <literal>p.&#x223C;</literal>. We&#x2019;ll start with the innermost type,
      <literal>p.&#x223C;[String,String]</literal>, and map the type declaration to
      the output we saw in the <literal>scala</literal> session <literal>"Buck
      Trends"&#x223C;(2&#x223C;weeks&#x223C;List())</literal>.</para>

      <para id="para_the_p_string_string_corre">The
      <literal>p.&#x223C;[String,String]</literal> corresponds to the parser that
      handles expressions like <literal role="keep-together">2
      weeks</literal>. Hence, the instance created when we parsed our example
      string was the instance <literal>p.&#x223C;("2", "weeks")</literal>. Calling
      the <literal>p.&#x223C;.toString</literal> method produces the output
      <literal>(2~weeks)</literal>.</para>

      <para id="para_working_out_one_level_we_have">Working out one level, we
      have <literal>p.&#x223C;[String,p.&#x223C;[String,String]]</literal>. This combination
      parses <literal>paycheck for employee "Buck Trends" is salary for 2
      weeks</literal>. Recall that we discard <literal>paycheck for
      employee</literal> and <literal>is salary for</literal>, keeping only
      the <literal>Buck Trends</literal> and <literal>2 weeks</literal>. So we
      create an instance <literal>p.&#x223C;("Buck Trends", p.&#x223C;("2",
      "weeks"))</literal>. Calling <literal>toString</literal> again results
      in the string <literal>("Buck Trends"&#x223C;(2&#x223C;weeks))</literal>.</para>

      <para id="para_finally_at_the_outer_level_of">Finally, at the outermost
      level, you can see we have the following:
      <literal>p.&#x223C;[p.&#x223C;[String,p.&#x223C;[String,String]],List[String]]</literal>.
      We&#x2019;ve already discussed everything up to the last
      <literal>List[String]</literal>, which comes from the
      <literal>deduct</literal> production:</para>

      <programlisting linenumbering="unnumbered">def deduct = "minus" ~&gt; "deductions" ~&gt; "for" ~&gt;
             "{" ~&gt; repsep(deductItem, "," ) &lt;~ "}"</programlisting>

      <para id="para_we_discard_everything_except_f">We discard everything
      except for the list of zero or more <literal>deductItems</literal>.
      There are none in our example, so we get an empty list for which
      <literal>toString</literal> returns <literal>List()</literal>.
      Therefore, calling <literal>p.&#x223C;.toString</literal> on our outermost
      type, the one that parameterizes <literal>p.Parser</literal>, <phrase role="keep-together">returns</phrase> the string <literal>"Buck
      Trends"&#x223C;(2&#x223C;weeks&#x223C;List())</literal>. We&#x2019;re done!</para>

      <para id="para_well_not_quite_we_re_still_n">Well, not quite. We&#x2019;re
      still not calculating an actual paycheck for ol&#x2019; Buck. Let&#x2019;s <phrase role="keep-together">complete</phrase> our implementation.<indexterm class="endofrange" startref="ch11_parsercombScala"/><indexterm class="endofrange" startref="ch11_DSLsparser"/></para>
    </sect2>

    <sect2 id="_generating_paychecks_with_the_external_dsl">
      <title>Generating Paychecks with the External DSL</title>

      <para id="para_as_we_parse_the_dsl_we_want_t">As we parse the DSL, we
      want to look up the employee by name, fetch his or her gross salary for
      the specified pay period, and then calculate the deductions as we go.
      When the parser returned by <literal>paycheck</literal> finishes, we
      want to return a <literal>Pair</literal> with the
      <literal>Employee</literal> instance and the completed
      <literal>Paycheck</literal>.<indexterm class="startofrange" id="ch11_parsersfinal">
          <primary>parser combinators, external DSLs with</primary>

          <secondary>generating paychecks with
          PayrollParserCombinators</secondary>
        </indexterm><indexterm class="startofrange" id="ch11_DSLexternalpaycheck">
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>external DSLs with parser combinators</secondary>

          <tertiary>generating paychecks with external DSL</tertiary>
        </indexterm></para>

      <para id="para_we_will_reuse_domain_class">We will reuse &#x201C;domain&#x201D;
      classes like <literal>Employee</literal>, <literal>Money</literal>,
      <literal>Paycheck</literal>, etc. from earlier in the chapter. To do the
      calculations on demand, we will create a second iteration of <literal role="keep-together">PayrollParserCombinatorsV1</literal> that we&#x2019;ll
      call <literal>PayrollParserCombinators</literal>. We&#x2019;ll modify the
      parsers returned by some of the production methods to return new kinds
      of parsers. We&#x2019;ll also do administrative work like storing running
      context data, as needed. Our implementation won&#x2019;t be thread-safe. You&#x2019;ll
      want to ensure that only one thread uses a given
      <literal>PayrollParserCombinators</literal>. We could make it more
      robust, but doing so isn&#x2019;t the goal of this exercise.</para>

      <para id="para_here_is_our_final_payrollpars">Here is our final
      <literal>PayrollParserCombinators</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb.scala

package payroll.pcdsl
import scala.util.parsing.combinator._
import org.specs._
import payroll._
import payroll.Type2Money._

class UnknownEmployee(name: Name) extends RuntimeException(name.toString)

class PayrollParserCombinators(val employees: Map[Name, Employee])
  extends JavaTokenParsers {

  var currentEmployee: Employee = null
  var grossAmount: Money = Money(0)

  /** @return Parser[(Employee, Paycheck)] */
  def paycheck = empl ~ gross ~ deduct ^^ {
    case e ~ g ~ d =&gt; (e, Paycheck(g, g-d, d))
  }

  /** @return Parser[Employee] */
  def empl = "paycheck" ~&gt; "for" ~&gt; "employee" ~&gt; employeeName ^^ { name =&gt;
    val names = name.substring(1, name.length-1).split(" ") // remove ""
    val n = Name(names(0), names(1));
    if (! employees.contains(n))
      throw new UnknownEmployee(n)
    currentEmployee = employees(n)
    currentEmployee
  }

  /** @return Parser[Money] */
  def gross = "is" ~&gt; "salary" ~&gt; "for" ~&gt; duration ^^ { dur =&gt;
    grossAmount = salaryForDays(dur)
    grossAmount
  }

  def deduct = "minus" ~&gt; "deductions" ~&gt; "for" ~&gt; "{" ~&gt; deductItems  &lt;~ "}"

  /**
   * "stringLiteral" provided by JavaTokenParsers
   * @return Parser[String]
   */
  def employeeName = stringLiteral

  /**
   * "decimalNumber" provided by JavaTokenParsers
   * @return Parser[Int]
   */
  def duration = decimalNumber ~ weeksDays ^^ {
    case n ~ factor =&gt; n.toInt * factor
  }

  def weeksDays = weeks | days

  def weeks = "weeks?".r ^^ { _ =&gt; 5 }

  def days = "days?".r ^^ { _ =&gt; 1 }

  /** @return Parser[Money] */
  def deductItems = repsep(deductItem, ",") ^^ { items =&gt;
    items.foldLeft(Money(0)) {_ + _}
  }

  /** @return Parser[Money] */
  def deductItem = deductKind ~&gt; deductAmount

  def deductKind = tax | insurance | retirement

  def tax = fedState &lt;~ "income" &lt;~ "tax"

  def fedState = "federal" | "state"

  def insurance = "insurance" ~&gt; "premiums"

  def retirement = "retirement" ~&gt; "fund" ~&gt; "contributions"

  def deductAmount = percentage | amount

  /** @return Parser[Money] */
  def percentage = toBe ~&gt; doubleNumber &lt;~ "percent" &lt;~ "of" &lt;~ "gross"  ^^ {
    percentage =&gt; grossAmount * (percentage / 100.)
  }

  def amount = toBe ~&gt; doubleNumber &lt;~ "in" &lt;~ "gross" &lt;~ "currency" ^^ {
    Money(_)
  }

  def toBe = "is" | "are"

  def doubleNumber = floatingPointNumber ^^ { _.toDouble }

  // Support method. Assume 260 (52 * 5) paid work days/year
  def salaryForDays(days: Int) =
      (currentEmployee.annualGrossSalary / 260.0) * days
}</programlisting>

      <para id="para_for_simplicity_we_ll_use_a_ma">For simplicity, we&#x2019;ll use
      a map of &#x201C;known&#x201D; employees, keyed by <literal>Name</literal> instances,
      that we save as a field in <literal>PayrollParserCombinators</literal>.
      A real implementation would probably use a data store of some
      kind.</para>

      <para id="para_there_are_two_other_fields_c">There are two other fields:
      <literal>currentEmployee</literal>, which remembers which employee we
      are processing, and <literal>grossAmount</literal>, which remembers the
      gross amount of pay for the employee for the pay period. Both fields
      have a slight <emphasis>design smell</emphasis>. They are mutable. They
      are set only once per parse, but not when they are declared, only when
      we parse the input that allows us to calculate them. You might have also
      noticed that if the same <literal>PayrollParserCombinators</literal>
      instance is used more than once, we don&#x2019;t reset these fields to their
      default values. No doubt it would be possible to write scripts in the
      DSL that exploit this bug.</para>

      <para id="para_these_weaknesses_are_not_inher">These weaknesses are not
      inherent to parser combinators. They reflect simplifications we used for
      our purposes. As an exercise, you might try improving the implementation
      to eliminate these weaknesses.</para>

      <para id="para_we_have_added_javadoc_style_">We have added Javadoc-style
      <literal>@return</literal> annotations for most of the productions to
      make it clear what they are now returning. In some cases, the
      productions are unchanged, as the original parser instances are fine as
      is. Most of the changes reflect our desire to calculate the paycheck as
      we go.<indexterm>
          <primary sortas="return annotations">@return annotation</primary>
        </indexterm><indexterm>
          <primary>Javadoc-style @return annotation</primary>
        </indexterm></para>

      <?dbfo-need height=”1in”
?>

      <para id="para_consider_the_new_paycheck_pr">Consider the new
      <literal>paycheck</literal> production:</para>

      <programlisting linenumbering="unnumbered">/** @return Parser[(Employee, Paycheck)] */
def paycheck = empl ~ gross ~ deduct ^^ {
  case e ~ g ~ d =&gt; (e, Paycheck(g, g-d, d))
}</programlisting>

      <para id="para_now_we_return_a_pair_with_th">Now, we return a
      <literal>Pair</literal> with the <literal>Employee</literal> and the
      computed <literal>Paycheck</literal>. The <literal>empl &#x223C; gross &#x223C;
      deduct</literal> combination would still return
      <literal>Parser[String]</literal> (we&#x2019;ll drop the <phrase role="keep-together">path-</phrase><phrase role="keep-together">dependent</phrase> prefix for now). We have added a
      new combinator <literal>^^</literal>, e.g., <literal>prod1 ^^
      func1</literal>, where <literal>func1</literal> is a function. If
      <literal>prod1</literal> succeeds, then the result of applying
      <literal>func1</literal> to the result of <literal>prod1</literal> is
      returned. That is, we return <literal>func1(prod1)</literal>.</para>

      <para id="para_for_paycheck_we_give_it_a_f">For
      <literal>paycheck</literal>, we give it a function literal that does a
      pattern match to extract the three results from <literal>empl</literal>,
      <literal>gross</literal>, and <literal>deduct</literal>, respectively.
      We create a 2-tuple (<literal>Pair</literal>) with <literal>e</literal>,
      the <literal>Employee</literal>, and a <literal>Paycheck</literal>
      calculated from the gross salary for the pay period (in
      <literal>g</literal>) and the sum of all the deductions (in
      <literal>d</literal>).</para>

      <para id="para_it_s_important_to_keep_clear_t">It&#x2019;s important to keep
      clear that the anonymous function passed as an argument to
      <literal>^^</literal> returns a tuple <literal>(Employee,
      Paycheck)</literal>, but the production <literal>paycheck</literal>
      method itself returns a <literal>Parser[(Employee, Paycheck)]</literal>.
      This pattern has been true from the beginning, actually, where
      <literal>Strings</literal> were always involved in our first version. It
      will remain true for all the production rules in
      <literal>PayrollParserCombinators</literal>.</para>

      <para id="para_the_empl_production_assumes_">The <literal>empl</literal>
      production assumes the employee&#x2019;s first name and last name are given.
      (Obviously, this would be inadequate in a real application.)</para>

      <programlisting linenumbering="unnumbered">/** @return Parser[Employee] */
def empl = "paycheck" ~&gt; "for" ~&gt; "employee" ~&gt; employeeName ^^ { name =&gt;
   val names = name.substring(1, name.length-1).split(" ") // remove ""
   val n = Name(names(0), names(1));
   if (! employees.contains(n))
     throw new UnknownEmployee(n)
   currentEmployee = employees(n)
   currentEmployee
}</programlisting>

      <para id="para_to_construct_the_name_the_emb">To construct the name, the
      embedded double quotes have to be removed, which is why we start by
      extracting the substring that tosses the first and last characters. The
      name is used to look up the <literal>Employee</literal> instance in the
      map, saving the value in the <literal>currentEm&#x2060;ployee</literal> field.
      In general, there is not a lot of &#x201C;graceful&#x201D; error handling in
      <literal>PayrollParserCombinators</literal>. However, the
      <literal>empl</literal> method handles the case where no employee is
      found with the specified name, throwing an
      <literal>UnknownEmployee</literal> exception when this <phrase role="keep-together">occurs</phrase>.</para>

      <para id="para_the_rest_of_the_productions_wo">The rest of the
      productions work similarly. Sometimes, a parser converts an input string
      to an <literal>Int</literal> (e.g., <literal>duration</literal>) or a
      <literal>Money</literal> (e.g., <literal>gross</literal>). An
      interesting case is <literal>deduct</literal>. It folds the list of
      deductions into a single deduction amount, using addition. The
      <literal>foldLeft</literal> method takes two argument lists. The first
      has a single argument that specifies the initial value, in this case,
      zero <literal>Money</literal>. The second argument list has a single
      function literal argument that takes two arguments: the accumulated
      value of the folding operation, and an item from the list. In this case,
      we return the sum of the arguments. So, <literal role="keep-together">foldLeft</literal> iterates over the
      <literal>items</literal> collection, adding them together. See <xref linkend="TraversingMappingFilteringFolding"/> for more information on
      <literal>foldLeft</literal> and related operations.</para>

      <para id="para_the_weeks_and_days_product">The <literal>weeks</literal>
      and <literal>days</literal> productions remind us that we are using
      parser combinators based on regular-expressions. (We&#x2019;re also using
      <literal>stringLiteral</literal>, <literal>decimalNumber</literal>, and
      <literal>floatingPointNumber</literal> provided by
      <literal>JavaTokenParsers</literal>.) Note that <literal>weeks</literal>
      and <literal>days</literal> ignore the parsed string. They just return a
      multiplication factor used to determine total days in the pay period in
      the <literal>duration</literal> production rule.</para>

      <para id="para_there_are_other_combinator_met">There are other
      combinator methods for applying functions to parser results in different
      ways. See the <literal>Parsers</literal> Scaladoc page for
      details.</para>

      <para id="para_the_following_specification_w">The following (somewhat
      incomplete) specification shows the calculation of paychecks when there
      are no deductions and when there are several deductions:</para>

      <programlisting linenumbering="unnumbered">// code-examples/DSLs/payroll/pcdsl/payroll-parser-comb-spec.scala

package payroll.pcdsl
import scala.util.parsing.combinator._
import org.specs._
import payroll._
import payroll.Type2Money._

// Doesn't test "sad path" scenarios...
object PayrollParserCombinatorsSpec
    extends Specification("PayrollParserCombinators") {

  val salary = Money(100000.1)  // for a full year
  val gross = salary / 26.      // for two weeks
  val buck = Employee(Name("Buck", "Trends"), salary)
  val employees = Map(buck.name -&gt; buck)

  implicit def money2double(m: Money) = m.amount.doubleValue

  "PayrollParserCombinators" should {
    "calculate the gross == net when there are no deductions" in {
      val input = """paycheck for employee "Buck Trends"
                     is salary for 2 weeks minus deductions for {}"""
      val p = new PayrollParserCombinators(employees)
      p.parseAll(p.paycheck, input) match {
        case p.Success(Pair(employee, paycheck),_) =&gt;
          employee mustEqual buck
          paycheck.gross must beCloseTo(gross, Money(.001))
          paycheck.net must beCloseTo(gross, Money(.001))
          // zero deductions?
          paycheck.deductions must beCloseTo(Money(0.), Money(.001))
        case x =&gt; fail(x.toString)
      }
    }

    "calculate the gross, net, and deductions for the pay period" in {
      val input =
        """paycheck for employee "Buck Trends"
           is salary for 2 weeks minus deductions for {
             federal income tax            is  25.  percent of gross,
             state income tax              is  5.   percent of gross,
             insurance premiums            are 500. in gross currency,
             retirement fund contributions are 10.  percent of gross
           }"""

      val p = new PayrollParserCombinators(employees)
      p.parseAll(p.paycheck, input) match {
        case p.Success(Pair(employee, paycheck),_) =&gt;
          employee mustEqual buck
          val deductions = (gross * .4) + Money(500)
          val net = gross - deductions
          paycheck.gross must beCloseTo(gross, Money(.001))
          paycheck.net must beCloseTo(net, Money(.001))
          paycheck.deductions must beCloseTo(deductions, Money(.001))
        case x =&gt; fail(x.toString)
      }
    }
  }
}</programlisting>

      <para id="para_if_you_work_out_what_the_resul">If you work out what the
      results should be from the input strings, you&#x2019;ll see that the
      implementation correctly calculates the paycheck.</para>

      <para id="para_besides_the_many_small_details">Besides the many small
      details that differ between this implementation of the external DSL and
      the previous implementation of the internal DSL, there is one big
      conceptual difference from the two implementations. Here we are
      computing the paycheck as we parse code written in the external DSL. In
      the internal DSL case, we generated a <phrase role="keep-together">paycheck</phrase> calculator when we parsed the
      DSL. Afterward, we used that calculator to <phrase role="keep-together">compute</phrase> paychecks for one employee at a
      time. We could have generated a paycheck calculator like we did before,
      but we chose a simpler approach to focus on the construction of the
      parser itself. Also, as we discussed earlier, we weren&#x2019;t as careful
      about thread safety and other issues in the implementation.<indexterm class="endofrange" startref="ch11_parsercombinators"/><indexterm class="endofrange" startref="ch11_parsersfinal"/><indexterm class="endofrange" startref="ch11_DSLexternalpaycheck"/><indexterm class="endofrange" startref="ch11_DSLexternal"/></para>
    </sect2>

    <sect2 id="ExternalDSLsFinalThoughts">
      <title>Internal Versus External DSLs: Final Thoughts</title>

      <para id="para_scala_provides_rich_support_fo">Scala provides rich
      support for creating your own internal and external DSLs. However, a
      non-trivial DSL can be a challenge to implement and debug. For the
      examples in this chapter, the parser combinators implementation was
      easier to design and write than the implementation for the internal DSL.
      However, we found that debugging the <phrase role="keep-together">internal</phrase> DSL was easier.<indexterm>
          <primary>external DSLs</primary>

          <secondary>internal DSLs versus</secondary>
        </indexterm><indexterm>
          <primary>internal DSLs</primary>

          <secondary>external DSLs versus</secondary>
        </indexterm><indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>internal versus external</secondary>
        </indexterm></para>

      <?dbfo-need height=”2in”
?>

      <para id="para_another_problem_you_must_consi">You must also consider
      how robust the parser must be when handling invalid input. Depending on
      the level of sophistication of the users of the DSL, you may need to
      provide very good feedback when errors occur, especially when your users
      are non-programmers. The parser combinator library in Scala version 2.8
      will provide improved support for error recovery and reporting, compared
      to the version 2.7.X library.</para>

      <para id="para_the_version_2_8_library_will_a">The version 2.8 library
      will also provide support for writing <emphasis>packrat
      parsers</emphasis> that can implement unambiguous <emphasis>parsing
      expression grammars</emphasis> (PEGs). The 2.8 implementation of packrat
      parsers also supports <emphasis>memoization</emphasis>, which helps
      improve performance, among other benefits. If you need a fast parser, a
      packrat parser will take you further before you need to consider more
      specialized tools, like parser generators.<indexterm>
          <primary>memoization</primary>

          <secondary>support by packrat parsers</secondary>
        </indexterm><indexterm>
          <primary>PEGs (parsing expression grammars)</primary>
        </indexterm><indexterm>
          <primary>parsing expression grammars (PEGs)</primary>
        </indexterm><indexterm>
          <primary>packrat parsers</primary>
        </indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="_recap_and_what_s_next_3">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_so_it_s_tempting_to_create_ds">It&#x2019;s tempting to create DSLs
    with abandon. DSLs in Scala can be quite fun to work with, but don&#x2019;t
    underestimate the effort required to create robust DSLs that meet your
    clients usability needs, nor long-term maintenance and support
    issues.</para>

    <para id="para_if_you_choose_to_write_a_dsl_">If you choose to write a
    DSL, you have rich options in Scala. The syntax is flexible yet powerful
    enough that an internal DSL may be sufficient. A internal DSL is an
    excellent starting point, especially if other programmers will be the
    primary writers of code in the DSL.</para>

    <para id="para_if_you_expect_your_non_program">If you expect your
    non-programming stakeholders to read or even write code written in the
    DSL, it might be worth the extra effort to create an external DSL that
    eliminates as many of the programming-language idioms as possible.
    Consider whether the code written in the DSL will need to be processed for
    other purposes, like generating documentation, spreadsheets, etc. Since
    you will have to write a parser for the DSL anyway, it might be
    straightforward to write others to handle these different purposes.</para>

    <para id="para_so_far_we_have_only_hinted_at">In the next chapter, we&#x2019;ll
    explore the richness of Scala&#x2019;s type system. We&#x2019;ve learned many of its
    features already. Now, we&#x2019;ll explore the type system in full
    detail.<indexterm class="endofrange" startref="ch11_DSLs"/></para>
  </sect1>
</chapter>
  <chapter id="ScalasTypeSystem">
  <title>The Scala Type System</title>

  <para id="para_types_intro">Scala is a statically typed language. Its type
  system is one of the most sophisticated in any programming language, in part
  because it combines comprehensive ideas from functional programming and
  object-oriented programming. The type system tries to be logically
  comprehensive, complete, and consistent. It exceeds limitations in Java&#x2019;s
  type system while containing innovations that appear in Scala for the first
  time.<indexterm>
      <primary>type system</primary>

      <seealso>data types</seealso>
    </indexterm><indexterm class="startofrange" id="ch12_datatypes">
      <primary>data types</primary>
    </indexterm></para>

  <para id="para_however_much_of_this_sophisti">However, the type system can
  be intimidating at first, especially if you come from a dynamically typed
  language like Ruby or Python. Fortunately, type inference hides most of the
  complexities away. Most of the time, you don&#x2019;t need to know the particulars,
  so we encourage you not to worry that you must master the type system in
  order to use Scala effectively. You might choose to skim this chapter if
  you&#x2019;re new to Scala, so you&#x2019;ll know where to look when type-related
  questions arise later.<indexterm>
      <primary>types</primary>

      <seealso>data types</seealso>
    </indexterm></para>

  <para id="para_still_the_more_you_know_about">Still, the more you know about
  the type system, the more you will be able to exploit its features in your
  programs. This is especially true for library writers, who will want to
  understand when to use parameterized types versus abstract types, which type
  parameters should be covariant, contravariant, or invariant under subtyping,
  and so forth. Also, some understanding of the type system will help you
  understand and debug the occasional compilation failure related to typing.
  Finally, this understanding will help you make sense of the type information
  shown in the sources and Scaladocs for Scala libraries.</para>

  <para id="para_if_you_didn_t_understand_some_">If you didn&#x2019;t understand some
  of the terms we used in the preceding paragraphs, don&#x2019;t worry. We&#x2019;ll explain
  them and why they are useful. We&#x2019;re not going to discuss Scala&#x2019;s type system
  in exhaustive detail. Rather, we want you to come away with a pragmatic
  understanding of the type system. You should develop an awareness of the
  features available, what purposes they serve, and how to read and understand
  type declarations.</para>

  <para id="para_we_ll_also_highlight_similarit">We&#x2019;ll also highlight
  similarities with Java&#x2019;s type system, since it may be a familiar point of
  reference for you. Understanding the differences is also useful for
  interoperability with Java libraries. To focus the discussion, we won&#x2019;t
  cover the .NET type system, except to point out some notable differences
  that .NET programmers will want to know.</para>

  <sect1 id="ReflectingOnTypes">
    <title>Reflecting on Types</title>

    <para id="para_reflecting_on_types">Scala supports the same reflection
    capabilities that Java and .NET support. The syntax is different in some
    cases.<indexterm>
        <primary>data types</primary>

        <secondary>reflection</secondary>
      </indexterm><indexterm>
        <primary>reflection</primary>
      </indexterm></para>

    <para id="para_java_class_methods">First, you can use the same methods you
    might use in Java or .NET code. The following script shows some of the
    reflection methods available on the JVM, through
    <literal>java.lang.Object</literal> and
    <literal>java.lang.Class</literal>:<indexterm>
        <primary>Java</primary>

        <secondary>JVM (Java Virtual Machine)</secondary>

        <tertiary>reflection methods</tertiary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/reflection/jvm-script.scala

trait T[A] {
  val vT: A
  def mT = vT
}

class C extends T[String] {
  val vT = "T"
  val vC = "C"
  def mC = vC

  class C2
  trait T2
}

val c = new C
val clazz = c.getClass              // method from java.lang.Object
val clazz2 = classOf[C]             // Scala method: classOf[C] ~ C.class
val methods = clazz.getMethods      // method from java.lang.Class&lt;T&gt;
val ctors = clazz.getConstructors   // ...
val fields = clazz.getFields
val annos = clazz.getAnnotations
val name  = clazz.getName
val parentInterfaces = clazz.getInterfaces
val superClass = clazz.getSuperclass
val typeParams = clazz.getTypeParameters</programlisting>

    <para id="para_note_that_these_methods_are_on">Note that these methods are
    only available on subtypes of <literal>AnyRef</literal>.<indexterm>
        <primary>AnyRef object</primary>

        <secondary>reflection methods</secondary>
      </indexterm></para>

    <para id="para_the_classof_t_method_return">The
    <literal>classOf[T]</literal> method returns the runtime representation
    for a Scala type. It is analogous to the Java expression
    <literal>T.class</literal>. Using <literal>classOf[T]</literal> is
    convenient when you have a type that you want information about, while
    <literal>getClass</literal> is convenient for retrieving the same
    information from an instance of the type.</para>

    <para id="para_however_classof_t_and_get">However,
    <literal>classOf[T]</literal> and <literal>getClass</literal> return
    slightly different values, reflecting the effect of <emphasis>type
    erasure</emphasis> on the JVM, in the case of
    <literal>getClass</literal>:<indexterm>
        <primary>type erasure</primary>

        <secondary>getClass method on JVM</secondary>
      </indexterm></para>

    <screen>scala&gt; classOf[C]
res0: java.lang.Class[C] = class C

scala&gt; c.getClass
res1: java.lang.Class[_] = class C</screen>

    <note id="para_note_although_net_does_not_h">
      <para>Although .NET does not have type erasure, meaning it supports
      <emphasis>reified types</emphasis>, the .NET version of Scala currently
      follows the JVM&#x2019;s erasure model in order to avoid incompatibilities that
      would require a &#x201C;forked&#x201D; implementation.</para>
    </note>

    <para id="para_we_ll_discuss_a_workaround_for">We&#x2019;ll discuss a workaround
    for erasure, called <literal>Manifest</literal>s, after we discuss
    <emphasis>parameterized types</emphasis> in the next section.</para>

    <para id="para_scala_also_provides_methods_fo">Scala also provides methods
    for testing whether an object matches a type and also for casting an
    object to a type.</para>

    <para id="para__any_isinstanceof_t_will_ret"><literal>x.isInstanceOf[T]</literal>
    will return <literal>true</literal> if the instance <literal>x</literal>
    is of type <literal>T</literal>. However, this test is subject to type
    erasure. For example,
    <literal>List(3.14159).isInstanceOf[List[String]]</literal> will return
    <literal>true</literal> because the type parameter of
    <literal>List</literal> is lost at the byte code level. However, you&#x2019;ll
    get an &#x201C;unchecked&#x201D; warning from the compiler.</para>

    <para id="para__any_asinstanceof_t_will_cas"><literal>x.asInstanceOf[T]</literal>
    will cast <literal>x</literal> to <literal>T</literal> or throw a
    <literal>ClassCastException</literal> if <literal>T</literal> and the type
    of <literal>x</literal> are not compatible. Once again, type erasure must
    be considered with parameterized types. The expression
    <literal>List(3.14159).asInstanceOf[List[String]]</literal> will
    succeed.</para>

    <para id="para_note_that_these_two_operations">Note that these two
    operations are methods and not keywords in the language, and their names
    are deliberately somewhat verbose. Normally, type checks and casts like
    these should be avoided. For type checks, use pattern matching instead.
    For casts, consider why a cast is necessary and determine if a refactoring
    of the design can eliminate the requirement for a cast.</para>

    <note id="para_exper_scala_reflect">
      <para>At the time of this writing, there are some experimental features
      that might appear in the final version 2.8 release in the
      <literal>scala.reflect</literal> package. These features are designed to
      make reflective examination and invocation of code easier than using the
      corresponding Java methods.</para>
    </note>
  </sect1>

  <sect1 id="ParameterizedTypes">
    <title>Understanding Parameterized Types</title>

    <para id="para_we_introduced__parameterized_t">We introduced
    <emphasis>parameterized types</emphasis> and <emphasis>methods</emphasis>
    in <xref linkend="IntroducingScala"/>, and filled in a few more details
    in <xref linkend="AbstractTypesAndParameterizedTypes"/>. If you come from
    a Java or C# background, you probably already have some knowledge of
    parameterized types and methods. Now we explore the details of Scala&#x2019;s
    sophisticated support for parameterized types.<indexterm>
        <primary>parameterized types</primary>
      </indexterm><indexterm>
        <primary>data types</primary>

        <secondary>parameterized types</secondary>
      </indexterm></para>

    <para id="para_scala_s_parameterized_types_ar">Scala&#x2019;s parameterized types
    are similar to Java and C# generics and C++ templates. They provide the
    same capabilities as Java generics, but with significant differences and
    extensions, reflecting the sophistication of Scala&#x2019;s type system.</para>

    <para id="para_to_recap_a_declaration_like_">To recap, a declaration like
    <literal>class List[+A]</literal> means that <literal>List</literal> is
    parameterized by a single type, represented by <literal>A</literal>. The
    <literal>+</literal> is called a <emphasis>variance annotation</emphasis>.
    We&#x2019;ll come back to it in <xref linkend="VarianceUnderInheritance"/>.<indexterm>
        <primary>variance annotations</primary>
      </indexterm></para>

    <para id="para_a_declaration_like_list_043">Sometimes, a parameterized
    type like <literal>List</literal> is called a <emphasis>type
    constructor</emphasis>, because it is used to create specific types. For
    example, <literal>List</literal> is the type constructor for
    <literal>List[String]</literal> and <literal>List[Int]</literal>, which
    are different types (although they are actually implemented with the same
    byte code due to <emphasis>type erasure</emphasis>). In fact, it&#x2019;s more
    accurate to say that all traits and classes are type constructors. Those
    without type parameters are effectively <phrase role="keep-together">zero-</phrase><phrase role="keep-together">argument</phrase>, parameterized types.</para>

    <warning id="para_warning_if_you_write_class_s">
      <para>If you write <literal>class StringList[String] extends
      List[String] {...}</literal>, Scala will interpret
      <literal>String</literal> as the name of the type parameter, not the
      creation of a type based on actual Strings. You want to write
      <literal>class StringList extends List[String] {...}</literal>.</para>
    </warning>

    <sect2 id="Manifests">
      <title>Manifests</title>

      <para id="para_there_is_an_experimental_featu">There is an experimental
      feature in Scala (since version 2.7.2), called
      <literal>Manifest</literal>s, that captures type information that is
      erased in the byte code. This feature is not documented in the
      Scaladocs, but you can examine the source for the
      <literal>scala.reflect.Manifest</literal> trait. <link linkend="Ortiz2008" xrefstyle="select:nopage">[Ortiz2008]</link>
      discusses <literal>Manifest</literal>s and provides examples of their
      use.<indexterm>
          <primary>Manifests</primary>
        </indexterm><indexterm>
          <primary>parameterized types</primary>

          <secondary>Manifests</secondary>
        </indexterm></para>

      <para id="para_a_manifest_is_declared_as_an">A
      <literal>Manifest</literal> is declared as an implicit argument to a
      method or type that wants to capture the erased type information. Unlike
      most implicit arguments, the user does not need to supply an in-scope
      <literal>Manifest</literal> value or method. Instead, the compiler
      generates one automatically. Here is an example that illustrates some of
      the strengths and weaknesses of <literal>Manifest</literal>s:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/manifests/manifest-script.scala

import scala.reflect.Manifest

object WhichList {
  def apply[B](value: List[B])(implicit m: Manifest[B]) = m.toString match {
    case "int"              =&gt; println( "List[Int]" )
    case "double"           =&gt; println( "List[Double]" )
    case "java.lang.String" =&gt; println( "List[String]" )
    case _                  =&gt; println( "List[???]" )
  }
}

WhichList(List(1, 2, 3))
WhichList(List(1.1, 2.2, 3.3))
WhichList(List("one", "two", "three"))

List(List(1, 2, 3), List(1.1, 2.2, 3.3), List("one", "two", "three")) foreach {
  WhichList(_)
}</programlisting>

      <para id="para__whichlist_tries_to_determine"><literal>WhichList</literal>
      tries to determine the type of list passed in. It uses the value of the
      <literal role="keep-together">Manifest</literal>&#x2019;s
      <literal>toString</literal> method to determine this information. Notice
      that it works when the list is constructed inside the call to
      <literal>WhichList.apply</literal>. It does <emphasis>not</emphasis>
      work when a previously constructed list is passed to
      <literal>WhichList.apply</literal>.</para>

      <para id="para_the_compiler_exploits_the_type">The compiler exploits the
      type information it knows in the first case to construct the implicit
      <literal>Manifest</literal> with the correct <literal>B</literal>.
      However, when given previously constructed lists, the crucial type
      information is already lost.</para>

      <para id="para_hence_manifests_can_t_resur">Hence,
      <literal>Manifest</literal>s can&#x2019;t &#x201C;resurrect&#x201D; type information from
      byte code, but they can be used to capture and exploit type information
      before it is erased.</para>
    </sect2>

    <sect2 id="ParameterizedMethods">
      <title>Parameterized Methods</title>

      <para id="para_because_the_runtime_system_ins">Individual methods can
      also be parameterized. Good examples are the <literal>apply</literal>
      methods in companion objects for parameterized classes. Recall that
      companion objects are singleton objects associated with a companion
      class. There is only one instance of a singleton object, as its name
      implies, so type parameters would be meaningless.<indexterm>
          <primary>parameterized methods</primary>
        </indexterm><indexterm>
          <primary>parameterized types</primary>

          <secondary>parameterized methods</secondary>
        </indexterm><indexterm>
          <primary>methods</primary>

          <secondary>parameterized</secondary>
        </indexterm></para>

      <para id="para_often_the_methods_in_these_co">Let&#x2019;s consider
      <literal>object List</literal>, the companion object for <literal>class
      List[+A]</literal>. Here is the definition of the
      <literal>apply</literal> method in <literal>object
      List</literal>:<indexterm>
          <primary>List object</primary>

          <secondary>apply method, parameterized</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">def apply[A](xs: A*): List[A] = xs.toList</programlisting>

      <para id="para_so_the_following_declarations">The
      <literal>apply</literal> methods takes a variable length list of
      arguments of type <literal>A</literal>, which will be inferred from the
      arguments, and returns a list created from the arguments. Here is an
      example:</para>

      <programlisting linenumbering="unnumbered">val languages = List("Scala", "Java", "Ruby", "C#", "C++", "Python", ...)
val positiveInts = List(1, 2, 3, 4, 5, 6, 7, ...)</programlisting>

      <para id="para_we_ll_look_at_other_parameteri">We&#x2019;ll look at other
      parameterized methods shortly.</para>
    </sect2>
  </sect1>

  <sect1 id="VarianceUnderInheritance">
    <title>Variance Under Inheritance</title>

    <para id="para_parameterized_types_diff_with_java">An important difference
    between Java and Scala generics is how <emphasis>variance</emphasis> under
    inheritance works. For example, if a method has an argument of type
    <literal>List[AnyRef]</literal>, can you pass a
    <literal>List[String]</literal> value? In other words, should a
    <literal>List[String]</literal> be considered a
    <emphasis>subtype</emphasis> of <literal>List[AnyRef]</literal>? If so,
    this kind of variance is called <emphasis>covariance</emphasis>, because
    the supertype-subtype relationship of the container (the parameterized
    type) &#x201C;goes in the same direction&#x201D; as the relationship between the type
    parameters. In other contexts, you might want
    <emphasis>contravariant</emphasis> or <emphasis>invariant</emphasis>
    behavior, which we&#x2019;ll describe shortly.<indexterm>
        <primary>type variance</primary>

        <seealso>variance under inheritance</seealso>
      </indexterm><indexterm>
        <primary>generics</primary>

        <secondary>variance under inheritance, differences between Java and
        Scala</secondary>
      </indexterm><indexterm>
        <primary>data types</primary>

        <secondary>variance under inheritance</secondary>
      </indexterm><indexterm>
        <primary>variance under inheritance</primary>
      </indexterm><indexterm class="startofrange" id="ch12_inheritvariance">
        <primary>inheritance</primary>

        <secondary>variance under</secondary>
      </indexterm></para>

    <para id="para_in_scala_the_type_designer_sp">In Scala, the variance
    behavior is defined at the <emphasis>declaration site</emphasis> using
    <emphasis>variance annotations</emphasis>: <literal>+</literal>,
    <literal>-</literal>, or nothing. In other words, the type designer
    decides how the type should vary under inheritance.<indexterm>
        <primary>declaration site</primary>
      </indexterm><indexterm>
        <primary>- (minus sign)</primary>

        <secondary>variance annotations</secondary>
      </indexterm><indexterm>
        <primary>+ (plus sign)</primary>

        <secondary>variance annotations</secondary>
      </indexterm><indexterm>
        <primary>variance annotations</primary>

        <secondary>summary of</secondary>
      </indexterm></para>

    <para id="para_let_s_examine_the_three_kinds_">Let&#x2019;s examine the three
    kinds of variance, summarized in <xref linkend="type-variance-annotations-table"/>, and understand how to use
    them effectively. We&#x2019;ll assume that
    <literal>T</literal><superscript>sup</superscript> is a
    <emphasis>supertype</emphasis> of <literal>T</literal> and
    <literal>T</literal><subscript>sub</subscript> is a
    <emphasis>subtype</emphasis> of <literal>T</literal>.</para>

    <table id="type-variance-annotations-table">
      <title>Type variance annotations and their meanings</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Annotation</entry>

            <entry><phrase role="keep-together">Java
            equivalent</phrase></entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para>+</para></entry>

            <entry><para><literal>? extends T</literal></para></entry>

            <entry><para><emphasis>Covariant</emphasis> subclassing. E.g.,
            <literal>List[T</literal><subscript>sub</subscript><literal>]</literal>
            is a subtype of <literal>List[T]</literal>.</para></entry>
          </row>

          <row>
            <entry><para>-</para></entry>

            <entry><para><literal>? super T</literal></para></entry>

            <entry><para><emphasis>Contravariant</emphasis> subclassing. E.g.,
            <literal>X[T</literal><superscript>sup</superscript><literal>]</literal>
            is a subtype of <literal>X[T]</literal>.</para></entry>
          </row>

          <row>
            <entry><para><emphasis>none</emphasis></para></entry>

            <entry><para><literal>T</literal></para></entry>

            <entry><para><emphasis>Invariant</emphasis> subclassing. E.g.,
            Can&#x2019;t substitute
            <literal>Y[T</literal><superscript>sup</superscript><literal>]</literal>
            or
            <literal>Y[T</literal><subscript>sub</subscript><literal>]</literal>
            for <literal>Y[T]</literal>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_the_java_equivalent_column">The &#x201C;Java equivalent&#x201D; column is
    a bit misleading; we&#x2019;ll explain why in a moment.<indexterm>
        <primary>invariant subclassing</primary>
      </indexterm><indexterm>
        <primary>covariant subclassing</primary>
      </indexterm><indexterm>
        <primary>contravariant subclassing</primary>
      </indexterm></para>

    <para id="para_class_list_is_declared_list">Class <literal>List</literal>
    is declared <literal>List[+A]</literal>, which means that
    <literal>List[String]</literal> is a subclass of
    <literal>List[AnyRef]</literal>, so <literal>Lists</literal> are covariant
    in the type parameter <literal>A</literal>. (When a type like
    <literal>List</literal> has only one covariant type parameter, you&#x2019;ll
    often hear the shorthand expression &#x201C;Lists are covariant&#x201D; and similarly
    for types with a single contravariant type parameter.)<indexterm>
        <primary>FunctionN object</primary>

        <secondary>variance under inheritance</secondary>
      </indexterm></para>

    <para id="para_the_declarations_function__n_">The traits
    <literal>FunctionN</literal>, for <literal>N</literal> equals 0 to 22, are
    used by Scala to implement function values as true objects. Let&#x2019;s pick
    <literal>Function1</literal> as a representative example. It is declared
    <literal>trait Function1[-T, +R]</literal>.</para>

    <para id="para_the_043_r_is_the_return_ty">The <literal>+R</literal> is
    the return type and has the covariant annotation <literal>+</literal>. The
    type for the single argument has the <emphasis>contravariant</emphasis>
    annotation <literal>-</literal>. For functions with more than one
    argument, all the argument types have the contravariant annotation. So,
    for example, using our <literal>T</literal>,
    <literal>T</literal><superscript>sup</superscript>, and
    <literal>T</literal><subscript>sub</subscript> types, the following
    definition would be legal:</para>

    <programlisting>val f: Function1[T, T] = new Function1[T<superscript>sup</superscript>, T<subscript>sub</subscript>] { ... }</programlisting>

    <para id="para_hence_the_function_traits_are">Hence, the function traits
    are covariant in the return type parameter <literal>R</literal> and
    contravariant in the argument parameters
    <literal>T</literal><subscript>1</subscript><literal>,
    T</literal><subscript>2</subscript><literal>, ...,
    T</literal><subscript>N</subscript>.</para>

    <para id="para_so_what_does_this_really_mean_">So, what does this really
    mean? Let&#x2019;s look at an example to understand the variance behavior. If you
    have prior experience with <emphasis>Design by Contract</emphasis> (see
    <link linkend="DesignByContract" xrefstyle="select:nopage">[DesignByContract]</link>), it might help you to
    recall how it works, which is very similar. (We will discuss Design by
    Contract briefly in <xref linkend="DesignByContractExample"/>.) This
    script demonstrates variance under inheritance:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/variances/func-script.scala
// WON'T COMPILE

class CSuper                { def msuper = println("CSuper") }
class C      extends CSuper { def m      = println("C") }
class CSub   extends C      { def msub   = println("CSub") }

var f: C =&gt; C = (c: C)      =&gt; new C       // #1
    f         = (c: CSuper) =&gt; new CSub    // #2
    f         = (c: CSuper) =&gt; new C       // #3
    f         = (c: C)      =&gt; new CSub    // #4
    f         = (c: CSub)   =&gt; new CSuper  // #5: ERROR!</programlisting>

    <para id="para_this_script_doesn_t_produce_an">This script doesn&#x2019;t produce
    any output. If you run it, it will fail to compile on the last
    line.</para>

    <para id="para_start_with_simple_hierarchy_of_3_classes">We start by
    defining a very simple hierarchy of three classes, <literal>C</literal>
    and its superclass <literal>CSuper</literal> and its subtype
    <literal>CSub</literal>. Each one defines a method, which we&#x2019;ll exploit
    shortly.</para>

    <para id="para_next_we_define_a_var_named_">Next we define a
    <literal>var</literal> named <literal>f</literal> on the line with the #1
    comment. It is a function with the signature <literal>C =&gt; C</literal>.
    More precisely, it is of type <literal>Function1(-C,+C)</literal>. To be
    clear, the value assigned to <literal>f</literal> is after the equals
    sign, <literal>(c: C) =&gt; new C</literal>. We actually ignore the input
    <literal>c</literal> value and just create a new
    <literal>C</literal>.</para>

    <para id="para_now_we_call_applyfunc_passi">Now we assign different
    anonymous function values to <literal>f</literal>. We use whitespace to
    make the similarities and differences stand out when comparing the
    original declaration of <literal>f</literal> and the subsequent
    reassignments. We keep reassigning to <literal>f</literal> because we are
    just testing what will and won&#x2019;t compile at this point. Specifically, we
    want to know what function values we can legally assign to <literal>f: (C)
    =&gt; C</literal>.</para>

    <para id="para_the_second_invocation_2_pas">The second assignment on line
    #2 assigns <literal>(x:CSuper) =&gt; new CSub</literal> as the function
    value. This also works, because the argument to
    <literal>Function1</literal> is <emphasis>contravariant</emphasis>, so we
    can substitute the <emphasis>supertype</emphasis>, while the return type
    of <literal>Function1</literal> is <emphasis>covariant</emphasis>, so our
    function value can return an instance of the
    <emphasis>subtype</emphasis>.</para>

    <para id="para_the_next_two_lines_also_work_">The next two lines also
    work. On line #3, we use a <literal>CSuper</literal> for the argument,
    which works as it did in line #2. We return a <literal>C</literal>, which
    also works as expected. Similarly, on line #4, we use <literal>C</literal>
    as the argument and <literal>CSub</literal> as the return type, both of
    which worked fine in the previous lines.</para>

    <para id="para_the_last_line_does_not_compile">The last line, #5, does not
    compile because we are attempting to use a covariant argument in a
    contravariant position. We&#x2019;re also attempting to use a contravariant
    return value where only covariant values are allowed.<indexterm>
        <primary>Design by Contract</primary>
      </indexterm></para>

    <para id="para_okay_but__why__is_all_this_co">Why is the behavior correct
    in these cases? Here&#x2019;s where Design by Contract thinking comes in handy.
    Let&#x2019;s see how a client might use some of these definitions of
    <literal>f</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/variances/func2-script.scala
// WON'T COMPILE

class CSuper                { def msuper = println("CSuper") }
class C      extends CSuper { def m      = println("C") }
class CSub   extends C      { def msub   = println("CSub") }

def useF(f: C =&gt; C) = {
  val c1 = new C     // #1
  val c2: C = f(c1)  // #2
  c2.msuper          // #3
  c2.m               // #4
}

useF((c: C)      =&gt; new C)        // #5
useF((c: CSuper) =&gt; new CSub)     // #6
useF((c: CSub)   =&gt; {println(c.msub); new CSuper})   // #7: ERROR!</programlisting>

    <para id="para_the_usef_method_takes_a_func">The <literal>useF</literal>
    method takes a function <literal>C =&gt; C</literal> as an argument.
    (We&#x2019;re just passing function literals now, rather than assigning them to
    <literal>f</literal>.) It creates a <literal>C</literal> (line #1) and
    passes it to the input function to create a new <literal>C</literal> (line
    #2). Then it uses the features of <literal>C</literal>; namely, it calls
    the <literal>msuper</literal> and <literal>m</literal> methods (lines #3
    and #4, respectively).</para>

    <para id="para_in_invocation_2_we_passed_">You could say that the
    <literal>useF</literal> method specifies a <emphasis>contract</emphasis>
    of behavior. It expects to be passed a function that can take a
    <literal>C</literal> and return a <literal>C</literal>. It will call the
    passed-in function, passing a <literal>C</literal> instance to it, and it
    will expect to receive a <literal>C</literal> back.<indexterm>
        <primary>contract</primary>
      </indexterm></para>

    <para id="para_in_line_5_we_pass_usef_a_f">In line #5, we pass
    <literal>useF</literal> a function that takes a <literal>C</literal> and
    returns a <literal>C</literal>. The returned <literal>C</literal> will
    work with lines #3 and #4, by definition. All is good.</para>

    <para id="para_in_line_6_we_pass_in_a_fun">Finally, we come to the point
    of this example. In line #6, we pass in a function that is &#x201C;willing&#x201D; to
    accept a <literal>CSuper</literal> and &#x201C;promises&#x201D; to return a
    <literal>CSub</literal>. That is, this function is type inferred to be
    <literal>Function1[CSuper,CSub]</literal>. In effect, it widens the
    allowed instances by accepting a supertype. Keep in mind that it will
    never actually be passed a <literal>CSuper</literal> by
    <literal>useF</literal>, only a <literal>C</literal>. However, since it
    can accept a wider set of instances, it will work fine if it only gets
    <literal>C</literal> instances.</para>

    <para id="para_return_promise">Similarly, by &#x201C;promising&#x201D; to return a
    <literal>CSub</literal>, this anonymous function narrows the possible
    values returned to <literal>useF</literal>. That&#x2019;s OK, too, because
    <literal>useF</literal> will accept any <literal>C</literal> in return, so
    if it only gets <literal>CSubs</literal>, it will be happy. Lines #3 and
    #4 will still work.</para>

    <para id="para_applying_the_same_arguments_w">Applying the same arguments,
    we can see why the last line in the script, line #7, fails to compile. Now
    the anonymous function can only accept a <literal>CSub</literal>, but
    <literal>useF</literal> will pass it a <literal>C</literal>. The body of
    the anonymous function would now break, because it calls
    <literal>c.msub</literal>, which doesn&#x2019;t exist in <literal>C</literal>.
    Similarly, returning a <literal>CSuper</literal> when a
    <literal>C</literal> is expected breaks line #4 in
    <literal>useF</literal>, because <literal>CSuper</literal> doesn&#x2019;t have
    the <literal>m</literal> method.</para>

    <para id="para_the_same_arguments_explain_how">The same arguments are used
    to explain how contracts can change under inheritance in Design by
    Contract.</para>

    <para id="para_note_that_variance_annotations">Note that variance
    annotations only make sense on the type parameters for parameterized
    types, not parameterized methods, because the annotations affect the
    behavior of subtyping. Methods aren&#x2019;t subtyped, but the types that contain
    them might be <phrase role="keep-together">subtyped</phrase>.<indexterm>
        <primary>- (minus sign)</primary>

        <secondary>variance annotations</secondary>
      </indexterm><indexterm>
        <primary>+ (plus sign)</primary>

        <secondary>variance annotations</secondary>
      </indexterm></para>

    <note id="para_note_the_8216_043_8217_">
      <para>The <literal>+</literal> <emphasis>variance annotation</emphasis>
      means the parameterized type is <emphasis>covariant</emphasis> in the
      type parameter. The <literal>-</literal> variance annotation means the
      parameterized type is <emphasis>contravariant</emphasis> in the type
      parameter. No variance annotation means the parameterized type is
      <emphasis>invariant</emphasis> in the type parameter.</para>
    </note>

    <para id="para_finally_the_compiler_checks_y">Finally, the compiler checks
    your use of variance annotations for problems like the one we just
    described in the last lines of the examples. Suppose you attempted to
    define your own function type this way:</para>

    <programlisting linenumbering="unnumbered">trait MyFunction2[+T1, +T2, -R] {
  def apply(v1:T1, v2:T2): R = { ... }
  ...
}</programlisting>

    <para id="para_variance_errors_compile_checks">The compiler would throw
    the following errors for the <literal>apply</literal> method:</para>

    <screen>... error: contravariant type R occurs in covariant position in type (T1,T2)R
       def apply(v1:T1, v2:T2):R
           ^
... error: covariant type T1 occurs in contravariant position in type T1 ...
       def apply(v1:T1, v2:T2):R
                 ^
... error: covariant type T2 occurs in contravariant position in type T2 ...
       def apply(v1:T1, v2:T2):R
                        ^</screen>

    <sect2 id="VarianceOfMutableTypes">
      <title>Variance of Mutable Types</title>

      <para id="para_all_the_parameterized_types_we">All the parameterized
      types we&#x2019;ve discussed so far have been immutable types. What about the
      variance behavior of mutable types? The short answer is that only
      <emphasis>invariance</emphasis> is allowed. Consider this
      example:<indexterm>
          <primary>data types</primary>

          <secondary>variance under inheritance</secondary>

          <tertiary>variance of mutable types</tertiary>
        </indexterm><indexterm>
          <primary>variance under inheritance</primary>

          <secondary>variance of mutable types</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/variances/mutable-type-variance-script.scala
// WON'T COMPILE: Mutable parameterized types can't have variance annotations

class ContainerPlus[+A](var value: A)      // ERROR
class ContainerMinus[-A](var value: A)     // ERROR

println( new ContainerPlus("Hello World!") )
println( new ContainerMinus("Hello World!") )</programlisting>

      <para id="para_mutable_type_script_errors">Running this script throws
      the following errors:</para>

      <screen>... 4: error: covariant type A occurs in contravariant position in type A \
    of parameter of setter value_=
class ContainerPlus[+A](var value: A) &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;// ERROR
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;^
... 5: error: contravariant type A occurs in covariant position in type =&gt; A \
    of method value
class ContainerMinus[-A](var value: A) &#xA0;&#xA0;&#xA0;&#xA0;// ERROR
&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;^
two errors found</screen>

      <para id="para_we_can_make_sense_of_these_err">We can make sense of
      these errors by remembering our discussion of
      <literal>FunctionN</literal> type variance under inheritance, where the
      types of the function arguments are <emphasis>contravariant</emphasis>
      (i.e., <literal>-T1</literal>) and the return type is
      <emphasis>covariant</emphasis> (i.e., <literal>+R</literal>).</para>

      <para id="para_the_problem_with_a_mutable_typ">The problem with a
      mutable type is that at least one of its fields has the equivalent of
      read <emphasis>and</emphasis> write operations, either through direct
      access or through accessor methods.</para>

      <para id="para_in_the_first_error_we_are_try">In the first error, we are
      trying to use a covariant type as an argument to a setter (write)
      method, but we saw from our discussion of function types that argument
      types to a method must be contravariant. A covariant type is fine for
      the getter (read) method.</para>

      <para id="para_similarly_for_the_second_erro">Similarly, for the second
      error, we are trying to use a contravariant type as the return value of
      a read method, which must be covariant. For the write method, the
      contravariant type is fine.</para>

      <para id="para_hence_the_compiler_won_t_let_">Hence, the compiler won&#x2019;t
      let us use a variance annotation on a type that is used for a mutable
      field. For this reason, all the mutable parameterized types in the Scala
      library are <emphasis>invariant</emphasis> in their type parameters.
      Some of them have corresponding immutable types that have covariant or
      contravariant parameters.</para>
    </sect2>

    <sect2 id="VarianceInScalaVsJava">
      <title>Variance In Scala Versus Java</title>

      <para id="para_in_scala_the_variance_behavio">As we said, the variance
      behavior is defined at the <emphasis>declaration site</emphasis> in
      Scala. In Java, it is defined at the <emphasis>call site</emphasis>. The
      <emphasis>client</emphasis> of a type defines the variance behavior
      desired (see <link linkend="Naftalin2006" xrefstyle="select:nopage">[Naftalin2006]</link>). In other words, when
      you use a Java generic and specify the type parameter, you also specify
      the variance behavior (including invariance, which is the default). You
      can&#x2019;t specify variance behavior at the definition site in Java, although
      you can use expressions that look similar. Those expressions define
      <emphasis>type bounds</emphasis>, which we&#x2019;ll discuss shortly.<indexterm class="startofrange" id="ch12_datatypesvarianceSvJ">
          <primary>data types</primary>

          <secondary>variance under inheritance</secondary>

          <tertiary>variance in Scala versus Java</tertiary>
        </indexterm><indexterm>
          <primary>type bounds</primary>
        </indexterm><indexterm class="startofrange" id="ch12_Javavariance">
          <primary>Java</primary>

          <secondary>variance</secondary>
        </indexterm><indexterm class="startofrange" id="ch12_varianceSvJ">
          <primary>variance under inheritance</primary>

          <secondary>variance in Scala versus Java</secondary>
        </indexterm></para>

      <para id="para_in_java_variance_specification">In Java variance
      specifications, a wildcard <literal>?</literal> always appears before
      the <literal>super</literal> or <literal>extends</literal> keyword, as
      shown earlier in <xref linkend="type-variance-annotations-table"/>.
      When we said after the table that the &#x201C;Java Equivalent&#x201D; column is a bit
      misleading, we were referring to the differences between declaration
      versus call site specifications. There is another way in which the Scala
      and Java behaviors differ, which we&#x2019;ll cover in <xref linkend="ExistentialTypes"/>.</para>

      <para id="para_because_variances_in_java_are_">A drawback of call-site
      variance specifications is that they force the users of Java generics to
      understand the type system more thoroughly than is necessary for users
      of Scala parameterized types, who don&#x2019;t need to specify this behavior
      when using parameterized types. (Scala users also benefit greatly from
      type inference.)</para>

      <para id="para_let_s_look_at_a_java_example_">Let&#x2019;s look at a Java
      example, a simplified Java version of Scala&#x2019;s <literal>Option</literal>,
      <literal>Some</literal>, and <literal>None</literal> types:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/variances/Option.java

package variances;

abstract public class Option&lt;T&gt; {
  abstract public boolean isEmpty();

  abstract public T get();

  public T getOrElse(T t) {
    return isEmpty() ? t : get();
  }
}</programlisting>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/variances/Some.java

package variances;

public class Some&lt;T&gt; extends Option&lt;T&gt; {

  public Some(T value) {
    this.value = value;
  }

  public boolean isEmpty() { return false; }

  private T value;

  public T get() { return value; }

  public String toString() {
    return "Option(" + value + ")";
  }
}</programlisting>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/variances/None.java

package variances;

public class None&lt;T&gt; extends Option&lt;T&gt; {

  public boolean isEmpty() { return true; }

  public T get() { throw new java.util.NoSuchElementException(); }

  public String toString() {
    return "None";
  }
}</programlisting>

      <para id="para_here_is_an_example_that_uses_t">Here is an example that
      uses this Java <literal>Option</literal> hierarchy:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/variances/OptionExample.java

package variances;
import java.io.*;
import shapes.*;  // From "Introducing Scala" chapter

public class OptionExample {
  static String[] shapeNames = {"Rectangle", "Circle", "Triangle", "Unknown"};
  static public void main(String[] args) {

    Option&lt;? extends Shape&gt; shapeOption =
      makeShape(shapeNames[0], new Point(0.,0.), 2., 5.);
    print(shapeNames[0], shapeOption);

    shapeOption = makeShape(shapeNames[1], new Point(0.,0.), 2.);
    print(shapeNames[1], shapeOption);

    shapeOption = makeShape(shapeNames[2],
      new Point(0.,0.), new Point(2.,0.), new Point(0.,2.));
    print(shapeNames[2], shapeOption);

    shapeOption = makeShape(shapeNames[3]);
    print(shapeNames[3], shapeOption);
  }

  static public Option&lt;? extends Shape&gt; makeShape(String shapeName,
      Object... args) {
    if (shapeName == shapeNames[0])
      return new Some&lt;Rectangle&gt;(new Rectangle((Point) args[0],
        (Double) args[1], (Double) args[2]));
    else if (shapeName == shapeNames[1])
      return new Some&lt;Circle&gt;(new Circle((Point) args[0], (Double) args[1]));
    else if (shapeName == shapeNames[2])
      return new Some&lt;Triangle&gt;(new Triangle((Point) args[0],
        (Point) args[1], (Point) args[2]));
    else
      return new None&lt;Shape&gt;();
  }

  static void print(String name, Option&lt;? extends Shape&gt; shapeOption) {
    System.out.println(name + "? " + shapeOption);
  }
}</programlisting>

      <para id="para__optionexample_main_uses_the_"><literal>OptionExample.main</literal>
      uses the <literal>Shape</literal> hierarchy from <xref linkend="IntroducingScala"/>, but we have updated it slightly to
      exploit features that we&#x2019;ve learned since then, such as
      <literal>case</literal> classes:<indexterm class="endofrange" startref="ch12_Javavariance"/></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/shapes/shapes.scala

package shapes {
  case class Point(x: Double, y: Double) {
    override def toString() = "Point(" + x + "," + y + ")"
  }

  abstract class Shape() {
    def draw(): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape {
    def draw() = println("Circle.draw: " + this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
        extends Shape {
    def draw() = println("Rectangle.draw: " + this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
        extends Shape() {
    def draw() = println("Triangle.draw: " + this)
  }
}</programlisting>

      <para id="para_running_optionexample_with_">Running
      <literal>OptionExample</literal> with <literal>scala -cp ...
      variances.OptionExample</literal> produces the following output:</para>

      <screen>Rectangle? Option(Rectangle(Point(0.0,0.0),2.0,5.0))
Circle? Option(Circle(Point(0.0,0.0),2.0))
Triangle? Option(Triangle(Point(0.0,0.0),Point(2.0,0.0),Point(0.0,2.0)))
Unknown? None</screen>

      <para id="para_note_that_we_are_also_demonstr">By the way, we are also
      demonstrating Scala-Java interoperability, which we&#x2019;ll revisit in <xref linkend="JavaInterop"/>.</para>

      <para id="para__optionexample_main_calls_the"><literal>OptionExample.main</literal>
      calls the static factory method <literal>makeShape</literal>, whose
      arguments are the name of a geometric shape and a variable length list
      of parameters to pass to the <literal>Shape</literal>
      constructors.</para>

      <para id="para_note_that_the_makeshape_retu">Note that
      <literal>makeShape</literal> returns <literal>Option&lt;? extends
      Shape&gt;</literal>, and when we instantiate a <literal>Shape</literal>,
      we return a <literal>Some</literal> parameterized with the
      <literal>Shape</literal> subtype it wraps. If an unknown shape name is
      passed in, then we return a <literal>None&lt;Shape&gt;</literal>. We
      must parameterize a <literal>None</literal> instance with
      <literal>Shape</literal>. Because Scala defines a subtype of
      <emphasis>all</emphasis> types, <literal>Nothing</literal>, Scala can
      define <literal>None</literal> as <literal>case object None extends
      Option[Nothing]</literal>.<indexterm>
          <primary>Nothing type</primary>
        </indexterm></para>

      <para id="para_the_java_type_system_provides_">The Java type system
      provides no way to implement our Java <literal>None</literal> in a
      similar way. Having a singleton object <literal>None</literal> has a
      number of advantages, including greater efficiency, because we aren&#x2019;t
      creating lots of little objects, and unambiguous behavior of
      <literal>equals</literal>, because we don&#x2019;t need to define the semantics
      of equality between different type instantiations of our Java
      <literal>None&lt;?&gt;</literal> type&#x2014;for example,
      <literal>None&lt;String&gt;</literal> versus
      <literal>None&lt;Shape&gt;</literal>.</para>

      <para id="para_finally_note_that_main_a_c">Finally, note that
      <literal>OptionExample</literal>, a client of <literal>Option</literal>,
      has to specify type variance, <literal>Option&lt;? extends
      Shape&gt;</literal> in several places. In Scala, the client doesn&#x2019;t
      carry this burden.<indexterm class="endofrange" startref="ch12_varianceSvJ"/><indexterm class="endofrange" startref="ch12_datatypesvarianceSvJ"/></para>
    </sect2>

    <sect2 id="ImplementationNotes">
      <title>Implementation Notes</title>

      <para id="para_it_s_worth_noting_how_paramete">The implementation of
      parameterized types and methods is worth noting. The implementations are
      generated when the defining source file is compiled. For each type
      parameter, the implementation assumes that <literal>Any</literal>
      subtype could be specified (<literal>Object</literal> is used in Java
      generics). These aspects have performance implications that we will
      revisit when we discuss the <literal>@specialized</literal> annotation
      in <xref linkend="Annotations"/>.<indexterm class="endofrange" startref="ch12_inheritvariance"/></para>
    </sect2>
  </sect1>

  <sect1 id="TypeBounds">
    <title>Type Bounds</title>

    <para id="para_when_defining_a_parameterized_">When defining a
    parameterized type or method, it may be necessary to specify
    <emphasis>bounds</emphasis> on the type. For example, a parameterized type
    might assume that a particular type parameter contains certain
    methods.<indexterm class="startofrange" id="ch12_typebounds">
        <primary>type bounds</primary>
      </indexterm><indexterm class="startofrange" id="ch12_datatypestypebounds">
        <primary>data types</primary>

        <secondary>type bounds</secondary>
      </indexterm></para>

    <sect2 id="UpperTypeBounds">
      <title>Upper Type Bounds</title>

      <para id="para_for_example_there_are_several">Consider the overloaded
      <literal>apply</literal> methods in <literal>object
      scala.Array</literal> that create new arrays. There are optimized
      implementations for each of the <literal>AnyVal</literal> types. There
      is another implementation of <literal>apply</literal> that is
      parameterized for any type that is a subtype of <literal role="keep-together">AnyRef</literal>. Here is the implementation in
      Scala version 2.7.5:<indexterm>
          <primary>Array object, apply method overloaded for AnyVal and AnyRef
          types</primary>
        </indexterm><indexterm>
          <primary>upper type bounds</primary>
        </indexterm><indexterm>
          <primary>type bounds</primary>

          <secondary>upper</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">object Array {
  ...
  def apply[A &lt;: AnyRef](xs: A*): Array[A] = {
    val array = new Array[A](xs.length)
    var i = 0
    for (x &lt;- xs.elements) { array(i) = x; i += 1 }
    array
  }
  ...
}</programlisting>

      <para id="para_the_type_parameter_a_anyre">The type parameter <literal>A
      &lt;: AnyRef</literal> means &#x201C;any type <literal>A</literal> that is a
      <emphasis>subtype</emphasis> of <literal>AnyRef</literal>.&#x201D; Note that a
      type is always a subtype and a supertype of itself, so
      <literal>A</literal> could also equal <literal>AnyRef</literal>. So the
      <literal>&lt;:</literal> operator indicates that the type to the left
      must be derived from the type to the right, or that they must be the
      same type. As we said in <xref linkend="ReservedWords"/>, this operator
      is actually a reserved word in the <phrase role="keep-together">language</phrase>.</para>

      <para id="para_these_bounds_are_called__upper">These bounds are called
      <emphasis>upper type bounds</emphasis>, following the de facto
      convention that diagrams of type hierarchies put subtypes below their
      supertypes. We followed this convention in the diagram shown in <xref linkend="ScalaTypeHierarchy"/>.</para>

      <para id="para_without_the_bound_in_this_case">Without the bound in this
      case, i.e., if the signature were <literal>def apply[A](xs: A*):
      Array[A]</literal>, the declaration would be ambiguous with the other
      <literal>apply</literal> methods for each of the
      <literal>AnyVal</literal> types.</para>

      <note id="para_note_the_type_signature_a_">
        <para>The type signature <literal>A &lt;: B</literal> says that
        <literal>A</literal> must be a <emphasis>subtype</emphasis> of
        <literal>B</literal>. In Java, this would be expressed as <literal>A
        extends B</literal> in a type declaration. This is different from
        <emphasis>instantiating</emphasis> a type at a call site, where the
        syntax <literal>? extends B</literal> is used in Java, indicating the
        <emphasis>variance</emphasis> behavior.</para>
      </note>

      <para id="para_keep_in_mind_the_distinction_b">Keep in mind the
      distinction between type variance and type bounds. For a type like
      <literal>List</literal>, the <emphasis>variance</emphasis> behavior
      describes how actual types instantiated from it, like
      <literal>List[AnyRef]</literal> and <literal>List[String]</literal>, are
      related. In this case, <literal>List[String]</literal> is a subtype of
      <literal>List[AnyRef]</literal>, since <literal>String</literal> is a
      subtype of <literal>AnyRef</literal>.</para>

      <para id="para_in_contrast_a__type_bound__li">In contrast, lower and
      upper type bounds limit the allowed types that can be used for a type
      parameter when instantiating a type from a parameterized type. For
      example, <literal>def apply[A &lt;: AnyRef]...</literal> says that any
      type used for <literal>A</literal> must be a subtype of
      <literal>AnyRef</literal>.</para>
    </sect2>

    <sect2 id="LowerTypeBounds">
      <title>Lower Type Bounds</title>

      <para id="para_similarly_there_are_circumsta">Similarly, there are
      circumstances when we might want to express that only
      <literal>supertypes</literal> of a particular type are allowed. (Recall
      that a type is also a supertype of itself.) We call these
      <emphasis>lower type bounds</emphasis>, again because the allowed type
      would be above the boundary in a typical type hierarchy
      diagram.<indexterm>
          <primary>lower type bounds</primary>
        </indexterm><indexterm>
          <primary>type bounds</primary>

          <secondary>lower</secondary>
        </indexterm></para>

      <para id="para_in_fact_any_method_can_be_par">A particularly interesting
      example is the <literal>::</literal> (&#x201C;cons&#x201D;) method in class
      <literal>List[+A]</literal>. Recall that this operator is used to create
      a new list by prepending an element to a list:</para>

      <programlisting linenumbering="unnumbered">class List[+A] {
  ...
  def ::[B &gt;: A](x : B) : List[B] = new scala.::(x, this)
  ...
}</programlisting>

      <para id="para_the_new_list_is_of_type_scala">The new list will be of
      type <literal>List[B]</literal>, specifically a
      <literal>scala.::</literal>. The <literal>::</literal>
      <emphasis>class</emphasis> (as opposed to the <literal>::</literal>
      <emphasis>method</emphasis>) is derived from <literal>List</literal>.
      We&#x2019;ll come back to it in a moment.</para>

      <para id="para_the_operator_can_prepend_">The <literal>::</literal>
      method can prepend an object of a different type from
      <literal>A</literal>, the type of the elements in the original list. The
      compiler will infer the closest common supertype for
      <literal>A</literal> and the parameter <literal>x</literal>. It will use
      that supertype as <literal>B</literal>. Here&#x2019;s an example that prepends
      a different type of object on a list:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/bounds/list-ab-script.scala

val languages = List("Scala", "Java", "Ruby", "C#", "C++", "Python")
val list = 3.14 :: languages
println(list)</programlisting>

      <para id="para_the_script_prints_the_followin">The script prints the
      following output:</para>

      <screen>List(3.14, Scala, Java, Ruby, C#, C++, Python)</screen>

      <para id="para_the_new_list_of_type_list_any">The new list of type
      <literal>List[Any]</literal>, since <literal>Any</literal> is the
      closest common supertype of <literal>String</literal> and
      <literal>Double</literal>. We started with a list of
      <literal>Strings</literal>, so <literal>A</literal> was
      <literal>String</literal>. Then we prepended a
      <literal>Double</literal>, so the compiler inferred <literal>B</literal>
      to be <literal>Any</literal>, the closest (and only) common
      supertype.</para>

      <note id="para_note_the_type_signature_b_">
        <para>The type signature <literal>B &gt;: A</literal> says that
        <literal>B</literal> must be a <emphasis>supertype</emphasis> of
        <literal>A</literal>. There is no analog in Java; <literal>B super
        A</literal> is not supported.</para>
      </note>
    </sect2>

    <sect2 id="ACloserLookAtLists">
      <title>A Closer Look at Lists</title>

      <para id="para_putting_these_features_togethe">Putting these features
      together, it&#x2019;s worth looking at the implementation of the
      <literal>List</literal> class in the Scala library. It illustrates
      several useful idioms for functional-style, immutable data structures
      that are fully type-safe, yet flexible. We won&#x2019;t show the entire
      implementation, and we&#x2019;ll omit the <literal>object List</literal>, many
      methods in the <literal>List</literal> class, and the comments that are
      used to generate the Scaladocs. We encourage you to look at the complete
      implementation of <literal>List</literal>, either by downloading the
      source distribution from the <ulink url="http://www.scala-lang.org/">Scala website</ulink> or by browsing to
      the implementation through the Scaladocs page for
      <literal>List</literal>. To avoid confusion with
      <literal>scala.List</literal>, we&#x2019;ll use our own package and name,
      <literal>AbbrevList</literal>:<indexterm class="startofrange" id="ch12_typeboundsList">
          <primary>type bounds</primary>

          <secondary>List class, Scala implementation</secondary>
        </indexterm><indexterm class="startofrange" id="ch12_Listclass">
          <primary>List class</primary>

          <secondary>Scala implementation</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/bounds/abbrev-list.scala
// Adapted from scala/List.scala in the Scala version 2.7.5 distribution.

package bounds.abbrevlist

sealed abstract class AbbrevList[+A] {

  def isEmpty: Boolean
  def head: A
  def tail: AbbrevList[A]

  def ::[B &gt;: A] (x: B): AbbrevList[B] = new bounds.abbrevlist.::(x, this)

  final def foreach(f: A =&gt; Unit) = {
    var these = this
    while (!these.isEmpty) {
      f(these.head)
      these = these.tail
    }
  }
}

// The empty AbbrevList.

case object AbbrevNil extends AbbrevList[Nothing] {
  override def isEmpty = true

  def head: Nothing =
    throw new NoSuchElementException("head of empty AbbrevList")

  def tail: AbbrevList[Nothing] =
    throw new NoSuchElementException("tail of empty AbbrevList")
}

// A non-empty AbbrevList characterized by a head and a tail.

final case class ::[B](private var hd: B,
    private[abbrevlist] var tl: AbbrevList[B]) extends AbbrevList[B] {

  override def isEmpty: Boolean = false
  def head : B = hd
  def tail : AbbrevList[B] = tl
}</programlisting>

      <para id="para_notice_that_while_abbrevlist_">Notice that while
      <literal>AbbrevList</literal> is immutable, the internal implementation
      uses mutable variables, e.g., in <literal>forEach</literal>.</para>

      <para id="para_there_are_three_types_defined_">There are three types
      defined, forming a sealed hierarchy. <literal>AbbrevList</literal> (the
      analog of <literal>List</literal>) is an abstract trait that declares
      three abstract methods: <literal>isEmpty</literal>,
      <literal>head</literal>, and <literal>tail</literal>. It defines the
      &#x201C;cons&#x201D; operator (<literal>::</literal>) and a <literal>foreach</literal>
      method. All the other methods found in <literal>List</literal> could be
      implemented with these methods, although some methods (like
      <literal>List.length</literal>) use different implementation options for
      efficiency.</para>

      <para id="para__abbrevnil_is_the_analog_of_"><literal>AbbrevNil</literal> is
      the analog of <literal>Nil</literal>. It is a case object that extends
      <literal>AbbrevList[Nothing]</literal>. It returns
      <literal>true</literal> from <literal>isEmpty</literal>, and it throws
      an exception from <literal>head</literal> and <literal>tail</literal>.
      Because <literal>AbbrevNil</literal> (and <literal>Nil</literal>) have
      essentially no state and behavior, having an object rather than a class
      eliminates unnecessary copies, makes <literal>equals</literal> fast and
      simple, etc.</para>

      <para id="para_the_class_is_final_its_a">The <literal>::</literal> class
      is the analog of <literal>scala.::</literal> derived from
      <literal>List</literal>. It is declared final. Its arguments are the
      element to become the <literal>head</literal> of the new list and an
      existing list, which will be the <literal>tail</literal> of the new
      list. Note that these values are stored directly as fields. The
      <literal>head</literal> and <literal>tail</literal> methods defined in
      <literal>AbbrevList</literal> are just reader methods for these fields.
      There is no other data structure required to represent the
      list.<indexterm>
          <primary>: (colon)</primary>

          <secondary>:: class</secondary>
        </indexterm></para>

      <para id="para_this_is_why_prepending_a_new_e">This is why prepending a
      new element to create a new list is an O(1) operation. The
      <literal>List</literal> class also has a deprecated method
      <literal>+</literal> for creating a new list by appending an element to
      the end of an existing list. That operation is O(N), where N is the
      length of the list.</para>

      <para id="para_as_you_build_up_new_lists_by_p">As you build up new lists
      by prepending elements to other lists, a nested hierarchy of
      <literal>::</literal> instances is created. Because the lists are
      immutable, there are no concerns about corruption if one of the
      <literal>::</literal> is changed in some way.</para>

      <para id="para_you_can_see_this_nesting_if_yo">You can see this nesting
      if you print out a list, exploiting the <literal>toString</literal>
      method generated because of the <literal>case</literal> keyword. Here is
      an example <literal>scala</literal> session:</para>

      <screen>$ scala -cp ...
Welcome to Scala version 2.7.5.final ...
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import bounds.abbrevlist._
import bounds.abbrevlist._

scala&gt; 1 :: 2 :: 3 :: AbbrevNil
res1: bounds.abbrevlist.AbbrevList[Int] = ::(1,::(2,::(3,AbbrevNil)))</screen>

      <para id="para_abbrevnil_to_string_output">Note the output on the last
      line, which shows the nesting of <literal>(head,tail)</literal>
      elements.</para>

      <para id="para_for_another_example_of_a_simil">For another example using
      similar approaches, this time for defining a stack, refer to <ulink url="http://www.scala-lang.org/node/129"/>.<indexterm class="endofrange" startref="ch12_Listclass"/><indexterm class="endofrange" startref="ch12_typeboundsList"/></para>
    </sect2>

    <sect2 id="ViewsAndViewBounds">
      <title>Views and View Bounds</title>

      <para id="para_we_ve_seen_many_examples_where">We&#x2019;ve seen many examples
      where an <literal>implicit</literal> method was used to convert one type
      to another&#x2014;for example, to give the appearance of adding new methods to
      an existing type, the so-called Pimp My Library pattern. We used this
      pattern extensively in <xref linkend="DomainSpecificLanguages"/>. You
      can also use function values that have the <literal>implicit</literal>
      keyword. We&#x2019;ll see examples of both shortly.<indexterm class="startofrange" id="ch12_views">
          <primary>views</primary>
        </indexterm><indexterm>
          <primary>type bounds</primary>

          <secondary>views and view bounds</secondary>
        </indexterm></para>

      <para id="para_a__view__is_a_value_of_functio">A
      <emphasis>view</emphasis> is an implicit value of function type that
      converts a type <literal>A</literal> to <literal>B</literal>. The
      function has the type <literal>A =&gt; B</literal> or <literal>(=&gt; A)
      =&gt; B</literal> (recall that <literal>(=&gt; A)</literal> is a
      <emphasis>by-name parameter</emphasis>). An in-scope implicit method
      with the same signature can also be used as a view, e.g., an implicit
      method imported from an <literal>object</literal>. The term
      <emphasis>view</emphasis> conveys the sense of having a view from one
      type (<literal>A</literal>) to another type
      (<literal>B</literal>).<indexterm>
          <primary>by-name parameters</primary>
        </indexterm></para>

      <para id="para_a_view_is_applied_in_two_circu">A view is applied in two
      circumstances.</para>

      <orderedlist id="para_1_when_a_type_a_is_used_in_" numeration="arabic">
        <listitem>
          <para>When a type <literal>A</literal> is used in a context where
          another type <literal>B</literal> is expected and there is a view in
          scope that can convert <literal>A</literal> to
          <literal>B</literal>.</para>
        </listitem>

        <listitem>
          <para>When a non-existent member <literal>m</literal> of a type
          <literal>A</literal> is referenced, but there is an in-scope view
          that can convert <literal>A</literal> to a <literal>B</literal> that
          has the <literal>m</literal> member.</para>
        </listitem>
      </orderedlist>

      <para id="para_a_common_example_of_the_second">A common example of the
      second circumstance is the <literal>x -&gt; y</literal> initialization
      syntax for <literal>Maps</literal>, which triggers invocation of
      <literal>Predef.anyToArrowAssoc(x)</literal>, as we discussed in <xref linkend="PredefObject"/>.</para>

      <para id="para_for_the_first_case_predef_a">For an example of the first
      circumstance, <literal>Predef</literal> also defines many views for
      converting between <literal>AnyVal</literal> types and for converting an
      <literal>AnyVal</literal> type to its corresponding
      <literal>java.lang</literal> type. For example,
      <literal>double2Double</literal> converts a
      <literal>scala.Double</literal> to a
      <literal>java.lang.Dou&#x2060;ble</literal>.</para>

      <para id="para_a__view_bound__a_b_is_i">A <emphasis>view
      bound</emphasis> in a type declaration is indicated with the
      <literal>&lt;%</literal> keyword, e.g., <literal>A &lt;% B</literal>. It
      allows any type to be used for <literal>A</literal> if it can be
      converted to <literal>B</literal> using a view.<indexterm>
          <primary>&lt; &gt; (angle brackets)</primary>

          <secondary>&lt;% indicating view bound in type
          declaration</secondary>
        </indexterm><indexterm class="startofrange" id="ch12_viewbounds">
          <primary>view bounds</primary>
        </indexterm></para>

      <para id="para_a_method_or_class_containing_s">A method or class
      containing such a type parameter is treated as being equivalent to a
      corresponding method or class with an extra argument list with one
      element, a view. For example, consider the following method definition
      with a view bound:</para>

      <programlisting linenumbering="unnumbered">def m [A &lt;% B](arglist): R = ...</programlisting>

      <para id="para_it_is_effectively_this_method_">It is effectively the
      same as this method definition:</para>

      <programlisting linenumbering="unnumbered">def m [A](arglist)(implicit viewAB: A =&gt; B): R = ...</programlisting>

      <para id="para_the_implicit_parameter_view_">(The implicit parameter
      <literal>viewAB</literal> would be given a unique name by the compiler.)
      Note that we have an additional argument list, as opposed to an
      additional argument in the existing argument list.</para>

      <para id="para_why_does_view_bounds_trans_work">Why does this
      transformation work? We said that a valid <literal>A</literal> must have
      a view in scope that transforms it to a <literal>B</literal>. The
      implicit <literal>viewAB</literal> argument will get invoked inside
      <literal>m</literal> to convert all <literal>A</literal> instances to
      <literal>B</literal> instances where needed.</para>

      <para id="para_for_this_to_work_there_must_b">For this to work, there
      must be a view of the correct type in scope to satisfy the implicit
      argument. You could also pass a function with the correct signature
      explicitly as the second argument list when you call
      <literal>m</literal>. However, there is one situation where this won&#x2019;t
      work, which we&#x2019;ll describe after our upcoming example.</para>

      <para id="para_for_view_bounds_on_types_the_">For view bounds on types,
      the implicit view argument list would be added to the primary
      constructor.</para>

      <note id="para_note_traits_can_t_have_view_b">
        <para>Traits can&#x2019;t have view bounds for their type parameters, because
        they can&#x2019;t have constructor argument lists.</para>
      </note>

      <para id="para_to_make_this_more_concrete_le">To make this more
      concrete, let&#x2019;s use view bounds to implement a
      <literal>LinkedList</literal> class that uses <literal>Nodes</literal>,
      where each <literal>Node</literal> has a <literal>payload</literal> and
      a reference to the next <literal>Node</literal> in the list. First, here
      is a hierarchy of <literal>Nodes</literal>:<indexterm>
          <primary>LinkedList class that uses Nodes (example)</primary>
        </indexterm><indexterm>
          <primary>view bounds</primary>

          <secondary>implementing LinkedList class that uses Nodes</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/bounds/node.scala

package bounds

abstract trait Node[+A] {
  def payload: A
  def next: Node[A]
}

case class ::[+A](val payload: A, val next: Node[A]) extends Node[A] {
  override def toString =
    String.format("(%s :: %s)", payload.toString, next.toString)
}

object NilNode extends Node[Nothing] {
  def payload = throw new NoSuchElementException("No payload in NilNode")
  def next    = throw new NoSuchElementException("No next in NilNode")

  override def toString = "*"
}</programlisting>

      <para id="para_this_type_hierarchy_looks_a_lo">This type hierarchy is
      modeled after <literal>List</literal> and <literal>AbbrevList</literal>
      earlier. The <literal>::</literal> type represents intermediate nodes,
      and <literal>NilNode</literal> is analogous to <literal>Nil</literal>
      for <literal>Lists</literal>. We also override
      <literal>toString</literal> to give us convenient output, which we&#x2019;ll
      examine shortly.</para>

      <para id="para_the_following_script_defines_t">The following script
      defines a <literal>LinkedList</literal> type that uses
      <literal>Nodes</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/bounds/view-bounds-script.scala

import bounds._

implicit def any2Node[A](x: A): Node[A] = bounds.::[A](x, NilNode)

case class LinkedList[A &lt;% Node[A]](val head: Node[A]) {

  def ::[B &gt;: A &lt;% Node[B]](x: Node[B]) =
    LinkedList(bounds.::(x.payload, head))

  override def toString = head.toString
}

val list1 = LinkedList(1)
val list2 = 2 :: list1
val list3 = 3 :: list2
val list4 = "FOUR!" :: list3

println(list1)
println(list2)
println(list3)
println(list4)</programlisting>

      <para id="para_it_starts_with_a_definition_of">It starts with a
      definition of a parameterized implicit method,
      <literal>any2Node</literal>, that converts <literal>A</literal> to
      <literal>Node[A]</literal>. It will be used as the implicit view
      argument when we work with <literal>LinkedLists</literal>. It creates a
      &#x201C;leaf&#x201D; node using a <literal>bounds.::</literal> node with a reference
      to <literal>NilNode</literal> as the &#x201C;next&#x201D; element in the list.</para>

      <para id="para_an_alternative_would_be_a_func">An alternative would be a
      function value that converts <literal>Any</literal> to
      <literal>Node[Any]</literal>:</para>

      <programlisting linenumbering="unnumbered">implicit val any2Node = (a: Any) =&gt; bounds.::[Any](a, NilNode)</programlisting>

      <para id="para_otherwise_the_script_would_ru">Otherwise, the script
      would run the same, except that some of the temporary lists would be
      using <literal>Node[Any]</literal> rather than
      <literal>Node[Int]</literal>.</para>

      <para id="para_look_at_the_declaration_of_li">Look at the declaration of
      <literal>LinkedList</literal>:</para>

      <programlisting linenumbering="unnumbered">case class LinkedList[A &lt;% Node[A]](val head: Node[A]) { ... }</programlisting>

      <para id="para_it_defines_a_view_bound_on_a_">It defines a view bound on
      <literal>A</literal> and takes a single argument, the head
      <literal>Node</literal> of the list (which may be the head of a chain of
      <literal>Nodes</literal>). As we see later in the script, even though
      the constructor expects a <literal>Node[A]</literal> argument, we can
      pass it an <literal>A</literal> and the implicit view
      <literal>any2Node</literal> will get invoked. The beauty of this
      approach is that a client never has to worry about proper construction
      of <literal>Nodes</literal>. The machinery handles that process
      automatically.</para>

      <para id="para_the_class_also_has_a_cons_">The class also has a &#x201C;cons&#x201D;
      operator:</para>

      <programlisting linenumbering="unnumbered">def ::[B &gt;: A &lt;% Node[B]](x: Node[B]) = ...</programlisting>

      <para id="para_the_type_parameter_means_b_">The type parameter means
      ``<literal>B</literal> is lower bounded by (i.e., is a supertype of)
      <literal>A</literal>, and <literal>B</literal> also has a view bound of
      <literal>B &lt;% Node[B]</literal>. As we saw for
      <literal>List</literal> and <literal>AbbrevList</literal>, the lower
      bound allows us to prepend items of different types from the original
      <literal>A</literal> type. This method will have its own implicit view
      argument, but our parameterized, implicit method,
      <literal>any2Node</literal>, will be used for this argument, too.</para>

      <para id="para_we_mentioned_previously_that_i">We mentioned previously
      that if you don&#x2019;t have a view in scope, you could pass a &#x201C;non-implicit&#x201D;
      converter as the second argument list explicitly. This actually won&#x2019;t
      work in our example, because the constructor and <literal>::</literal>
      method in <literal>LinkedList</literal> take <literal>Node[A]</literal>
      arguments, but we call them with <literal>Ints</literal> and
      <literal>Strings</literal>. We would have to call them with
      <literal>Node[Int]</literal> and <literal>Node[String]</literal>
      arguments explicitly. We would also have to invoke <literal>::</literal>
      in an ugly way&#x2014;<literal>val list2 = list1.::(2)(converter)</literal>,
      for example.</para>

      <para id="para_even_though_it_looks_like_the_">Let&#x2019;s clarify the syntax
      a bit. When you see <literal>B &gt;: A &lt;% Node[B]</literal>, it&#x2019;s
      tempting to assume that the <literal>&lt;%</literal> should apply to
      <literal>A</literal> in this expression. It actually applies to
      <literal>B</literal>. The grammar for type parameters, including view
      bounds, is the following (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>):</para>

      <programlisting linenumbering="unnumbered">TypeParam ::= (id | &#x2018;_&#x2019;) [TypeParamClause] [&#x2018;&gt;:&#x2019; Type] [&#x2018;&lt;:&#x2019; Type] [&#x2018;&lt;%&#x2019; Type]
TypeParamClause ::= &#x2018;[&#x2019; VariantTypeParam {&#x2018;,&#x2019; VariantTypeParam} &#x2018;]&#x2019;
VariantTypeParam ::= [&#x2018;+&#x2019; | &#x2018;&#x2019;] TypeParam</programlisting>

      <para id="para_so_yes_you_can_have_some_ver">So, yes, you can have some
      very complex, hierarchical types! In our <literal>::</literal> method,
      the <literal>id</literal> is <literal>B</literal>, the
      <literal>TypeParamClause</literal> is empty, and we have the
      <literal>&gt;: A</literal> and <literal>&lt;% Node[B]</literal>
      expressions on the right. Again, all the bounds expressions apply to the
      first <literal>id</literal> (<literal>B</literal>) or the underscore
      (&#x2009;<literal>_</literal>&#x2009;).</para>

      <para id="para_you_would_use_the_underscore_">The underscore is used for
      <emphasis>existential types</emphasis>, which we&#x2019;ll cover in <xref linkend="ExistentialTypes"/>.<indexterm>
          <primary>existential types</primary>
        </indexterm></para>

      <para id="para_finally_we_create_a_linkedli">Finally, we create a
      <literal>LinkedList</literal> in the script, prepend some values to
      create new lists, and then print them out:</para>

      <screen>1 :: *
2 :: 1 :: *
3 :: 2 :: 1 :: *
FOUR! :: 3 :: 2 :: 1 :: *</screen>

      <para id="para_again_the_view_bounds_let_us_">To recap, the view bounds
      let us work with &#x201C;payloads&#x201D; of <literal>Ints</literal> and
      <literal>Strings</literal> while the implementation handled the
      necessary conversions to <literal>Nodes</literal>.</para>

      <para id="para_view_bounds_are_not_used_as_of">View bounds are not used
      as often as upper and lower bounds, but they provide an elegant
      mechanism for those times when automatic coercion from one type into
      another is useful. As always, use implicits with caution; implicit
      conversions are far from obvious when reading code and debugging
      mysterious behavior.<indexterm class="endofrange" startref="ch12_viewbounds"/><indexterm class="endofrange" startref="ch12_views"/><indexterm class="endofrange" startref="ch12_typebounds"/><indexterm class="endofrange" startref="ch12_datatypestypebounds"/></para>
    </sect2>
  </sect1>

  <sect1 id="NothingAndNull">
    <title>Nothing and Null</title>

    <para id="para_nothing_and_null">In <xref linkend="ScalaTypeHierarchy"/>,
    we mentioned that <literal>Null</literal> is a subtype of all
    <literal>AnyRef</literal> types and <literal>Nothing</literal> is a
    subtype of all types, including <literal>Null</literal>.<indexterm>
        <primary>data types</primary>

        <secondary>Nothing and Null</secondary>
      </indexterm></para>

    <para id="para__null_is_declared_as_a_final"><literal>Null</literal> is
    declared as a <literal>final trait</literal> (so it can&#x2019;t be subtyped),
    and it has only one instance, <literal>null</literal>. Since
    <literal>Null</literal> is a subtype of all <literal>AnyRef</literal>
    types, you can always assign <literal>null</literal> as an instance of any
    of those types. Java, in contrast, simply treats <literal>null</literal>
    as a keyword with special handling by the compiler. However, Java&#x2019;s
    <literal>null</literal> actually behaves as if it were a subtype of all
    reference types, just like Scala&#x2019;s <literal>Null</literal>.<indexterm>
        <primary>Null object</primary>
      </indexterm></para>

    <para id="para_null_not_subtype_of_anyval">On the other hand, since
    <literal>Null</literal> is not a subtype of <literal>AnyVal</literal>, it
    is not possible to assign <literal>null</literal> to an
    <literal>Int</literal>, for example, which is also consistent with the
    primitive semantics in Java.</para>

    <para id="para_for_example_nil_is_of_type_"><literal>Nothing</literal> is
    also a <literal>final trait</literal>, but it has no instances. However,
    it is still useful for defining types. The best example is
    <literal>Nil</literal>, the empty list, which is a <literal>case
    object</literal>. It is of type <literal>List[Nothing]</literal>. Because
    lists are covariant in Scala, as we saw earlier, this makes
    <literal>Nil</literal> an instance of <literal>List[T]</literal>, for any
    type T. We also exploited this feature in our
    <literal>AbbrevList</literal> and <literal>LinkedList</literal>
    implementations.<indexterm>
        <primary>List class</primary>

        <secondary>Nil case object</secondary>
      </indexterm><indexterm>
        <primary>Nil case object</primary>
      </indexterm><indexterm>
        <primary>Nothing type</primary>
      </indexterm></para>
  </sect1>

  <sect1 id="_understanding_abstract_types">
    <title>Understanding Abstract Types</title>

    <para id="para_what_are_abstract_types">Besides parameterized types, which
    are common in statically typed, object-oriented <phrase role="keep-together">languages</phrase>, Scala also supports abstract
    types, which are common in functional <phrase role="keep-together">languages</phrase>. We introduced abstract types in
    <xref linkend="AbstractTypesAndParameterizedTypes"/>.<indexterm class="startofrange" id="ch12_abstracttypes">
        <primary>abstract types</primary>
      </indexterm><indexterm class="startofrange" id="ch12_datatypesabstract">
        <primary>data types</primary>

        <secondary>abstract</secondary>
      </indexterm></para>

    <para id="para_these_two_features_overlap_som">These two features overlap
    somewhat. Technically, you could implement almost all the idioms that
    parameterized types support using abstract types and vice versa. However,
    in practice, each feature is a natural fit for different design
    problems.</para>

    <para id="para_recall_our_version_of_observe">Recall our version of
    <literal>Observer</literal> that uses abstract types in <xref linkend="AdvancedObjectOrientedProgramming"/>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/observer/observer2.scala

package observer

trait AbstractSubject {
  type Observer

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (notify(_))

  def notify(observer: Observer): Unit
}

trait SubjectForReceiveUpdateObservers extends AbstractSubject {
  type Observer = { def receiveUpdate(subject: Any) }

  def notify(observer: Observer): Unit = observer.receiveUpdate(this)
}

trait SubjectForFunctionalObservers extends AbstractSubject {
  type Observer = (AbstractSubject) =&gt; Unit

  def notify(observer: Observer): Unit = observer(this)
}</programlisting>

    <para id="para__abstractsubject_declares_a_t"><literal>AbstractSubject</literal>
    declares a type <literal>Observer</literal> with no type bounds. It is
    defined in the two derived traits. In
    <literal>SubjectForReceiveUpdateObservers</literal>, it is defined to be a
    <emphasis>structural type</emphasis>. In
    <literal>SubjectForFunctionalObservers</literal>, it is defined to be a
    <emphasis>function type</emphasis>. We&#x2019;ll have more to say about
    structural and function types later in this chapter.</para>

    <para id="para_we_can_also_use_type_bounds_wh">We can also use type bounds
    when we declare or refine the declaration of abstract types. We saw a
    simple example previously in <xref linkend="TypeProjections"/> where we
    had a declaration <literal>type t &lt;: AnyRef</literal>. That is,
    <literal>t</literal> had an upper type bound (superclass) of
    <literal>AnyRef</literal>. <literal>AnyVal</literal> types weren&#x2019;t
    allowed.<indexterm>
        <primary>upper type bounds</primary>
      </indexterm><indexterm>
        <primary>type bounds</primary>

        <secondary>using in abstract type declarations</secondary>
      </indexterm></para>

    <para id="para_we_can_also_have__lower_bounds">We can also have lower type
    bounds (subclasses), and we can use most of the <emphasis>value
    type</emphasis>s (see <xref linkend="ValueTypes"/>) in the bounds
    expressions. Here is an example illustrating the most common
    options:<indexterm>
        <primary>value types</primary>

        <secondary>use in type bounds expressions</secondary>
      </indexterm><indexterm>
        <primary>lower type bounds</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/abstracttypes/abs-type-examples-script.scala

trait exampleTrait {
  type t1               // Unconstrained
  type t2 &gt;: t3 &lt;: t1   // t2 must be a supertype of t3 and a subtype of t1
  type t3 &lt;: t1         // t3 must be a subtype of t1
  type t4               // Unconstrained
  type t5 = List[t4]    // List of t4, whatever t4 will eventually be...

  val v1: t1            // Can't initialize until t1 defined.
  val v3: t3            // etc.
  val v2: t2            // ...
  val v4: t4            // ...
  val v5: t5            // ...
}

trait T1 { val name1: String }
trait T2 extends T1 { val name2: String }
class C(val name1: String, val name2: String) extends T2

object example extends exampleTrait {
  type t1 = T1
  type t2 = T2
  type t3 = C
  type t4 = Int

  val v1 = new T1 { val name1 = "T1"}
  val v3 = new C("C1", "C2")
  val v2 = new T2 { val name1 = "T1"; val name2 = "T2" }
  val v4 = 10
  val v5 = List(1,2,3,4,5)
}</programlisting>

    <para id="para_the_comments_explain_most_of_t">The comments explain most
    of the details. The relationships between <literal>t1</literal>,
    <literal>t2</literal>, and <literal>t3</literal> have some interesting
    points. First, the declaration of <literal>t2</literal> says that it must
    be &#x201C;between&#x201D; <literal>t1</literal> and <literal>t3</literal>. Whatever
    <literal>t1</literal> becomes, it must be a super class of
    <literal>t2</literal> (or equal to it), and <literal>t3</literal> must be
    a subclass of <literal>t2</literal> (or equal to it).</para>

    <para id="para_remember_from_typebounds">Remember from <xref linkend="TypeBounds"/> that we are making a declaration of the
    <emphasis>first</emphasis> type after the <literal>type</literal> keyword,
    <literal>t2</literal>, not the type in the middle, <literal>t3</literal>.
    The rest of <phrase role="keep-together">the expression</phrase> is
    telling us the bounds of <literal>t2</literal>.</para>

    <para id="para_consider_the_next_line_that_de">Consider the next line that
    declares <literal>t3</literal> to be a subtype of <literal>t1</literal>.
    If you were to omit the type bound, the compiler would throw an error,
    because <literal>t3 &lt;: t1</literal> is implied by the previous
    declaration of <literal>t2</literal>. That doesn&#x2019;t mean that you can leave
    out the declaration of <literal>t3</literal>. It has to be there, but it
    also has to show a consistent type bound with the one implied in the
    <literal>t2</literal> declaration.</para>

    <para id="para_when_we_revisit_the_observer_p">When we revisit the
    Observer Pattern in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>, we&#x2019;ll see another
    example of type bounds used on abstract types. We&#x2019;ll see a problem they
    can cause, along with an elegant solution.</para>

    <para id="para_finally_abstract_types_don_t_">Finally, abstract types
    don&#x2019;t have variance annotations:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/abstracttypes/abs-type-variances-wont-compile.scala
// WON'T COMPILE

trait T1 { val name1: String }
trait T2 extends T1 { val name2: String }
class C(val name1: String, val name2: String) extends T2

trait T {
  type t: +T1   // ERROR, no +/- type variance annotations
  val v
}</programlisting>

    <para id="para_remember_that_the_types_are__m">Remember that the abstract
    types are <emphasis>members</emphasis> of the enclosing type, not type
    parameters, as for parameterized types. The enclosing type may have an
    inheritance relationship with other types, but member types behave just
    like member methods and <phrase role="keep-together">variables</phrase>.
    They don&#x2019;t affect the inheritance relationships of their enclosing type.
    Like other members, abstract types can be declared abstract or concrete.
    However, they can also be refined in subtypes without being fully defined,
    unlike variables and methods. Of course, instances can only be created
    when the abstract types are given concrete <phrase role="keep-together">definitions</phrase>.</para>

    <sect2 id="_parameterized_types_vs_abstract_types">
      <title>Parameterized Types Versus Abstract Types</title>

      <para id="para_when_to_use_one__vs___the_othe">When should you use
      parameterized types versus abstract types? Parameterized types are the
      most natural fit for parameterized container types like
      <literal>List</literal> and <literal>Option</literal>. Consider the
      declaration of <literal>Some</literal> from the standard
      library:<indexterm>
          <primary>data types</primary>

          <secondary>abstract</secondary>

          <tertiary>parameterized types versus</tertiary>
        </indexterm><indexterm>
          <primary>parameterized types</primary>

          <secondary>abstract types versus</secondary>
        </indexterm><indexterm>
          <primary>abstract types</primary>

          <secondary>parameterized types versus</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">case final class Some[+A](val x : A) { ... }</programlisting>

      <para id="para_if_we_tried_to_convert_this_to">If we tried to convert
      this to use abstract types, we might start with the following:</para>

      <programlisting linenumbering="unnumbered">case final class Some(val x : ???) {
  type A
  ...
}</programlisting>

      <para id="para_what_should_be_the_type_of_the">What should be the type
      of the field <literal>x</literal>? We can&#x2019;t use <literal>A</literal>
      because it&#x2019;s not in scope at the point of the constructor argument. We
      could use <literal>Any</literal>, but that defeats the value of having
      appropriately typed declarations.</para>

      <para id="para_if_a_type_will_have_constructo">If a type will have
      constructor arguments declared using a &#x201C;placeholder&#x201D; type that has not
      yet been defined, then parameterized types are the only good solution
      (short of using <literal>Any</literal> or
      <literal>AnyRef</literal>).</para>

      <para id="para_you_can_use_abstract_types_as_">You can use abstract
      types as method arguments and return values within a function. However,
      two problems can arise. First, you can run into problems with <phrase role="keep-together">path-</phrase><phrase role="keep-together">dependent</phrase> types (discussed in <xref linkend="PathDependentTypes"/>), where the compiler thinks you are
      trying to use an incompatible type in a particular context, when in fact
      they are paths to compatible types. Second, it&#x2019;s awkward to express
      methods like <literal>List.::</literal> (&#x201C;cons&#x201D;) using abstract types
      where type changes (expansion in this case) can occur:<indexterm>
          <primary>methods</primary>

          <secondary>abstract types as arguments</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">class List[+A] {
  ...
  def ::[B &gt;: A](x : B) : List[B] = new scala.::(x, this)
  ...
}</programlisting>

      <para id="para_also_if_you_want_to_express_v">Also, if you want to
      express variance under inheritance that is tied to the type
      abstractions, then parameterized types with variance annotations make
      these behaviors obvious and explicit.<indexterm>
          <primary>variance under inheritance</primary>

          <secondary>abstract versus parameterized types</secondary>
        </indexterm></para>

      <para id="para_these_limitations_of_abstract_">These limitations of
      abstract types really reflect the tension between object-oriented
      inheritance and the origin of abstract types in pure functional
      programming type <phrase role="keep-together">systems</phrase>, which
      don&#x2019;t have inheritance. Parameterized types are more popular in
      object-oriented languages because they handle inheritance more naturally
      in most <phrase role="keep-together">circumstances</phrase>.</para>

      <para id="para_on_the_other_hand_when_you_wa">On the other hand,
      sometimes it&#x2019;s useful to refer to a type abstraction as a member of
      another type, as opposed to a parameter used to construct new types from
      a parameterized type. Refining an abstract type declaration through a
      series of enclosing type refinements can be quite elegant:</para>

      <programlisting linenumbering="unnumbered">trait T1 {
  type t
  val v: t
}
trait T2 extends T1 {
  type t &lt;: SomeType1
}
trait T3 extends T2 {
  type t &lt;: SomeType2  // where SomeType2 &lt;: SomeType1
}
class C extends T3 {
  type t = Concrete    // where Concrete &lt;: SomeType2
  val v = new Concrete(...)
}
...</programlisting>

      <para id="para_abstract_types_are_often_used_">This example also shows
      that abstract types are often used to declare abstract variables of the
      same type. Less frequently, they are used for method
      declarations.</para>

      <para id="para_when_the_abstract_variables_ar">When the abstract
      variables are eventually made concrete, they can either be defined
      inside the type body, much as they were originally declared, or they can
      be initialized through constructor arguments. Using constructor
      arguments lets the user decide on the actual values, while initializing
      them in the body lets the type designer decide on the appropriate
      value.</para>

      <para id="para_we_used_constructor_arguments_">We used constructor
      arguments in the brief <literal>BulkReader</literal> example we
      presented in <xref linkend="AbstractTypesAndParameterizedTypes"/>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/abstract-types-script.scala

import java.io._

abstract class BulkReader {
  type In
  val source: In
  def read: String
}

class StringBulkReader(val source: String) extends BulkReader {
  type In = String
  def read = source
}

class FileBulkReader(val source: File) extends BulkReader {
  type In = File
  def read = {
    val in = new BufferedInputStream(new FileInputStream(source))
    val numBytes = in.available()
    val bytes = new Array[Byte](numBytes)
    in.read(bytes, 0, numBytes)
    new String(bytes)
  }
}

println( new StringBulkReader("Hello Scala!").read )
println( new FileBulkReader(new File("abstract-types-script.scala")).read )</programlisting>

      <para id="para_if_you_come_from_an_object_ori">If you come from an
      object-oriented background, you will naturally tend to use parameterized
      types more often than abstract types. The Scala standard library tends
      to emphasize parameterized types, too. Still, you should learn the
      merits of abstract types and use them when they make sense.<indexterm class="endofrange" startref="ch12_abstracttypes"/><indexterm class="endofrange"/></para>
    </sect2>
  </sect1>

  <sect1 id="PathDependentTypes">
    <title>Path-Dependent Types</title>

    <para id="para_languages_that_let_you_nest_ty">Languages that let you nest
    types provide ways to refer to those type <emphasis>paths</emphasis>.
    Scala provides a rich syntax for path-dependent types. Although you will
    probably use them rarely, it&#x2019;s useful to understand the basics, as
    compiler errors often contain type paths.<indexterm>
        <primary>data types</primary>

        <secondary>path-dependent types</secondary>
      </indexterm><indexterm>
        <primary>path-dependent types</primary>
      </indexterm></para>

    <para id="para_path_dependent_types">Consider the following
    example:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/typepaths/type-path-wont-compile.scala
// ERROR: Won't compile

trait Service {
  trait Logger {
    def log(message: String): Unit
  }
  val logger: Logger

  def run = {
    logger.log("Starting " + getClass.getSimpleName + ":")
    doRun
  }

  protected def doRun: Boolean
}

object MyService1 extends Service {
  class MyService1Logger extends Logger {
    def log(message: String) = println("1: "+message)
  }
  override val logger = new MyService1Logger
  def doRun = true  // do some real work...
}

object MyService2 extends Service {
  override val logger = MyService1.logger  // ERROR
  def doRun = true  // do some real work...
}</programlisting>

    <?dbfo-need height=”1in”
?>

    <para id="para_if_you_compile_this_file_you_g">If you compile this file,
    you get the following error:</para>

    <screen>...:27: error: error overriding value logger in trait Service of type \
    MyService2.Logger;
 value logger has incompatible type MyService1.MyService1Logger
  override val logger = MyService1.logger  // ERROR
               ^
one error found</screen>

    <para id="para_the_error_says_that_the_logge">The error says that the
    <literal>logger</literal> value in <literal role="keep-together">MyService2</literal> on line 25 has type
    <literal>MyService2.Log&#x2060;ger</literal>, even though it&#x2019;s declared to be of
    type <literal>Logger</literal> in the parent <literal>Service</literal>
    trait. Also, we&#x2019;re trying to assign it a value of type
    <literal>MyService1.MyService1Logger</literal>.</para>

    <para id="para_these_three_types_are_differen">These three types are
    different in Scala. <literal>Logger</literal> is nested in
    <literal>Service</literal>, which is the parent of
    <literal>MyService1</literal> and <literal>MyService2</literal>. In Scala,
    that means that the nested <literal>Logger</literal> type is unique for
    each of the service types. The actual type is
    <emphasis>path-dependent</emphasis>.</para>

    <para id="para_in_this_case_the_easiest_solu">In this case, the easiest
    solution is to move the declaration of <literal>Logger</literal> outside
    of <literal role="keep-together">Service</literal>, thereby removing the
    path dependency. In other cases, it&#x2019;s possible to qualify the type so that
    it resolves to what you want.</para>

    <para id="para_there_are_several_kinds_of_typ">There are several kinds of
    type paths.</para>

    <sect2 id="_c_this">
      <title>C.this</title>

      <para id="para_for_a_class_c_you_can_use_c_">For a class
      <literal>C</literal>, you can use <literal>C.this</literal> or
      <literal>this</literal> inside the body to refer to the current
      instance:<indexterm>
          <primary>C.this type</primary>
        </indexterm><indexterm>
          <primary>path-dependent types</primary>

          <secondary>C.this</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">class C1 {
  var x = "1"
  def setX1(x:String) = this.x = x
  def setX2(x:String) = C1.this.x = x
}</programlisting>

      <para id="para_both_setx1_and_setx2_have_">Both <literal>setX1</literal>
      and <literal>setX2</literal> have the same effect, because
      <literal>C1.this</literal> is equivalent to
      <literal>this</literal>.</para>

      <para id="para_inside_a_type_body_and_outside">Inside a type body and
      outside a method definition, <literal>this</literal> refers to the type
      itself:</para>

      <programlisting linenumbering="unnumbered">trait T1 {
  class C
  val c1 = new C
  val c2 = new this.C
}</programlisting>

      <para id="para_the_values_c1_and_c2_have_">The values
      <literal>c1</literal> and <literal>c2</literal> have the same type. The
      <literal>this</literal> in the expression <literal>this.C</literal>
      refers to the trait <literal>T1</literal>.</para>
    </sect2>

    <sect2 id="_c_super">
      <title>C.super</title>

      <para id="para_you_can_refer_specifically_to_">You can refer
      specifically to the parent of a type with
      <literal>super</literal>:<indexterm>
          <primary>path-dependent types</primary>

          <secondary>C.super</secondary>
        </indexterm><indexterm>
          <primary>C.super type</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">class C2 extends C1
class C3 extends C2 {
  def setX3(x:String) = super.setX1(x)
  def setX4(x:String) = C3.super.setX1(x)
  def setX5(x:String) = C3.super[C2].setX1(x)
}</programlisting>

      <para id="para__c3_super_is_equivalent_to_s"><literal>C3.super</literal>
      is equivalent to <literal>super</literal> in this example. If you want
      to refer specifically to one of the parents of a type, you can qualify
      <literal>super</literal> with the type, as shown in
      <literal>setX5</literal>. This is particularly useful for the case where
      a type mixes in several traits, each of which overrides the same method.
      If you need access to one of the methods in a specific trait, you can
      qualify <literal>super</literal>. However, this qualification can&#x2019;t
      refer to &#x201C;grandparent&#x201D; types.</para>

      <para id="para_super_and_linearization">What if you are calling
      <literal>super</literal> in a class with several mixins and it extends
      another type? To which type does <literal>super</literal> bind? Without
      the qualification, the rules of <emphasis>linearization</emphasis>
      determine the target of <literal>super</literal> (see <xref linkend="Linearization"/>).<indexterm>
          <primary>linearization of object hierarchy</primary>
        </indexterm></para>

      <para id="para_just_as_for_this_you_can_us">Just as for
      <literal>this</literal>, you can use <literal>super</literal> to refer
      to the parent type in a type body outside a method:</para>

      <programlisting linenumbering="unnumbered">class C4 {
  class C5
}
class C6 extends C4 {
  val c5a = new C5
  val c5b = new super.C5
}</programlisting>

      <para id="para_both_c5a_and_c5b_have_the_">Both <literal>c5a</literal>
      and <literal>c5b</literal> have the same type.</para>
    </sect2>

    <sect2 id="_path_x">
      <title>path.x</title>

      <para id="para_you_can_reach_a_nested_type_">You can reach a nested type
      with a period-delimited path expression:<indexterm>
          <primary>. (dot)</primary>

          <secondary>period-delimited path expressions</secondary>
        </indexterm><indexterm>
          <primary>path-dependent types</primary>

          <secondary>period-delimited path expressions</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">package P1 {
  object O1 {
    object O2 {
      val name = "name"
    }
  }
}
class C7 {
  val name = P1.O1.O2.name
}</programlisting>

      <para id="para_the_elements_of_a_type_path_mu"><literal>C7.name</literal> uses
      a path to the <literal>name</literal> value in <literal>O2</literal>.
      The elements of a type path must be <emphasis>stable</emphasis>, which
      roughly means that all elements in the path must be packages, singleton
      objects, or type declarations that alias the same. The last element in
      the path can be a class or trait. See <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link> for the details:</para>

      <programlisting linenumbering="unnumbered">object O3 {
  object O4 {
    type t = java.io.File
    class C
    trait T
  }
  class C2 {
    type t = Int
  }
}
class C8 {
  type t1 = O3.O4.t
  type t2 = O3.O4.C
  type t3 = O3.O4.T
//  type t4 = O3.C2.t   // ERROR: C2 is not a "value" in O3
}</programlisting>
    </sect2>
  </sect1>

  <sect1 id="ValueTypes">
    <title>Value Types</title>

    <para id="para_because_scala_is_a_strongly_an">Because Scala is strongly
    and statically typed, every value has a type. The term <emphasis>value
    types</emphasis> refers to all the different forms these types take, so it
    encompasses many forms that are now familiar to us, plus a few new ones we
    haven&#x2019;t encountered until now.<indexterm class="startofrange" id="ch12_datatypesvalue">
        <primary>data types</primary>

        <secondary>value types</secondary>
      </indexterm><indexterm>
        <primary>value types</primary>
      </indexterm></para>

    <warning id="para_warning_we_are_using_the_term">
      <para>We are using the term <emphasis>value type</emphasis> here in the
      same way the term is used by <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>. However, elsewhere in
      the book we also follow the specification&#x2019;s overloaded use of the term
      to refer to all subtypes of <literal>AnyVal</literal>.</para>
    </warning>

    <sect2 id="_type_designators">
      <title>Type Designators</title>

      <para id="para_the_conventional_type_ids_we_c">The conventional type IDs
      we commonly use are called <emphasis>type
      designators</emphasis>:<indexterm>
          <primary>value types</primary>

          <secondary>type designators</secondary>
        </indexterm><indexterm>
          <primary>type designators</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">class Person              // "Person" is a type designator
object O { type t }       // "O" and "t" are type designators
...</programlisting>

      <para id="para_they_are_actually_a_short_hand">They are actually a
      shorthand syntax for <emphasis>type projections</emphasis>, which we
      cover later.</para>
    </sect2>

    <sect2 id="_tuples">
      <title>Tuples</title>

      <para id="para_a_value_of_the_form_x_1_">A value of the form
      <literal>(x</literal><subscript>1</subscript><literal>, ...
      x</literal><subscript>N</subscript><literal>)</literal> is a tuple value
      type.<indexterm>
          <primary>tuples</primary>

          <secondary>value type, syntax for</secondary>
        </indexterm><indexterm>
          <primary>value types</primary>

          <secondary>tuples</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="_parameterized_types">
      <title>Parameterized Types</title>

      <para id="para_when_we_create_a_type_from_a_t">When we create a type
      from a parameterized type, e.g., <literal>List[Int]</literal> and
      <literal>List[String]</literal> from <literal>List[A]</literal>, the
      types <literal>List[Int]</literal> and <literal>List[String]</literal>
      are value types, because they are associated with declared values, e.g.,
      <literal>val names = List[String]()</literal>.<indexterm>
          <primary>parameterized types</primary>

          <secondary>value types created from</secondary>
        </indexterm><indexterm>
          <primary>value types</primary>

          <secondary>parameterized types</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="_annotated_types">
      <title>Annotated Types</title>

      <para id="para_when_we_annotate_a_type__e_g_">When we annotate a type,
      e.g., <literal>@serializable @cloneable class C(val x:String)</literal>,
      the actual type includes the annotations.<indexterm>
          <primary>annotated types</primary>
        </indexterm><indexterm>
          <primary>annotated types</primary>
        </indexterm></para>
    </sect2>

    <sect2 id="_compound_types">
      <title>Compound Types</title>

      <para id="para_a_declaration_of_the_form_t_">A declaration of the form
      <literal>T</literal><subscript>1</subscript><literal> extends
      T</literal><subscript>2</subscript><literal> with
      T</literal><subscript>3</subscript><literal> { R }</literal>, where
      <literal>R</literal> is the <emphasis>refinement</emphasis> (body),
      declares a compound type. Any declarations in the refinement are part of
      the compound type definition. The notion of compound types accounts for
      the fact that not all types are named, since we can have anonymous
      types, such as this example <literal>scala</literal> session:<indexterm>
          <primary>refinement in compound type declarations</primary>
        </indexterm><indexterm>
          <primary>compound types</primary>
        </indexterm></para>

      <screen>scala&gt; val x = new T1 with T2 {
        type z = String
        val v: z = "Z"
}
x: java.lang.Object with T1 with T2{type z = String; def zv: this.z} = \
    $anon$1@9d9347d</screen>

      <para id="para_note_that_path_dependent_type_">Note that path-dependent
      type <literal>this.z</literal> in the output.</para>

      <para id="para_a_particularly_interesting_cas">A particularly
      interesting case is a declaration of the form <literal>val x = new { R
      }</literal>, i.e., without any type IDs. This is equivalent to
      <literal>val x = new AnyRef { R }</literal>.</para>
    </sect2>

    <sect2 id="_infix_types">
      <title>Infix Types</title>

      <para id="para_some_parameterized_types_take_">Some parameterized types
      take two type arguments, e.g., <literal>scala.Either[+A,+B]</literal>.
      Scala allows you to declare instances of these types using an infix
      notation, e.g., <literal>a Either b</literal>. Consider the following
      script that uses <literal>Either</literal>:<indexterm>
          <primary>value types</primary>

          <secondary>infix types</secondary>
        </indexterm><indexterm>
          <primary>infix types</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/valuetypes/infix-types-script.scala

def attempt(operation: =&gt; Boolean): Throwable Either Boolean = try {
  Right(operation)
} catch {
  case t: Throwable =&gt; Left(t)
}

println(attempt { throw new RuntimeException("Boo!") })
println(attempt { true })
println(attempt { false })</programlisting>

      <para id="para_the_attempt_method_will_eval">The
      <literal>attempt</literal> method will evaluate the
      <emphasis>call-by-name</emphasis> parameter <literal>operation</literal>
      and return its <literal>Boolean</literal> result, wrapped in a
      <literal>Right</literal>, <emphasis>or</emphasis> any
      <literal>Throwable</literal> that is caught, wrapped in a
      <literal>Left</literal>. The script produces this output:</para>

      <screen>Left(java.lang.RuntimeException: Boo!)
Right(true)
Right(false)</screen>

      <para id="para_notice_the_return_value_thro">Notice the declared return
      value, <literal>Throwable Either Boolean</literal>. It is identical to
      <literal>Either[Throwable, Boolean]</literal>. Recall from <xref linkend="ScalaTypeHierarchy"/> that when using this exception-handling
      idiom with <literal>Either</literal>, it is conventional to use
      <literal>Left</literal> for the exception and <literal>Right</literal>
      for the normal return value.</para>
    </sect2>

    <sect2 id="FunctionTypes">
      <title>Function Types</title>

      <para id="para_about_function_types">The functions we have been writing
      are also typed. <literal>(T</literal><subscript>1</subscript><literal>,
      T</literal><subscript>2</subscript><literal>, ...
      T</literal><subscript>N</subscript><literal>) =&gt; R</literal> is the
      type for all functions that take <literal>N</literal> arguments and
      return a value of type <literal>R</literal>.<indexterm>
          <primary>value types</primary>

          <secondary>function types</secondary>
        </indexterm><indexterm>
          <primary>function types</primary>
        </indexterm></para>

      <para id="para_when_there_is_only_one_argumen">When there is only one
      argument, you can drop the parentheses: <literal>T =&gt; R</literal>. A
      function that takes a <emphasis>call-by-name</emphasis> parameter (as
      discussed in <xref linkend="FunctionalProgramming"/>) has the type
      <literal>(=&gt;T) =&gt; R</literal>. We used a call-by-name argument in
      our <literal>attempt</literal> example in the previous
      section.<indexterm>
          <primary>call-by-name parameters</primary>
        </indexterm></para>

      <para id="para_recall_that_everything_in_scal">Recall that everything in
      Scala is an object, even functions. The Scala library defines traits for
      each <literal>FunctionN</literal>, for <literal>N</literal> from
      <literal>0</literal> to <literal>22</literal>, inclusive. Here, for
      example, is the version 2.7.5 source for
      <literal>scala.Function3</literal>, omitting most comments and a few
      other details that don&#x2019;t concern us now:<indexterm>
          <primary>FunctionN object</primary>

          <secondary>defining traits for</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// From Scala version 2.7.5: scala.Function3 (excerpt).
package scala

trait Function3[-T1, -T2, -T3, +R] extends AnyRef {
  def apply(v1:T1, v2:T2, v3:T3): R
  override def toString() = "&lt;function&gt;"

  /** f(x1,x2,x3)  == (f.curry)(x1)(x2)(x3)
   */
  def curry: T1 =&gt; T2 =&gt; T3 =&gt; R = {
    (x1: T1) =&gt; (x2: T2) =&gt; (x3: T3) =&gt; apply(x1,x2,x3)
  }
}</programlisting>

      <para id="para_as_we_discussed_in_varianceu">As we discussed in <xref linkend="VarianceUnderInheritance"/>, the <literal>FunctionN</literal>
      traits are <emphasis>contravariant</emphasis> in the type parameters for
      the arguments and <emphasis>covariant</emphasis> in the return type
      parameter.</para>

      <para id="para_recall_that_when_you_reference">Recall that when you
      reference any object followed by an argument list, Scala calls the
      <literal>apply</literal> method on the object. In this way, any object
      with an <literal>apply</literal> method can also be considered a
      function, providing a nice symmetry with the object-oriented nature of
      Scala.<indexterm>
          <primary>apply method</primary>

          <secondary>objects with, considered as functions</secondary>
        </indexterm></para>

      <para id="para_when_you_define_a_function_val">When you define a
      function value, the compiler instantiates the appropriate <literal role="keep-together">FunctionN</literal> object and uses your definition
      of the function as the body of <literal>apply</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/valuetypes/function-types-script.scala

val capitalizer = (s: String) =&gt; s.toUpperCase

val capitalizer2 = new Function1[String,String] {
  def apply(s: String) = s.toUpperCase
}

println( List("Programming", "Scala") map capitalizer)
println( List("Programming", "Scala") map capitalizer2)</programlisting>

      <para id="para_the_capitalizer_and_capital">The
      <literal>capitalizer</literal> and <literal>capitalizer2</literal>
      function values are effectively the same, where the latter mimics the
      compiler&#x2019;s output.</para>

      <para id="para_the_curry_method_returns_a_n">We discussed the
      <literal>curry</literal> method previously in <xref linkend="Currying"/>. It returns a new function with
      <literal>N</literal> argument lists, each of which has a single argument
      taken from the original argument list of <literal>N</literal> arguments.
      Note that the same <literal>apply</literal> method is invoked:<indexterm>
          <primary>curried functions</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/valuetypes/curried-function-script.scala

val f  = (x: Double, y: Double, z: Double) =&gt; x * y / z
val fc = f.curry

val answer1 = f(2., 5., 4.)
val answer2 = fc(2.)(5.)(4.)
println( answer1 + " == " + answer2 + "? " + (answer1 == answer2))

val fc1 = fc(2.)
val fc2 = fc1(5.)
val answer3 = fc2(4.)
println( answer3 + " == " + answer2 + "? " + (answer3 == answer2))</programlisting>

      <para id="para_curried_function_script_output">This script produces the
      following output:</para>

      <screen>2.5 == 2.5? true
2.5 == 2.5? true</screen>

      <para id="para_in_the_first_part_of_the_scrip">In the first part of the
      script, we define a <literal>Function3</literal> value
      <literal>f</literal> that does <literal>Double</literal> arithmetic. We
      create a new function value <literal>fc</literal> by currying
      <literal>f</literal>. Then we call both functions with the same
      arguments and print out the results. As expected, they both produce the
      same output. (There are no concerns about rounding errors in the
      comparison here; recall that both functions call the same
      <literal>apply</literal> method, so they must return the same
      value.)</para>

      <para id="para_in_the_second_part_of_the_scri">In the second part of the
      script, we exploit the feature of curried functions that we can
      <emphasis>partially apply</emphasis> arguments, creating new functions,
      until we apply all the arguments. The example also helps us make sense
      of the declaration of <literal>curry</literal> in
      <literal>Function3</literal>.</para>

      <para id="para_functions_are_right_associativ">Functions are
      right-associative, so a type <literal>T1 =&gt; T2 =&gt; T3 =&gt;
      R</literal> is equivalent to <literal>T1 =&gt; (T2 =&gt; (T3 =&gt;
      R))</literal>. We see this in the script. In the statement <literal>val
      fc1 = fc(2.)</literal>, we call <literal>fc</literal> with just the
      first argument list (corresponding to <literal>T1</literal> equals
      <literal>Double</literal>). It returns a <emphasis>new</emphasis>
      function of type <literal>T2 =&gt; (T3 =&gt; R)</literal> or
      <literal>Double =&gt; (Double =&gt; Double)</literal>, in our
      case.</para>

      <para id="para_next_in_val_fc2_fc1_5_">Next, in <literal>val fc2 =
      fc1(5.)</literal>, we supply the second (<literal>T2</literal>)
      argument, returning a new function of type <literal>T3 =&gt;
      R</literal>, that is, <literal>Double =&gt; Double</literal>. Finally,
      in <literal>val answer3 = fc2(4.)</literal> we supply the last argument
      to compute the value of type <literal>R</literal>, that is
      <literal>Double</literal>.</para>

      <note id="para_note_a_type_t1_062_t2_">
        <para>A type <literal>T1 =&gt; T2 =&gt; T3 =&gt; R</literal> is
        equivalent to <literal>T1 =&gt; (T2 =&gt; (T3 =&gt; R))</literal>.
        When we call a function of this type with a value for
        <literal>T1</literal>, it returns a new function of type <literal>T2
        =&gt; (T3 =&gt; R)</literal>, and so forth.</para>
      </note>

      <para id="para_finally_since_functions_are_i">Finally, since functions
      are instances of traits, you can use the traits as parents of other
      types. In the Scala library, <literal>Seq[+A]</literal> is a subclass of
      <literal>PartialFunction[Int,A]</literal>, which is a subclass of
      <literal>(Int) =&gt; A</literal>, i.e.,
      <literal>Function1[Int,A]</literal>.<indexterm>
          <primary>traits</primary>

          <secondary>functions as instances of</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="TypeProjections">
      <title>Type Projections</title>

      <para id="para_about_type_projections"><emphasis>Type
      projections</emphasis> are a way to refer to a type declaration nested
      in another type:<indexterm>
          <primary>type projections</primary>
        </indexterm><indexterm>
          <primary>value types</primary>

          <secondary>type projections</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/valuetypes/type-projection-script.scala

trait T {
  type t &lt;: AnyRef
}
class C1 extends T {
  type t = String
}
class C2 extends C1

val ic1: C1#t = "C1"
val ic2: C2#t = "C2"
println(ic1)
println(ic2)</programlisting>

      <para id="para_type_proj_output">Both <literal>C1#t</literal> and
      <literal>C2#t</literal> are <literal>String</literal>. You can also
      reference the abstract type <literal>T#t</literal>, but you can&#x2019;t use it
      in a declaration because it is abstract.</para>
    </sect2>

    <sect2 id="_singleton_types">
      <title>Singleton Types</title>

      <para id="para_about_singleton_types">If you have a value
      <literal>v</literal> of a subtype of <literal>AnyRef</literal>,
      including <literal>null</literal>, you can get its <emphasis>singleton
      type</emphasis> using the expression <literal>v.type</literal>. These
      expressions can be used as types in declarations. This feature is useful
      on rare occasions to work around the fact that types are path dependent,
      which we discussed in <xref linkend="PathDependentTypes"/>. In these
      cases an object may have a path-dependent type that appears to be
      incompatible with another path-dependent type, when in fact they are
      compatible. Using the <literal>v.type</literal> expression retrieves the
      singleton type, a &#x201C;unique&#x201D; type that eliminates the path dependency. Two
      values <literal>v1</literal> and <literal>v2</literal> may have
      different path-dependent types, but they could have the same singleton
      type.<indexterm>
          <primary>singleton types</primary>
        </indexterm><indexterm>
          <primary>value types</primary>

          <secondary>singleton types</secondary>
        </indexterm></para>

      <para id="para_this_example_uses_the_singleto">This example uses the
      singleton type for one value in a declaration of another:</para>

      <programlisting linenumbering="unnumbered">class C {
  val x = "Cx"
}
val c = new C
val x: c.x.type = c.x</programlisting>
    </sect2>
  </sect1>

  <sect1 id="SelfTypeAnnotations">
    <title>Self-Type Annotations</title>

    <para id="para_self_types">You can use <literal>this</literal> in a method
    to refer to the enclosing type, which is useful for referencing a member
    of the type. Using <literal>this</literal> is not usually necessary for
    this purpose, but it&#x2019;s useful occasionally for disambiguating a reference
    when several values are in scope with the same name. By default, the type
    of <literal>this</literal> is the same as the enclosing type, but this is
    not really essential.<indexterm>
        <primary>this keyword</primary>

        <secondary>self-type annotations</secondary>
      </indexterm><indexterm class="startofrange" id="ch12_typeself">
        <primary>type annotations</primary>

        <secondary>self-type annotations</secondary>
      </indexterm><indexterm class="startofrange" id="ch12_selftype">
        <primary>self-type annotations</primary>
      </indexterm><indexterm class="startofrange" id="ch12_datatypesself">
        <primary>data types</primary>

        <secondary>self-type annotations</secondary>
      </indexterm><indexterm class="endofrange" startref="ch12_datatypesvalue"/></para>

    <para id="para__self_type_annotations__let_yo"><emphasis>Self-type
    annotations</emphasis> let you specify additional type expectations for
    <literal>this</literal>, and they can be used to create aliases for
    <literal>this</literal>. Let&#x2019;s consider the latter case first:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/selftype/this-alias-script.scala

class C1 { self =&gt;
  def talk(message: String) = println("C1.talk: " + message)
  class C2 {
    class C3 {
      def talk(message: String) = self.talk("C3.talk: " + message)
    }
    val c3 = new C3
  }
  val c2 = new C2
}
val c1 = new C1
c1.talk("Hello")
c1.c2.c3.talk("World")</programlisting>

    <para id="para_this_alias_script_output">It prints the following:</para>

    <screen>C1.talk: Hello
C1.talk: C3.talk: World</screen>

    <para id="para_we_give_the_outer_scope_c1_">We give the outer scope
    (<literal>C1</literal>) <literal>this</literal> the alias
    <literal>self</literal>, so we can easily refer to it in
    <literal>C3</literal>. We could use <literal>self</literal> within any
    method inside the body of <literal>C1</literal> or its nested types. Note
    that the name <literal>self</literal> is arbitrary, but it is somewhat
    conventional. In fact, you could say <literal>this =&gt;</literal>, but it
    would be completely redundant.</para>

    <para id="para_if_the_self_type_annotation_ha">If the self-type annotation
    has types in the annotation, we get some very different <phrase role="keep-together">benefits</phrase>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/selftype/selftype-script.scala

trait Persistence {
  def startPersistence: Unit
}

trait Midtier {
  def startMidtier: Unit
}

trait UI {
  def startUI: Unit
}

trait Database extends Persistence {
  def startPersistence = println("Starting Database")
}

trait ComputeCluster extends Midtier {
  def startMidtier = println("Starting ComputeCluster")
}

trait WebUI extends UI {
  def startUI = println("Starting WebUI")
}

trait App {
  self: Persistence with Midtier with UI =&gt;

  def run = {
    startPersistence
    startMidtier
    startUI
  }
}

object MyApp extends App with Database with ComputeCluster with WebUI

MyApp.run</programlisting>

    <para id="para_this_script_shows_a_schematic_">This script shows a
    schematic layout for an <literal>App</literal> (application)
    infrastructure supporting several tiers/components, persistent storage,
    midtier, and UI. We&#x2019;ll explore this approach to component design in more
    detail in <xref linkend="ApplicationDesign"/>.</para>

    <para id="para_for_now_we_just_care_about_th">For now, we just care about
    the role of self types. Each abstract trait declares a &#x201C;start&#x201D; method that
    does the work of initializing the tier. (We&#x2019;re ignoring issues like
    success versus failure of startup, etc.) Each abstract tier is implemented
    by a corresponding concrete trait (not a class, so we can use them as
    mixins). We have traits for database persistence, some sort of computation
    cluster to do the heavy lifting for the business logic, and a web-based
    UI.</para>

    <para id="para_the_app_traits_wires_the_tie">The <literal>App</literal>
    trait wires the tiers together. For example, it does the work of starting
    the tiers in the <literal>run</literal> method.</para>

    <para id="para_note_the_self_type_annotation_">Note the self-type
    annotation, <literal>self: Persistence with Midtier with UI
    =&gt;</literal>. It has two practical effects:</para>

    <orderedlist numeration="arabic">
      <listitem>
        <para>The body of the trait can assume it is an instance of
        <literal>Persistence</literal>, <literal>Midtier</literal>, and
        <literal>UI</literal>, so it can call methods defined in those types,
        whether or not they are actually defined at this point. We&#x2019;re doing
        just that in <literal>run</literal>.</para>
      </listitem>

      <listitem>
        <para>The concrete type that mixes in this trait must also mix in
        these three other traits or descendants of them.</para>
      </listitem>
    </orderedlist>

    <para id="para_in_other_words_the_self_type_">In other words, the self
    type in <literal>App</literal> specifies dependencies on other components.
    These dependencies are satisfied in <literal>MyApp</literal>, which mixes
    in the concrete traits for the three tiers.</para>

    <para id="para_if_you_think_about_it_we_coul">We could have declared
    <literal>App</literal> using inheritance instead:</para>

    <programlisting linenumbering="unnumbered">trait App with Persistence with Midtier with UI {

  def run = { ... }
}</programlisting>

    <para id="para_it_is_effectively_the_same_thi">This is effectively the
    same. As we said, the self-type annotation lets the <literal>App</literal>
    assume it is of type <literal>Persistence</literal>, etc. That&#x2019;s exactly
    what happens when you mix in a trait, too.</para>

    <para id="para_so_why_are_self_types_useful_">Why, then, are self types
    useful if they appear to be equivalent to inheritance? There are some
    theoretical reasons and a few special cases where self-type annotations
    offer unique benefits. In practice, you could use inheritance for almost
    all cases. By convention, people use inheritance when they want to imply
    that a type <emphasis>behaves as</emphasis> (inherits from) another type,
    and they use self-type annotations when they want to express a dependency
    between a type and other types (see <link linkend="McIver2009" xrefstyle="select:nopage">[McIver2009]</link>).</para>

    <para id="para_in_our_case_we_don_t_really_t">In our case, we don&#x2019;t really
    think of an <literal>App</literal> as <emphasis>being</emphasis> a UI,
    database, etc. We think of an <literal>App</literal> as being composed of
    those things. Note that in most object-oriented languages, you would
    express this compositional dependency with member fields, especially if
    your language doesn&#x2019;t support mixin composition, like Java. For example,
    you might write <literal>App</literal> in Java this way:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/selftype/JavaApp.java

package selftype;

public abstract class JavaApp {
  public interface Persistence {
    public void startPersistence();
  }

  public interface Midtier {
    public void startMidtier();
  }

  public interface UI {
    public void startUI();
  }

  private Persistence persistence;
  private Midtier midtier;
  private UI ui;

  public JavaApp(Persistence persistence, Midtier midtier, UI ui) {
    this.persistence = persistence;
    this.midtier = midtier;
    this.ui = ui;
  }

  public void run() {
    persistence.startPersistence();
    midtier.startMidtier();
    ui.startUI();
  }
}</programlisting>

    <para id="para_you_can_certainly_write_applic">(We nested the component
    interfaces inside <literal>JavaApp</literal> to avoid creating separate
    files for each one!) You can certainly write applications this way in
    Scala. However, the self-type approach turns programmatic dependency
    resolution, i.e., passing dependencies to constructors or setter methods
    at runtime, into declarative dependency resolution at compile time, which
    catches errors earlier. Declarative programming, which is a hallmark of
    functional programming, is generally more robust, succinct, and clear,
    compared to imperative programming.</para>

    <para id="para_in_selftypeannotationsandabs">We will return to self-type
    annotations as a component composition model in <xref linkend="ApplicationDesign"/>. See <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/> and <xref linkend="DependencyInjectionInScala"/>.<indexterm class="endofrange" startref="ch12_datatypesself"/><indexterm class="endofrange" startref="ch12_selftype"/><indexterm class="endofrange" startref="ch12_typeself"/></para>
  </sect1>

  <sect1 id="StructuralTypes">
    <title>Structural Types</title>

    <para id="para_structural_types">You can think of <emphasis>structural
    types</emphasis> as a type-safe approach to <emphasis>duck
    typing</emphasis>, the popular name for the way method resolution works in
    dynamically typed languages. In Ruby, for example, when you write
    <literal>starFighter.shootWeapons</literal>, the runtime looks for a
    <literal role="keep-together">shootWeapons</literal> method on the object
    referenced by <literal>starFighter</literal>. That method, if found, might
    have been defined in the class used to instantiate
    <literal>starFighter</literal> or one of its parents or &#x201C;included&#x201D;
    modules. The method might also have been added to the object using the
    metaprogramming facility of Ruby. Finally, the object might override the
    catch-all <literal>method_missing</literal> method and do something
    reasonable when the object receives the <literal>shootWeapons</literal>
    &#x201C;message.&#x201D;<indexterm>
        <primary>Ruby</primary>

        <secondary>method resolution in</secondary>
      </indexterm><indexterm>
        <primary>duck typing</primary>
      </indexterm><indexterm>
        <primary>data types</primary>

        <secondary>structural types</secondary>
      </indexterm><indexterm>
        <primary>structural types</primary>
      </indexterm></para>

    <para id="para_what_scala_allows_you_do_inste">Scala doesn&#x2019;t support this
    kind of method resolution, Instead, Scala allows you to specify that an
    object must adhere to a certain <emphasis>structure</emphasis>: that it
    contains certain types, fields, or methods, without concern for the actual
    type of the object. We first encountered structural types near the
    beginning of <xref linkend="Traits"/>. Here is the example we saw then, a
    variation of the Observer Pattern:</para>

    <programlisting linenumbering="unnumbered">// code-examples/Traits/observer/observer.scala

package observer

trait Subject {
  type Observer = { def receiveUpdate(subject: Any) }

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (_.receiveUpdate(this))
}</programlisting>

    <para id="para_the_declaration_type_observer">The declaration
    <literal>type Observer = { def receiveUpdate(subject: Any) }</literal>
    says that any valid observer must have the
    <literal>receiveUpdate</literal> method. It doesn&#x2019;t matter what the actual
    type is for a particular observer.</para>

    <para id="para_structural_types_have_the_virt">Structural types have the
    virtue of minimizing the interface between two things. In this case, the
    coupling consists of only a single method signature, rather than a type,
    such as a shared trait. A drawback of a structural type is that we still
    couple to a particular <emphasis>name</emphasis>. If a name is arbitrary,
    we don&#x2019;t really care about its name so much as its intent. In our example
    of a single method, we can avoid coupling to the name using a function
    object instead. In fact, we did this in <xref linkend="OverridingAbstractTypes"/>.</para>

    <para id="para_structural_types_when_names_are_good">On the other hand, if
    the name is a universal convention in some sense, then coupling to it has
    more merit. For example, <literal>foreach</literal> is very common name in
    the Scala library with a particular meaning, so defining a structural type
    based on <literal>foreach</literal> might be better for conveying intent
    to the user, rather than using an anonymous function of some kind.</para>
  </sect1>

  <sect1 id="ExistentialTypes">
    <title>Existential Types</title>

    <para id="para_existential_types"><emphasis>Existential types</emphasis>
    are a way of abstracting over types. They let you &#x201C;acknowledge&#x201D; that there
    is a type involved without specifying exactly what it is, usually because
    you don&#x2019;t know what it is and you don&#x2019;t need that knowledge in the current
    context.<indexterm>
        <primary>data types</primary>

        <secondary>existential types</secondary>
      </indexterm><indexterm>
        <primary>existential types</primary>
      </indexterm></para>

    <para id="para_existential_types_are_particul">Existential types are
    particularly useful for interfacing to Java&#x2019;s type system for three
    cases:<indexterm>
        <primary>Java</primary>

        <secondary>interfacing with type system, using existential
        types</secondary>
      </indexterm></para>

    <itemizedlist>
      <listitem>
        <para>The type parameters of generics are &#x201C;erased&#x201D; at the byte code
        level (called <emphasis>type erasure</emphasis>). For example, when a
        <literal>List[Int]</literal> is created, the <literal>Int</literal>
        type is not available in the byte code.</para>
      </listitem>

      <listitem>
        <para>You might encounter &#x201C;raw&#x201D; types, such as pre-Java 5 libraries
        where collections had no type parameters. (All type parameters are
        effectively <literal>Object</literal>.)</para>
      </listitem>

      <listitem>
        <para>When Java uses wildcards in generics to express variance
        behavior when the generics are <emphasis>used</emphasis>, the actual
        type is unknown. (We discussed this earlier in <xref linkend="VarianceUnderInheritance"/>.)</para>
      </listitem>
    </itemizedlist>

    <para id="para_consider_the_case_of_pattern_m">Consider the case of
    pattern matching on <literal>List[A]</literal> objects. You might like to
    write code like the following:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/existentials/type-erasure-wont-work.scala
// WARNINGS: Does not work as you might expect.

object ProcessList {
  def apply[B](list: List[B]) = list match {
    case lInt:    List[Int]    =&gt; // do something
    case lDouble: List[Double] =&gt; // do something
    case lString: List[String] =&gt; // do something
    case _                     =&gt; // default behavior
  }
}</programlisting>

    <para id="para_if_you_compile_this_with_the_">If you compile this with the
    <literal>-unchecked</literal> flag on the JVM, you&#x2019;ll get warnings that
    the type parameters like <literal>Int</literal> are unchecked, because of
    type erasure. Hence, we can&#x2019;t distinguish between any of the list types
    shown.</para>

    <para id="para_the_manifests_that_we_discus">The
    <literal>Manifest</literal>s that we discussed previously won&#x2019;t work
    either, because they can&#x2019;t recover the erased type of
    <literal>B</literal>.</para>

    <para id="para_we_ve_already_learned_that_the">We&#x2019;ve already learned that
    the best we can do in pattern matching is to focus on the fact that we
    have a list and not try to determine the &#x201C;lost&#x201D; type parameter for the
    list instance. For type safety, we have to specify that a list has a
    parameter, but since we don&#x2019;t know what it is, we use the wildcard
    <literal>_</literal> character for the type parameter, e.g.:</para>

    <programlisting linenumbering="unnumbered">case l: List[_] =&gt; // do something "generic" with the list</programlisting>

    <para id="para_when_used_in_a_type_context_li">When used in a type context
    like this, the <literal>List[_]</literal> is actually shorthand for the
    <emphasis>existential type</emphasis>, <literal>List[T] forSome { type T
    }</literal>. This is the most general case. We&#x2019;re saying the type
    parameter for the list could be any type. <xref linkend="existential-type-examples-table"/> lists some other examples
    that demonstrate the use of type bounds.<indexterm>
        <primary>existential types</primary>

        <secondary>examples of</secondary>
      </indexterm></para>

    <table id="existential-type-examples-table">
      <title>Existential type examples</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Shorthand</entry>

            <entry>Full</entry>

            <entry>Description</entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal>List[_]</literal></para></entry>

            <entry><para><literal>List[T] forSome { type T
            }</literal></para></entry>

            <entry><para>T can be any subtype of
            <literal>Any</literal>.</para></entry>
          </row>

          <row>
            <entry><para><literal role="keep-together">List[_ &lt;:</literal>
            <literal role="keep-together">scala.actors.AbstractActor]</literal></para></entry>

            <entry><para><literal role="keep-together">List[T] forSome { type
            T &lt;:</literal> <literal role="keep-together">scala.actors.AbstractActor
            }</literal></para></entry>

            <entry><para>T can be any subtype of <literal role="keep-together">AbstractActor</literal>.</para></entry>
          </row>

          <row>
            <entry><para><literal>List[_ &gt;: MyFancyActor &lt;:</literal>
            <literal role="keep-together">scala.actors.AbstractActor]</literal></para></entry>

            <entry><para><literal>List[T] forSome { type T &gt;: MyFancyActor
            &lt;: scala.actors.AbstractActor }</literal></para></entry>

            <entry><para>T can be any subtype of <literal role="keep-together">AbstractActor</literal> up to and including
            the subtype <literal role="keep-together">MyFancyActor</literal>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_if_you_think_about_how_scala_s">If you think about how
    Scala syntax for generics is mapped to Java syntax, you might have noticed
    that an expression like <literal>java.util.List[_ &lt;:
    scala.actors.AbstractAc&#x2060;tor]</literal> is structurally similar to the Java
    variance expression <literal>java.util.List&lt;? extends
    scala.actors.AbstractActor&gt;</literal>. In fact, they are the same
    declarations. Although we said that variance behavior in Scala is defined
    at the declaration site, you can use existential type expressions in Scala
    to define call-site variance behavior. It is not recommended, for the
    reasons discussed previously, but you have that option.</para>

    <para id="para_you_won_t_see_the_forsome_ex">You won&#x2019;t see the
    <literal>forSome</literal> existential type syntax very often in Scala
    code, because existential types exist primarily to support Java generics
    while preserving correctness in Scala&#x2019;s type system. Type inference hides
    the details from us in most contexts. When working with Scala types, the
    other type constructs we have discussed in this chapter are preferred to
    existential types.</para>
  </sect1>

  <sect1 id="InfiniteDataStructuresAndLaziness">
    <title>Infinite Data Structures and Laziness</title>

    <para id="para_infinite_data_structures">We described lazy values in <xref linkend="FunctionalProgramming"/>. In functional languages that are lazy
    by default, like Haskell, laziness makes it easy to support
    <emphasis>infinite</emphasis> data structures.<indexterm>
        <primary>lazy evaluation, infinite data structures and</primary>
      </indexterm><indexterm>
        <primary>infinite data structures</primary>

        <secondary>laziness and</secondary>
      </indexterm><indexterm>
        <primary>data types</primary>

        <secondary>infinite data structures and lazy vals</secondary>
      </indexterm></para>

    <para id="para_for_example_consider_the_foll">For example, consider the
    following Scala method <literal>fib</literal> that calculates the
    Fibonacci number for <literal>n</literal> in the infinite Fibonacci
    sequence:<indexterm>
        <primary>Fibonacci sequence, calculating</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">def fib(n: Int): Int = n match {
  case 0 | 1 =&gt; n
  case _ =&gt; fib(n-1) + fib(n-2)
}</programlisting>

    <para id="para_if_scala_were_purely_lazy_we_">If Scala were purely lazy,
    we could imagine a definition of the Fibonacci sequence like the following
    and it wouldn&#x2019;t create an infinite loop:</para>

    <programlisting linenumbering="unnumbered">fibonacci_sequence = for (i &lt;- 0 to infinity) yield fib(i)</programlisting>

    <para id="para_scala_isn_t_lazy_by_default_b">Scala isn&#x2019;t lazy by default
    (and there is no <literal>infinity</literal> value or keyword&#x2026;), but the
    library contains a <literal>Stream</literal> class that supports lazy
    evaluation and hence it can support infinite data structures. We&#x2019;ll show
    an implementation of the Fibonacci sequence in a moment. First, here is a
    simpler example that uses streams to represent all positive integers, all
    positive odd integers, and all positive even integers:<indexterm>
        <primary>Stream class</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/lazy/lazy-ints-script.scala

def from(n: Int): Stream[Int] = Stream.cons(n, from(n+1))

lazy val ints = from(0)
lazy val odds = ints.filter(_ % 2 == 1)
lazy val evens = ints.filter(_ % 2 == 0)

odds.take(10).print
evens.take(10).print</programlisting>

    <para id="para_lazy_ints_output">It produces this output:</para>

    <screen>1, 3, 5, 7, 9, 11, 13, 15, 17, 19, Stream.empty
0, 2, 4, 6, 8, 10, 12, 14, 16, 18, Stream.empty</screen>

    <para id="para_the_from_method_is_recursive">The <literal>from</literal>
    method is recursive and never terminates! We use it to define the
    <literal>ints</literal> by calling <literal>from(0)</literal>.
    <literal>Streams.cons</literal> is an object with an
    <literal>apply</literal> method that is analogous to the
    <literal>::</literal> (&#x201C;cons&#x201D;) method on <literal>List</literal>. It
    returns a new stream with the first argument as the head and the second
    argument, another stream, as the tail. The <literal>odds</literal> and
    <literal>evens</literal> infinite streams are computed by filtering
    <literal>ints</literal>.</para>

    <para id="para_once_we_have_defined_the_strea">Once we have defined the
    streams, the <literal>take</literal> method returns a new stream of the
    fixed size specified, 10 in this case. When we print this stream with the
    <literal>print</literal> method, it prints the 10 elements followed by
    <literal>Stream.empty</literal> when it hits the end of the stream.</para>

    <para id="para_returning_to_the_fibonacci_seq">Returning to the Fibonacci
    sequence, there is a famous definition using infinite, lazy sequences that
    exploits the <literal>zip</literal> operation (see, e.g., <link linkend="Abelson1996" xrefstyle="select:nopage">[Abelson1996]</link>). Our
    discussion for Scala is adapted from <link linkend="Ortiz2007" xrefstyle="select:nopage">[Ortiz2007]</link>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/lazy/lazy-fibonacci-script.scala

lazy val fib: Stream[Int] =
  Stream.cons(0, Stream.cons(1, fib.zip(fib.tail).map(p =&gt; p._1 + p._2)))

fib.take(10).print</programlisting>

    <para id="para_lazy_fibonacci_output">It produces this output:</para>

    <screen>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, Stream.empty</screen>

    <para id="para_how_does_this_work_like_our_i">How does this work? Like our
    iterative definition at the start of this section, we explicitly specify
    the first two values, 0 and 1. The rest of the numbers are computed using
    <literal>zip</literal>, exploiting the fact that <literal>fib(n) =
    fib(n-1) + fib(n-2)</literal>, for <literal>n &gt; 1</literal>.</para>

    <para id="para_the_call_fib_zip_fib_tail_c">The call
    <literal>fib.zip(fib.tail)</literal> creates a new stream of tuples with
    the elements of <literal>fib</literal> in the first position of the tuple,
    and the elements of <literal>fib.tail</literal> in the second position of
    the tuple. To get back to a single integer for each position in the
    stream, we map the stream of tuples to a stream of <literal>Ints</literal>
    by adding the tuple elements. Here are the tuples calculated:</para>

    <screen>(0,1), (1,1), (1,2), (2,3), (3,5), (5,8), (8,13), (13, 21), (21, 34), ...</screen>

    <para id="para_note_that_each_second_element_">Note that each second
    element is the next number in the Fibonacci sequence after the first
    element in the tuple. Adding them we get the following:</para>

    <screen>1, 2, 3, 5, 8, 13, 21, 34, 55, ...</screen>

    <para id="para_since_we_concatenate_this_stre">Since we concatenate this
    stream after 0 and 1, we get the Fibonacci sequence:</para>

    <screen>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...</screen>

    <para id="para_another_scala_type_that_is_laz">Another lazy Scala type,
    albeit a finite one, is <literal>Range</literal>. Typically, you write
    literal ranges such as <literal>1 to 1000</literal>.
    <literal>Range</literal> is lazy, so very large ranges don&#x2019;t consume too
    many resources. However, this feature can lead to subtle problems unless
    you are careful, as documented by <link linkend="Smith2009b" xrefstyle="select:nopage">[Smith2009b]</link> and commenters. Using the
    example described there, consider this function for returning a
    <literal>Seq</literal> of three random integers:<indexterm>
        <primary>Range object</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/TypeSystem/lazy/lazy-range-danger-script.scala

def mkRandomInts() = {
  val randInts = for {
    i &lt;- 1 to 3
    val rand = i + (new scala.util.Random).nextInt
  } yield rand
  randInts
}
val ints1 = mkRandomInts

println("Calling first on ints1 Seq:")
for (i &lt;- 1 to 3) {
  println( ints1.first)
}

val ints2 = ints1.toList
println("Calling first on List created from ints1 Seq:")
for (i &lt;- 1 to 3) {
  println( ints2.first)
}</programlisting>

    <para id="para_here_is_the_output_from_one_ru">Here is the output from one
    run. The actual values will vary from run to run:</para>

    <screen>Calling first on ints1 Seq:
-1532554511
-1532939260
-1532939260
Calling first on List created from ints1 Seq:
-1537171498
-1537171498
-1537171498</screen>

    <para id="para_calling_first_on_the_sequenc">Calling
    <literal>first</literal> on the sequence does not always return the same
    value! The reason is that the range at the beginning of the
    <literal>for</literal> comprehension effectively forces the whole sequence
    to be lazy. Hence, it is reevaluated with <emphasis>each</emphasis> call
    to <literal>first</literal>, and the first value in the sequence actually
    changes, since <literal>Random</literal> returns a different number each
    time (at least, it will if there is a sufficient time delta between
    calls).</para>

    <para id="para_however_calling_tolist_on_t">However, calling
    <literal>toList</literal> on the sequence forces it to evaluate the whole
    range and create a <emphasis>strict</emphasis> list.</para>

    <warning id="para_warning_avoid_using_ranges_in">
      <para>Avoid using ranges in <literal>for (...) yield x</literal>
      constructs, while <literal>for (...) {...}</literal> alternatives are
      fine.</para>
    </warning>

    <para id="para_finally_scala_version_2_8_wil">Finally, Scala version 2.8
    will include a <literal>force</literal> method on all collections that
    will force them to be strict.</para>
  </sect1>

  <sect1 id="_recap_and_what_8217_s_next_5">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_it_s_important_to_remember_tha">It&#x2019;s important to remember
    that you don&#x2019;t have to master the intricacies of Scala&#x2019;s rich type system
    to use Scala effectively. As you use Scala more and more, mastering the
    type system will help you create powerful, sophisticated libraries that
    accelerate your productivity.</para>

    <para id="para_the_scalaspec2009_describe">The <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>
    describes the type system in formal detail. Like any specification, it can
    be difficult reading. The effort is worthwhile if you want a deep
    understanding of the type system. There are also a multitude of papers on
    Scala&#x2019;s type system. You can find links to many of them on the official
    <ulink url="http://scala-lang.org"/> website.<indexterm>
        <primary>documentation</primary>

        <secondary>Scala type system</secondary>
      </indexterm><indexterm>
        <primary>data types</primary>

        <secondary>documentation for Scala type system</secondary>
      </indexterm></para>

    <para id="para_we_have_completed_the_heavy_">The next two chapters cover
    the pragmatics of application design and Scala&#x2019;s development tools and
    libraries.<indexterm class="endofrange" startref="ch12_datatypes"/></para>
  </sect1>
</chapter>
  <chapter id="ApplicationDesign">
  <title>Application Design</title>

  <para id="para_in_this_chapter_we_take_a_pra">In this chapter, we take a
  pragmatic look at developing applications in Scala. We discuss a few
  language and API features that we haven&#x2019;t covered before, examine common
  design patterns and idioms, and revisit <emphasis>traits</emphasis> with an
  eye toward structuring our code effectively.<indexterm class="startofrange" id="ch13_appdesign">
      <primary>application design</primary>
    </indexterm></para>

  <sect1 id="Annotations">
    <title>Annotations</title>

    <para id="para_like_java_and_net_scala_supp">Like Java and .NET, Scala
    supports <emphasis>annotations</emphasis> for adding
    <emphasis>metadata</emphasis> to declarations. Annotations are used by a
    variety of tools in typical enterprise and Internet applications. For
    example, there are annotations that provide directives to the compiler,
    and some Object-Relational Mapping (ORM) frameworks use annotations on
    types and type members to indicate persistence mapping information. While
    some uses for annotations in the Java and .NET worlds can be accomplished
    through other means in Scala, annotations can be essential for
    interoperating with Java and .NET libraries that rely heavily on them.
    Fortunately, Java and .NET annotations can be used in Scala
    code.<indexterm class="startofrange" id="ch13_declarationsannotations">
        <primary>declarations</primary>

        <secondary>annotations in</secondary>
      </indexterm><indexterm class="startofrange" id="ch13_appdesignannotations">
        <primary>application design</primary>

        <secondary>annotations</secondary>
      </indexterm><indexterm>
        <primary>metadata</primary>

        <secondary>adding to declarations</secondary>
      </indexterm><indexterm class="startofrange" id="ch13_annotations">
        <primary>annotations</primary>
      </indexterm></para>

    <para id="para_the_interpretation_of_scala_an">The interpretation of Scala
    annotations depends on the runtime environment. In this section, we will
    focus on the JDK environment.</para>

    <para id="para_in_java_annotations_are_decla">In Java, annotations are
    declared using special conventions, e.g., declaring annotations with the
    <literal>@interface</literal> keyword instead of the
    <literal>class</literal> or <literal>interface</literal> keyword. Here is
    the declaration of an annotation taken from a toolkit called Contract4J
    (see <link linkend="Contract4J" xrefstyle="select:nopage">[Contract4J]</link>) that uses annotations to
    support <emphasis>Design by Contract</emphasis> programming in Java (see
    also <xref linkend="DesignByContractExample"/>). Some of the comments
    have been removed for clarity:<indexterm>
        <primary sortas="interface keyword">@interface keyword
        (Java)</primary>
      </indexterm><indexterm>
        <primary>Java</primary>

        <secondary>annotations</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/Pre.java

package org.contract4j5.contract;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface Pre {
  /**
   * The "value" is the test expression, which must evaluate to true or false.
   * It must be a valid expression in the scripting language you are using.
   */
  String value() default "";

  /**
   * An optional message to print with the standard message when the contract
   * fails.
   */
  String message() default "";
}</programlisting>

    <para id="para_the_pre_annotation_is_used_">The <literal>@Pre</literal>
    annotation is used to specify &#x201C;preconditions&#x201D; that must be satisfied when
    <emphasis>entering</emphasis> a method or constructor, or
    <emphasis>before</emphasis> using a parameter passed to a method or
    constructor. The conditions are specified as a string that is actually a
    snippet of source code that evaluates to <literal>true</literal> or
    <literal>false</literal>. The source <emphasis>languages</emphasis>
    supported for these snippets are scripting languages like Groovy and
    JRuby. The name of the variable for this string, <literal>value</literal>,
    is a conventional name for the most important field in the
    annotation.<indexterm>
        <primary>metadata</primary>

        <seealso>annotations</seealso>
      </indexterm><indexterm>
        <primary sortas="Pre annotation">@Pre annotation</primary>
      </indexterm></para>

    <para id="para_the_other_field_is_an_optional">The other field is an
    optional <literal>message</literal> to use when reporting failures.</para>

    <para id="para_the_declaration_has_other_anno">The declaration has other
    annotations applied to it&#x2014;for example, the <literal>@Retention</literal>
    annotation with the value <literal>RetentionPolicy.RUNTIME</literal> means
    that when <literal>@Pre</literal> is used, its information will be
    retained in the class file for runtime use.<indexterm>
        <primary sortas="Retention annotation">@Retention annotation</primary>
      </indexterm></para>

    <para id="para_here_is_a_scala_example_that_u">Here is a Scala example
    that uses <literal>@Pre</literal> and shows several ways to specify the
    <literal>value</literal> and <literal>message</literal> parameters:</para>

    <screen>// code-examples/AppDesign/annotations/pre-example.scala

import org.contract4j5.contract._

class Person(
  @Pre( "name != null &amp;&amp; name.length() &gt; 0" )
  val name: String,
  @Pre{ val value = "age &gt; 0", val message = "You're too young!" }
  val age: Int,
  @Pre( "ssn != null" )
  val ssn: SSN)

class SSN(
  @Pre( "valid(ssn)" ) { val message = "Format must be NNN-NN-NNNN." }
  val ssn: String) {

  private def valid(value: String) =
    value.matches("""^\s*\d{3}-\d{2}-\d{4}\s*$""")
}</screen>

    <para id="para_in_the_person_class_the_p">In the <literal>Person</literal>
    class, the <literal>@Pre</literal> annotation on <literal>name</literal>
    has a simple string argument: the &#x201C;precondition&#x201D; that users must satisfy
    when passing in a name. This value can&#x2019;t be <literal>null</literal>, and
    it can&#x2019;t be of zero length. As in Java, if a single argument is given to
    the annotation, it is assigned to the <literal>value</literal>
    field.</para>

    <para id="para_a_similar_pre_annotation_is">A similar
    <literal>@Pre</literal> annotation is used for the third argument, the
    <literal>ssn</literal> (Social Security number). In both cases, the
    <literal>message</literal> defaults to the empty string specified in the
    definition of <literal>Pre</literal>.</para>

    <para id="para_the_pre_annotation_for_the_">The <literal>@Pre</literal>
    annotation for the age shows one way to specify values for more than one
    field. Instead of parentheses, curly braces are used. The syntax for each
    field looks like a <literal>val</literal> declaration, without any type
    information, since the types can always be inferred! This syntax allows
    you to use the shorthand syntax for the <literal>value</literal> and still
    specify values for other fields.</para>

    <note id="para_note_if_person_were_a_java_">
      <para>If <literal>Person</literal> were a Java class, this annotation
      expression would look identical, except there would be no
      <literal>val</literal> keywords and parentheses would be used.</para>
    </note>

    <para id="para_the_pre_annotation_on_the_c">The <literal>@Pre</literal>
    annotation on the constructor parameter for the <literal>SSN</literal>
    class shows the alterna<phrase role="keep-together">tive syntax</phrase>
    for specifying values for more than one field. The
    <literal>value</literal> field is specified as before with a one-element
    parameter list. The <literal>message</literal> is initialized in a
    follow-on block in curly braces.</para>

    <para id="para_testing_this_code_would_requir">Testing this code would
    require the Contract4J library, build setup, etc. We won&#x2019;t cover those
    steps here. Refer to <link linkend="Contract4J" xrefstyle="select:nopage">[Contract4J]</link> for more information.</para>

    <para id="para_scala_annotations_don_t_use_a_">Scala annotations don&#x2019;t use
    a special declaration syntax. They are declared as normal classes. This
    approach eliminates a &#x201C;special case&#x201D; in the language, but it also means
    that some of the features provided by Java annotations aren&#x2019;t supported,
    as we will see. Here is an example annotation from the Scala library,
    <literal>SerialVersionUID</literal> (again with the comments removed for
    clarity):</para>

    <programlisting linenumbering="unnumbered">package scala

class SerialVersionUID(uid: Long) extends StaticAnnotation</programlisting>

    <para id="para_the_serialversionuid_annota">The
    <literal>@SerialVersionUID</literal> annotation is applied to a class to
    define a globally unique ID as a <literal>Long</literal>. When the
    annotation is used, the ID is specified as a constructor argument. This
    annotation serves the same purpose as a <literal>static</literal> field
    named <literal>serialVersionUID</literal> in a Java class. This is one
    example of a Scala annotation that maps to a &#x201C;non-annotation&#x201D; construct in
    Java.<indexterm>
        <primary sortas="serialVersionUID">@serialVersionUID
        annotation</primary>
      </indexterm></para>

    <para id="para_the_parent_of_serialversionui">The parent of
    <literal>SerialVersionUID</literal> is the trait
    <literal>scala.StaticAnnotation</literal>, which is used as the parent for
    all annotations that should be visible to the type checker, even across
    compilation units. The parent class of
    <literal>scala.StaticAnnotation</literal> is
    <literal>scala.Annotation</literal>, which is the parent of all Scala
    annotations.<indexterm>
        <primary>Annotation class</primary>
      </indexterm><indexterm>
        <primary>StaticAnnotation class</primary>
      </indexterm></para>

    <para id="para_did_you_notice_that_there_is_n">Did you notice that there
    is no <literal>val</literal> on <literal>uid</literal>? Why isn&#x2019;t
    <literal>uid</literal> a field? The reason is that the annotation&#x2019;s data
    is not intended for use by the program. Recall that it is metadata
    designed for external tools to use, such as <literal>scalac</literal>.
    This also means that Scala annotations have no way to define default
    values in version 2.7.X, as implicit arguments don&#x2019;t work. However, the
    new default arguments feature in version 2.8.0 may work. (It is not yet
    implemented at the time of this writing.)<indexterm>
        <primary>metadata</primary>

        <secondary>default values and</secondary>
      </indexterm></para>

    <para id="para_like_java_and_net_annotatio">Like Java (and .NET)
    annotations, a Scala annotation clause applies to the definition it
    precedes. You can have as many annotation clauses as you want, and the
    order in which they appear is not significant.</para>

    <para id="para_like_java_annotations_scala_a">Like Java annotations, Scala
    annotation clauses are written using the syntax <literal role="keep-together">@MyAnnotation</literal> if the annotation constructor
    takes no parameters, or <literal>@MyAnnotation(arg1, .., argN)</literal>
    if the constructor takes parameters. The annotation must be a subclass of
    <literal>scala.Annotation</literal>.</para>

    <para id="para_all_the_constructor_parameters">All the constructor
    parameters must be constant expressions, including strings, class
    literals, Java enumerations, numerical expressions and one-dimensional
    arrays of the same. However, the compiler also allows annotation clauses
    with other arguments, such as boolean values and maps, as shown in this
    example:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/anno-example.scala

import scala.StaticAnnotation

class Persist(tableName: String, params: Map[String,Any])
  extends StaticAnnotation

// Doesn't compile:
//@Persist("ACCOUNTS", Map("dbms" -&gt; "MySql", "writeAutomatically" -&gt; true))
@Persist("ACCOUNTS", Map(("dbms", "MySql"), ("writeAutomatically", true)))
class Account(val balance: Double)</programlisting>

    <para id="para_curiously_if_you_attempt_to_u">Curiously, if you attempt to
    use the standard <literal>Map</literal> literal syntax that is shown in
    the comments, you get a compilation error that the
    <literal>-&gt;</literal> method doesn&#x2019;t exist for
    <literal>String</literal>. The implicit conversion to
    <literal>ArrowAssoc</literal> that we discussed in <xref linkend="PredefObject"/> isn&#x2019;t invoked. Instead, you have to use a list
    of <literal>Tuples</literal>, which <literal>Map.apply</literal> actually
    expects.<indexterm>
        <primary>ClassfileAnnotation class</primary>
      </indexterm></para>

    <para id="para_another_child_of_scala_annota">Another child of
    <literal>scala.Annotation</literal> that is intended to be a parent of
    other annotations is the trait
    <literal>scala.ClassfileAnnotation</literal>. It is supposed to be used
    for annotations that should have runtime retention, i.e., the annotations
    should be visible in the class file so they are available at runtime.
    However, actually using it with the JDK version of Scala results in
    compiler errors like the following:</para>

    <screen>...: warning: implementation restriction: subclassing Classfile does not
make your annotation visible at runtime.  If that is what
you want, you must write the annotation class in Java.
...</screen>

    <para id="para_hence_if_you_want_runtime_vis">Hence, if you want runtime
    visibility, you have to implement the annotation in Java. This works fine,
    since you can use any Java annotation in Scala code. The Scala library
    currently defines no annotations derived from
    <literal>ClassfileAnnotation</literal>, perhaps for obvious
    reasons.</para>

    <warning id="para_warning_avoid_classfileannot">
      <para>Avoid <literal>ClassfileAnnotation</literal>. Implement
      annotations that require runtime retention in Java instead.</para>
    </warning>

    <para id="para_for_scala_version_2_7_x_anoth">For Scala version 2.7.X,
    another important limitation to keep in mind is that annotations can&#x2019;t be
    nested. This causes problems when using JPA annotations in Scala code, for
    example, as discussed in <link linkend="JPAScala" xrefstyle="select:nopage">[JPAScala]</link>. However, Scala version 2.8
    removes this <phrase role="keep-together">limitation</phrase>.<indexterm>
        <primary>annotations</primary>

        <secondary>nesting</secondary>
      </indexterm></para>

    <warning id="para_warning_annotations_can_only_">
      <para>Annotations can only be nested in Scala version 2.8.</para>
    </warning>

    <para id="para_the_following_tables_describe_">Tables <xref linkend="scala-annotations" xrefstyle="select: labelnumber"/> and <xref linkend="scala-static-annotations" xrefstyle="select: labelnumber"/>
    describe all the annotations defined in the Scala library (adapted and
    expanded from <ulink url="http://www.scala-lang.org/node/106"/>).
    We start with the direct children of <literal>Annotation</literal>,
    followed by the children of <literal>StaticAnnotation</literal>.<indexterm>
        <primary>Annotation class</primary>

        <secondary>Scala annotations derived from</secondary>
      </indexterm><indexterm>
        <primary>annotations</primary>

        <secondary>Scala annotations derived from Annotation</secondary>
      </indexterm></para>

    <table id="scala-annotations">
      <title>Scala annotations derived from Annotation</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry>Java equivalent</entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal role="keep-together">ClassfileAnnotation</literal></para></entry>

            <entry><para>Annotate with <literal>@Retention<?lb ?>(RetentionPolicy.RUNTIME)</literal></para></entry>

            <entry><para>The parent trait for annotations that should be
            retained in the class file for runtime access, but it doesn&#x2019;t
            actually work on the JDK!</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanDescription</literal></para></entry>

            <entry><para><literal role="keep-together">BeanDescriptor</literal>
            (class)</para></entry>

            <entry><para>An annotation for <emphasis>JavaBean</emphasis> types
            or members that associates a short description (provided as the
            annotation argument) that will be included when generating bean
            information.</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanDisplayName</literal></para></entry>

            <entry><para><literal>BeanDescriptor</literal>
            (class)</para></entry>

            <entry><para>An annotation for <emphasis>JavaBean</emphasis> types
            or members that associates a name (provided as the annotation
            argument) that will be included when generating bean
            information.</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanInfo</literal></para></entry>

            <entry><para><literal>BeanInfo</literal> (class)</para></entry>

            <entry><para>A marker that indicates that a <literal role="keep-together">BeanInfo</literal> class should be generated
            for the marked Scala class. A <literal>val</literal> <phrase role="keep-together">becomes</phrase> a read-only property. A
            <literal>var</literal> <phrase role="keep-together">becomes</phrase> a read-write property. A
            <literal>def</literal> becomes a method.</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanInfoSkip</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker that indicates that bean information should
            not be generated for the annotated member.</para></entry>
          </row>

          <row>
            <entry><para><literal>StaticAnnotation</literal></para></entry>

            <entry><para>Static fields, <?lb ?><literal role="keep-together">@Target(ElementType.TYPE)</literal></para></entry>

            <entry><para>The parent trait of annotations that should be
            visible across compilation units and define &#x201C;static&#x201D;
            metadata.</para></entry>
          </row>

          <row>
            <entry><para><literal>TypeConstraint</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>An annotation trait that can be applied to other
            annotations that define constraints on a type, relying only on
            information defined within the type itself, as opposed to external
            context information where the type is defined or used. The
            compiler can exploit this restriction to rewrite the constraint.
            There are currently no library annotations that use this
            trait.</para></entry>
          </row>

          <row>
            <entry><para><literal>unchecked</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker annotation for the selector in a match
            statement (e.g., the <literal>x</literal> in <literal>x match
            {...}</literal>) that suppresses a compiler warning if the
            <literal>case</literal> clauses are not &#x201C;exhaustive.&#x201D; You can
            still have a runtime <literal>MatchError</literal> occur if a
            value of <literal>x</literal> fails to match any of the
            <literal>case</literal> clauses. See the upcoming
            example.</para></entry>
          </row>

          <row>
            <entry><para><literal>unsealed</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>Deprecated, use <literal>@unchecked</literal> <phrase role="keep-together">instead</phrase>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table id="scala-static-annotations">
      <title>Scala annotations derived from StaticAnnotation</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry><phrase role="keep-together">Java
            equivalent</phrase></entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal>BeanProperty<indexterm>
                <primary>StaticAnnotation class</primary>

                <secondary>annotations derived from</secondary>
              </indexterm><indexterm>
                <primary>annotations</primary>

                <secondary>Scala annotations derived from
                StaticAnnotation</secondary>
              </indexterm></literal></para></entry>

            <entry><para><emphasis>JavaBean</emphasis>
            convention</para></entry>

            <entry><para>A marker for a field (including a constructor
            argument with the <literal>val</literal> or <literal>var</literal>
            keyword) that tells the compiler to generate a JavaBean-style
            &#x201C;getter&#x201D; and &#x201C;setter&#x201D; method. The setter is only generated for
            <literal>var</literal> declarations. See the discussion in <xref linkend="JavaBeanProperties"/>.</para></entry>
          </row>

          <row>
            <entry><para><literal>cloneable</literal></para></entry>

            <entry><para><literal role="keep-together">java.lang.Cloneable</literal> (<phrase role="keep-together">interface</phrase>)</para></entry>

            <entry><para>A class marker indicating that a class can be
            cloned.</para></entry>
          </row>

          <row>
            <entry><para><literal>cps</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) Generate byte code using continuation
            passing style.</para></entry>
          </row>

          <row>
            <entry><para><literal>deprecated</literal></para></entry>

            <entry><para><literal role="keep-together">java.lang.Deprecated</literal></para></entry>

            <entry><para>A marker for any definition indicating that the
            defined &#x201C;item&#x201D; is obsolete. The compiler will issue a warning when
            the item is used.</para></entry>
          </row>

          <row>
            <entry><para><literal>inline</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A method marker telling the compiler that it should
            try &#x201C;<phrase role="keep-together">especially</phrase> hard&#x201D; to
            inline the method.</para></entry>
          </row>

          <row>
            <entry><para><literal>native</literal></para></entry>

            <entry><para><literal>native</literal> (keyword)</para></entry>

            <entry><para>A method marker indicating the method is implemented
            as &#x201C;native&#x201D; code. The method body will not be generated by the
            compiler, but usage of the method will be type
            checked.</para></entry>
          </row>

          <row>
            <entry><para><literal>noinline</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A method marker that prevents the compiler from
            inlining the method, even when it appears to be safe to do
            so.</para></entry>
          </row>

          <row>
            <entry><para><literal>remote</literal></para></entry>

            <entry><para><literal>java.rmi.Remote</literal> (<phrase role="keep-together">interface</phrase>)</para></entry>

            <entry><para>A class marker indicating that the class can be
            invoked from a remote JVM.</para></entry>
          </row>

          <row>
            <entry><para><literal>serializable</literal></para></entry>

            <entry><para><literal role="keep-together">java.io.Serializable</literal> (<phrase role="keep-together">interface</phrase>)</para></entry>

            <entry><para>A class marker indicating that the class can be
            serialized.</para></entry>
          </row>

          <row>
            <entry><para><literal role="keep-together">SerialVersionUID</literal></para></entry>

            <entry><para><literal>serialVersionUID</literal>
            <emphasis>static</emphasis> <phrase role="keep-together">field in
            a class</phrase></para></entry>

            <entry><para>Defines a globally unique ID for serialization
            purposes. The annotation&#x2019;s constructor takes a
            <literal>Long</literal> argument for the UID.</para></entry>
          </row>

          <row>
            <entry><para><literal>switch</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) An annotation to be applied to a match
            expression, e.g., <literal>(x: @switch) match {...}</literal>.
            When present, the compiler will verify that the match has been
            compiled to a table-based or lookup-based
            <literal>switch</literal> statement. If not, it will issue an
            error if it instead compiles into a series of conditional
            expressions, which are less efficient.</para></entry>
          </row>

          <row>
            <entry><para><literal>specialized</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) An annotation applied to type
            parameters in parameterized types and methods. It tells the
            compiler to generate optimized versions of the type or method for
            the <literal>AnyVal</literal> types corresponding to platform
            primitive types. Optionally, you can limit the
            <literal>AnyVal</literal> types for which specialized
            implementations will be generated. See the upcoming
            discussion.</para></entry>
          </row>

          <row>
            <entry><para><literal>tailRec</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) A method annotation that tells the
            compiler to verify that the method will be compiled with
            <emphasis>tail-call optimization</emphasis>. If it is present, the
            compiler will issue an error if the method cannot be optimized
            into a loop. This happens, for example, when the method is not
            <literal>private</literal> or <literal>final</literal>, when it
            could be overridden, and when recursive invocations are not true
            tail calls.</para></entry>
          </row>

          <row>
            <entry><para><literal>throws</literal></para></entry>

            <entry><para><literal>throws</literal> (keyword)</para></entry>

            <entry><para>Indicates which exceptions are thrown by the
            annotated method. See the upcoming discussion.</para></entry>
          </row>

          <row>
            <entry><para><literal>transient</literal></para></entry>

            <entry><para><literal>transient</literal> (keyword)</para></entry>

            <entry><para>Marks a method as &#x201C;transient.&#x201D;</para></entry>
          </row>

          <row>
            <entry><para><literal>uncheckedStable</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker for a value that is assumed to be stable
            even though its type is volatile (i.e., annotated with
            <literal>@volatile</literal>).</para></entry>
          </row>

          <row>
            <entry><para><literal role="keep-together">uncheckedVariance</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker for a type argument that is volatile, when
            it is used in a parameterized type, to suppress variance
            checking.</para></entry>
          </row>

          <row>
            <entry><para><literal>volatile</literal></para></entry>

            <entry><para><literal>volatile</literal> (keyword, <phrase role="keep-together">for fields only</phrase>)</para></entry>

            <entry><para>A marker for an individual field or a whole type,
            which affects all fields, indicating that the field may be
            modified by a separate thread.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_28_annotations">The annotations marked with &#x201C;(version 2.8)&#x201D;
    are only available in Scala version 2.8 or later. Consider
    <literal>@tailrec</literal>, as used in the following example:<indexterm>
        <primary>annotations</primary>

        <secondary>available only in Scala version 2.8 or later</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">import scala.annotation.tailrec

@tailrec
def fib(i: Int): Int = i match {
  case _ if i &lt;= 1 =&gt; i
  case _ =&gt; fib(i-1) + fib(i-2)
}
println(fib(5))</programlisting>

    <para id="para_fib_tailrec_annotation">Note that <literal>fib</literal>,
    which calculates Fibonacci numbers, is recursive, but it isn&#x2019;t tail-call
    recursive, because the call to itself is not the very last thing that
    happens in the second case clause. Rather, after calling itself twice, it
    does an addition. Hence, a tail-call optimization can&#x2019;t be performed on
    this method. When the compiler sees the <literal>@tailrec</literal>
    annotation, it throws an error if it can&#x2019;t apply the tail-call
    optimization. Attempting to run this script produces the following
    error:<indexterm>
        <primary>tail calls</primary>

        <secondary>@tailRec annotation and</secondary>
      </indexterm><indexterm>
        <primary sortas="tailRec annotation">@tailRec annotation</primary>
      </indexterm></para>

    <screen>... 4: error: could not optimize @tailrec annotated method
def fib(i: Int): Int = i match {
     ^
one error found</screen>

    <para id="para_switch_annotation">We can also use the same method to
    demonstrate the new <literal>@switch</literal> annotation available in
    version 2.8:<indexterm>
        <primary sortas="switch annotation">@switch annotation</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">import scala.annotation.switch

def fib(i: Int): Int = (i: @switch) match {
  case _ if i &lt;= 1 =&gt; i
  case _ =&gt; fib(i-1) + fib(i-2)
}
println(fib(5))</programlisting>

    <para id="para_fib_switch_annotation">This time we annotate the
    <literal>i</literal> in the <literal>match</literal> statement. This
    annotation causes the compiler to raise an error if it can&#x2019;t generate a
    switch construct in byte code from the cases in the match statement.
    Switches are generally more efficient than conditional logic. Running this
    script produces this output:</para>

    <screen>... 3: error: could not emit switch for @switch annotated match
def fib(i: Int): Int = (i: @switch) match {
                                     ^
one error found</screen>

    <para id="para_fib_switch_annotation2">Conditional blocks have to be
    generated instead. The reason a switch can&#x2019;t be generated is because of
    the condition guard clause we put in the first case clause, <literal>if i
    &lt;= 1</literal>.</para>

    <para id="para_let_s_look_at_an_example_of_">Let&#x2019;s look at an example of
    <literal>@unchecked</literal> in use (adapted from the Scaladoc entry for
    <literal>@unchecked</literal>). Consider the following code
    fragment:<indexterm>
        <primary>exceptions</primary>

        <secondary>@unchecked annotation and</secondary>
      </indexterm><indexterm>
        <primary sortas="unchecked annotation">@unchecked annotation</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">...
def process(x: Option[int]) = x match {
  case Some(value) =&gt; ...
}
...</programlisting>

    <para id="para_if_you_compile_it_you_will_ge">If you compile it, you will
    get the following warning:</para>

    <screen>...: warning: does not cover case {object None}
  def f(x: Option[int]) = x match {
                          ^
one warning found</screen>

    <para id="para_normally_you_would_want_to_ad">Normally, you would want to
    add a case for <literal>None</literal>. However, if you want to suppress
    the warning message in situations like this, change the method as
    follows:</para>

    <programlisting linenumbering="unnumbered">...
def process(x: Option[int]) = (x: @unchecked) match {
  case Some(value) =&gt; ...
}
...</programlisting>

    <para id="para_with_the_unchecked_annotati">With the
    <literal>@unchecked</literal> annotation applied to <literal>x</literal>
    as shown, the warning will be suppressed. However, if <literal>x</literal>
    is ever <literal>None</literal>, then a <literal>MatchError</literal> will
    be thrown.</para>

    <para id="para_the_specialized_annotation_">The
    <literal>@specialized</literal> annotation is another optimization-related
    annotation added in <phrase role="keep-together">version</phrase> 2.8. It
    is a pragmatic solution to a tradeoff between space efficiency and
    performance. In Java and Scala, the implementation of a parameterized type
    or method is generated at the point of the declaration (as we discussed in
    <xref linkend="ParameterizedTypes"/>). In contrast, in C++, a
    <emphasis>template</emphasis> is used to generate an implementation for
    the actual type parameters where the template is used. The <phrase role="keep-together">C++</phrase> approach has the advantage of allowing
    optimized implementations to be generated for primitive types, while it
    has the disadvantage of resulting in code bloat from all the
    instantiations of templates.<indexterm>
        <primary sortas="specialized annotation">@specialized
        annotation</primary>
      </indexterm><indexterm>
        <primary>C++</primary>

        <secondary>templates</secondary>
      </indexterm></para>

    <para id="para_in_jvm_related_languages_the_">In JVM-related languages,
    the &#x201C;on-demand&#x201D; generation of implementations isn&#x2019;t suitable, primarily
    because there is no &#x201C;link&#x201D; step as in compiled languages, where every
    required instantiation of a template can be determined. This creates a
    dilemma. By default, a Scala parameterized type or method will be
    translated to a single implementation assuming <literal>Any</literal> for
    the type parameters (in part due to type erasure at the byte code level).
    Java generics work the same way. However, if a particular use of the type
    or method uses one of the <literal>AnyVal</literal> types, say
    <literal>Int</literal>, then we get inefficient boxing and unboxing
    operations in the implementation.</para>

    <para id="para_the_alternative_would_be_to_ge">The alternative would be to
    generate a separate implementation for every <literal>AnyVal</literal>
    corresponding to a primitive type, but this would lead to code bloat,
    especially since it would be rare that an application would use all those
    implementations. So, we are faced with a dilemma.</para>

    <para id="para_the_specialized_annotation_is_pragmatic">The
    <literal>@specialized</literal> annotation is a pragmatic compromise. It
    lets the user tell the compiler that runtime efficiency is more important
    than space efficiency, so the compiler will generate the separate
    implementations for each primitive corresponding to an
    <literal>AnyVal</literal>. Here is an example of how the annotation is
    used:</para>

    <programlisting linenumbering="unnumbered">class SpecialCollection[@specialized +T](...) {
  ...
}</programlisting>

    <para id="para_at_the_time_of_this_writing_t">At the time of this writing,
    the implementation in the version 2.8 &#x201C;nightly&#x201D; build only supports
    generation of specialized implementations for <literal>Int</literal> and
    <literal>Double</literal>. For the final version 2.8 library, it is
    planned that the other <literal>AnyVal</literal> types will be supported.
    There are also plans to allow the user to specify the types for which
    optimized implementations are generated so that unused implementations for
    the other <literal>AnyVals</literal> are avoided. See the final 2.8
    Scaladocs for details on the final feature set.</para>

    <para id="para_another_planned_version_2_8_an">Another planned version 2.8
    annotation is <literal>@cps</literal>, which stands for
    <emphasis>continuation passing style</emphasis>. It will be a directive
    interpreted by a compiler plugin that will trigger generation of
    continuation-based byte code for method invocation, rather than the
    default stack frame byte code. The annotation will have no effect unless
    the corresponding <literal>scalac</literal> plugin is used. Consult the
    release documentation for more information on this feature, when it
    becomes available.<indexterm>
        <primary sortas="cps">@cps (continual passing style)
        annotation</primary>
      </indexterm></para>

    <para id="para_to_understand_the_throws_an">To understand the
    <literal>@throws</literal> annotation, it&#x2019;s important to remember that
    Scala does not have checked exceptions, in contrast with Java. There is
    also no <literal>throws</literal> clause available for Scala method
    declarations. This is not a problem if a Scala method calls a Java method
    that is declared to throw a checked exception. The exception is treated as
    unchecked in Scala. However, suppose the Scala method in question doesn&#x2019;t
    catch the exception, but lets it pass through. What if this Scala method
    is called by other Java code?<indexterm>
        <primary>exceptions</primary>

        <secondary>@throws annotation and</secondary>
      </indexterm><indexterm>
        <primary sortas="throws annotation">@throws annotation</primary>
      </indexterm></para>

    <para id="para_let_s_look_at_an_example_invol">Let&#x2019;s look at an example
    involving <literal>java.io.IOException</literal>, which is a checked
    exception. The following Scala class prints out the contents of a
    <literal>java.io.File</literal>:<indexterm>
        <primary>java.io.IOException class</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/file-printer.scala

import java.io._

class FilePrinter(val file: File) {

  @throws(classOf[IOException])
  def print() = {
    var reader: LineNumberReader = null
    try {
      reader = new LineNumberReader(new FileReader(file))
      loop(reader)
    } finally {
      if (reader != null)
        reader.close
    }
  }

  private def loop(reader: LineNumberReader): Unit = {
    val line = reader.readLine()
    if (line != null) {
      format("%3d: %s\n", reader.getLineNumber, line)
      loop(reader)
    }
  }
}</programlisting>

    <para id="para_note_the_throws_annotation_">Note the
    <literal>@throws</literal> annotation applied to the
    <literal>print</literal> method. The argument to the annotation
    constructor is a single <literal>java.lang.Class[Any]</literal> object, in
    this case, <literal>classOf[IO&#x2060;Exception]</literal>. The Java IO API
    methods used by <literal>print</literal> and the private method
    <literal>loop</literal> might throw this exception.</para>

    <para id="para_by_the_way_notice_that_loop_">By the way, notice that
    <literal>loop</literal> uses functional-style tail recursion, rather than
    a loop. No variables were mutated during the production of this output!
    (Well, we don&#x2019;t actually know what&#x2019;s happening inside the Java IO
    classes....)</para>

    <?dbfo-need height=”1in”
?>

    <para id="para_here_is_a_java_class_that_uses">Here is a Java class that
    uses <literal>FilePrinter</literal>. It provides the
    <literal>main</literal> routine:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/FilePrinterMain.java

import java.io.*;

public class FilePrinterMain {
  public static void main(String[] args) {
    for (String fileName: args) {
      try {
        File file = new File(fileName);
        new FilePrinter(file).print();
      } catch (IOException ioe) {
        System.err.println("IOException for file " + fileName);
        System.err.println(ioe.getMessage());
      }
    }
  }
}</programlisting>

    <para id="para_these_classes_compile_without_">These classes compile
    without error. You can try them out with the following command (which
    assumes that <literal>FilePrinterMain.java</literal> is in the
    <filename>annotations</filename> directory, as in the example code
    distribution):</para>

    <screen>scala -cp build FilePrinterMain annotations/FilePrinterMain.java</screen>

    <para id="para_you_should_get_the_following_o">You should get the
    following output:</para>

    <screen> 1: import java.io.*;
 2:
 3: public class FilePrinterMain {
 4:   public static void main(String[] args) {
 5:     for (String fileName: args) {
 6:       try {
 7:         File file = new File(fileName);
 8:         new FilePrinter(file).print();
 9:       } catch (IOException ioe) {
10:         System.err.println("IOException for file " + fileName);
11:         System.err.println(ioe.getMessage());
12:       }
13:     }
14:   }
15: }</screen>

    <para id="para_now_returning_to_file_print">Now, returning to the
    <literal>FilePrinter</literal> class, suppose you comment out the
    <literal>@throws</literal> line. This file will continue to compile, but
    when you compile <literal>FilePrinterMain.java</literal>, you will get the
    following error:</para>

    <screen>annotations/FilePrinterMain.java:9: exception java.io.IOException is never
thrown in body of corresponding try statement
      } catch (IOException ioe) {
        ^
1 error</screen>

    <para id="para_even_though_java_io_ioexcepti">Even though
    <literal>java.io.IOException</literal> may get thrown by
    <literal>FilePrinter</literal>, that information isn&#x2019;t in the byte code
    generated by <literal>scalac</literal>, so the analysis done by
    <literal>javac</literal> mistakenly concludes that
    <literal>IOException</literal> is never thrown.</para>

    <para id="para_so_the_purpose_of_throws_i">So, the purpose of
    <literal>@throws</literal> is to insert the information on thrown checked
    exceptions into the byte code that <literal>javac</literal> will
    read.<indexterm class="endofrange" startref="ch13_declarationsannotations"/><indexterm class="endofrange" startref="ch13_appdesignannotations"/><indexterm class="endofrange" startref="ch13_annotations"/></para>

    <tip id="para_tip_in_a_mixed_java_scala_env">
      <para>In a mixed Java-Scala environment, consider adding the
      <literal>@throws</literal> <phrase role="keep-together">annotation</phrase> for all your Scala methods that
      can throw Java checked exceptions. Eventually, some Java code will
      probably call one of those <phrase role="keep-together">methods</phrase>.</para>
    </tip>
  </sect1>

  <sect1 id="EnumerationsVsPatternMatching">
    <title>Enumerations Versus Pattern Matching</title>

    <para id="para_enumerations_are_a_way_of_defi">Enumerations are a way of
    defining a finite set of constant values. They are a lightweight
    alternative to case classes. You can reference the values directly,
    iterate through them, index into them with integer indices, etc.<indexterm>
        <primary>case classes</primary>

        <secondary>enumerations as alternative to</secondary>
      </indexterm><indexterm class="startofrange" id="ch13_enumerations">
        <primary>enumerations</primary>
      </indexterm><indexterm class="startofrange" id="ch13_appdesignenumvpm">
        <primary>application design</primary>

        <secondary>enumerations versus pattern matching</secondary>
      </indexterm></para>

    <para id="para_just_as_for_annotations_scala">Just as for annotations,
    Scala&#x2019;s form of enumerations are class-based, with a particular set of
    idioms, rather than relying on special keywords for defining them, as is
    used for enumerations in Java and .NET. However, you can also use
    enumerations defined in those languages.</para>

    <para id="para_scala_enumerations_are_defined">Scala enumerations are
    defined by subclassing the abstract <literal>scala.Enumeration</literal>
    class. There are several ways to construct and use an enumeration. We&#x2019;ll
    demonstrate one idiom that most closely matches the Java and .NET forms
    you may already know.<indexterm>
        <primary>enumerations</primary>

        <secondary>scala.Enumeration class</secondary>
      </indexterm></para>

    <para id="para_recall_http_methods_script_">Recall the HTTP methods
    scripts that we wrote in <xref linkend="SealedClassHierarchies"/>. We
    defined the set of HTTP 1.1 methods using a sealed case class
    hierarchy:</para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/sealed/http-script.scala

sealed abstract class HttpMethod()
case class Connect(body: String) extends HttpMethod
case class Delete (body: String) extends HttpMethod
case class Get    (body: String) extends HttpMethod
case class Head   (body: String) extends HttpMethod
case class Options(body: String) extends HttpMethod
case class Post   (body: String) extends HttpMethod
case class Put    (body: String) extends HttpMethod
case class Trace  (body: String) extends HttpMethod

def handle (method: HttpMethod) = method match {
  case Connect (body) =&gt; println("connect: " + body)
  case Delete  (body) =&gt; println("delete: "  + body)
  case Get     (body) =&gt; println("get: "     + body)
  case Head    (body) =&gt; println("head: "    + body)
  case Options (body) =&gt; println("options: " + body)
  case Post    (body) =&gt; println("post: "    + body)
  case Put     (body) =&gt; println("put: "     + body)
  case Trace   (body) =&gt; println("trace: "   + body)
}

val methods = List(
  Connect("connect body..."),
  Delete ("delete body..."),
  Get    ("get body..."),
  Head   ("head body..."),
  Options("options body..."),
  Post   ("post body..."),
  Put    ("put body..."),
  Trace  ("trace body..."))

methods.foreach { method =&gt; handle(method) }</programlisting>

    <para id="para_in_that_example_each_method_h">In that example, each method
    had a <literal>body</literal> attribute for the message body. We&#x2019;ll assume
    here that the body is handled through other means and we only care about
    identifying the kind of HTTP method. So, here is a Scala
    <literal>Enumeration</literal> class for the HTTP 1.1 <phrase role="keep-together">methods</phrase>:<indexterm class="startofrange" id="ch13_enumsHttpMethod">
        <primary>enumerations</primary>

        <secondary>HttpMethod object (example)</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-enum-script.scala

object HttpMethod extends Enumeration {
  type Method = Value
  val Connect, Delete, Get, Head, Options, Post, Put, Trace = Value
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println("Connect: " + method.id)
  case Delete  =&gt; println("Delete: "  + method.id)
  case Get     =&gt; println("Get: "     + method.id)
  case Head    =&gt; println("Head: "    + method.id)
  case Options =&gt; println("Options: " + method.id)
  case Post    =&gt; println("Post: "    + method.id)
  case Put     =&gt; println("Put: "     + method.id)
  case Trace   =&gt; println("Trace: "   + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println( HttpMethod )</programlisting>

    <para id="para_this_script_produces_the_follo">This script produces the
    following output:</para>

    <screen>Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Main$$anon$1$HttpMethod(0), Main$$anon$1$HttpMethod(1),
Main$$anon$1$HttpMethod(2), Main$$anon$1$HttpMethod(3),
Main$$anon$1$HttpMethod(4), Main$$anon$1$HttpMethod(5),
Main$$anon$1$HttpMethod(6), Main$$anon$1$HttpMethod(7)}</screen>

    <para>(We wrapped the lines for the output between the
    <literal>{...}</literal>.) There are two uses of <literal>Value</literal>
    in the definition of <literal>HttpMethod</literal>. The first usage is
    actually a reference to an abstract class,
    <literal>Enumeration.Value</literal>, which encapsulates some useful
    operations for the &#x201C;values&#x201D; in the enumeration. We define a new
    <literal>type</literal>, <literal>Method</literal>, that functions as an
    alias for <literal>Value</literal>. We see it used in the type of the
    argument passed to the <literal>handle</literal> method, which
    demonstrates <literal>HttpMethod</literal> in use.
    <literal>HttpMethod.Method</literal> is a more meaningful name to the
    reader than the generic <literal>HttpMethod.Value</literal>. Note that one
    of the fields in <literal>Enumeration.Value</literal> is
    <literal>id</literal>, which we also use in
    <literal>handle</literal>.<indexterm>
        <primary>Value class</primary>
      </indexterm><indexterm>
        <primary>Enumeration.Value class</primary>
      </indexterm></para>

    <para id="para_the_second_use_of_value_is_a">The second use of
    <literal>Value</literal> is actually a call to a method. There is no
    namespace collision between these two names. The line <literal>val
    Connect, Delete, Get, Head, Options, Post, Put, Trace = Value</literal>
    defines the set of values for the enumeration. The
    <literal>Value</literal> method is called for each one. It creates a new
    <literal>Enumeration.Value</literal> for each one and adds it to the
    managed set of values.</para>

    <para id="para_in_the_code_below_the_definiti">In the code below the
    definition, we import the definitions in <literal>HttpMethod</literal> and
    we define a <literal>handle</literal> method that pattern matches on
    <literal>HttpMethod.Method</literal> objects. It simply prints a message
    for each value along with its <literal>id</literal>. Note that while the
    example has no &#x201C;default&#x201D; case clause (e.g. <literal>case _ &#x21D2;
    ...</literal>), none is required in this case. However, the compiler
    doesn&#x2019;t actually know that all the possible values are covered, in
    contrast to a sealed case class hierarchy. If you comment out one of the
    case statements in <literal>handle</literal>, you will get no warnings,
    but you will get a <literal>MatchError</literal>.<indexterm>
        <primary>pattern matching</primary>

        <secondary sortas="enumerations">on enumerations</secondary>
      </indexterm></para>

    <warning id="para_warning_when_pattern_matching">
      <para>When pattern matching on enumeration values, the compiler can&#x2019;t
      tell if the match is &#x201C;exhaustive.&#x201D;</para>
    </warning>

    <para id="para_you_might_wonder_why_we_hard_c">You might wonder why we
    hardcoded strings like &#x201C;Connect&#x201D; in the <literal>println</literal>
    statements in the case clauses. Can&#x2019;t we get the name from the
    <literal>HttpMethod.Method</literal> object itself? And why didn&#x2019;t the
    output of <literal>println(HttpMethod)</literal> include those names,
    instead of the ugly internal object names?</para>

    <para id="para_you_are_probably_accustomed_to">You are probably accustomed
    to using such names with Java or .NET enumerations. Unfortunately, we
    can&#x2019;t get those names from the values in the Scala enumeration, at least
    given the way that we declared <literal>HttpMethod</literal>. However,
    there are two ways we can change the implementation to get name strings.
    In the first approach, we pass the name to <literal>Value</literal> when
    creating the fields:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-enum2-script.scala

object HttpMethod extends Enumeration {
  type Method = Value
  val Connect = Value("Connect")
  val Delete  = Value("Delete")
  val Get     = Value("Get")
  val Head    = Value("Head")
  val Options = Value("Options")
  val Post    = Value("Post")
  val Put     = Value("Put")
  val Trace   = Value("Trace")
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println( HttpMethod )</programlisting>

    <para id="para_redundant_connect">It is a bit redundant to have to use the
    same word twice in declarations like <literal>val Connect =
    Value("Connect")</literal>.</para>

    <para id="para_http-enum2-script_output">Running this script produces the
    following nicer output:</para>

    <screen>Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Connect, Delete, Get, Head, Options, Post, Put, Trace}</screen>

    <para id="para_in_the_second_approach_we_pas">In the second approach, we
    pass the list of names to the <literal>Enumeration</literal>
    constructor:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-enum3-script.scala

object HttpMethod extends Enumeration(
    "Connect", "Delete", "Get", "Head", "Options", "Post", "Put", "Trace") {
  type Method = Value
  val Connect, Delete, Get, Head, Options, Post, Put, Trace = Value
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println( HttpMethod )</programlisting>

    <para id="para_note_that_we_have_a__redundant">This script produces
    identical output. Note that we have a <emphasis>redundant</emphasis> list
    of name strings and names of the <literal>vals</literal>. <emphasis>It is
    up to you to keep the items in the list and their order consistent with
    the declared values!</emphasis> This version has fewer characters, but it
    is more error-prone. Internally, <literal>Enumeration</literal> pairs the
    strings with the corresponding <literal>Value</literal> instances as they
    are created.</para>

    <para id="para_on_the_plus_side_the_output_i">The output when printing the
    whole <literal>HttpMethod</literal> object is better for either
    alternative implementation. When the values have names, their
    <literal>toString</literal> returns the name. In fact, our final two
    examples have become quite artificial because we now have identical
    statements for each case clause! Of course, in a real implementation, you
    would handle the different HTTP methods differently.<indexterm class="endofrange" startref="ch13_enumerations"/><indexterm class="endofrange" startref="ch13_enumsHttpMethod"/><indexterm class="endofrange" startref="ch13_appdesignenumvpm"/></para>
  </sect1>

  <sect1 id="ThoughtsOnAnnotationsAndEnumerations">
    <title>Thoughts On Annotations and Enumerations</title>

    <para id="para_for_both_annotations_and_enume">For both annotations and
    enumerations, there are advantages and disadvantages to the Scala
    approach, where we use regular class-based mechanisms, rather than
    inventing custom keywords and syntax. The advantages include fewer special
    cases in the language. Classes and traits are used in more or less the
    same ways they are used for &#x201C;normal&#x201D; code. The disadvantages include the
    need to understand and use ad hoc conventions that are not always as
    convenient to use as the custom syntax mechanisms required in Java and
    .NET. Also, Scala&#x2019;s implementations are not as full-featured.<indexterm>
        <primary>enumerations</primary>

        <secondary>advantages and disadvantages of</secondary>
      </indexterm><indexterm>
        <primary>annotations</primary>

        <secondary>advantages and disadvantages of</secondary>
      </indexterm></para>

    <para id="para_so_should_the_scala_community">So, should the Scala
    community relent and implement ad hoc, but more full-featured mechanisms
    for annotations and enumerations? Maybe not. Scala is a more flexible
    language than most languages. Many of the features provided by Java and
    .NET annotations and enumerations can be implemented in Scala by other
    means.</para>

    <para id="para_some_use_cases_for_the_mor">Some use cases for the more
    advanced features of Java annotations can be implemented more elegantly
    with &#x201C;normal&#x201D; Scala code, as we will discuss in <xref linkend="DesignPatterns"/>. For enumerations, sealed case classes and
    pattern matching provide a more flexible solution, in many
    cases.<indexterm>
        <primary>pattern matching</primary>

        <secondary>using with case classes, enumerations versus</secondary>
      </indexterm><indexterm>
        <primary>case classes</primary>

        <secondary>enumerations versus</secondary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>enumerations versus case classes and pattern
        matching</secondary>
      </indexterm><indexterm>
        <primary>enumerations</primary>

        <secondary>case classes and pattern matching versus</secondary>
      </indexterm></para>

    <sect2 id="EnumerationsVsCaseClassesAndPatternMatching">
      <title>Enumerations Versus Case Classes and Pattern Matching</title>

      <para id="para_let_s_revisit_http_methods_s">Let&#x2019;s revisit the HTTP
      method script, which uses a sealed case class hierarchy versus the
      version we wrote previously that uses an <literal>Enumeration</literal>.
      Since the enumeration version doesn&#x2019;t handle the message body, let&#x2019;s
      write a modified version of the sealed case class version that is closer
      to the enumeration version, i.e., it also doesn&#x2019;t hold the message body
      and it has <literal>name</literal> and <literal>id</literal>
      methods:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-case-script.scala

sealed abstract class HttpMethod(val id: Int) {
  def name = getClass getSimpleName
  override def toString = name
}

case object Connect extends HttpMethod(0)
case object Delete  extends HttpMethod(1)
case object Get     extends HttpMethod(2)
case object Head    extends HttpMethod(3)
case object Options extends HttpMethod(4)
case object Post    extends HttpMethod(5)
case object Put     extends HttpMethod(6)
case object Trace   extends HttpMethod(7)

def handle (method: HttpMethod) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

List(Connect, Delete, Get, Head, Options, Post, Put, Trace) foreach {
  method =&gt; handle(method)
}</programlisting>

      <para id="para_note_that_we_used_case_object">Note that we used
      <literal>case object</literal> for all the concrete subclasses, to have
      a true set of constants. To mimic the enumeration <literal>id</literal>,
      we added a field explicitly, but now it&#x2019;s up to us to pass in valid,
      unique values! The <literal>handle</literal> methods in the two
      implementations are nearly identical.</para>

      <para id="para_this_script_outputs_the_follow">This script outputs the
      following:</para>

      <screen>Main$$anon$1$Connect$: 0
Main$$anon$1$Delete$: 1
Main$$anon$1$Get$: 2
Main$$anon$1$Head$: 3
Main$$anon$1$Options$: 4
Main$$anon$1$Post$: 5
Main$$anon$1$Put$: 6
Main$$anon$1$Trace$: 7</screen>

      <para id="para_the_object_names_are_ugly_but">The object names are ugly,
      but we could parse the string and remove the substring we really care
      about.</para>

      <para id="para_both_approaches_support_the_co">Both approaches support
      the concept of a finite and fixed set of values, as long as the case
      class hierarchy is sealed. An additional advantage of a sealed case
      class hierarchy is the fact that the compiler will warn you if pattern
      matching statements aren&#x2019;t <phrase role="keep-together">exhaustive</phrase>. Try removing one of the case
      clauses and you&#x2019;ll get the usual warning. The compiler can&#x2019;t do this
      with enumerations, as we saw.</para>

      <para id="para_the_enumeration_format_is_more">The enumeration format is
      more succinct, despite the name duplication we had to use, and it also
      supports the ability to iterate through the values. We had to do that
      manually in the case clause implementation.</para>

      <para id="para_the_case_class_implementation_">The case class
      implementation naturally accommodates other fields, e.g., the
      <literal>body</literal>, as in the original implementation, while
      enumerations can only accommodate constant <literal>Values</literal>
      with associated names and IDs.</para>

      <tip id="para_tip_for_cases_where_you_need_">
        <para>For cases where you need only a simple list of constants by name
        or ID number, use enumerations. Be careful to follow the usage idioms.
        For fixed sets of more complex, constant objects, use sealed case
        objects.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="UsingNullsVsOptions">
    <title>Using Nulls Versus Options</title>

    <para id="para_when_we_introduced_option_in">When we introduced
    <literal>Option</literal> in <xref linkend="OptionSomeNone"/>, we briefly
    discussed how it encourages avoiding <literal>null</literal> references in
    your code, which Tony Hoare, who introduced the concept of
    <literal>null</literal> in 1965, called his &#x201C;billion dollar mistake&#x201D; (see
    <link linkend="Hoare2009" xrefstyle="select:nopage">[Hoare2009]</link>).<indexterm>
        <primary>Option class</primary>

        <secondary>nulls versus</secondary>
      </indexterm><indexterm>
        <primary>nulls</primary>

        <secondary>Options versus</secondary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>nulls versus Options</secondary>
      </indexterm></para>

    <para id="para_scala_has_to_support_null_b">Scala has to support
    <literal>null</literal>, because <literal>null</literal> is supported on
    both the JVM and .NET and other libraries use <literal>null</literal>. In
    fact, <literal>null</literal> is used by some Scala libraries.</para>

    <para id="para_what_if_null_were_not_availa">What if
    <literal>null</literal> were not available? How would that change your
    designs? The <literal>Map</literal> API offers some useful examples.
    Consider these two <literal>Map</literal> methods:</para>

    <programlisting linenumbering="unnumbered">trait Map[A,+B] {
  ...
  def get(key: A) : Option[B]
  def getOrElse [B2 &gt;: B](key : A, default : =&gt; B2) : B2 = ...
  ...
}</programlisting>

    <para id="para_a_map_may_not_have_a_value_for">A map may not have a value
    for a particular key. Both of these methods avoid returning
    <literal>null</literal> in that case. Concrete implementations of
    <literal>get</literal> in subclasses return a <literal>None</literal> if
    no value exists for the key. Otherwise, they return a
    <literal>Some</literal> wrapping the value. The method signature tells you
    that a value might not exist, and it forces you to handle that situation
    gracefully:</para>

    <programlisting linenumbering="unnumbered">val stateCapitals = Map("Alabama" -&gt; "Montgomery", ...)
...

stateCapitals.get("North Hinterlandia") match {
  case None =&gt; println ("No such state!")
  case Some(x) =&gt; println(x)
}</programlisting>

    <para id="para_similarly_getorelse_forces_">Similarly,
    <literal>getOrElse</literal> forces you to design defensively. You have to
    specify a default value for when a key isn&#x2019;t in the map. Note that the
    default value can actually be an instance of a supertype relative to the
    map&#x2019;s value type:</para>

    <programlisting linenumbering="unnumbered">println(stateCapitals.getOrElse("North Hinterlandia", "No such state!"))</programlisting>

    <para id="para_a_lot_of_java_and_net_apis_al">A lot of Java and .NET APIs
    allow <literal>null</literal> method arguments and can return
    <literal>null</literal> values. You can write Scala wrappers around them
    to implement an appropriate strategy for handling
    <literal>nulls</literal>.</para>

    <para id="para_for_example_let_s_revisit_our">For example, let&#x2019;s revisit
    our previous file printing example from <xref linkend="Annotations"/>.
    We&#x2019;ll refactor our <literal>FilePrinter</literal> class and the Java
    driver into a combined script. We&#x2019;ll address two issues: 1) wrap
    <literal>LineNumberReader.readLine</literal> with a method that returns an
    <literal>Option</literal> instead of <literal>null</literal>, and 2) wrap
    checked <literal>IOExceptions</literal> in our own unchecked exception,
    called <literal>ScalaIOException</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/options-nulls/file-printer-refactored-script.scala

import java.io._

class ScalaIOException(cause: Throwable) extends RuntimeException(cause)

class ScalaLineNumberReader(in: Reader) extends LineNumberReader(in) {
  def inputLine() = readLine() match {
    case null =&gt; None
    case line =&gt; Some(line)
  }
}

object ScalaLineNumberReader {
  def apply(file: File) = try {
     new ScalaLineNumberReader(new FileReader(file))
  } catch {
    case ex: IOException =&gt; throw new ScalaIOException(ex)
  }
}

class FilePrinter(val file: File) {
  def print() = {
    val reader = ScalaLineNumberReader(file)
    try {
      loop(reader)
    } finally {
      if (reader != null)
        reader.close
    }
  }

  private def loop(reader: ScalaLineNumberReader): Unit = {
    reader.inputLine() match {
      case None =&gt;
      case Some(line) =&gt; {
        format("%3d: %s\n", reader.getLineNumber, line)
        loop(reader)
      }
    }
  }
}

// Process the command-line arguments (file names):
args.foreach { fileName =&gt;
  new FilePrinter(new File(fileName)).print();
}</programlisting>

    <para id="para_the_scalabufferedreader_clas">The
    <literal>ScalaLineNumberReader</literal> class defines a new method
    <literal>inputLine</literal> that calls <literal role="keep-together">LineNumberReader.readLine</literal> and pattern
    matches the result. If <literal>null</literal>, then
    <literal>None</literal> is returned. <phrase role="keep-together">Otherwise</phrase>, the line is returned wrapped in a
    <literal>Some[String]</literal>.</para>

    <para id="para__scalaioexception_is_a_subcla"><literal>ScalaIOException</literal>
    is a subclass of <literal>RuntimeException</literal>, so it is unchecked.
    We use it to wrap any <literal>IOExceptions</literal> thrown in
    <literal>ScalaLineNumberReader.apply</literal>.</para>

    <para id="para_the_refactored_fileprinter_c">The refactored
    <literal>FilePrinter</literal> class uses
    <literal>ScalaLineNumberReader.apply</literal> in its
    <literal>print</literal> method. It uses
    <literal>ScalaLineNumberReader.inputLine</literal> in its
    <literal>loop</literal> method. While the original version properly
    handled the case of <literal>LineNumberReader.readLine</literal> returning
    <literal>null</literal>, now the user of
    <literal>ScalaLineNumberReader</literal> has no choice but to handle a
    <literal>None</literal> return value.</para>

    <para id="para_the_script_ends_with_a_loop_ov">The script ends with a loop
    over the input arguments, which are stored automatically in the
    <literal>args</literal> variable. Each argument is treated as a file name
    to be printed. The script will print itself with the following
    command:</para>

    <screen>scala file-printer-refactored-script.scala file-printer-refactored-script.scala</screen>

    <sect2 id="OptionsAndForComprehensions">
      <title>Options and for Comprehensions</title>

      <para id="para_one_other_benefit_of_option_with_for_comps">There is one
      other benefit of using <literal>Options</literal> with
      <literal>for</literal> comprehensions, automatic <phrase role="keep-together">removal</phrase> of <literal>None</literal>
      elements from comprehensions, under most conditions (refer to <link linkend="Pollak2007" xrefstyle="select:nopage">[Pollak2007]</link> and
      <link linkend="Spiewak2009c" xrefstyle="select:nopage">[Spiewak2009c]</link>). Consider this first
      version of a script that uses <literal>Options</literal> in a
      <literal>for</literal> <phrase role="keep-together">comprehension</phrase>:<indexterm>
          <primary>for comprehensions</primary>

          <secondary>using Options with</secondary>
        </indexterm><indexterm>
          <primary>Option class</primary>

          <secondary>using with for comprehensions</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/options-nulls/option-for-comp-v1-script.scala

case class User(userName: String, name: String, email: String, bio: String)

val newUserProfiles = List(
  Map("userName" -&gt; "twitspam", "name" -&gt; "Twit Spam"),
  Map("userName" -&gt; "bucktrends", "name" -&gt; "Buck Trends",
      "email" -&gt; "thebuck@stops.he.re", "bio" -&gt; "World's greatest bloviator"),
  Map("userName" -&gt; "lonelygurl", "name" -&gt; "Lonely Gurl",
      "bio" -&gt; "Obviously fake..."),
  Map("userName" -&gt; "deanwampler", "name" -&gt; "Dean Wampler",
      "email" -&gt; "dean@....com", "bio" -&gt; "Scala passionista"),
  Map("userName" -&gt; "al3x", "name" -&gt; "Alex Payne",
      "email" -&gt; "al3x@....com", "bio" -&gt; "Twitter API genius"))

// Version #1

var validUsers = for {
  user     &lt;- newUserProfiles
  if (user.contains("userName") &amp;&amp; user.contains("name") &amp;&amp;   // #1
      user.contains("email") &amp;&amp; user.contains("bio"))         // #1
  userName &lt;- user get "userName"
  name     &lt;- user get "name"
  email    &lt;- user get "email"
  bio      &lt;- user get "bio" }
    yield User(userName, name, email, bio)

validUsers.foreach (user =&gt; println(user))</programlisting>

      <para id="para_imagine_this_code_is_used_in_s">Imagine this code is used
      in some sort of social networking site. New users submit profile data,
      which is passed to this service in bulk for processing. For example, we
      hardcoded a list of submitted profiles, where each profile data set is a
      map. The map might have been copied from an HTTP session.</para>

      <para id="para_the_service_filters_out_incomp">The service filters out
      incomplete profiles (missing fields), shown with the #1 comments, and
      creates new user objects from the complete profiles.</para>

      <para id="para_3_of_5_users_printed">Running the script prints out three
      new users from the five submitted profiles:</para>

      <screen>User(bucktrends,Buck Trends,thebuck@stops.he.re,World's greatest bloviator)
User(deanwampler,Dean Wampler,dean@....com,Scala passionista)
User(al3x,Alex Payne,al3x@....com,Twitter API genius)</screen>

      <para id="para_now_comment_out_the_two_lines">Now, delete the two lines
      with the #1 comment:</para>

      <programlisting linenumbering="unnumbered">...
var validUsers = for {
  user     &lt;- newUserProfiles
  userName &lt;- user get "userName"
  name     &lt;- user get "name"
  email    &lt;- user get "email"
  bio      &lt;- user get "bio" }
    yield User(userName, name, email, bio)

validUsers.foreach (user =&gt; println(user))</programlisting>

      <para id="para_before_you_rerun_the_script_w">Before you rerun the
      script, what do you expect to happen? Will it print five lines with some
      fields empty (or containing other kinds of values)?</para>

      <para id="para_same_3_of_5_users_printed">It prints the same thing! How
      did it do the filtering we wanted without the explicit
      conditional?</para>

      <para id="para_the_answer_lies_in_the_way_tha">The answer lies in the
      way that <literal>for</literal> comprehensions are implemented. Here are
      a couple of simple for comprehensions followed by their translations
      (see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>). First, we&#x2019;ll look at
      a single <emphasis>generator</emphasis> with a
      <literal>yield</literal>:<indexterm>
          <primary>generators</primary>

          <secondary sortas="for comprehensions">in for
          comprehensions</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1) yield e2          // for comprehension

e1 map ( case p1 =&gt; e2 )         // translation</programlisting>

      <para id="para_here_s_the_translation_a_singl">Here&#x2019;s the translation of
      a single generator followed by an arbitrary expression (which could be
      several expressions in braces, etc.):</para>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1) e2                // for comprehension

e1 foreach ( case p1 =&gt; e2 )     // translation</programlisting>

      <para id="para_with_more_than_one__generator_">With more than one
      generator, <literal>map</literal> is replaced with
      <literal>flatMap</literal> in the <literal>yield</literal> expressions,
      but <literal>foreach</literal> is unchanged:</para>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1; p2 &lt;- e2 ...) yield eN       // for comprehension

e1 flatMap ( case p1 =&gt; for (p2 &lt;- e2 ...) yield eN )  // translation</programlisting>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1; p2 &lt;- e2 ...) eN             // for comprehension

e1 foreach ( case p1 =&gt; for (p2 &lt;- e2 ...) eN )       // translation</programlisting>

      <para id="para_note_that_the_second_through_t">Note that the second
      through the N<superscript>th</superscript> generators become nested for
      comprehensions that need translating.</para>

      <para id="para_there_are_similar_translations">There are similar
      translations for conditional statements (which become calls to <literal role="keep-together">filter</literal>) and <literal>val</literal>
      assignments. We won&#x2019;t show them here, since our primary purpose is to
      describe just enough of the implementation details so you can understand
      how <literal>Options</literal> and <literal>for</literal> comprehensions
      work together. The additional details are described in <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>, with examples.</para>

      <para id="para_if_you_follow_this_translation">If you follow this
      translation process on our example, you get the following
      expansion:</para>

      <programlisting linenumbering="unnumbered">var validUsers = newUserProfiles flatMap {
  case user =&gt; user.get("userName") flatMap {
    case userName =&gt; user.get("name") flatMap {
      case name =&gt; user.get("email") flatMap {
        case email =&gt; user.get("bio") map {
          case bio =&gt; User(name, userName, email, bio)    // #1
        }
      }
    }
  }
}</programlisting>

      <para id="para_note_that_we_have_flatmap_ca">Note that we have
      <literal>flatMap</literal> calls until the most nested case, where
      <literal>map</literal> is used (<literal role="keep-together">flatMap</literal> and <literal>map</literal> behave
      equivalently in this case).</para>

      <para id="para_now_we_can_understand_why_the_">Now we can understand why
      the big conditional was unnecessary. Recall that <literal>user</literal>
      is a <literal>Map</literal> and <literal>user.get("...")</literal>
      returns an <literal>Option</literal>, either <literal>None</literal> or
      <literal>Some(value)</literal>. The key is the behavior of
      <literal>flatMap</literal> defined on <literal>Option</literal>, which
      lets us treat <literal>Options</literal> like other collections. Here is
      the definition of <literal>flatMap</literal>:</para>

      <programlisting linenumbering="unnumbered">def flatMap[B](f: A =&gt; Option[B]): Option[B] =
  if (isEmpty) None else f(this.get)</programlisting>

      <para id="para_if_user_get_returns_">If
      <literal>user.get("...")</literal> returns <literal>None</literal>, then
      <literal>flatMap</literal> simply returns <literal>None</literal> and
      never evaluates the function literal. Hence, the nested iterations
      simply stop and never get to the line marked with the comment #1, where
      the <literal>User</literal> is created.</para>

      <para id="para_the_outer_most_flatmap_is_on">The outermost
      <literal>flatMap</literal> is on the input <literal>List</literal>,
      <literal>newUserProfiles</literal>. On a multi-element <phrase role="keep-together">collection</phrase> like this, the behavior of
      <literal>flatMap</literal> is similar to <literal>map</literal>, but it
      flattens the new <phrase role="keep-together">collection</phrase> and
      doesn&#x2019;t require the resulting map to have the same number of elements as
      the original collection, like <literal>map</literal> does.</para>

      <para id="para_finally_recall_from_partial">Finally, recall from <xref linkend="PartialFunctions"/> that the <literal>case user =&gt;
      ...</literal> <phrase role="keep-together">statements</phrase>, for
      example, cause the compiler to generate a
      <literal>PartialFunction</literal> to pass to <literal role="keep-together">flatMap</literal> and <literal>map</literal>, so no
      corresponding <literal>foo match {...}</literal> style wrappers are
      necessary.</para>

      <tip id="para_tip_using_options_with_for">
        <para>Using <literal>Options</literal> with <literal>for</literal>
        comprehensions eliminate the need for most &#x201C;null/empty&#x201D; checks.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="ExceptionsAndTheAlternatives">
    <title>Exceptions and the Alternatives</title>

    <para id="para_if_nulls_are_the_billion_d">If <literal>nulls</literal> are
    the &#x201C;billion dollar mistake&#x201D; as we discussed in <xref linkend="OptionSomeNone"/>, then what about exceptions? You can argue
    that <literal>nulls</literal> should never occur and you can design a
    language and libraries that never use them. However, exceptions have a
    legitimate place because they <emphasis>separate the con&#x2060;cerns</emphasis>
    of normal program flow from &#x201C;exceptional&#x201D; program flow. The divide isn&#x2019;t
    always clear-cut. For example, if a user mistypes his username, is that
    normal or exceptional?<indexterm>
        <primary>application design</primary>

        <secondary>exceptions and alternatives</secondary>
      </indexterm><indexterm>
        <primary>exceptions</primary>

        <secondary>and alternatives to</secondary>
      </indexterm></para>

    <para id="para_another_question_is_where_shou">Another question is where
    should the exception be caught and handled? Java&#x2019;s checked exceptions were
    designed to document for the API user what exceptions might be thrown by a
    method. The flaw was that it encouraged handling of the exception in ways
    that are often suboptimal. If one method calls another method that might
    throw a checked exception, the calling method is forced to either handle
    the exception or declare that it also throws the exception. More often
    than not, the calling method is the wrong place to handle the exception.
    It is too common for methods to simply &#x201C;eat&#x201D; an exception that should
    really be passed up the stack and handled in a more appropriate context.
    Otherwise, <literal>throws</literal> declarations are required up the
    stack of method calls. This is not only tedious, but it pollutes the
    intermediate contexts with exception names that often have no connection
    to the local context.</para>

    <para id="para_as_we_have_seen_scala_doesn_t_">As we have seen, Scala
    doesn&#x2019;t have checked exceptions. Any exception can propagate to the point
    where it is most appropriate to handle it. However, design discipline is
    required to implement handlers in the appropriate places for all
    exceptions for which recovery is possible!</para>

    <para id="para_every_now_and_then_an_argumen">Every now and then, an
    argument erupts among developers in a particular language community about
    whether or not it&#x2019;s OK to use exceptions as a control-flow mechanism for
    normal processing. Sometimes this use of exceptions is seen as a useful
    <literal role="keep-together">longjump</literal> or non-local
    <literal>goto</literal> mechanism for exiting out of a deeply nested
    scope. One reason this debate pops up is that this use of exceptions is
    sometimes more efficient than a more &#x201C;conventional&#x201D; implementation.</para>

    <para id="para_for_example_you_might_impleme">For example, you might
    implement <literal>Iterable.foreach</literal> to blindly traverse a
    collection and stop when it catches whatever exception indicates it went
    past the end of the <phrase role="keep-together">collection</phrase>.</para>

    <para id="para_when_it_comes_to_application_d">When it comes to
    application design, communicating <emphasis>intent</emphasis> is very
    important. Using exceptions as a <literal>goto</literal> mechanism breaks
    the <emphasis>principle of least surprise</emphasis>. It will be rare that
    the performance gain will justify the loss of clarity, so we encourage you
    to use exceptions only for truly &#x201C;exceptional&#x201D; conditions. Note that Ruby
    actually provides a non-local <literal>goto</literal>-like mechanism. In
    Ruby the keywords <literal>throw</literal> and <literal>catch</literal>
    are actually reserved for this purpose, while <literal>raise</literal> and
    <literal>rescue</literal> are the keywords for raising an exception and
    handling it.<indexterm>
        <primary>Ruby</primary>

        <secondary>exceptions</secondary>
      </indexterm></para>

    <para id="para_whatever_your_view_on_the_prop">Whatever your view on the
    proper use of exceptions, when you design APIs, minimizing the possibility
    of raising an exception will benefit your users. This is the flip side of
    an exception handling strategy, preventing them in the first place.
    <literal>Option</literal> can help.<indexterm>
        <primary>Option class</primary>

        <secondary>alternatives to exceptions</secondary>
      </indexterm></para>

    <para id="para_consider_two_methods_on_seq_">Consider two methods on
    <literal>Seq</literal>, <literal>first</literal> and
    <literal>firstOption</literal>:<indexterm>
        <primary>Seq class, first and firstOption methods</primary>
      </indexterm></para>

    <screen>trait Seq[+A] {
  ...
  def first : A = ...
  def firstOption : Option[A] = ...
  ...
}</screen>

    <para id="para_the_first_method_throws_a_p">The <literal>first</literal>
    method throws a <literal>Predef.UnsupportedOperationException</literal> if
    the sequence is empty. Returning <literal>null</literal> in this case
    isn&#x2019;t an option, because the sequence could have <literal>null</literal>
    elements! In contrast, the <literal>firstOption</literal> method returns
    an <literal>Option</literal>, so it returns <literal>None</literal> if the
    sequence is empty, which is unambiguous.</para>

    <para id="para_you_could_argue_that_the_seq_">You could argue that the
    <literal>Seq</literal> API would be more robust if it only had a &#x201C;first&#x201D;
    method that returned an <literal>Option</literal>. It&#x2019;s useful to ask
    yourself, &#x201C;How can I prevent the user from ever failing?&#x201D; When &#x201C;failure&#x201D;
    can&#x2019;t be prevented, use <literal>Option</literal> or a similar construct
    to document for the user that a failure mode is possible. Thinking in
    terms of valid state transformations, the <literal>first</literal> method,
    while convenient, isn&#x2019;t really valid for a sequence in an empty state.
    Should the &#x201C;first&#x201D; methods not exist for this reason? This choice is
    probably too draconian, but by returning <literal>Option</literal> from
    <literal>firstOption</literal>, the API communicates to the user that
    there are circumstances when the method can&#x2019;t satisfy the request and it&#x2019;s
    up to the user to recover gracefully. In this sense,
    <literal>firstOption</literal> treats an empty sequence as a
    non-exceptional situation.</para>

    <para id="para_recall_that_we_saw_another_exa">Recall that we saw another
    example of this decision tradeoff in <xref linkend="OptionSomeNone"/>. We
    discussed two methods on <literal>Option</literal> for retrieving the
    value an instance wraps (when the instance is actually a
    <literal>Some</literal>). The <literal>get</literal> method throws an
    exception if there is no value, i.e., the <literal>Option</literal>
    instance is actually <literal>None</literal>. The other method,
    <literal>getOrElse</literal>, takes a second argument, a default value to
    return if the <literal>Option</literal> is actually
    <literal>None</literal>. In this case, no exception is thrown.</para>

    <para id="para_of_course_it_is_impossible_to">Of course, it is impossible
    to avoid all exceptions. Part of the original intent of checked versus
    unchecked exceptions was to distinguish between potentially recoverable
    problems and catastrophic failures, like out-of-memory errors.</para>

    <para id="para_however_the_alternative_metho">However, the alternative
    methods in <literal>Seq</literal> and <literal>Option</literal> show a way
    to &#x201C;encourage&#x201D; the user of an API to consider the consequences of a
    possible failure, like asking for the first element in an empty sequence.
    The user can specify the contingency in the event that a failure occurs.
    Minimizing the possibility of exceptions will improve the robustness of
    your Scala libraries and the applications that use them.</para>
  </sect1>

  <sect1 id="ScalableAbstractions">
    <title>Scalable Abstractions</title>

    <para id="para_it_has_been_a_goal_for_some_ti">It has been a goal for some
    time in our industry to create reusable <emphasis>components</emphasis>.
    Unfortunately, there is little agreement on the meaning of the term
    <emphasis>component</emphasis>, nor on a related term,
    <emphasis>module</emphasis> (which some people consider synonymous with
    <emphasis>component</emphasis>). Proposed definitions usually start with
    assumptions about the platform, granularity, deployment and configuration
    scenarios, versioning issues, etc. (see <link linkend="Szyperski1998" xrefstyle="select:nopage">[Szyperski1998]</link>).<indexterm class="startofrange" id="ch13_components"/><indexterm>
        <primary>modules</primary>

        <secondary>components and</secondary>
      </indexterm><indexterm>
        <primary>components</primary>

        <secondary>defined</secondary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>scalable abstractions</secondary>
      </indexterm></para>

    <para id="para_we_ll_avoid_that_discussion_an">We&#x2019;ll avoid that discussion
    and use the term <emphasis>component</emphasis> informally to refer to a
    grouping of types and packages that exposes coherent abstractions
    (preferably just one) for the services it offers, that has minimal
    coupling to other components, and that is internally cohesive.<indexterm>
        <primary>scalable abstractions</primary>

        <see>components</see>
      </indexterm></para>

    <para id="para_all_languages_offer_mechanisms">All languages offer
    mechanisms for defining components, at least to some degree. Objects are
    the primary encapsulation mechanism in object-oriented languages. However,
    objects alone aren&#x2019;t enough, because we quickly find that objects
    naturally cluster together into more coarse-grained aggregates, especially
    as our applications grow. Generally speaking, an object isn&#x2019;t necessarily
    a component, and a component may contain many objects. Scala and Java
    offer packages for aggregating types. Ruby modules serve a similar
    purpose, as do C# and C++ namespaces.</para>

    <para id="para_however_these_packaging_mecha">However, these packaging
    mechanisms still have limitations. A common problem is that they don&#x2019;t
    clearly define what is publicly visible outside the component boundary and
    what is internal to the component. For example, in Java, any public type
    or public method on a public type is visible outside the package boundary
    to every other component. You can make types and methods &#x201C;package
    private,&#x201D; but then they are invisible to other packages encapsulated in
    the component. Java doesn&#x2019;t have a clear sense of component
    boundaries.</para>

    <para id="para_scala_provides_several_mechani">Scala provides a number of
    mechanisms that improve this situation. We have seen many of them
    already.</para>

    <sect2 id="FineGrainedVisibilityRules">
      <title>Fine-Grained Visibility Rules</title>

      <para id="para_we_saw_in_visibilityrules_">We saw in <xref linkend="VisibilityRules"/> that Scala provides more fine-grained
      visibility rules than most other languages. You can control the
      visibility of types and methods outside type and package
      boundaries.<indexterm>
          <primary>components</primary>

          <secondary>fine-grained visibility rules in Scala</secondary>
        </indexterm><indexterm>
          <primary>visibility</primary>

          <secondary>fine-grained visibility rules in Scala</secondary>
        </indexterm></para>

      <para id="para_consider_the_following_encodedstring_component">Consider
      the following example of a component in package
      <literal>encodedstring</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/encoded-string.scala

package encodedstring {

  trait EncodedString {
    protected[encodedstring] val string: String
    val separator: EncodedString.Separator.Delimiter

    override def toString = string

    def toTokens = string.split(separator.toString).toList
  }

  object EncodedString {
    object Separator extends Enumeration {
      type Delimiter = Value
      val COMMA = Value(",")
      val TAB   = Value("\t")
    }

    def apply(s: String, sep: Separator.Delimiter) = sep match {
      case Separator.COMMA =&gt; impl.CSV(s)
      case Separator.TAB   =&gt; impl.TSV(s)
    }

    def unapply(es: EncodedString) = Some(Pair(es.string, es.separator))
  }

  package impl {
    private[encodedstring] case class CSV(override val string: String)
        extends EncodedString {
      override val separator = EncodedString.Separator.COMMA
    }

    private[encodedstring] case class TSV(override val string: String)
        extends EncodedString {
      override val separator = EncodedString.Separator.TAB
    }
  }
}</programlisting>

      <para id="para_encapsulates_encoded_strings">This example encapsulates
      handling of strings encoding comma-separated values (CSVs) or
      tab-separated values (TSVs). The <literal>encodedstring</literal>
      package exposes a trait <literal>EncodedString</literal> that is visible
      to clients. The concrete classes implementing CSVs and TSVs are declared
      <literal>private[encodedstring]</literal> in the
      <literal>encodedstring.impl</literal> package. The trait defines two
      abstract <literal>val</literal> fields: one to hold the encoded
      <literal>string</literal>, which is protected from client access, and
      the other to hold the <literal>separator</literal> (e.g., a comma).
      Recall from <xref linkend="AdvancedObjectOrientedProgramming"/> that
      abstract fields, like abstract types and methods, must be initialized in
      concrete instances. In this case, <literal>string</literal> will be
      defined through a concrete constructor, and the
      <literal>separator</literal> is defined explicitly in the concrete
      classes, <literal>CSV</literal> and <literal>TSV</literal>.</para>

      <para id="para_the_tostring_method_on_enco">The
      <literal>toString</literal> method on <literal>EncodedString</literal>
      prints the string as a &#x201C;normal&#x201D; string. By hiding the
      <literal>string</literal> value and the concrete classes, we have
      complete freedom in how the string is actually stored. For example, for
      extremely large strings, we might want to split them on the delimiter
      and store the tokens in a data structure. This could save space if the
      strings are large enough and we can share tokens between strings. Also,
      we might find this storage useful for various searching, sorting, and
      other manipulation tasks. All these implementation issues are
      transparent to the client.</para>

      <para id="para_exposes_encoded_strings_abstractions">The package also
      exposes an object with an <literal>Enumeration</literal> for the known
      separators, an <literal>apply</literal> factory method to construct new
      encoded strings, and an <literal>unapply</literal> extractor method to
      decompose the encoded string into its enclosed string and the delimiter.
      In this case, the <literal>unapply</literal> method looks trivial, but
      if we stored the strings in a different way, this method could
      transparently reconstitute the original string.</para>

      <para id="para_clients_of_encoded_strings">So, clients of this component
      only know about the <literal>EncodedString</literal> abstraction and the
      enumeration representing the supported types of encoded strings. All the
      actual implementation types and details are private to the
      <literal>encodedstring</literal> package. (We put them in the same file
      for convenience, but normally you would kept them separate.) Hence, the
      boundary is clear between the exposed abstractions and the internal
      implementation details.</para>

      <para id="para_encoded_strings_script">The following script demonstrates
      the component in use:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/encoded-string-script.scala

import encodedstring._
import encodedstring.EncodedString._

def p(s: EncodedString) = {
  println("EncodedString: " + s)
  s.toTokens foreach (x =&gt; println("token: " + x))
}

val csv = EncodedString("Scala,is,great!", Separator.COMMA)
val tsv = EncodedString("Scala\tis\tgreat!", Separator.TAB)

p(csv)
p(tsv)

println( "\nExtraction:" )
List(csv, "ProgrammingScala", tsv, 3.14159) foreach {
  case EncodedString(str, delim) =&gt;
    println( "EncodedString: \"" + str + "\", delimiter: \"" + delim + "\"" )
  case s: String =&gt; println( "String: " + s )
  case x =&gt; println( "Unknown Value: " + x )
}</programlisting>

      <para id="para_encoded_strings_script_output">It produces the following
      output:</para>

      <screen>EncodedString: Scala,is,great!
token: Scala
token: is
token: great!
EncodedString: Scala    is      great!
token: Scala
token: is
token: great!

Extraction:
EncodedString: "Scala,is,great!", delimiter: ","
String: ProgrammingScala
EncodedString: "Scala   is      great!", delimiter: "   "
Unknown Value: 3.14159</screen>

      <para id="para_cant_access_CSV">However, if we try to use the
      <literal>CSV</literal> class directly, for example, we get the following
      error:</para>

      <screen>scala&gt; import encodedstring._
import encodedstring._

scala&gt; val csv = impl.CSV("comma,separated,values")
&lt;console&gt;:6: error: object CSV cannot be accessed in package encodedstring.impl
       val csv = impl.CSV("comma,separated,values")
                      ^

scala&gt;</screen>

      <para id="para_was_it_necessary_to_make_the_c">In this simple example,
      it wasn&#x2019;t essential to make the concrete types private to the component.
      However, we have a very minimal interface to clients of the component,
      and we are free to modify the implementation as we see fit with little
      risk of forcing client code modifications. A common cause of maintenance
      paralysis in mature applications is the presence of too many
      dependencies between concrete types, which become difficult to modify
      since they force changes to client code. So, for larger, more
      sophisticated components, this clear separation of abstraction from
      implementation can keep the code maintainable and reusable for a long
      time.</para>
    </sect2>

    <sect2 id="MixinComposition">
      <title>Mixin Composition</title>

      <para id="para_we_saw_in_traits_in_obje">We saw in <xref linkend="Traits"/> how traits promote mixin composition. A class can
      focus on its <emphasis>primary domain</emphasis>, and other
      responsibilities can be implemented separately in traits. When instances
      are constructed, classes and traits can be combined to compose the full
      range of required behaviors.<indexterm>
          <primary>traits</primary>

          <secondary>promotion of mixin composition</secondary>
        </indexterm><indexterm>
          <primary>mixin composition</primary>
        </indexterm></para>

      <para id="para_in_overridingabstracttypes_">For example, in <xref linkend="OverridingAbstractTypes"/>, we discussed our second version of
      the Observer Pattern:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/observer/observer2.scala

package observer

trait AbstractSubject {
  type Observer

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (notify(_))

  def notify(observer: Observer): Unit
}

trait SubjectForReceiveUpdateObservers extends AbstractSubject {
  type Observer = { def receiveUpdate(subject: Any) }

  def notify(observer: Observer): Unit = observer.receiveUpdate(this)
}

trait SubjectForFunctionalObservers extends AbstractSubject {
  type Observer = (AbstractSubject) =&gt; Unit

  def notify(observer: Observer): Unit = observer(this)
}</programlisting>

      <para id="para_we_used_this_version_to_observ">We used this version to
      observe button &#x201C;clicks&#x201D; in a UI. Let&#x2019;s revisit this implementation and
      resolve a few limitations, using our next tool for scalable
      abstractions, <emphasis>self-type annotations</emphasis> combined with
      abstract type members.<indexterm>
          <primary>abstract types</primary>

          <secondary>combined with self-type annotations</secondary>
        </indexterm><indexterm>
          <primary>self-type annotations</primary>

          <secondary>and abstract type members</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="SelfTypeAnnotationsAndAbstractTypeMembers">
      <title>Self-Type Annotations and Abstract Type Members</title>

      <para id="para_there_are_a_few_things_that_are_unsatisfying1">There are
      a few things that are unsatisfying about the implementation of
      <literal>AbstractSub&#x2060;ject</literal> in our second version of the
      Observer Pattern. The first occurs in
      <literal>SubjectForRe&#x2060;ceiveUpdateObservers</literal>, where the
      <literal>Observer</literal> type is defined to be the structural type
      <literal>{ def receiveUpdate(subject: Any) }</literal>. It would be nice
      to narrow the type of <literal role="keep-together">subject</literal> to
      something more specific than <literal>Any</literal>.</para>

      <para id="para_there_are_a_few_things_that_are_unsatisfying2">The second
      issue, which is really the same problem in a different form, occurs in
      <literal>SubjectForFunctionalObservers</literal>, where the
      <literal>Observer</literal> type is defined to be the type
      <literal>(AbstractSubject) =&gt; Unit</literal>. We would like the
      argument to the function to be something more specific than
      <literal>AbstractSubject</literal>. Perhaps this drawback wasn&#x2019;t so
      evident before, because our simple examples never needed to access
      <literal>Button</literal> state information or methods.<indexterm>
          <primary>polymorphism</primary>

          <secondary>family polymorphism</secondary>
        </indexterm><indexterm>
          <primary>family polymorphism</primary>
        </indexterm><indexterm>
          <primary>covariant specialization</primary>
        </indexterm></para>

      <para id="para_in_fact_we_expect_the_actual_">In fact, we expect the
      actual types of the subject and observer to be specialized <emphasis role="keep-together">covariantly</emphasis>. For example, when we&#x2019;re
      observing <literal>Buttons</literal>, we expect our observers to be
      specialized for <literal>Buttons</literal>, so they can access
      <literal>Button</literal> state and methods. This
      <emphasis>covariant</emphasis> specialization is sometimes called
      <emphasis>family polymorphism</emphasis> (see <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>).
      Let&#x2019;s fix our design to support this covariance.</para>

      <para id="para_to_simplify_the_example_let_s">To simplify the example,
      let&#x2019;s focus on just the <literal>receiveUpdate</literal> form of the
      <literal>Observer</literal>, which we implemented with
      <literal>SubjectForReceiveUpdateObservers</literal> before. Here is a
      reworking of our pattern, loosely following an example in <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>.
      (Note that the Scala syntax has changed somewhat since that paper was
      written.)</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/observer3-wont-compile.scala
// WON'T COMPILE

package observer

abstract class SubjectObserver {
  type S &lt;: Subject
  type O &lt;: Observer

  trait Subject {
    private var observers = List[O]()
    def addObserver(observer: O) = observers ::= observer
    def notifyObservers = observers foreach (_.receiveUpdate(this)) // ERROR
  }

  trait Observer {
    def receiveUpdate(subject: S)
  }
}</programlisting>

      <para id="para_type_and_parents">We&#x2019;ll explain the error in a minute.
      Note how the types <literal>S</literal> and <literal>O</literal> are
      declared. As we saw in <xref linkend="ParameterizedTypes"/>, the
      expression <literal>type S &lt;: Subject</literal> defines an abstract
      type <literal>S</literal> where the only allowed concrete types will be
      subtypes of <literal>Subject</literal>. The declaration of
      <literal>O</literal> is similar. To be clear, <literal>S</literal> and
      <literal>O</literal> are &#x201C;placeholders&#x201D; at this point, while
      <literal>Subject</literal> and <literal>Observer</literal> are abstract
      traits defined in <literal>SubjectObserver</literal>.</para>

      <para id="para_subjectobserver_as_abstract_class_or_trait">By the way,
      declaring <literal>SubjectObserver</literal> as an abstract class versus
      a trait is somewhat arbitrary. We&#x2019;ll derive concrete objects from it
      shortly. We need <literal>SubjectObserver</literal> primarily so we have
      a type to &#x201C;hold&#x201D; our abstract type members <literal>S</literal> and
      <literal>O</literal>.</para>

      <para id="para_if_you_attempt_to_compile_this">However, if you attempt
      to compile this code as currently written, you get the following
      error:</para>

      <screen>... 10: error: type mismatch;
 found   : SubjectObserver.this.Subject
 required: SubjectObserver.this.S
      def notifyObservers = observers foreach (_.receiveUpdate(this))
                                                               ^
one error found</screen>

      <para id="para_in_the_nested_observer_trait">In the nested
      <literal>Observer</literal> trait, <literal>receiveUpdate</literal> is
      expecting an instance of type <literal>S</literal>, but we are passing
      it <literal>this</literal>, which is of type <literal>Subject</literal>.
      In other words, we are passing an instance of a parent type of the type
      expected. One solution would be to change the signature to just expect
      the parent type, <literal>Subject</literal>. That&#x2019;s undesirable. We just
      mentioned that our concrete observers need the more specific type, the
      actual concrete type we&#x2019;ll eventually define for <literal>S</literal>,
      so they can call methods on it. For example, when observing UI <literal role="keep-together">CheckBoxes</literal>, the observers will want to
      read whether or not a box is checked. We don&#x2019;t want to force the
      observers to use unsafe casts.</para>

      <para id="para_a__self_type_annotation__ode">We looked at composition
      using <emphasis>self-type annotations</emphasis> in <xref linkend="SelfTypeAnnotations"/>. Let&#x2019;s use this feature now to solve
      our current compilation problem. Here is the same code again with a
      self-type annotation:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/observer3.scala

package observer

abstract class SubjectObserver {
  type S &lt;: Subject
  type O &lt;: Observer

  trait Subject {
    self: S =&gt;    // #1
    private var observers = List[O]()
    def addObserver(observer: O) = observers ::= observer
    def notifyObservers = observers foreach (_.receiveUpdate(self))  // #2
  }

  trait Observer {
    def receiveUpdate(subject: S)
  }
}</programlisting>

      <para id="para_comment_1_shows_the_self_type">Comment #1 shows the
      self-type annotation, <literal>self: S =&gt;</literal>. We can now use
      <literal>self</literal> as an alias for <literal>this</literal>, but
      whenever it appears, the type will be assumed to be
      <literal>S</literal>, not <literal>Subject</literal>. It is as if we&#x2019;re
      telling <literal>Subject</literal> to impersonate another type, but in a
      type-safe way, as we&#x2019;ll see.<indexterm>
          <primary>this keyword</primary>

          <secondary>self versus, in self-type annotations</secondary>
        </indexterm></para>

      <para id="para_actually_we_could_have_used_">Actually, we could have
      used <literal>this</literal> instead of <literal>self</literal> in the
      annotation, but <literal>self</literal> is somewhat conventional. A
      different name also reminds us that we&#x2019;re working with a different
      type.</para>

      <para id="para_when_an_actual_concrete_subje">Are self-type annotations
      a safe thing to use? When an actual concrete <literal role="keep-together">SubjectOb&#x2060;server</literal> is defined,
      <literal>S</literal> and <literal>O</literal> will be specified and type
      checking will be performed to ensure that the concrete
      <literal>S</literal> and <literal>O</literal> are compatible with
      <literal>Subject</literal> and <literal>Observer</literal>. In this
      case, because we also defined <literal>S</literal> to be a subtype of
      <literal>Subject</literal> and <literal>O</literal> to be a subtype of
      <literal>Observer</literal>, any concrete types derived from
      <literal>Subject</literal> and <literal>Observer</literal>,
      respectively, will work.</para>

      <para id="para_comment_2_shows_that_we_now_p">Comment #2 shows that we
      pass <literal>self</literal> instead of <literal>this</literal> to
      <literal>receiveUpdate</literal>.</para>

      <para id="para_to_be_continued_">Now that we have a generic
      implementation of the pattern, let&#x2019;s specialize it for observing button
      clicks:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/button-observer3.scala

package ui
import observer._

object ButtonSubjectObserver extends SubjectObserver {
  type S = ObservableButton
  type O = ButtonObserver

  class ObservableButton(name: String) extends Button(name) with Subject {
    override def click() = {
      super.click()
      notifyObservers
    }
  }

  trait ButtonObserver extends Observer {
    def receiveUpdate(button: ObservableButton)
  }
}</programlisting>

      <para id="para_we_declare_an_object_buttonsubjectobserver">We declare an
      object <literal>ButtonSubjectObserver</literal> where we define
      <literal>S</literal> and <literal>O</literal> to be
      <literal>ObservableButton</literal> and
      <literal>ButtonObserver</literal>, respectively, both of which are
      defined in the object. We use an <literal>object</literal> now so that
      we can refer to the nested types easily, as we&#x2019;ll see shortly.</para>

      <para id="para_observablebutton_is_a_concrete_class"><literal>ObservableButton</literal>
      is a concrete class that overrides <literal>click</literal> to notify
      observers, similar to our previous implementations in <xref linkend="Traits"/>. However, <literal>ButtonObserver</literal> is still
      an abstract trait, because <literal>receiveUpdate</literal> is not
      defined. Notice that the argument to <literal role="keep-together">receiveUpdate</literal> is now an
      <literal>ObservableButton</literal>, the value assigned to
      <literal>S</literal>.</para>

      <para id="para_the_final_piece_of_the_puzzle_">The final piece of the
      puzzle is to define a concrete observer. As before, we&#x2019;ll count button
      clicks. However, to emphasize the value of having the specific type of
      instance passed to the observer, a <literal>Button</literal> in this
      case, we&#x2019;ll enhance the observer to track clicks for multiple buttons
      using a hash map with the button labels as the keys. No type casts are
      required!</para>

      <screen>// code-examples/AppDesign/abstractions/button-click-observer3.scala

package ui
import observer._

class ButtonClickObserver extends ButtonSubjectObserver.ButtonObserver {
  val clicks = new scala.collection.mutable.HashMap[String,Int]()

  def receiveUpdate(button: ButtonSubjectObserver.ObservableButton) = {
    val count = clicks.getOrElse(button.label, 0) + 1
    clicks.update(button.label, count)
  }
}</screen>

      <para id="para_every_time_buttonclickobserve">Every time
      <literal>ButtonClickObserver.receiveUpdate</literal> is called, it
      fetches the current count for the button, if any, and updates the map
      with an incremented count. Note that it is now impossible to call
      <literal>receiveUpdate</literal> with a normal
      <literal>Button</literal>. We have to use an <literal role="keep-together">ObservableButton</literal>. This restriction
      eliminates bugs where we don&#x2019;t get the notifications we expected. We
      also have access to any &#x201C;enhanced&#x201D; features that
      <literal>ObservableButton</literal> may have.</para>

      <para id="para_finally_here_is_a_specificati">Finally, here is a
      specification that exercises the code:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/button-observer3-spec.scala

package ui
import org.specs._
import observer._
<?dbfo-need height="1in"
?>
object ButtonObserver3Spec extends Specification {
  "An Observer counting button clicks" should {
    "see all clicks" in {
      val button1 = new ButtonSubjectObserver.ObservableButton("button1")
      val button2 = new ButtonSubjectObserver.ObservableButton("button2")
      val button3 = new ButtonSubjectObserver.ObservableButton("button3")
      val buttonObserver = new ButtonClickObserver
      button1.addObserver(buttonObserver)
      button2.addObserver(buttonObserver)
      button3.addObserver(buttonObserver)
      clickButton(button1, 1)
      clickButton(button2, 2)
      clickButton(button3, 3)
      buttonObserver.clicks("button1") mustEqual 1
      buttonObserver.clicks("button2") mustEqual 2
      buttonObserver.clicks("button3") mustEqual 3
    }
  }

  def clickButton(button: Button, nClicks: Int) =
    for (i &lt;- 1 to nClicks)
      button.click()
}</programlisting>

      <para id="para_we_create_three_buttons_and_on">We create three buttons
      and one observer for all of them. We then click the buttons different
      numbers of times. Finally, we confirm that the clicks were properly
      counted for each button.</para>

      <para id="para_abstract_types_and_self_types_conclusion_">We see again
      how abstract types combined with self-type annotations provide a
      reusable abstraction that is easy to extend in a type-safe way for
      particular needs. Even though we defined a general protocol for
      observing an &#x201C;event&#x201D; after it happened, we were able to define subtypes
      specific to <literal>Buttons</literal> without resorting to unsafe casts
      from <literal>Subject</literal> abstractions.</para>

      <para id="para_modular_scala_compiler">The Scala compiler itself is
      implemented using these mechanisms (see <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>) to make it modular in
      useful ways. For example, it is relatively straightforward to implement
      compiler plugins.</para>

      <para id="para_revisit_in_di">We&#x2019;ll revisit these idioms in <xref linkend="DependencyInjectionInScala"/>.<indexterm class="endofrange" startref="ch13_components"/></para>
    </sect2>
  </sect1>

  <sect1 id="EffectiveTraitsDesign">
    <title>Effective Design of Traits</title>

    <para id="para_one_of_the_reasons_that_java_d">One of the reasons that
    many languages (like Java) do not implement multiple inheritance is
    because of the problems observed with multiple inheritance in C++. One of
    those problems is the so-called <emphasis>diamond of death</emphasis>,
    which is illustrated in <xref linkend="diamond-of-death"/>.<indexterm>
        <primary>C++</primary>

        <secondary>multiple inheritance</secondary>
      </indexterm><indexterm>
        <primary>inheritance</primary>

        <secondary>multiple, problems with</secondary>
      </indexterm><indexterm>
        <primary>diamond of death (problem with multiple
        inheritance)</primary>
      </indexterm><indexterm class="startofrange" id="ch13_appdesigntraits">
        <primary>application design</primary>

        <secondary>effective trait design</secondary>
      </indexterm><indexterm class="startofrange" id="ch13_traitseffective">
        <primary>traits</primary>

        <secondary>effective design of</secondary>
      </indexterm></para>

    <figure float="none" id="diamond-of-death">
      <title>Diamond of death in languages with multiple inheritance</title>

      <mediaobject>
        <imageobject role="print">
          <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1301.pdf" format="PDF"/>
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1301.png" format="PNG"/>
        </imageobject>
      </mediaobject>
    </figure>

    <para id="para_in_c_each_constructor_for_">In C++, each constructor for
    <literal>C</literal> will invoke a constructor for <literal>B1</literal>
    and a constructor for <literal>B2</literal> (explicitly or implicitly).
    Each constructor for <literal>B1</literal> and <literal>B2</literal> will
    invoke a constructor for <literal>A</literal>. Hence, in a
    <emphasis>na&#xEF;ve</emphasis> implementation of multiple inheritance, the
    fields of <literal>A</literal>, <literal>a1</literal> and
    <literal>a2</literal>, could be initialized <emphasis>twice</emphasis> and
    possibly initialized in an inconsistent way or there might be two
    different <literal>A</literal> &#x201C;pieces&#x201D; in the <literal>C</literal>
    instance, one for <literal>B1</literal> and one for <literal>B2</literal>!
    C++ has mechanisms to clarify what should happen, but it&#x2019;s up to the
    developer to understand the details and to do the correct thing.</para>

    <para id="para_scala_s_single_inheritance_wit">Scala&#x2019;s single inheritance
    and support for traits avoid these problems, while providing the most
    important benefit of multiple inheritance: <emphasis>mixin</emphasis>
    composition. The order of construction is unambiguous (see <xref linkend="Linearization"/>). Traits can&#x2019;t have constructor argument lists,
    but Scala ensures that their fields are properly initialized when
    instances are created, as we saw in <xref linkend="ConstructingTraits"/>
    and <xref linkend="OverridingFieldsInTraits"/>. We saw another example of
    initializing <literal>vals</literal> in a trait in <xref linkend="FineGrainedVisibilityRules"/>. There we defined concrete classes
    that overrode the definitions of the two abstract fields in the
    <literal>EncodedString</literal> trait.<indexterm>
        <primary>inheritance</primary>

        <secondary>single inheritance plus traits in Scala</secondary>
      </indexterm><indexterm>
        <primary>mixin composition</primary>
      </indexterm></para>

    <para id="para_however_since_a_trait_can_con">So, Scala handles many
    potential issues that arise when mixing the contributions of different
    traits into the set of possible states of an instance. Still, it&#x2019;s
    important to consider how the contributions of different traits interact
    with each other.</para>

    <para id="para_when_considering_the_state_of_">When considering the state
    of an instance, it is useful to consider the instance as possessing a
    <emphasis>state machine</emphasis>, where <emphasis>events</emphasis>
    (e.g., method calls and field writes) cause transitions from one state to
    another. The set of all possible states form a <emphasis>space</emphasis>.
    You can think of each <emphasis>field</emphasis> as contributing one
    <emphasis>dimension</emphasis> to this space.</para>

    <para id="para_for_example_recall_our_vetoa">For example, recall our
    <literal>VetoableClicks</literal> trait in <xref linkend="StackableTraits"/>, where button clicks were counted and
    additional clicks were vetoed after a certain number of clicks occurred.
    Our simple <literal>Button</literal> class contributed only a
    <literal>label</literal> dimension, while
    <literal>VetoableClicks</literal> contributed a <literal>count</literal>
    dimension and a <literal>maxAllowed</literal> constant. Here is a recap of
    these types, collected together into a single script that also exercises
    the code:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/vetoable-clicks1-script.scala

trait Clickable {
  def click()
}

class Widget
class Button(val label: String) extends Widget with Clickable {
  def click() = println("click!")
}

trait VetoableClicks extends Clickable {
  val maxAllowed = 1
  private var count = 0
  abstract override def click() = {
    if (count &lt; maxAllowed) {
      count += 1
      super.click()
    }
  }
}

val button1 = new Button("click me!")
println("new Button(...)")
for (i &lt;- 1 to 3 ) button1.click()

val button2 = new Button("click me!") with VetoableClicks
println("new Button(...) with VetoableClicks")
for (i &lt;- 1 to 3 ) button2.click()</programlisting>

    <para id="ui2-vetoable-clicks-recap-output">This script prints the
    following output:</para>

    <screen>new Button(...)
click!
click!
click!
new Button(...) with VetoableClicks
click!</screen>

    <para id="para_maxallowed_is_a_constant">Note that
    <literal>maxAllowed</literal> is a constant, but it can be overridden when
    instantiating each instance. So, two instances could differ only by the
    value of <literal>maxAllowed</literal>. Therefore,
    <literal>maxAllowed</literal> also contributes a dimension to the state,
    but with only one value per <phrase role="keep-together">instance</phrase>!</para>

    <para id="para_so_for_a_button_labeled_sub">So, for a button labeled
    &#x201C;Submit,&#x201D; with <literal>maxAllowed</literal> set to 3, and which has been
    clicked twice (so <literal>count</literal> equals 2), its state can be
    represented by the tuple <literal>("Submit", 2, 3)</literal>.</para>

    <para id="para_in_general_a_single_trait_can">In general, a single trait
    can either be stateless, i.e., it contributes no new dimensions of state
    to the instance, or it can contribute <emphasis>orthogonal</emphasis>
    state dimensions to the instance, i.e., dimensions that are independent of
    the state contributions from other traits and the parent class. In the
    script, <literal>Clickable</literal> is trivially stateless (ignoring the
    button&#x2019;s label), while <literal>VetoableClicks</literal> contributes
    <literal>maxAllowed</literal> and <literal>count</literal>. Traits with
    orthogonal state often have orthogonal methods, too. For example, the
    Observer Pattern traits we used in <xref linkend="Traits"/> contained
    methods for managing their lists of observers.</para>

    <para id="para_independent_of_these_two_possi">Independent of whether a
    trait contributes state dimensions, a trait can also modify the possible
    values for a dimension contributed by a different trait or the parent
    class. To see an example, let&#x2019;s refactor the script to move the click
    <literal>count</literal> to the <literal role="keep-together">Clickable</literal> trait:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/vetoable-clicks2-script.scala

trait Clickable {
  private var clicks = 0
  def count = clicks

  def click() = { clicks += 1 }
}

class Widget
class Button(val label: String) extends Widget with Clickable {
  override def click() = {
    super.click()
    println("click!")
  }
}

trait VetoableClicks extends Clickable {
  val maxAllowed = 1
  abstract override def click() = {
    if (count &lt; maxAllowed)
      super.click()
  }
}

val button1 = new Button("click me!")
println("new Button(...)")
for (i &lt;- 1 to 3 ) button1.click()

val button2 = new Button("click me!") with VetoableClicks
println("new Button(...) with VetoableClicks")
for (i &lt;- 1 to 3 ) button2.click()</programlisting>

    <para id="para_now_clickable_contributes_th">This script prints the same
    output as before. Now <literal>Clickable</literal> contributes one state
    dimension for <literal>count</literal> (which is now a method that returns
    the value of the private <literal>clicks</literal> field).
    <literal>VetoableClicks</literal> <emphasis>modifies</emphasis> this
    dimension by reducing the number of possible values for
    <literal>count</literal> from <literal>0</literal> to infinity down to
    just <literal>0</literal> and <literal>1</literal>. Therefore, one trait
    affects the <emphasis>behavior</emphasis> of another. We might say that
    <literal>VetoableClicks</literal> is <emphasis>invasive</emphasis>,
    because it changes the behavior of other mixins.<indexterm>
        <primary>mixins</primary>

        <secondary>invasive</secondary>
      </indexterm></para>

    <para id="para_why_is_all_this_important_whi">Why is all this important?
    While the problems of multiple-inheritance are eliminated in Scala&#x2019;s model
    of single inheritance plus traits, care is required when mixing state and
    behavior contributions to create well-behaved applications. For example,
    if you have a test suite that <literal>Button</literal> passes, will a
    <literal>Button with VetoableClicks</literal> instance pass the same test
    suite? The suite won&#x2019;t pass if it assumes that you can click a button as
    many times as you want. There are different &#x201C;specifications&#x201D; for these two
    kinds of buttons. This difference is expressed by the <emphasis>Liskov
    Substitution Principle</emphasis> (see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>). An instance of a
    <literal>Button with VetoableClicks</literal> won&#x2019;t be
    <emphasis>substitutable</emphasis> in every situation where a regular
    <literal>Button</literal> instance is used. This is a consequence of the
    invasive nature of <literal role="keep-together">VetoableClicks</literal>.</para>

    <para id="para_similarly_orthogonal_state_an">When a trait adds only
    orthogonal state and behavior, without affecting the rest of the state and
    behavior of the instance, it makes reuse and composition much easier, as
    well as reducing the potential for bugs. The Observer Pattern
    implementations we have seen are quite reusable. The only requirement for
    reuse is to provide some &#x201C;glue&#x201D; to adapt the generic subject and observer
    traits to particular circumstances.</para>

    <para id="para_this_does_not_mean_that__invas">This does not mean that
    invasive mixins are bad, just that they should be used wisely. The
    &#x201C;vetoable events&#x201D; pattern can be very useful.<indexterm class="endofrange" startref="ch13_appdesigntraits"/><indexterm class="endofrange" startref="ch13_traitseffective"/></para>
  </sect1>

  <sect1 id="DesignPatterns">
    <title>Design Patterns</title>

    <para id="para_design_patterns_have_taken_a_b">Design patterns have taken
    a beating lately. Critics dismiss them as workarounds for missing language
    features. Indeed, some of the <emphasis>Gang of Four</emphasis> patterns
    (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>)
    are not really needed in Scala, as native features provide better
    substitutes. Other patterns are part of the language itself, so no special
    coding is needed. Of course, patterns are frequently misused, but that&#x2019;s
    not the fault of the patterns themselves.<indexterm>
        <primary>Gang of Four (GOF) patterns</primary>
      </indexterm><indexterm class="startofrange" id="ch13_designpatterns">
        <primary>design patterns</primary>
      </indexterm><indexterm class="startofrange" id="ch13_appsdesignpatterns">
        <primary>application design</primary>

        <secondary>design patterns</secondary>
      </indexterm></para>

    <para id="para_we_think_the_criticisms_often_">We think the criticisms
    often overlook an important point: the distinction between an idea and how
    it is implemented and used in a particular situation. Design patterns
    document recurring, widely useful ideas. These ideas are part of the
    <emphasis>vocabulary</emphasis> that software developers use to describe
    their designs.<indexterm>
        <primary>singleton objects</primary>

        <secondary>eliminating need for Singleton Pattern</secondary>
      </indexterm></para>

    <para id="para_pattern_ideas_language_features">Some common patterns are
    native language features in Scala, like <emphasis>singleton</emphasis>
    objects that eliminate the need for a <emphasis>Singleton
    Pattern</emphasis> (<link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>) implementation like you often
    use in Java code.</para>

    <para id="para_pattern_ideas_language_features2">The <emphasis>Iterator
    Pattern</emphasis> (<link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>) is so pervasive in programming
    that most languages include iteration mechanisms for any type that can be
    treated like a collection. For example, in Scala you can iterate through
    the characters in a <literal>String</literal> with
    <literal>foreach</literal>:<indexterm>
        <primary>Iterator Pattern</primary>
      </indexterm></para>

    <screen>"Programming Scala" foreach {c =&gt; println(c)}</screen>

    <para id="para_pattern_ideas_language_features_string_foreach">Actually,
    in this case, an implicit conversion is invoked to convert the
    <literal>java.lang.String</literal> to a <literal>RichString</literal>,
    which has the <literal>foreach</literal> method. That&#x2019;s an example of the
    pattern called <emphasis>Pimp My Library</emphasis>, which we saw in <xref linkend="ImplicitConversions"/>.</para>

    <para id="para_pattern_ideas_language_better_alternatives">Other common
    patterns have better alternatives in Scala. We&#x2019;ll discuss a better
    alternative to the <emphasis>Visitor Pattern</emphasis> (<link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>) in a
    moment.</para>

    <para id="para_other_patterns_useful">Finally, still other patterns can be
    implemented in Scala and remain very useful. For example, the
    <emphasis>Observer Pattern</emphasis> that we discussed earlier in this
    chapter and in <xref linkend="Traits"/> is a very useful pattern for many
    design problems. It can be implemented very elegantly using mixin
    composition.<indexterm>
        <primary>Observer Pattern</primary>
      </indexterm></para>

    <para id="para_wont_discuss_all_patterns">We won&#x2019;t discuss all the well
    known patterns, such as those in <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>. A number of the GOF patterns
    are discussed at <link linkend="ScalaWikiPatterns" xrefstyle="select:nopage">[ScalaWiki:Patterns]</link>, along with other
    patterns that are somewhat specific to Scala. Instead, we&#x2019;ll discuss a few
    illustrative examples. We&#x2019;ll start by discussing a replacement for the
    <emphasis>Visitor Pattern</emphasis> that uses functional <phrase role="keep-together">idioms</phrase> and implicit conversions. Then we&#x2019;ll
    discuss a powerful way of implementing <emphasis>dependency
    injection</emphasis> in Scala using the <emphasis>Cake
    Pattern</emphasis>.</para>

    <sect2 id="VisitorAlternativeInScala">
      <title>The Visitor Pattern: A Better Alternative</title>

      <para id="para_visitor_pattern_description">The Visitor Pattern solves
      the problem of adding a new operation to a class hierarchy without
      editing the source code for the classes in the hierarchy. For a number
      of practical reasons, it may not be feasible or desirable to edit the
      hierarchy to support the new operation.<indexterm class="startofrange" id="ch13_VisitorPattern">
          <primary>Visitor Pattern, alternative to</primary>
        </indexterm><indexterm class="startofrange" id="ch13_designpatternVisitor">
          <primary>design patterns</primary>

          <secondary>alternative to Visitor Pattern</secondary>
        </indexterm></para>

      <para id="para_let_s_look_at_an_example_of_th">Let&#x2019;s look at an example
      of the pattern using the <literal>Shape</literal> class hierarchy we
      have used previously. We&#x2019;ll start with the case class version from <xref linkend="CaseClasses"/>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-case.scala

package shapes {
  case class Point(x: Double, y: Double)

  abstract class Shape() {
    def draw(): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape() {
    def draw() = println("Circle.draw: " + this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
      extends Shape() {
    def draw() = println("Rectangle.draw: " + this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
      extends Shape() {
    def draw() = println("Triangle.draw: " + this)
  }
}</programlisting>

      <para id="para_suppose_we_don_t_want_the_dra">Suppose we don&#x2019;t want the
      <literal>draw</literal> method in the classes. This is a reasonable
      design choice, since the drawing method will be highly dependent on the
      particular context of use, such as details of the graphics libraries on
      the platforms the application will run on. For greater reusability, we
      would like drawing to be an operation we decouple from the shapes
      themselves.</para>

      <para id="para_first_we_refactor_the_shape_">First, we refactor the
      <literal>Shape</literal> hierarchy to support the Visitor Pattern,
      following the example in <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-visitor.scala

package shapes {
  trait ShapeVisitor {
    def visit(circle: Circle): Unit
    def visit(rect: Rectangle): Unit
    def visit(tri: Triangle): Unit
  }

  case class Point(x: Double, y: Double)

  sealed abstract class Shape() {
    def accept(visitor: ShapeVisitor): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
        extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
        extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }
}</programlisting>

      <para id="para_first_we_define_a_shapevisit">We define a
      <literal>ShapeVisitor</literal> trait, which has one method for each
      concrete class in the hierarchy, e.g., <literal>visit(circle:
      Circle)</literal>. Each such method takes one parameter of the
      corresponding type to visit. Concrete derived classes will implement
      each method to do the appropriate operation for the particular type
      passed in.</para>

      <para id="para_the_visitor_pattern_requires_a">The Visitor Pattern
      requires a one-time modification to the class hierarchy. An overridden
      method named <literal>accept</literal> must be added, which takes a
      <literal>Visitor</literal> parameter. This method must be overridden for
      each class. It calls the corresponding method defined on the
      <literal>visitor</literal> instance, passing <literal>this</literal> as
      the argument.</para>

      <para id="para_finally_note_that_we_declared">Finally, note that we
      declared <literal>Shape</literal> to be <literal>sealed</literal>. It
      won&#x2019;t help us prevent some bugs in the Visitor Pattern implementation,
      but it will prove useful shortly.</para>

      <para id="para_here_is_a_concrete_visitor_tha">Here is a concrete
      visitor that supports our original <literal>draw</literal>
      operation:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-visitor.scala

package shapes {
  class ShapeDrawingVisitor extends ShapeVisitor {
    def visit(circle: Circle): Unit =
      println("Circle.draw: " + circle)

    def visit(rect: Rectangle): Unit =
      println("Rectangle.draw: " + rect)

    def visit(tri: Triangle): Unit =
      println("Triangle.draw: " + tri)
  }
}</programlisting>

      <para id="para_for_each_visitx_method_it_">For each
      <literal>visit</literal> method, it &#x201C;draws&#x201D; the <literal>Shape</literal>
      instance appropriately. Finally, here is a script that exercises the
      code:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-visitor-script.scala

import shapes._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

val shapesDrawer = new ShapeDrawingVisitor
list foreach { _.accept(shapesDrawer) }</programlisting>

      <para id="shape-hier-draw-visitor-script-output">It produces the
      following output:</para>

      <screen>Circle.draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</screen>

      <para id="para_visitor_has_been_criticized_fo">Visitor has been
      criticized for being somewhat inelegant and for breaking the
      <emphasis>Open-Closed Principle</emphasis> (OCP; see <link linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>),
      because if the hierarchy changes, you are forced to edit (and test and
      redeploy) <emphasis>all</emphasis> the visitors for that hierarchy. Note
      that every <literal>ShapeVisitor</literal> trait has methods that
      hardcode information about every <literal>Shape</literal> derived type.
      These kinds of changes are also error-prone.<indexterm>
          <primary>Open-Closed Principle (OCP)</primary>

          <secondary>violation by Visitor Pattern</secondary>
        </indexterm></para>

      <para id="para_visitor_pattern_alt_ruby_open_types">In languages with
      &#x201C;open types,&#x201D; like Ruby, an alternative to the Visitor Pattern is to
      create a new source file that reopens all the types in the hierarchy and
      inserts an appropriate method implementation in each one. No
      modifications to the original source code are required.</para>

      <para id="para_scala_does_not_support_open_ty">Scala does not support
      open types, of course, but it offers a few alternatives. The first
      approach we&#x2019;ll discuss combines pattern matching with implicit
      conversions. Let&#x2019;s begin by refactoring the
      <literal>ShapeVisitor</literal> code to remove the Visitor Pattern
      logic:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes.scala

package shapes2 {
  case class Point(x: Double, y: Double)

  sealed abstract class Shape()

  case class Circle(center: Point, radius: Double) extends Shape()

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
      extends Shape()

  case class Triangle(point1: Point, point2: Point, point3: Point)
      extends Shape()
}</programlisting>

      <para id="para_if_we_would_like_to_invoke_dr">If we would like to invoke
      <literal>draw</literal> as a method on any <literal>Shape</literal>,
      then we will have to use an implicit conversion to a wrapper class with
      the <literal>draw</literal> method:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-implicit.scala

package shapes2 {
  class ShapeDrawer(val shape: Shape) {
    def draw = shape match {
      case c: Circle    =&gt; println("Circle.draw: " + c)
      case r: Rectangle =&gt; println("Rectangle.draw: " + r)
      case t: Triangle  =&gt; println("Triangle.draw: " + t)
    }
  }

  object ShapeDrawer {
    implicit def shape2ShapeDrawer(shape: Shape) = new ShapeDrawer(shape)
  }
}</programlisting>

      <para id="para_instances_of_shapedrawer_hol">Instances of
      <literal>ShapeDrawer</literal> hold a <literal>Shape</literal> object.
      When <literal>draw</literal> is called, the shape is pattern matched
      based on its type to determine the appropriate way to draw it.</para>

      <para id="para_a_companion_object_declares_an">A companion object
      declares an implicit conversion that wraps a <literal>Shape</literal> in
      a <literal>ShapeDrawer</literal>.</para>

      <para id="para_implicit_script_exercises_code">This script exercises the
      code:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-implicit-script.scala

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

import shapes2.ShapeDrawer._

list foreach { _.draw }</programlisting>

      <para id="para_same_output_as_visitor">It produces the same output as
      the example using the Visitor Pattern.</para>

      <para id="para_this_implementation_shares_a_l">This implementation of
      <literal>ShapeDrawer</literal> has some similarities with the Visitor
      Pattern, but it is more concise, elegant, and requires no code
      modifications to the original <literal>Shape</literal> hierarchy.</para>

      <para id="para_the_implementation_of_shapedr">Technically, the
      implementation has the same OCP issue as the Visitor Pattern. Changing
      the <literal>Shape</literal> hierarchy requires a change to the pattern
      matching expression. However, the required changes are isolated to one
      place and they are more succinct. In fact, all the logic for drawing is
      now contained in one place, rather than separated into
      <literal>draw</literal> methods in each <literal>Shape</literal> class
      and potentially scattered across different files. Note that because we
      <literal>sealed</literal> the hierarchy, a compilation error in
      <literal>draw</literal> will occur if we forget to change it when the
      hierarchy changes.</para>

      <para id="para_if_we_don_t_like_the_pattern_m">If we don&#x2019;t like the
      pattern matching in the draw method, we could implement a separate
      &#x201C;drawer&#x201D; class and a separate implicit conversion for each
      <literal>Shape</literal> class. That would allow us to keep each shape
      drawing operation in a separate file, for modularity, with the drawback
      of more code and files to manage.</para>

      <para id="para_if_on_the_other_hand_we_don_">If, on the other hand, we
      don&#x2019;t care about using the object-oriented <literal>shape.draw</literal>
      syntax, we could eliminate the implicit conversion and do the same
      pattern matching that is done in <literal>ShapeDrawer.draw</literal>.
      This approach could be simpler, especially when the extra behavior can
      be isolated to one place. Indeed, this approach would be a conventional
      functional approach, as illustrated in the following script:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-pattern-script.scala

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

val drawText = (shape:Shape) =&gt; shape match {
  case circle: Circle =&gt;  println("Circle.draw: " + circle)
  case rect: Rectangle =&gt; println("Rectangle.draw: " + rect)
  case tri: Triangle =&gt;   println("Triangle.draw: " + tri)
}

def pointToXML(point: Point) =
  "&lt;point&gt;&lt;x&gt;%.1f&lt;/x&gt;&lt;y&gt;%.1f&lt;/y&gt;&lt;/point&gt;".format(point.x, point.y)

val drawXML = (shape:Shape) =&gt; shape match {
  case circle: Circle =&gt;  {
    println("&lt;circle&gt;")
    println("  &lt;center&gt;" + pointToXML(circle.center) + "&lt;/center&gt;")
    println("  &lt;radius&gt;" + circle.radius + "&lt;/radius&gt;")
    println("&lt;/circle&gt;")
  }
  case rect: Rectangle =&gt; {
    println("&lt;rectangle&gt;")
    println("  &lt;lower-left&gt;" + pointToXML(rect.lowerLeft) + "&lt;/lower-left&gt;")
    println("  &lt;height&gt;" + rect.height + "&lt;/height&gt;")
    println("  &lt;width&gt;" + rect.width + "&lt;/width&gt;")
    println("&lt;/rectangle&gt;")
  }
  case tri: Triangle =&gt; {
    println("&lt;triangle&gt;")
    println("  &lt;point1&gt;" + pointToXML(tri.point1) + "&lt;/point1&gt;")
    println("  &lt;point2&gt;" + pointToXML(tri.point2) + "&lt;/point2&gt;")
    println("  &lt;point3&gt;" + pointToXML(tri.point3) + "&lt;/point3&gt;")
    println("&lt;/triangle&gt;")
  }
}

list foreach (drawText)
println("")
list foreach (drawXML)</programlisting>

      <para id="para_we_define_to__function_values_">We define two
      <emphasis>function values</emphasis> and assign them to variables,
      <literal>drawText</literal> and <literal>drawXML</literal>,
      respectively. Each <literal>drawX</literal> function takes an input
      <literal>Shape</literal>, pattern matches it to the correct type, and
      &#x201C;draws&#x201D; it appropriately. We also define a helper method to convert a
      <literal>Point</literal> to XML in the format we want.</para>

      <para id="para_finally_we_loop_through_the_l">Finally, we loop through
      the list of shapes twice. The first time, we pass
      <literal>drawText</literal> as the argument to
      <literal>foreach</literal>. The second time, we pass
      <literal>drawXML</literal>. Running this script reproduces the previous
      results for &#x201C;text&#x201D; output, followed by new XML output:</para>

      <screen>Circle.draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

&lt;circle&gt;
  &lt;center&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/center&gt;
  &lt;radius&gt;5.0&lt;/radius&gt;
&lt;/circle&gt;
&lt;rectangle&gt;
  &lt;lower-left&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/lower-left&gt;
  &lt;height&gt;2.0&lt;/height&gt;
  &lt;width&gt;3.0&lt;/width&gt;
&lt;/rectangle&gt;
&lt;triangle&gt;
  &lt;point1&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point1&gt;
  &lt;point2&gt;&lt;point&gt;&lt;x&gt;1.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point2&gt;
  &lt;point3&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;1.0&lt;/y&gt;&lt;/point&gt;&lt;/point3&gt;
&lt;/triangle&gt;</screen>

      <para id="para_this_is_a_powerful_way_to_add_">Any of these idioms
      provides a powerful way to add additional, special-purpose functionality
      that may not be needed &#x201C;everywhere&#x201D; in the application. It&#x2019;s a great way
      to remove methods from objects that don&#x2019;t <emphasis>absolutely have to
      be there</emphasis>.</para>

      <para id="para_a_drawing_application_should_o">A drawing application
      should only need to know how to do input and output of shapes in one
      place, whether it is serializing shapes to a textual format for storage
      or rendering shapes to the screen. We can separate the drawing &#x201C;concern&#x201D;
      from the rest of the <phrase role="keep-together">functionality</phrase>
      for shapes, and we can isolate the logic for drawing, all without
      modifying the <literal>Shape</literal> hierarchy or any of the places
      where it is used in the application. The Visitor Pattern gives us some
      of this separation and isolation, but we are required to add visitor
      implementation logic to each <literal>Shape</literal>.</para>

      <para id="para_let_s_conclude_with_a_discussi">Let&#x2019;s conclude with a
      discussion of one other option that may be applicable in some contexts.
      If you have complete control over how shapes are constructed, e.g.,
      through a single factory, you can modify the factory to mix in traits
      that add new behaviors as needed:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-factory.scala

package shapes2 {
  trait Drawing {
    def draw: Unit
  }

  trait CircleDrawing extends Drawing {
    def draw = println("Circle.draw " + this)
  }
  trait RectangleDrawing extends Drawing {
    def draw = println("Rectangle.draw: " + this)
  }
  trait TriangleDrawing extends Drawing {
    def draw = println("Triangle.draw: " + this)
  }

  object ShapeFactory {
    def makeShape(args: Any*) = args(0) match {
      case "circle" =&gt; {
        val center = args(1).asInstanceOf[Point]
        val radius = args(2).asInstanceOf[Double]
        new Circle(center, radius) with CircleDrawing
      }
      case "rectangle" =&gt; {
        val lowerLeft = args(1).asInstanceOf[Point]
        val height    = args(2).asInstanceOf[Double]
        val width     = args(3).asInstanceOf[Double]
        new Rectangle(lowerLeft, height, width) with RectangleDrawing
      }
      case "triangle" =&gt; {
        val p1 = args(1).asInstanceOf[Point]
        val p2 = args(2).asInstanceOf[Point]
        val p3 = args(3).asInstanceOf[Point]
        new Triangle(p1, p2, p3) with TriangleDrawing
      }
      case x =&gt; throw new IllegalArgumentException("unknown: " + x)
    }
  }
}</programlisting>

      <para id="para_we_define_a_drawing_trait_an">We define a
      <literal>Drawing</literal> trait and concrete derived traits for each
      <literal>Shape</literal> class. Then we define a
      <literal>ShapeFactory</literal> object with a
      <literal>makeShape</literal> factory method that takes a variable-length
      list of arguments. A match is done on the first argument to determine
      which shape to make. The trailing arguments are cast to appropriate
      types to construct each shape, with the corresponding drawing trait
      mixed in. A similar factory could be written for adding draw methods
      that output XML. (The variable-length list of <literal>Any</literal>
      values, heavy use of casting, and minimal error checking were done for
      expediency. A real implementation could minimize these &#x201C;hacks.&#x201D;)</para>

      <para id="para_factory_script">The following script exercises the
      factory:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-factory-script.scala

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(
    ShapeFactory.makeShape("circle", p00, 5.0),
    ShapeFactory.makeShape("rectangle", p00, 2.0, 3.0),
    ShapeFactory.makeShape("triangle", p00, p10, p01))

list foreach { _.draw }</programlisting>

      <para id="para_factory_script_output">Compared to our previous scripts,
      the list of shapes is now constructed using the factory. When we want to
      draw the shapes in the <literal>foreach</literal> statement, we simply
      call <literal>draw</literal> on each shape. As before, the output is the
      following:</para>

      <screen>Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</screen>

      <para id="para_there_is_one_subtlety_with_thi">There is one subtlety
      with this approach that we should discuss. Notice that the script never
      assigns the result of a <literal>ShapeFactory.makeShape</literal> call
      to a <literal>Shape</literal> variable. If it did that, it would not be
      able to call <literal>draw</literal> on the instance!</para>

      <para id="para_in_this_script_scala_inferred">In this script, Scala
      inferred a slightly different common supertype for the parameterized
      list. You can see that type if you use the <literal>:load</literal>
      command to load the script while inside the interactive
      <literal>scala</literal> interpreter, as in the following
      session:</para>

      <screen>$ scala -cp ...
Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; :load design-patterns/shapes-drawing-factory-script.scala
Loading design-patterns/shapes-drawing-factory-script.scala...
import shapes2._
p00: shapes2.Point = Point(0.0,0.0)
p10: shapes2.Point = Point(1.0,0.0)
p01: shapes2.Point = Point(0.0,1.0)
list: List[Product with shapes2.Shape with shapes2.Drawing] = List(...)
Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

scala&gt;</screen>

      <para id="para_notice_the_line_that_begins_l">Notice the line that
      begins <literal>list: List[Product with shapes2.Shape with
      shapes2.Draw&#x2060;ing]</literal>. This line was printed after the list of
      shapes was parsed. The inferred common supertype is <literal>Product
      with shapes2.Shape with shapes2.Drawing</literal>.
      <literal>Product</literal> is a trait mixed into all case classes, such
      as our concrete subclasses of <literal>Shape</literal>. Recall that to
      avoid case-class inheritance, <literal>Shape</literal> itself is not a
      case class. (See <xref linkend="CaseClasses"/> for details on why case
      class inheritance should be avoided.) So, our common supertype is an
      anonymous class that incorporates <literal>Shape</literal>,
      <literal>Product</literal>, and the <literal>Drawing</literal>
      trait.<indexterm>
          <primary>case classes</primary>

          <secondary>inheritance</secondary>
        </indexterm></para>

      <para id="para_if_you_want_to_assign_one_of_t">If you want to assign one
      of these drawable shapes to a variable and still be able to invoke
      <literal>draw</literal>, use a declaration like the following (shown as
      a continuation of the same interactive <literal>scala</literal>
      session):</para>

      <screen>scala&gt; val s: Shape with Drawing = ShapeFactory.makeShape("circle", p00, 5.0)
s: shapes2.Shape with shapes2.Drawing = Circle(Point(0.0,0.0),5.0)

scala&gt; s.draw
Circle.draw Circle(Point(0.0,0.0),5.0)

scala&gt;</screen>
    </sect2>

    <sect2 id="DependencyInjectionInScala">
      <title>Dependency Injection in Scala: The Cake Pattern</title>

      <para id="para_description_of_di"><emphasis>Dependency
      injection</emphasis> (DI), a form of <emphasis>inversion of
      control</emphasis> (IoC), is a powerful technique for resolving
      dependencies between &#x201C;components&#x201D; in larger applications. It supports
      minimizing the coupling between these components, so it is relatively
      easy to substitute different components for different
      circumstances.<indexterm>
          <primary>inversion of control (IoC)</primary>
        </indexterm><indexterm class="startofrange" id="ch13_DICakePattern">
          <primary>dependency injection (DI)</primary>

          <secondary>using Cake Pattern</secondary>
        </indexterm><indexterm class="startofrange" id="ch13_designpatternCAKE">
          <primary>design patterns</primary>

          <secondary>dependency injection (DI) implementation, Cake
          Pattern</secondary>
        </indexterm><indexterm class="endofrange" startref="ch13_designpatternVisitor"/><indexterm class="endofrange" startref="ch13_VisitorPattern"/></para>

      <para id="para_it_used_to_be_that_when_a_clie">It used to be that when a
      client object needed a database &#x201C;accessor&#x201D; object, for example, it would
      just instantiate the accessor itself. While convenient, this approach
      makes unit testing very difficult because you have to test with a real
      database. It also compromises reuse, for those alternative situations
      where another persistence mechanism (or none) is required. Inversion of
      control solves this problem by reversing responsibility for satisfying
      the dependency between the object and the database connection.</para>

      <para id="para_an_example_of_ioc_is_jndi_ins">An example of IoC is JNDI.
      Instead of instantiating an accessor object, the client object asks JDNI
      to provide one. The client doesn&#x2019;t care what actual type of accessor is
      returned. Hence, the client object is no longer coupled to a concrete
      implementation of the dependency. It only depends on an appropriate
      <emphasis>abstraction</emphasis> of a persistence accessor, i.e., a Java
      interface or Scala trait.</para>

      <para id="para_dependency_injection_takes_ioc">Dependency injection
      takes IoC to its logical conclusion. Now the object does nothing to
      resolve the dependency. Instead, an external mechanism with system-wide
      knowledge &#x201C;injects&#x201D; the appropriate accessor object using a constructor
      argument or a setter method. This happens when the client is
      constructed. DI eliminates dependencies on IoC mechanisms in code (e.g.,
      no more JNDI calls) and keeps objects relatively simple, with minimal
      coupling to other objects.</para>

      <para id="para_back_to_unit_testing_it_is_pr">Back to unit testing, it
      is preferable to use a <emphasis>test double</emphasis> for heavyweight
      dependencies to minimize the overhead and other complications of
      testing. Our client object with a dependency on a database accessor
      object is a classic example. While unit testing the client, the overhead
      and complications of using a real database are prohibitive. Using a
      lightweight test double with hardcoded sample data provides simpler
      setup and tear down, faster execution, and predictable behavior from the
      data accessor dependency.</para>

      <para id="para_java_di">In Java, DI is usually done using an inversion
      of control container, like the Spring Framework (<link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link>), or a Java-API
      equivalent like Google&#x2019;s Guice API (see <link linkend="Guice" xrefstyle="select:nopage">[Guice]</link>). These options can be used
      with Scala code, especially when you are introducing Scala into a mature
      Java environment.<indexterm>
          <primary>Java</primary>

          <secondary>DI (dependency injection)</secondary>
        </indexterm></para>

      <para id="para_the_cake_pattern_">However, Scala offers some unique
      options for implementing DI in Scala code, which are discussed by <link linkend="Boner2008b" xrefstyle="select:nopage">[Bon&#xE9;r2008b]</link>.
      We&#x2019;ll discuss one of them, the <emphasis>Cake Pattern</emphasis>, which
      can replace or complement these other dependency injection mechanisms.
      We&#x2019;ll see that it is similar to the implementation of the Observer
      Pattern we discussed earlier in this chapter, in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>. The Cake Pattern
      was described by <link linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>, although it was given
      that name after that paper was published. <link linkend="Boner2008b" xrefstyle="select:nopage">[Bon&#xE9;r2008b]</link> also discusses
      alternatives.<indexterm class="startofrange" id="ch12_CakePattern">
          <primary>Cake Pattern</primary>
        </indexterm></para>

      <para id="para_let_s_build_a_simple_component">Let&#x2019;s build a simple
      component model for an overly simplified Twitter client. We want a
      configurable UI, a configurable local cache of past tweets, and a
      configurable connection to the Twitter service itself. Each of these
      &#x201C;components&#x201D; will be specified separately, along with a client component
      that will function as the &#x201C;middleware&#x201D; that ties the application
      together. The client component will depend on the other components. When
      we create a concrete client, we&#x2019;ll configure in the concrete pieces of
      the other components that we need:<indexterm class="startofrange" id="ch13_Twitterclient">
          <primary>Twitter client, component model for (example)</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/dep-injection/twitter-client.scala

package twitterclient
import java.util.Date
import java.text.DateFormat

class TwitterUserProfile(val userName: String) {
  override def toString = "@" + userName
}

case class Tweet(
  val tweeter: TwitterUserProfile,
  val message: String,
  val time: Date) {

  override def toString = "(" +
    DateFormat.getDateInstance(DateFormat.FULL).format(time) + ") " +
    tweeter + ": " + message
}

trait Tweeter {
  def tweet(message: String)
}

trait TwitterClientUIComponent {
  val ui: TwitterClientUI

  abstract class TwitterClientUI(val client: Tweeter) {
    def sendTweet(message: String) = client.tweet(message)
    def showTweet(tweet: Tweet): Unit
  }
}

trait TwitterLocalCacheComponent {
  val localCache: TwitterLocalCache

  trait TwitterLocalCache {
    def saveTweet(tweet: Tweet): Unit
    def history: List[Tweet]
  }
}

trait TwitterServiceComponent {
  val service: TwitterService

  trait TwitterService {
    def sendTweet(tweet: Tweet): Boolean
    def history: List[Tweet]
  }
}

trait TwitterClientComponent {
  self: TwitterClientUIComponent with
        TwitterLocalCacheComponent with
        TwitterServiceComponent =&gt;

  val client: TwitterClient

  class TwitterClient(val user: TwitterUserProfile) extends Tweeter {
    def tweet(msg: String) = {
      val twt = new Tweet(user, msg, new Date)
      if (service.sendTweet(twt)) {
        localCache.saveTweet(twt)
        ui.showTweet(twt)
      }
    }
  }
}</programlisting>

      <para id="para_the_first_class_twitteruserp">The first class,
      <literal>TwitterUserProfile</literal>, encapsulates a user&#x2019;s profile,
      which we limit to the username. The second class is a case class,
      <literal>Tweet</literal>, that encapsulates a single &#x201C;tweet&#x201D; (a Twitter
      message, limited to 140 characters by the Twitter service). Besides the
      message string, it encapsulates the user who sent the tweet and the date
      and time when it was sent. We made this class a case class for the
      convenient support case classes provide for creating objects and pattern
      matching on them. We didn&#x2019;t make the profile class a case class, because
      it is more likely to be used as the parent of more detailed profile
      classes.</para>

      <para id="para_next_is_the_tweeter_trait_th">Next is the
      <literal>Tweeter</literal> trait that declares one method,
      <literal>tweet</literal>. This trait is defined solely to eliminate a
      potential circular dependency between two components,
      <literal>TwitterClientComponent</literal> and
      <literal>TwitterClientUIComponent</literal>. All the components are
      defined next in the file.</para>

      <para id="para_there_are_four_components_">There are four components.
      Note that they are implemented as traits:<indexterm>
          <primary>traits</primary>

          <secondary>implementing components with</secondary>
        </indexterm><indexterm>
          <primary>components</primary>

          <secondary>implementing as traits</secondary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para><literal>TwitterClientUIComponent</literal>, for the UI</para>
        </listitem>

        <listitem>
          <para><literal>TwitterLocalCacheComponent</literal>, for the local
          cache of prior tweets</para>
        </listitem>

        <listitem>
          <para><literal>TwitterServiceComponent</literal>, for accessing the
          Twitter service</para>
        </listitem>

        <listitem>
          <para><literal>TwitterClientComponent</literal>, the client that
          pulls the pieces together</para>
        </listitem>
      </itemizedlist>

      <para id="para_they_all_have_a_similar_struct">They all have a similar
      structure. Each one declares a nested trait or class that encapsulates
      the component&#x2019;s behavior. Each one also declares a
      <literal>val</literal> with one instance of the nested type.</para>

      <para id="para_java_packages_as_components">Often in Java, packages are
      informally associated with components. This is common in other
      languages, too, using their equivalent of a package, e.g., a module or a
      namespace. Here we define a more precise notion of a component, and a
      trait is the best vehicle for it, because traits are designed for mixin
      composition.</para>

      <para id="para__twitterclientuicomponent_dec"><literal>TwitterClientUIComponent</literal>
      declares a <literal>val</literal> named <literal>ui</literal> of the
      nested type <literal>TwitterClien&#x2060;tUI</literal>. This class has a
      <literal>client</literal> field that must be initialized with a
      <literal>Tweeter</literal> instance. In fact, this instance will be a
      <literal>TwitterClient</literal> (defined in
      <literal>TwitterClientComponent</literal>), which extends
      <literal>Tweeter</literal>.</para>

      <para id="para__twitterclientui_has_two_meth"><literal>TwitterClientUI</literal>
      has two methods. The first is <literal>sendTweet</literal>, which is
      defined to call the <literal>client</literal> object. This method would
      be used by the UI to call the client when the user sends a new tweet.
      The second method, <literal>showTweet</literal>, goes the other
      direction. It is called whenever a new tweet is to be displayed, e.g.,
      from another user. It is abstract, pending the &#x201C;decision&#x201D; of the kind of
      UI to use.</para>

      <para id="para_similarly_twitterlocalcachec">Similarly,
      <literal>TwitterLocalCacheComponent</literal> declares
      <literal>TwitterLocalCache</literal> and an instance of it. Instances
      with this trait save tweets to the local persistent cache when
      <literal>saveTweet</literal> is called. You can retrieve the cached
      tweets with <literal>history</literal>.</para>

      <para id="para__twitterservicecomponent_is_v"><literal>TwitterServiceComponent</literal>
      is very similar. Its nested type has a method,
      <literal>sendTweet</literal>, that sends a new tweet to Twitter. It also
      has a <literal>history</literal> method that retrieves all the tweets
      for the current user.</para>

      <para id="para_finally_twitterclientcompone">Finally,
      <literal>TwitterClientComponent</literal> contains a concrete class,
      <literal>TwitterClient</literal>, that integrates the components. Its
      one <literal>tweet</literal> method sends new tweets to the Twitter
      service. If successful, it sends the tweet back to the UI and to the
      local persistent cache.</para>

      <para id="para__twitterclientcomponent_also_"><literal>TwitterClientComponent</literal>
      also has the following <emphasis>self-type
      annotation</emphasis>:<indexterm>
          <primary>self-type annotations</primary>

          <secondary>TwitterClientComponent (example)</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">self: TwitterClientUIComponent with
      TwitterLocalCacheComponent with
      TwitterServiceComponent =&gt;</programlisting>

      <para id="para_the_effect_of_this_declaration">The effect of this
      declaration is to say that any concrete
      <literal>TwitterClientComponent</literal> must also behave like these
      other three components, thereby composing all the components into one
      client application instance. This composition will be realized by mixing
      in these components, which are traits, when we create concrete clients,
      as we will see shortly.</para>

      <para id="para_the_self_type_annotation_also_">The self-type annotation
      also means we can reference the <literal>vals</literal> declared in
      these components. Notice how <literal>TwitterClient.tweet</literal>
      references the <literal>service</literal>,
      <literal>localCache</literal>, and the <literal>ui</literal> as if they
      are variables in the scope of this method. In fact, they
      <emphasis>are</emphasis> in scope, because of the self-type
      annotation.</para>

      <para id="para_notice_also_that_all_the_metho">Notice also that all the
      methods that call other components are concrete. Those inter-component
      relationships are fully specified. The abstractions are directed
      &#x201C;outward,&#x201D; toward the graphical user interface, a caching mechanism,
      etc.</para>

      <para id="para_let_s_now_define_a_concrete_tw">Let&#x2019;s now define a
      concrete Twitter client that uses a textual (command-line) UI, an
      in-memory local cache, and fakes the interaction with the Twitter
      service:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/dep-injection/twitter-text-client.scala

package twitterclient

class TextClient(userProfile: TwitterUserProfile)
    extends TwitterClientComponent
    with TwitterClientUIComponent
    with TwitterLocalCacheComponent
    with TwitterServiceComponent {

  // From TwitterClientComponent:

  val client = new TwitterClient(userProfile)

  // From TwitterClientUIComponent:

  val ui = new TwitterClientUI(client) {
    def showTweet(tweet: Tweet) = println(tweet)
  }

  // From TwitterLocalCacheComponent:

  val localCache = new TwitterLocalCache {
    private var tweets: List[Tweet] = Nil

    def saveTweet(tweet: Tweet) = tweets ::= tweet

    def history = tweets
  }

  // From TwitterServiceComponent

  val service = new TwitterService() {
    def sendTweet(tweet: Tweet) = {
      println("Sending tweet to Twitter HQ")
      true
    }
    def history = List[Tweet]()
  }
}</programlisting>

      <para id="para_our_textclient_concrete_clas">Our
      <literal>TextClient</literal> concrete class extends
      <literal>TwitterClientComponent</literal> and mixes in the three other
      components. By mixing in the other components, we satisfy the self-type
      annotations in <literal>TwitterClientComponent</literal>. In other
      words, <literal>TextClient</literal> <emphasis>is</emphasis> also a
      <literal>TwitterClien&#x2060;tUIComponent</literal>, a
      <literal>TwitterLocalCacheComponent</literal>, and a
      <literal>TwitterServiceComponent</literal>, in addition to being a
      <literal>TwitterClientComponent</literal>.</para>

      <para id="para_the_textclient_constructor_t">The
      <literal>TextClient</literal> constructor takes one argument, a user
      profile, which will be passed onto the nested client class.</para>

      <para id="para__textclient_has_to_define_fou"><literal>TextClient</literal>
      has to define four <literal>vals</literal>, one from
      <literal>TwitterClientComponent</literal> and three from the other
      mixins. For the <literal>client</literal>, it simply creates a new
      <literal>TwitterClient</literal>, passing it the
      <literal>userProfile</literal>.</para>

      <para id="para_for_the_ui_it_instantiates_">For the
      <literal>ui</literal>, it instantiates an anonymous class derived from
      <literal role="keep-together">TwitterClientUI</literal>. It defines
      <literal>showTweet</literal> to print out the tweet.</para>

      <para id="para_for_the_localcache_it_insta">For the
      <literal>localCache</literal>, it instantiates an anonymous class
      derived from <literal role="keep-together">TwitterLocalC&#x2060;ache</literal>.
      It keeps the history of tweets in a <literal>List</literal>.</para>

      <para id="para_finally_for_the_service_it">Finally, for the
      <literal>service</literal>, it instantiates an anonymous class derived
      from <literal role="keep-together">TwitterSer&#x2060;vice</literal>. This
      &#x201C;fake&#x201D; defines <literal>sendTweet</literal> to print out a message and
      to return an empty list for the history.</para>

      <para id="para_let_s_try_our_client_with_the_">Let&#x2019;s try our client with
      the following script:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/dep-injection/twitter-text-client-script.scala

import twitterclient._

val client = new TextClient(new TwitterUserProfile("BuckTrends"))
client.ui.sendTweet("My First Tweet. How's this thing work?")
client.ui.sendTweet("Is this thing on?")
client.ui.sendTweet("Heading to the bathroom...")
println("Chat history:")
client.localCache.history.foreach {t =&gt; println(t)}</programlisting>

      <para id="para_may_3">We instantiate a <literal>TextClient</literal> for
      the user &#x201C;BuckTrends.&#x201D; Old Buck sends three insightful tweets through
      the UI. We finish by reprinting the history of tweets, in reverse order,
      that are cached locally. Running this script yields output like the
      following:</para>

      <screen>Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: My First Tweet. How's this thing work?
Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: Is this thing on?
Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: Heading to the bathroom...
Chat history:
(Sunday, May 3, 2009) @BuckTrends: Heading to the bathroom...
(Sunday, May 3, 2009) @BuckTrends: Is this thing on?
(Sunday, May 3, 2009) @BuckTrends: My First Tweet. How's this thing work?</screen>

      <para id="para_your_date_will_vary_of_course">Your date will vary, of
      course. Recall that the <literal>Sending tweet to Twitter HQ</literal>
      line is printed by the fake service.</para>

      <para id="para_to_recap_each_major_component">To recap, each major
      component in the Twitter client was declared in its own trait, with a
      nested type for the component&#x2019;s fields and methods. The client component
      declared its dependencies on the other components through a self-type
      annotation. The concrete client class mixed in those components and
      defined each component <literal>val</literal> to be an appropriate
      subtype of the corresponding abstract classes and traits that were
      declared in the components.</para>

      <para id="para_other_di_approaches">We get type-safe &#x201C;wiring&#x201D; together
      of components, a flexible component model, and we did it all in Scala
      code! There are alternatives to the Cake Pattern for implementing
      dependency injection in Scala. See <link linkend="Boner2008b" xrefstyle="select:nopage">[Bon&#xE9;r2008b]</link> for other
      examples.<indexterm class="endofrange" startref="ch13_designpatternCAKE"/><indexterm class="endofrange" startref="ch13_Twitterclient"/><indexterm class="endofrange" startref="ch13_DICakePattern"/><indexterm class="endofrange" startref="ch12_CakePattern"/><indexterm class="endofrange" startref="ch13_appsdesignpatterns"/><indexterm class="endofrange" startref="ch13_designpatterns"/></para>
    </sect2>
  </sect1>

  <sect1 id="DesignByContractExample">
    <title>Better Design with Design By Contract</title>

    <para id="para_we_ll_conclude_this_chapter_wi">We&#x2019;ll conclude this chapter
    with a look at an approach to programming called <emphasis>Design by
    Contract</emphasis> (<link linkend="DesignByContract" xrefstyle="select:nopage">[DesignByContract]</link>), which was developed
    by Bertrand Meyer for the Eiffel language (see <link linkend="Eiffel" xrefstyle="select:nopage">[Eiffel]</link>, <link linkend="Hunt2000" xrefstyle="select:nopage">[Hunt2000]</link>, and <xref linkend="Traits"/>). Design by Contract has been around for about 20
    years. It has fallen somewhat out of favor, but it is still very useful
    for thinking about design.<indexterm>
        <primary>Meyer, Bertrand</primary>
      </indexterm><indexterm>
        <primary>Eiffel language</primary>
      </indexterm><indexterm>
        <primary>Design by Contract</primary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>Design by Contract</secondary>
      </indexterm></para>

    <para id="para_when_considering_the_contract">When considering the
    &#x201C;contract&#x201D; of a module, you can specify three types of conditions. First,
    you can specify the required inputs for a module to successfully perform a
    service (e.g., when a method is called). These constraints are called
    <emphasis>preconditions</emphasis>. They can also include system
    requirements, e.g., global data (which you should normally avoid, of
    course).<indexterm>
        <primary>contractual constraints in Design by Contract</primary>
      </indexterm><indexterm>
        <primary>modules</primary>

        <secondary>contract of</secondary>
      </indexterm><indexterm>
        <primary>preconditions</primary>
      </indexterm></para>

    <para id="para_you_can_also_specify_the_resul">You can also specify the
    results the module guarantees to deliver, the
    <emphasis>postconditions</emphasis>, if the preconditions were
    satisfied.<indexterm>
        <primary>postconditions</primary>
      </indexterm></para>

    <para id="para_finally_you_can_specify__inva">Finally, you can specify
    <emphasis>invariants</emphasis> that must be true before and after an
    invocation of a service.<indexterm>
        <primary>invariants</primary>
      </indexterm></para>

    <para id="para_the_specific_addition_that_des">The specific addition that
    Design by Contract brings is the idea that these contractual constraints
    should be specified as executable code, so they can be enforced
    automatically at runtime, but usually only during testing.</para>

    <para id="para_a_constraint_failure_should_te">A constraint failure should
    terminate execution immediately, forcing you to fix the bug. Otherwise, it
    is very easy to ignore these bugs.</para>

    <para id="para_scala_doesn_t_provide_explicit">Scala doesn&#x2019;t provide
    explicit support for Design by Contract, but there are several methods in
    <literal>Predef</literal> that can be used for this purpose. The following
    example shows how to use <literal>require</literal> and
    <literal>assume</literal> for contract enforcement:<indexterm>
        <primary>Predef object</primary>

        <secondary>require and assume methods, using for contract
        enforcement</secondary>
      </indexterm></para>

    <?dbfo-need height=”1in”
?>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/design-by-contract/bank-account.scala

class BankAccount(val balance: Double) {
  require(balance &gt;= 0.0)
  def debit(amount: Double) = {
    require(amount &gt; 0.0, "The debit amount must be &gt; 0.0")
    assume(balance - amount &gt; 0.0, "Overdrafts are not permitted")
    new BankAccount(balance - amount)
  }
  def credit(amount: Double) = {
    require(amount &gt; 0.0, "The credit amount must be &gt; 0.0")
    new BankAccount(balance + amount)
  }
}</programlisting>

    <para id="para_class_bankaccount_uses_requ">The class
    <literal>BankAccount</literal> uses <literal>require</literal> to ensure
    that a non-negative balance is specified for the constructor. Similarly,
    the <literal>debit</literal> and <literal>credit</literal> methods use
    <literal>require</literal> to ensure that a positive
    <literal>amount</literal> is specified.</para>

    <para id="para_the_following_specification_co">The specification in <xref linkend="design-by-contract-example-spec"/> confirms that the &#x201C;contract&#x201D;
    is obeyed.<indexterm>
        <primary>Design by Contract</primary>

        <secondary>BankAccountSpec object (example)</secondary>
      </indexterm></para>

    <example id="design-by-contract-example-spec">
      <title>design-by-contract/bank-account-spec.scala: Testing the
      contract</title>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/design-by-contract/bank-account-spec.scala

import org.specs._

object BankAccountSpec extends Specification {
  "Creating an account with a negative balance" should {
    "fail because the initial balance must be positive." in {
      new BankAccount(-100.0) must throwAn[IllegalArgumentException]
    }
  }

  "Debiting an account" should {
    "fail if the debit amount is &lt; 0" in {
      val account = new BankAccount(100.0)
      (account.debit(-10.0)) must throwAn[IllegalArgumentException]
    }
  }

  "Debiting an account" should {
    "fail if the debit amount is &gt; the balance" in {
      val account = new BankAccount(100.0)
      (account.debit(110.0)) must throwAn[AssertionError]
    }
  }
}</programlisting>
    </example>

    <para id="para_if_we_attempt_to_create_a_ban">If we attempt to create a
    <literal>BankAccount</literal> with a negative balance, an
    <literal>IllegalArgumentEx&#x2060;ception</literal> is thrown. Similarly, the
    same kind of exception is thrown if the debit amount is less than zero.
    Both conditions are enforced using <literal>require</literal>, which
    throws an <literal role="keep-together">IllegalArgumentException</literal>
    when the condition specified is false.</para>

    <para id="para_the_assume_method_which_is_">The <literal>assume</literal>
    method, which is used to ensure that overdrafts don&#x2019;t occur, is
    functionally almost identical to <literal>require</literal>. It throws an
    <literal>AssertionError</literal> instead of an <literal role="keep-together">IllegalArgumentException</literal>.</para>

    <para id="para_both_require_and_assume_co">Both <literal>require</literal>
    and <literal>assume</literal> come in two forms: one that takes just a
    boolean condition, and the other that also takes an error message
    string.</para>

    <para id="para_there_is_also_an_assert_pair">There is also an
    <literal>assert</literal> pair of methods that behave identically to
    <literal>assume</literal>, except for a slight change in the generated
    failure message. Pick <literal>assert</literal> or
    <literal>assume</literal> depending on which of these &#x201C;names&#x201D; provides a
    better conceptual fit in a given context.</para>

    <para id="para__predef_also_defines_an_ensu"><literal>Predef</literal>
    also defines an <literal>Ensuring</literal> class that can be used to
    generalize the capabilities of these methods. <literal>Ensuring</literal>
    has one overloaded method, <literal>ensure</literal>, some versions of
    which take a function literal as a &#x201C;predicate.&#x201D;<indexterm>
        <primary>Ensuring class</primary>
      </indexterm></para>

    <para id="para_a_drawback_of_using_these_meth">A drawback of using these
    methods and <literal>Ensuring</literal> is that you can&#x2019;t disable these
    checks in production. It may <emphasis>not</emphasis> be acceptable to
    terminate abruptly if a condition fails, although if the system is allowed
    to &#x201C;limp along,&#x201D; it might crash later and the problem would be harder to
    debug. The performance overhead may be another reason to disable contract
    checks at runtime.</para>

    <para id="para_these_days_the_goals_of_desig">These days, the goals of
    Design by Contract are largely met by Test-Driven Development (TDD).
    However, thinking in terms of Design by Contract will complement the
    design benefits of TDD. If you decide to use Design by Contract in your
    code, consider creating a custom module that lets you disable the tests
    for production code.<indexterm>
        <primary>TDD (Test-Driven Development)</primary>

        <secondary>Design by Contract and</secondary>
      </indexterm></para>
  </sect1>

  <sect1 id="_recap_and_what_s_next_4">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_we_learned_a_number_of_pragmat">We learned a number of
    pragmatic techniques, patterns, and idioms for effective application
    development using Scala.</para>

    <para id="para_good_tools_and_libraries_are_i">Good tools and libraries
    are important for building applications in any language. The next chapter
    provides more details about Scala&#x2019;s command-line tools, describes the
    state of Scala IDE support, and introduces you to some important Scala
    libraries.<indexterm class="endofrange" startref="ch13_appdesign"/></para>
  </sect1>
</chapter>
  <chapter id="ScalaToolsLibs">
  <title>Scala Tools, Libraries, and IDE Support</title>

  <para id="para_in_the_last_chapter_applica">In the previous chapter, <xref linkend="ApplicationDesign"/>, we looked at how to design scalable
  applications in Scala. In this chapter, we discuss tools and libraries that
  are essential for Scala application developers.</para>

  <para id="para_we_briefly_introduced_you_to_t">We briefly introduced you to
  the Scala command-line tools in <xref linkend="IntroducingScala"/>. Now we
  explore these tools in greater detail and learn about other tools that are
  essential for the Scala developer. We&#x2019;ll discuss language-aware plugins for
  editors and IDEs, testing tools, and various libraries and frameworks. We
  won&#x2019;t cover these topics in exhaustive detail, but we will tell you where to
  look for more information.</para>

  <sect1 id="CommandLineTools">
    <title>Command-Line Tools</title>

    <para id="para_even_if_you_do_most_of_your_wo">Even if you do most of your
    work with IDEs, understanding how the command-line tools work gives you
    additional flexibility, as well as a fallback should the graphical tools
    fail you. In this chapter, we&#x2019;ll give you some practical advice for
    interacting with these tools. However, we won&#x2019;t describe each and every
    command-line option. For those gory details, we recommend downloading and
    consulting the tool documentation package
    <literal>scala-devel-docs</literal>, as described in <xref linkend="ForMoreInformation"/> and also in <xref linkend="CommandLineToolSbaz"/>.<indexterm class="startofrange" id="ch14_commandlinetools">
        <primary>command-line tools</primary>
      </indexterm></para>

    <para id="para_all_the_command_line_tools_are">All the command-line tools
    are installed in the
    <replaceable>scala-home</replaceable><filename>/bin</filename> directory
    (see <xref linkend="InstallingScala"/>).</para>

    <sect2 id="CommandLineToolScalac">
      <title>scalac Command-Line Tool</title>

      <para id="para_the_scalac_command_compiles_">The
      <literal>scalac</literal> command compiles Scala source files,
      generating JVM class files. In contrast with Java requirements, the
      source file name doesn&#x2019;t have to match the public class name in the
      file. In fact, you can define as many public classes in the file as you
      want. You can also use arbitrary package declarations without putting
      the files in corresponding directories.<indexterm>
          <primary>compiler</primary>

          <see>scalac compiler</see>
        </indexterm><indexterm>
          <primary>command-line tools</primary>

          <secondary>scalac</secondary>
        </indexterm><indexterm>
          <primary>scalac compiler</primary>
        </indexterm></para>

      <para id="para_however_in_order_to_conform_t">However, in order to
      conform to JVM requirements, a separate class file will be <phrase role="keep-together">generated</phrase> for each type with a name that
      corresponds to the type&#x2019;s name (sometimes <phrase role="keep-together">encoded</phrase>, e.g., for nested type
      definitions). Also, the class files will be written to directories
      corresponding to the package declarations. We&#x2019;ll see an example of the
      types of class files generated in the next section, when we discuss the
      <literal>scala</literal> command.</para>

      <para id="para_the_scalac_command_is_just_a">The
      <literal>scalac</literal> command is just a shell-script wrapper around
      the <literal>java</literal> command, passing it the name of the Scala
      compiler&#x2019;s <literal>Main</literal> object. It adds Scala JAR files to
      the <literal role="keep-together">CLASSPATH</literal> and it defines
      several Scala-related system properties. You invoke the command as
      follows:<indexterm>
          <primary>java command</primary>
        </indexterm></para>

      <screen><literal>scalac</literal> <replaceable>[options ...] [source-files]</replaceable></screen>

      <para id="para_scalac_examples">For example, we used the following
      <literal>scalac</literal> invocation command in <xref linkend="ATasteOfScala"/>, where we created a simple command-line tool
      to convert input strings to uppercase:</para>

      <screen>scalac upper3.scala</screen>

      <para id="para_options_for_scalac"><xref linkend="scalac-command-options"/> shows the list of the
      <literal>scalac</literal> <replaceable>options</replaceable>, as
      reported by <literal>scalac -help</literal>.<indexterm>
          <primary>scalac compiler</primary>

          <secondary>command options</secondary>
        </indexterm></para>

      <table id="scalac-command-options">
        <title>The scalac command options</title>

        <tgroup cols="2">
          <thead valign="top">
            <row>
              <entry>Option</entry>

              <entry><phrase role="keep-together">Description</phrase></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>-X</literal></para></entry>

              <entry><para>Print a synopsis of advanced
              options.</para></entry>
            </row>

            <row>
              <entry><para><literal>-bootclasspath</literal>
              <replaceable>path</replaceable></para></entry>

              <entry><para>Override location of bootstrap class
              files.</para></entry>
            </row>

            <row>
              <entry><para><literal>-classpath</literal>
              <replaceable>path</replaceable></para></entry>

              <entry><para>Specify where to find user class
              files.</para></entry>
            </row>

            <row>
              <entry><para><literal>-d</literal>
              <replaceable>directory</replaceable></para></entry>

              <entry><para>Specify where to place generated class
              files.</para></entry>
            </row>

            <row>
              <entry><para><literal>-dependencyfile</literal>
              <replaceable>file</replaceable></para></entry>

              <entry><para>Specify the file in which dependencies are tracked.
              (<phrase role="keep-together">version</phrase>
              2.8)</para></entry>
            </row>

            <row>
              <entry><para><literal>-deprecation</literal></para></entry>

              <entry><para>Output source locations where deprecated APIs are
              used.</para></entry>
            </row>

            <row>
              <entry><para><literal>-encoding</literal>
              <replaceable>encoding</replaceable></para></entry>

              <entry><para>Specify character encoding used by source
              files.</para></entry>
            </row>

            <row>
              <entry><para><literal>-explaintypes</literal></para></entry>

              <entry><para>Explain type errors in more detail.</para></entry>
            </row>

            <row>
              <entry><para><literal>-extdirs</literal>
              <replaceable>dirs</replaceable></para></entry>

              <entry><para>Override location of installed compiler
              extensions.</para></entry>
            </row>

            <row>
              <entry><para><literal>-g:</literal><replaceable>level</replaceable></para></entry>

              <entry><para>Specify <replaceable>level</replaceable> of
              generated debugging info: <literal>none</literal>,
              <literal>source</literal>, <literal>line</literal>,
              <literal>vars</literal>,
              <literal>notailcalls</literal>.</para></entry>
            </row>

            <row>
              <entry><para><literal>-help</literal></para></entry>

              <entry><para>Print a synopsis of standard
              options.</para></entry>
            </row>

            <row>
              <entry><para><literal>-make:</literal><replaceable>strategy</replaceable></para></entry>

              <entry><para>Specify recompilation detection strategy:
              <literal>all</literal>, <literal>changed</literal>,
              <literal>immediate</literal>, <literal>transitive</literal>.
              (<phrase role="keep-together">version</phrase>
              2.8)</para></entry>
            </row>

            <row>
              <entry><para><literal>-nowarn</literal></para></entry>

              <entry><para>Generate no warnings.</para></entry>
            </row>

            <row>
              <entry><para><literal>-optimise</literal></para></entry>

              <entry><para>Generate faster byte code by applying optimizations
              to the program.</para></entry>
            </row>

            <row>
              <entry><para><literal>-print</literal></para></entry>

              <entry><para>Print program with all Scala-specific features
              removed.</para></entry>
            </row>

            <row>
              <entry><para><literal>-sourcepath</literal>
              <replaceable>path</replaceable></para></entry>

              <entry><para>Specify where to find input source
              files.</para></entry>
            </row>

            <row>
              <entry><para><literal>-target:</literal><replaceable>target</replaceable></para></entry>

              <entry><para>Specify for which target JVM object files should be
              built: <literal>jvm-1.5</literal>, <literal>jvm-1.4</literal>,
              <literal>msil</literal>.</para></entry>
            </row>

            <row>
              <entry><para><literal>-unchecked</literal></para></entry>

              <entry><para>Enable detailed unchecked warnings.</para></entry>
            </row>

            <row>
              <entry><para><literal>-uniqid</literal></para></entry>

              <entry><para>Print identifiers with unique names for
              debugging.</para></entry>
            </row>

            <row>
              <entry><para><literal>-verbose</literal></para></entry>

              <entry><para>Output messages about what the compiler is
              doing.</para></entry>
            </row>

            <row>
              <entry><para><literal>-version</literal></para></entry>

              <entry><para>Print product version and exit.</para></entry>
            </row>

            <row>
              <entry><para><literal>@</literal>
              <replaceable>file</replaceable></para></entry>

              <entry><para>A text file containing compiler arguments (options
              and source files).</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <tip id="para_tip_we_recommend_routine_use_">
        <para>We recommend routine use of the <literal>-deprecation</literal>
        and <literal>-unchecked</literal> options. They help prevent some bugs
        and encourage you to eliminate use of obsolete libraries.</para>
      </tip>

      <para id="para_the_advanced_x_options_cont">The advanced
      <literal>-X</literal> options control verbose output, fine-tune the
      compiler behavior, including use of experimental extensions and plugins,
      etc. We&#x2019;ll discuss the <literal>-Xscript</literal> option when we
      discuss the <literal>scala</literal> command in the next
      section.<indexterm>
          <primary>scalac compiler</primary>

          <secondary><literal>-X</literal> options</secondary>
        </indexterm></para>

      <para id="para_two_other_advanced_options">A few other advanced options,
      <literal>-Xfuture</literal> and <literal>-Xcheckinit</literal>, are
      useful for the <literal>val</literal> override issue described in <xref linkend="OverridingFieldsInTraits"/> that affects Scala version 2.7.X.
      Similarly, the <literal>-Xexperimental</literal> option enables
      experimental changes and issues warnings for potentially risky behavior
      changes. See <xref linkend="OverridingFieldsInTraits"/> for
      details.</para>

      <para id="para_an_important_feature_of_scala">An important feature of
      <literal>scalac</literal> is its plugin architecture, which has been
      significantly enhanced in version 2.8. Compiler plugins can be inserted
      in all phases of the compilation, enabling code transformations,
      analysis, etc. For example, version 2.8 will include a continuations
      plugin that developers can use to generate byte code that uses a
      continuation-passing style (CPS), rather than a stack-based style. Other
      plugins that are under development include an &#x201C;effects&#x201D; analyzer, useful
      for determining whether functions are truly side-effect-free, whether or
      not variables are modified, etc. Finally, the preliminary
      <literal>sxr</literal> documentation tool (see <link linkend="SXR" xrefstyle="select:nopage">[SXR]</link>) uses a compiler plugin to
      generate <phrase role="keep-together">hyperlinked</phrase> documentation
      of Scala code.<indexterm>
          <primary>scalac compiler</primary>

          <secondary>plugin architecture</secondary>
        </indexterm></para>

      <para id="para_scalac_docs">You can read more information about
      <literal>scalac</literal> in the developer tools documentation that you
      can install with the <literal>sbaz</literal> command, discussed later in
      <xref linkend="CommandLineToolSbaz"/>. In particular, <xref linkend="sbaz-commands"/> shows an example <literal>sbaz</literal>
      command that installs the <literal>scala-devel-docs</literal>
      documentation.</para>

      <warning id="para_warning_scala_version_2_8_com">
        <para>Scala version 2.8 compiled byte code will not be fully
        compatible with version 2.7.5 byte code. Source compatibility will be
        preserved in most cases. If you have your own collections
        implementations, they may <phrase role="keep-together">require</phrase> changes.</para>
      </warning>
    </sect2>

    <sect2 id="CommandLineToolScala">
      <title>The scala Command-Line Tool</title>

      <para id="para_the_scala_command_is_also_a_">The
      <literal>scala</literal> command is also a shell-script wrapper around
      the <literal>java</literal> command. It adds Scala JAR files to the
      <literal>CLASSPATH</literal>, and it defines several Scala-related
      system properties. You invoke the command as follows:<indexterm class="startofrange" id="ch14_commandlinescala">
          <primary>command-line tools</primary>

          <secondary>scala</secondary>
        </indexterm><indexterm class="startofrange" id="ch14_scalacommand">
          <primary>scala command</primary>
        </indexterm></para>

      <screen>scala <replaceable>[options ...] [script-or-object] [arguments]</replaceable></screen>

      <para id="para_scala_examples">For example, after compiling our
      <filename>upper3.scala</filename> file in <xref linkend="ATasteOfScala"/>, which we revisited in the previous
      discussion of <literal>scalac</literal>, we can execute the
      &#x201C;application&#x201D; as follows:</para>

      <screen>scala -cp . Upper Hello World!</screen>

      <para id="para_scala_upper_output">The <literal>-cp .</literal> option
      adds the current working directory to the class path.
      <literal>Upper</literal> is the class name with a
      <literal>main</literal> method to run. <literal>Hello World</literal>
      are arguments passed to <literal>Upper</literal>. This command produces
      the following output:<indexterm>
          <primary>scala command</primary>

          <secondary>-cp option</secondary>
        </indexterm></para>

      <screen> HELLO WORLD!</screen>

      <para id="para_the_command_decides_what_to_do">The command decides what
      to do based on the <replaceable>script-or-object</replaceable>
      specified. If you don&#x2019;t specify a script or object,
      <literal>scala</literal> runs as an interactive interpreter. You type in
      code that is evaluated on the fly, a setup sometimes referred to as a
      REPL (Read, Evaluate, Print, Loop). There are a few special commands
      available in the interactive mode. Type <literal>:help</literal> to see
      a list of them.<indexterm>
          <primary>scala command</primary>

          <secondary>script or object specified for</secondary>
        </indexterm></para>

      <note id="para_note_the_version_2_8_repl_add">
        <para>The version 2.8 REPL adds many enhancements, including code
        <phrase role="keep-together">completion</phrase>.</para>
      </note>

      <para id="para_if_you_specify_a_fully_qualifi">Our
      <literal>Upper</literal> example demonstrates the case where you specify
      a fully qualified <literal>object</literal> name (or Java
      <literal>class</literal> name). In this case, <literal>scala</literal>
      behaves just like the <literal>java</literal> command; it searches the
      <literal>CLASSPATH</literal> for the corresponding code. It will expect
      to find a <literal>main</literal> method in the type. Recall that for
      Scala types, you have to define <literal>main</literal> methods in
      <literal>objects</literal>. Any <replaceable>arguments</replaceable> are
      passed as arguments to the <literal>main</literal> method.</para>

      <para id="para_if_you_specify_a_scala_source_">If you specify a Scala
      source file for <replaceable>script-or-object</replaceable>,
      <literal>scala</literal> interprets the file as a script (i.e., compiles
      and runs it). Many of the examples in the book are invoked this way. Any
      <replaceable>arguments</replaceable> are made available to the script in
      the <literal>args</literal> array. Here is an example script that
      implements the same &#x201C;upper&#x201D; feature:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/upper-script.scala

args.map(_.toUpperCase()).foreach(printf("%s ",_))
println("")</programlisting>

      <para id="para_hello_script_invocation">If we run this script with the
      following command, <literal>scala upper.scala Hello World</literal>, we
      get the same output we got before, <literal>HELLO
      WORLD</literal>.</para>

      <para id="para_interactive_mode_invocation">Finally, if you invoke
      <literal>scala</literal> without a script file or object name argument,
      <literal>scala</literal> runs in interpreted mode. Here is an example
      interactive session:<indexterm>
          <primary>scala command</primary>

          <secondary>running in interpreted mode</secondary>
        </indexterm></para>

      <screen>$ scala
Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; "Programming Scala" foreach { c =&gt; println(c) }
P
r
o
g
...</screen>

      <para id="para_the_scala_command_accepts_al">The
      <literal>scala</literal> command accepts all the options that
      <literal>scalac</literal> accepts (see <xref linkend="scalac-command-options"/>), plus the options listed in <xref linkend="scala-command-options"/>.<indexterm>
          <primary>scala command</primary>

          <secondary>options</secondary>
        </indexterm></para>

      <table id="scala-command-options">
        <title>The scala command options (in addition to the scalac
        options)</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1.25in"/>

          <colspec colnum="2" colwidth="3.5in"/>

          <thead valign="top">
            <row>
              <entry>Option</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>-howtorun script</literal></para></entry>

              <entry><para>Explicitly interpret
              <replaceable>script-or-object</replaceable> as a script
              file.</para></entry>
            </row>

            <row>
              <entry><para><literal>-howtorun object</literal></para></entry>

              <entry><para>Explicitly interpret
              <replaceable>script-or-object</replaceable> as a compiled
              object.</para></entry>
            </row>

            <row>
              <entry><para><literal>-howtorun guess</literal></para></entry>

              <entry><para>Guess what
              <replaceable>script-or-object</replaceable> is
              (default).</para></entry>
            </row>

            <row>
              <entry><para><literal>-i</literal>
              <replaceable>file</replaceable></para></entry>

              <entry><para>Preload <replaceable>file</replaceable>. It is only
              meaningful for interactive shells.</para></entry>
            </row>

            <row>
              <entry><para><literal>-e</literal>
              <replaceable>argument</replaceable></para></entry>

              <entry><para>Parse <replaceable>argument</replaceable> as Scala
              code.</para></entry>
            </row>

            <row>
              <entry><para><literal>-savecompiled</literal></para></entry>

              <entry><para>Save the compiled script for future
              use.</para></entry>
            </row>

            <row>
              <entry><para><literal>-nocompdaemon</literal></para></entry>

              <entry><para>Don&#x2019;t use <literal>fsc</literal>, the offline
              compiler. (See <xref linkend="CommandLineToolFsc"/>.)</para></entry>
            </row>

            <row>
              <entry><para><literal>-D</literal><replaceable>property</replaceable><literal>=</literal><replaceable>value</replaceable></para></entry>

              <entry><para>Set a Java system
              <replaceable>property</replaceable> to
              <replaceable>value</replaceable>.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_use_the_i_file_option_in_">Use the <literal>-i</literal>
      <replaceable>file</replaceable> option in the interactive mode when you
      want to preload a file before typing commands. Once in the shell, you
      can also load a file using the command <literal>:load</literal>
      <replaceable>filename</replaceable>. <xref linkend="scala-interactive-special-commands"/> lists the special
      <literal>:X</literal> commands available within the interactive
      mode.<indexterm>
          <primary>scala command</primary>

          <secondary>commands available in scala interactive mode</secondary>
        </indexterm></para>

      <table id="scala-interactive-special-commands">
        <title>Commands available within the scala interactive mode</title>

        <tgroup cols="2">
          <colspec colnum="1" colwidth="1.25in"/>

          <colspec colnum="2" colwidth="3.5in"/>

          <thead valign="top">
            <row>
              <entry>Option</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>:help</literal></para></entry>

              <entry><para>Prints a help message about these
              commands.</para></entry>
            </row>

            <row>
              <entry><para><literal>:load</literal></para></entry>

              <entry><para>Followed by a file name, loads a Scala
              file.</para></entry>
            </row>

            <row>
              <entry><para><literal>:replay</literal></para></entry>

              <entry><para>Resets execution and replays all previous
              commands.</para></entry>
            </row>

            <row>
              <entry><para><literal>:quit</literal></para></entry>

              <entry><para>Exits the interpreter.</para></entry>
            </row>

            <row>
              <entry><para><literal>:power</literal></para></entry>

              <entry><para>Enables power user mode. (version
              2.8)</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_power_user_mode">The new &#x201C;power user mode&#x201D; adds
      additional commands for viewing in-memory data, such as the abstract
      syntax tree and interpreter properties, and for doing other <phrase role="keep-together">operations</phrase>.</para>

      <para id="para_for__batch_mode__invocation_u">For
      <emphasis>batch-mode</emphasis> invocation, use the
      <literal>-e</literal> <replaceable>argument</replaceable> option to
      specify Scala code to interpret. If you are using command shells that
      support I/O redirection (e.g., the Bourne shell, the C shell, or their
      descendants) and you need to build up lines of code dynamically, you can
      also pipe the code into <literal>scala</literal>, as shown in the
      following somewhat contrived <emphasis>bash</emphasis> script
      example:</para>

      <programlisting linenumbering="unnumbered">#!/usr/bin/env bash
# code-examples/ToolsLibs/pipe-example.sh

h=Hello
w=World
function commands {
cat &lt;&lt;-EOF
println("$h")
println("$w")
EOF
}

commands | scala</programlisting>

      <para id="para_invoking_scripts_with_scala_">Invoking scripts with
      <literal>scala</literal> is tedious when you use these scripts
      frequently. On Windows and Unix-like systems, you can create standalone
      Scala scripts that don&#x2019;t require you to use the <literal>scala</literal>
      <replaceable>script-file-name</replaceable> invocation.<indexterm>
          <primary>scala command</primary>

          <secondary>invoking scripts</secondary>
        </indexterm></para>

      <para id="para_for_unix_like_systems_the_fol">For Unix-like systems, the
      following example demonstrates how to make an executable script.
      Remember that you have to make the permissions executable, e.g.,
      <literal>chmod +x secho</literal>:</para>

      <programlisting linenumbering="unnumbered">#!/bin/sh
exec scala "$0" "$@"
!#
print("You entered: ")
argv.toList foreach { s =&gt; format("%s ", s) }
println</programlisting>

      <para id="para_here_is_how_you_might_use_it_">Here is how you might use
      it:</para>

      <screen>$ secho Hello World
You entered: Hello World</screen>

      <para id="para_similarly_here_is_an_example_">Similarly, here is an
      example Windows <literal>.bat</literal> command:</para>

      <programlisting linenumbering="unnumbered">::#!
@echo off
call scala %0 %*
goto :eof
::!#
print("You entered: ")
argv.toList foreach { s =&gt; format("%s ", s) }
println</programlisting>

      <para id="para_see_the_scala_man_page_in_th">See the
      <literal>scala</literal> man page in the developer documentation package
      <literal>scala-devel-docs</literal> to find out more about all the
      command-line options for <literal>scala</literal>,<indexterm>
          <primary>scala command</primary>

          <secondary>documentation</secondary>
        </indexterm></para>

      <sect3 id="LimitationsOfScalaVsScalac">
        <title>Limitations of scala versus scalac</title>

        <para id="para_there_are_some_limitations_when_running">There are some
        limitations when running a source file with <literal>scala</literal>
        versus compiling it with <literal>scalac</literal>.<indexterm>
            <primary>scalac compiler</primary>

            <secondary>scala command versus</secondary>
          </indexterm><indexterm>
            <primary>scala command</primary>

            <secondary>limitations of, versus scalac</secondary>
          </indexterm></para>

        <para id="para_any_scripts_executed_with_scala">Any scripts executed
        with <literal>scala</literal> are wrapped in an anonymous
        <literal>object</literal> that looks more or less like the following
        example:</para>

        <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/script-wrapper.scala

object Script {
  def main(args: Array[String]): Unit = {
    new AnyRef {
      // Your script code is inserted here.
    }
  }
}</programlisting>

        <para id="para_as_of_this_writing_scala_obj">As of this writing, Scala
        <literal>objects</literal> cannot embed package declarations, and as
        such you can&#x2019;t declare packages in scripts. This is why the examples
        in this book that declare packages must be compiled and executed
        separately, such as this example from <xref linkend="TypeLessDoMore"/>:</para>

        <programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/package-example1.scala

package com.example.mypkg

class MyClass {
  // ...
}</programlisting>

        <para id="para_conversely_there_are_valid_sc">Conversely, there are
        valid scripts that can&#x2019;t be compiled with <literal>scalac</literal>,
        unless a special <literal role="keep-together">-X</literal> option is
        used. For example, function definitions and function invocations
        outside of types are not allowed. The following example runs fine with
        <literal>scala</literal>:</para>

        <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/example-script.scala

case class Message(name: String)

def printMessage(msg: Message) = {
  println(msg)
}

printMessage(new Message(
    "Must compile this script with scalac -Xscript &lt;name&gt;!"))</programlisting>

        <para id="para_running_this_script">Running this script with
        <literal>scala</literal> produces the following expected
        output:</para>

        <screen>Message(Must compile this script with scalac -Xscript &lt;name&gt;!)</screen>

        <para id="para_however_if_you_try_to_compile">However, if you try to
        compile the script with <literal>scalac</literal> (without the
        <literal>-Xscript</literal> option), you get the following
        errors:<indexterm>
            <primary>scalac compiler</primary>

            <secondary><literal>-Xscript</literal> option</secondary>
          </indexterm></para>

        <screen>example-script.scala:3: error: expected class or object definition
def printMessage(msg: Message) = {
^
example-script.scala:7: error: expected class or object definition
printMessage(new Message("Must compile this script with scalac -Xscript &lt;name&gt;!"))
^
two errors found</screen>

        <para id="para_the_script_itself_describes_th">The script itself
        describes the solution; to compile this script with
        <literal>scalac</literal> you must add the option
        <literal>-Xscript</literal> <replaceable>name</replaceable>, where
        <replaceable>name</replaceable> is the name you want to give the
        compiled class file. For example, using
        <literal>MessagePrinter</literal> for <replaceable>name</replaceable>
        will result in the creation of several class files with the name
        prefix <literal>MessagePrinter</literal>:</para>

        <screen>scalac -Xscript MessagePrinter example-script.scala</screen>

        <para id="para_run_msgprinter">You can now run the compiled code with
        the command:</para>

        <screen>scala -classpath . MessagePrinter</screen>

        <para id="para_the_directory_will_contain_the">The current directory
        will contain the following class files:</para>

        <screen>MessagePrinter$$anon$1$Message$.class
MessagePrinter$$anon$1$Message.class
MessagePrinter$$anon$1.class
MessagePrinter$.class
MessagePrinter.class</screen>

        <para id="para_what_are_all_those_files_mes">What are all those files?
        <literal>MessagePrinter</literal> and
        <literal>MessagePrinter$</literal> are wrappers generated by
        <literal>scalac</literal> to provide the entry point for the script as
        an &#x201C;application.&#x201D; Recall that we specified
        <literal>MessagePrinter</literal> as the
        <replaceable>name</replaceable> argument for
        <literal>-Xscript</literal>. <literal>MessagePrinter</literal> has the
        <literal>static main</literal> method we need.</para>

        <para id="para__messageprinter_036_036_ano"><literal>MessagePrinter$$anon$1</literal>
        is a generated class that wraps the whole script. The
        <literal>printMes&#x2060;sage</literal> method in the script is a method in
        this class. <literal>MessagePrinter$$anon$1$Message</literal> and
        <literal>MessagePrinter$$anon$1$Message$</literal> are the
        <literal>Message</literal> class and companion object, respectively,
        that are declared in the script. They are nested inside the generated
        class <literal>MessagePrinter$$anon$1</literal> for the whole script.
        If you want to see what&#x2019;s inside these class files, use one of the
        decompilers, which we describe next.<indexterm class="endofrange" startref="ch14_scalacommand"/><indexterm class="endofrange" startref="ch14_commandlinescala"/></para>
      </sect3>
    </sect2>

    <sect2 id="CommandLineToolDecompilers">
      <title>The scalap, javap, and jad Command-Line Tools</title>

      <para id="para_when_you_re_learning_scala_and">When you are learning
      Scala and you want to understand how Scala constructs are mapped to the
      runtime, there are several decompilers that are very useful. They are
      especially useful when you need to invoke Scala code from Java and you
      want to know how Scala names are <emphasis>mangled</emphasis> into
      JVM-compatible names, or you want to understand how the scala compiler
      translates Scala features into valid byte code.<indexterm>
          <primary>decompilers (scalap, javap, and jad)</primary>
        </indexterm><indexterm>
          <primary>scalap tool</primary>
        </indexterm><indexterm>
          <primary>command-line tools</primary>

          <secondary>scalap, javap, and jad</secondary>
        </indexterm></para>

      <para id="para_let_s_discuss_three_decompiler">Let&#x2019;s discuss three
      decompilers and the benefits they offer. Since the class files generated
      by <literal>scalac</literal> contain valid JVM byte codes, you can use
      Java decompilers tools:</para>

      <itemizedlist>
        <listitem>
          <para><literal>scalap</literal> is included with the Scala
          distribution. It outputs declarations as they would appear in Scala
          source code.</para>
        </listitem>

        <listitem>
          <para><literal>javap</literal> is included with the JDK. It outputs
          declarations as they would appear in Java source code. Therefore,
          running <literal>javap</literal> on Scala-generated class files is a
          good way to see how Scala definitions are mapped to valid byte
          code.<indexterm>
              <primary>javap tool</primary>
            </indexterm></para>
        </listitem>

        <listitem>
          <para><literal>jad</literal> is an open source command-line tool
          (see <link linkend="JAD" xrefstyle="select:nopage">[JAD]</link>). It
          attempts to reconstruct an entire Java source file from the class
          file, including method definitions, as well as the
          declarations.<indexterm>
              <primary>jad tool</primary>
            </indexterm></para>
        </listitem>
      </itemizedlist>

      <para id="para_scalap_output"><filename>MessagePrinter.class</filename>
      is one of the class files generated from the example script in the
      previous section. Let&#x2019;s run <literal>scalap -classpath .
      MessagePrinter</literal>. We get the following output:</para>

      <screen>package MessagePrinter;
final class MessagePrinter extends scala.AnyRef {
}
object MessagePrinter {
  def main(scala.Array[java.lang.String]): scala.Unit;
  def $tag(): scala.Int;
    throws java.rmi.RemoteException
}</screen>

      <para id="para_you_can_see_the_main_method_">Note that the first method
      inside <literal>object MessagePrinter</literal> is the
      <literal>main</literal> method. The <literal>$tag</literal> method is
      part of Scala&#x2019;s internal implementation. It is an abstract method
      defined by <literal>ScalaObject</literal>. The compiler automatically
      generates implementations for concrete types. The
      <literal>$tag</literal> method was originally introduced to optimize
      pattern matching, but it is now deprecated and it may be removed in a
      forthcoming release of Scala.<indexterm>
          <primary>ScalaObject class</primary>

          <secondary>$tag method</secondary>
        </indexterm><indexterm>
          <primary sortas="tag method">$tag method (ScalaObject)</primary>
        </indexterm></para>

      <para id="para_javap_output">Let&#x2019;s compare the <literal>scalap</literal>
      output to what we get when we run <literal>javap -classpath .
      MessagePrinter</literal>:</para>

      <screen>Compiled from "(virtual file)"
public final class MessagePrinter extends java.lang.Object{
  public static final void main(java.lang.String[]);
  public static final int $tag()       throws java.rmi.RemoteException;
}</screen>

      <para id="para_javap_output_main_method">Now we see the declaration of
      <literal>main</literal> as we would typically see it in a Java source
      file.</para>

      <para id="para_jad_output">Finally, to use <literal>jad</literal>, you
      simply give it the file name of the class file. It generates a
      corresponding output file with the <filename>.jad</filename> extension.
      If you run <literal>jad MessagePrinter.class</literal>, you get a long
      file named <filename>MessagePrinter.jad</filename>. You will also get
      several warnings that <literal>jad</literal> could not fully decompile
      some methods. We won&#x2019;t reproduce the output here, but the
      <filename>.jad</filename> file will print normal Java statements
      interspersed with several sections of JVM byte code instructions, where
      it could not decompile the byte code.</para>

      <para id="para_scalap_javap_jad_help">All these tools have command-line
      help:</para>

      <itemizedlist>
        <listitem>
          <para><literal>scalap -help</literal></para>
        </listitem>

        <listitem>
          <para><literal>javap -help</literal></para>
        </listitem>

        <listitem>
          <para><literal>jad --help</literal></para>
        </listitem>
      </itemizedlist>

      <para id="para_scalap_javap_jad_docs">The Scala developer documentation
      contains documentation for <literal>scalap</literal>. Similar
      documentation comes with the JDK for <literal>javap</literal>. The
      <literal>jad</literal> distribution includes a
      <filename>README</filename> file with documentation. The Mac and Linux
      distributions also include a man page.</para>

      <para id="para_finally_as_an_exercise_compi">Finally, as an exercise,
      compile the following very simple <literal>Complex</literal> class,
      representing complex numbers. Then run <literal>scalap</literal>,
      <literal>javap</literal>, and <literal>jad</literal> on the resulting
      class files:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex.scala

case class Complex(real: Double, imaginary: Double) {
  def +(that: Complex) =
    new Complex(real + that.real, imaginary + that.imaginary)
  def -(that: Complex) =
    new Complex(real - that.real, imaginary - that.imaginary)
}</programlisting>

      <para id="para_how_are_the_043_and_m">How are the <literal>+</literal>
      and <literal>-</literal> methods encoded? What are the names of the
      reader methods for the <literal>real</literal> and
      <literal>imaginary</literal> fields? What Java types are used for the
      fields?</para>
    </sect2>

    <sect2 id="CommandLineToolScaladoc">
      <title>The scaladoc Command-Line Tool</title>

      <para id="para_the_scaladoc_command_is_anal">The
      <literal>scaladoc</literal> command is analogous to
      <literal>javadoc</literal>. It is used to generate documentation from
      Scala source files, called Scaladocs. The <literal>scaladoc</literal>
      parser supports the same <literal>@</literal> <phrase role="keep-together">annotations</phrase> that
      <literal>javadoc</literal> supports, such as <literal>@author</literal>,
      <literal>@param</literal>, etc.<indexterm>
          <primary>command-line tools</primary>

          <secondary>scaladoc</secondary>
        </indexterm><indexterm>
          <primary>scaladoc tool</primary>
        </indexterm></para>

      <para id="para_if_you_use_scaladoc_for_your">If you use
      <literal>scaladoc</literal> for your documentation, you might want to
      investigate <literal>vscaladoc</literal>, an improved
      <literal>scaladoc</literal> tool that is available at <ulink url="http://code.google.com/p/vscaladoc/"/>. You can also find
      documentation on <literal>vscaladoc</literal> at <link linkend="ScalaTools" xrefstyle="select:nopage">[ScalaTools]</link>.</para>
    </sect2>

    <sect2 id="CommandLineToolSbaz">
      <title>The sbaz Command-Line Tool</title>

      <para id="para_scala_bazaar_system_sbaz_i">The Scala Bazaar System
      (<literal>sbaz</literal>) is a packaging system that helps automate
      maintenance of a Scala installation. It is analogous to the
      <emphasis>gem</emphasis> packaging system for Ruby,
      <emphasis>CPAN</emphasis> for Perl, etc.<indexterm>
          <primary>sbaz tool</primary>
        </indexterm><indexterm>
          <primary>command-line tools</primary>

          <secondary>sbaz</secondary>
        </indexterm></para>

      <para id="para_there_is_a_nice_summary_of_how">There is a nice summary
      of how to use <literal>sbaz</literal> on the <ulink url="http://www.scala-lang.org/node/93">scala-lang.org website</ulink>.
      All command-line options are described in the developer documentation.
      <xref linkend="sbaz-commands"/> summarizes the most useful
      options.</para>

      <table id="sbaz-commands">
        <title>The most useful sbaz command options</title>

        <tgroup cols="2">
          <thead valign="top">
            <row>
              <entry>Command</entry>

              <entry>Description</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>sbaz showuniverse</literal></para></entry>

              <entry><para>Show the current &#x201C;universe&#x201D; (remote repository).
              Defaults to <ulink url="http://scala-webapps.epfl.ch/sbaz/scala-dev"/>.</para></entry>
            </row>

            <row>
              <entry><para><literal>sbaz setuniverse</literal>
              <replaceable>univ</replaceable></para></entry>

              <entry><para>Points to a new &#x201C;universe&#x201D;
              <replaceable>univ</replaceable>.</para></entry>
            </row>

            <row>
              <entry><para><literal>sbaz installed</literal></para></entry>

              <entry><para>What&#x2019;s already installed locally?</para></entry>
            </row>

            <row>
              <entry><para><literal>sbaz available</literal></para></entry>

              <entry><para>What goodness awaits on the
              Interwebs?</para></entry>
            </row>

            <row>
              <entry><para><literal role="keep-together">sbaz install
              scala-devel-docs</literal></para></entry>

              <entry><para>Install the invaluable
              <literal>scala-devel-docs</literal> package (for
              example).</para></entry>
            </row>

            <row>
              <entry><para><literal>sbaz upgrade</literal></para></entry>

              <entry><para>Upgrade all installed packages to the latest and
              greatest.</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_note_that_a_remote_repository_">Note that a remote
      repository used by <literal>sbaz</literal> is called a
      &#x201C;universe.&#x201D;<indexterm>
          <primary>universe (sbaz remote repository)</primary>
        </indexterm></para>
    </sect2>

    <sect2 id="CommandLineToolFsc">
      <title>The fsc Command-Line Tool</title>

      <para id="para_the__fast_offline_scala_comp">The <emphasis>fast
      (offline) scala compiler</emphasis> runs as a daemon process to enable
      faster invocations of the compiler, mostly by eliminating the startup
      overhead. It is particularly useful when running scripts repeatedly (for
      example, when re-running a test suite until a bug can be reproduced). In
      fact, <literal>fsc</literal> is invoked automatically by the
      <literal>scala</literal> command. You can also invoke it
      directly.<indexterm>
          <primary>fsc (fast scala compiler) tool</primary>
        </indexterm><indexterm class="endofrange" startref="ch14_commandlinetools"/></para>
    </sect2>
  </sect1>

  <sect1 id="BuildTools">
    <title>Build Tools</title>

    <para id="para_scala_plugins_have_been_implem">Scala plugins have been
    implemented for several, commonly used build tools, including
    <emphasis><ulink url="http://ant.apache.org/">Ant</ulink></emphasis>,
    <emphasis><ulink url="http://maven.apache.org/">Maven</ulink></emphasis>,
    and <emphasis><ulink url="http://buildr.apache.org/">Buildr</ulink></emphasis>. There are also
    several build tools written in Scala and aimed specifically at Scala
    development. Perhaps the best known example of these tools is SBT (simple
    build tool&#x2014;see <link linkend="SBT" xrefstyle="select:nopage">[SBT]</link>).<indexterm>
        <primary>SBT (simple build tool)</primary>
      </indexterm><indexterm>
        <primary>Maven build tool</primary>
      </indexterm><indexterm>
        <primary>build tools</primary>
      </indexterm></para>

    <para id="para_build_tools_documented_on_sites">These plugins and tools
    are documented very well on their respective websites, so we refer you to
    those sites for details.<indexterm>
        <primary>Ant, Scala plugin for</primary>
      </indexterm></para>

    <para id="para_ant_support">The Scala distribution includes Ant tasks for
    <literal>scalac</literal>, <literal>fsc</literal>, and
    <literal>scaladoc</literal>. They are used very much like the
    corresponding Java Ant tasks. They are described at <ulink url="http://scala-lang.org/node/98"/>.</para>

    <para id="para_maven_support">A Scala Maven plugin is available at <ulink url="http://scala-tools.org/mvnsites/maven-scala-plugin/"/>. It
    does not require Scala to be installed, as it will download Scala for you.
    Several third-party Scala projects, such as Lift (see <xref linkend="Lift"/>), use Maven.</para>

    <para id="para_buildr_support">Buildr is an Apache project available at
    <ulink url="http://buildr.apache.org/"/>. It is aimed at JVM
    applications written in any language, with built-in support for Scala and
    Groovy as well as Java. It is compatible with Maven repositories and
    project layouts. Since build scripts are written in Ruby, they tend to be
    much more succinct than corresponding Maven files. Buildr is also useful
    for testing JVM applications with Ruby testing tools, like
    <emphasis><ulink url="http://rspec.info">RSpec</ulink></emphasis> and
    <ulink url="http://cukes.info">Cucumber</ulink>, if you use <ulink url="http://jruby.codehaus.org/">JRuby</ulink> to run your
    builds.<indexterm>
        <primary>Buildr tool</primary>
      </indexterm></para>

    <para id="para_sbt_support">The Scala-oriented SBT, available at <ulink url="http://code.google.com/p/simple-build-tool/"/>, has some
    similarities to Buildr. It is also compatible with Maven, but it uses
    Scala as the language for writing build scripts. It also has built-in
    support for generating Scaladocs and for testing with ScalaTest, Specs,
    and ScalaCheck.</para>
  </sect1>

  <sect1 id="IntegrationWithIDEs">
    <title>Integration with IDEs</title>

    <para id="para_java_background">If you come from a Java background, you
    are probably a little bit spoiled by the rich features of today&#x2019;s Java
    IDEs. Scala IDE support is not yet as good, but it is evolving rapidly in
    Eclipse, IntelliJ IDEA, and NetBeans. At the time of this writing, all the
    Scala plugins for these IDEs support syntax highlighting, project
    management, limited <phrase role="keep-together">support</phrase> for
    automated refactorings, etc. While each of the plugins has particular
    advantages over the others, they are all close enough in functionality
    that you will probably find it acceptable to adopt the plugin for the IDE
    that you already prefer.<indexterm class="startofrange" id="ch14_IDEs">
        <primary>IDEs (integrated development environments)</primary>
      </indexterm></para>

    <para id="para_this_section_describes_how_to_">This section describes how
    to use the Scala support available in Eclipse, IntelliJ IDEA, and
    NetBeans. We assume you already know how to use each IDE for development
    in other languages, like Java.</para>

    <sect2 id="_eclipse">
      <title>Eclipse</title>

      <para id="para_for_details_on_the_eclipse_sca">For details on the
      Eclipse Scala plugin, start at this web page, <ulink url="http://www.scala-lang.org/node/94"/>. If you are interested
      in contributing to the development of the plugin, see this web page,
      <ulink url="http://lampsvn.epfl.ch/trac/scala/wiki/EclipsePlugin"/>.<indexterm>
          <primary>Eclipse IDE</primary>

          <secondary>installing Scala plugin</secondary>
        </indexterm><indexterm>
          <primary>IDEs (integrated development environments)</primary>

          <secondary>Eclipse</secondary>

          <tertiary>installing Scala plugin</tertiary>
        </indexterm></para>

      <sect3 id="_installing_the_scala_plugin">
        <title>Installing the Scala plugin</title>

        <para id="para_the_plugin_requires_jdk_5_or_h">The plugin requires JDK
        5 or higher (JDK 6 is recommended) and Eclipse 3.3 or higher (Eclipse
        3.4 is recommended). The plugin installs the Scala SDK itself. To
        install the plugin, invoke the &#x201C;Software Updates&#x201D; command in the Help
        menu.</para>

        <para id="para_click_the__available_software_">Click the Available
        Software tab and click the &#x201C;Add Site&#x2026;&#x201D; button on the righthand side.
        You will see the dialog shown in <xref linkend="eclipse-add-site"/>.</para>

        <figure float="none" id="eclipse-add-site">
          <title>The Add Site Eclipse dialog</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1401.pdf" format="PDF" scale="90"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1401.png" format="PNG" scale="90"/>
            </imageobject>
          </mediaobject>
        </figure>

        <?dbfo-need height=”1in”
?>

        <para id="para_enter_the_url_that_shown_in_th">Enter the URL that is
        shown in the figure, <ulink url="http://www.scala-lang.org/scala-eclipse-plugin"/>. Some
        people prefer to work with the <emphasis>nightly</emphasis> releases,
        <ulink url="http://www.scala-lang.org/scala-eclipse-plugin-nightly"/>,
        but you should be aware that there is no guarantee they will
        work!</para>

        <para id="para_select_the_check_box_next_to_t">Select the checkbox
        next to the newly added update site and click the Install button, as
        indicated in <xref linkend="eclipse-install-scala2"/>.
        <emphasis>Don&#x2019;t</emphasis> click the &#x201C;default&#x201D; Close button!</para>

        <figure float="none" id="eclipse-install-scala2">
          <title>The Software Updates and Add-ons dialog</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1402.pdf" format="PDF"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1402.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>

        <warning id="para_warning_it_is_easy_to_be_conf">
          <para>It is easy to be confused by the poor usability of the
          Software Updates dialog.</para>
        </warning>

        <para id="para_after_finding_the_plugin_on_th">After finding the
        plugin on the update site, an Install dialog is presented. Click
        through the sequence of screens to complete the installation. You will
        be asked to restart Eclipse when the installation completes.</para>
      </sect3>

      <sect3 id="_developing_scala_applications">
        <title>Developing Scala applications</title>

        <para id="para_once_the_plugin_is_installed_">Once the plugin is
        installed, you can create Scala projects using the File &#x2192; New &#x2192; Other&#x2026;
        menu item. You will find a <emphasis>Scala Wizards</emphasis> folder
        that contains a wizard called Scala Project. This wizard works just
        like the familiar Java Project Wizard.<indexterm>
            <primary>Eclipse IDE</primary>

            <secondary>developing Scala applications</secondary>
          </indexterm><indexterm>
            <primary>IDEs (integrated development environments)</primary>

            <secondary>Eclipse</secondary>

            <tertiary>developing Scala applications</tertiary>
          </indexterm></para>

        <para id="para_you_can_work_with_your_scala_p">You can work with your
        Scala project using most of the same commands you would use with a
        typical Java project. For example, you can create a new Scala
        <literal>trait</literal>, <literal>class</literal>, or
        <literal>object</literal> using the context menu.</para>

        <para id="para_the_eclipse_scala_plugin_still">The Eclipse Scala
        plugin still has some rough edges, but Scala developers using Eclipse
        should find it acceptable for their daily needs.</para>
      </sect3>
    </sect2>

    <sect2 id="_intellij">
      <title>IntelliJ</title>

      <para id="para_the_intellij__idea__team_provi">The IntelliJ
      <emphasis>IDEA</emphasis> team provides a
      <emphasis>beta</emphasis>-quality Scala plugin. Start here for details:
      <ulink url="http://www.jetbrains.net/confluence/display/SCA/Scala+Plugin+for+IntelliJ+IDEA"/>.<indexterm>
          <primary>IntelliJ IDEA</primary>

          <secondary>installing Scala plugins</secondary>
        </indexterm><indexterm>
          <primary>IDEs (integrated development environments)</primary>

          <secondary>IntelliJ</secondary>

          <tertiary>installing Scala plugins</tertiary>
        </indexterm></para>

      <sect3 id="_installing_the_scala_plugins">
        <title>Installing the Scala plugins</title>

        <para id="para_to_use_the_plugin_you_must_us">To use the plugin, you
        must use IntelliJ 8.0.X or later. Consider using the most recent &#x201C;EAP&#x201D;
        build for the latest feature updates.</para>

        <para id="para_to_install_the_scala_plugin_s">To install the Scala
        plugin, start IDEA. Open the Settings panel, e.g., using the File &#x2192;
        Settings menu item. On the lefthand side, scroll down to and click the
        Plugins item, as shown in <xref linkend="idea-settings-plugins"/>.</para>

        <figure float="none" id="idea-settings-plugins">
          <title>IntelliJ IDEA Settings &#x2192; Plugins</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1403.pdf" format="PDF"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1403.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para id="para_select_the__available__tab_on_">Select the Available
        tab on the righthand side. Scroll down to the Scala plugin, as shown
        in <xref linkend="idea-settings-plugins-scala"/>.</para>

        <figure float="none" id="idea-settings-plugins-scala">
          <title>Available IntelliJ IDEA Scala plugins</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1404.pdf" format="PDF"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1404.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>

        <?dbfo-need height=”2in”
?>

        <para id="para_right_click_the__scala__plugin">Right-click the Scala
        plugin name and select &#x201C;Download and Install&#x201D; from the menu. Repeat
        for the Scala Application plugin. You will have to restart IDEA for
        the plugins to be enabled.</para>

        <para id="para_after_idea_restarts_confirm_t">After IDEA restarts,
        confirm that the two plugins were installed correctly by reopening the
        Plugin Manager. Click the Installed tab and scroll down to find the
        two Scala plugins. They should be listed with a black font, and the
        checkboxes next to them should be checked, as seen in <xref linkend="idea-settings-plugins-confirm"/>.</para>

        <figure float="none" id="idea-settings-plugins-confirm">
          <title>Installed IntelliJ IDEA Scala plugins</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1405.pdf" format="PDF"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1405.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para id="para_if_the_font_is_red_or_the_chec">If the font is red or
        the checkboxes are not checked, refer to the Scala plugin web page
        above for debugging help.<indexterm>
            <primary>IntelliJ IDEA</primary>

            <secondary>developing Scala applications</secondary>
          </indexterm></para>
      </sect3>

      <sect3 id="_developing_scala_applications_2">
        <title>Developing Scala applications</title>

        <para id="para_to_create_an_idea_scala_project_sta">To create an IDEA
        Scala project, start by selecting the File &#x2192; New Project menu item. In
        the dialog, select the appropriate radio button for your situation,
        e.g., &#x201C;Create New Project from Scratch.&#x201D;</para>

        <para id="para_on_the_next_screen_select__ja">On the next screen,
        select &#x201C;Java Module&#x201D; and fill in the usual project information. An
        example is shown in <xref linkend="idea-new-project1a"/>.<indexterm>
            <primary>IDEs (integrated development environments)</primary>

            <secondary>IntelliJ</secondary>

            <tertiary>developing Scala applications</tertiary>
          </indexterm></para>

        <figure float="none" id="idea-new-project1a">
          <title>Specifying IntelliJ IDEA Scala project details</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1406.pdf" format="PDF"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1406.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para id="para_click_through_to_the_screen_ti">Click through to the
        screen titled &#x201C;Please Select Desired Technology.&#x201D; Check the &#x201C;Scala&#x201D;
        checkbox, and check the &#x201C;New Scala SDK&#x201D; checkbox. Click the button
        labeled &#x201C;&#x2026;&#x201D; to navigate to the location of your Scala SDK
        installation, as shown in <xref linkend="idea-new-project1b"/>. You
        will only need to specify the SDK the first time you create a project
        or when you install a new SDK in a different location.</para>

        <figure float="none" id="idea-new-project1b">
          <title>Adding Scala to the IntelliJ IDEA project</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1407.pdf" format="PDF"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1407.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para id="para_click__finish__you_will_be_pr">Click Finish. You will
        be prompted to create either a project or an application. Select
        &#x201C;Application&#x201D; if you want to share this project with other Scala
        projects on the same machine.</para>

        <para id="para_now_you_can_work_with_your_sca">Now you can work with
        your Scala project using most of the same commands you would use with
        a typical Java project. For example, you can create a new Scala
        <literal>trait</literal>, <literal>object</literal>, or
        <literal>class</literal> using the context menu, as for Java
        projects.</para>

        <para id="para_the_intellij_idea_scala_plugin">The IntelliJ IDEA Scala
        plugin is still <emphasis>beta</emphasis>-quality, but Scala
        developers using IDEA should find it acceptable for their daily
        needs.</para>
      </sect3>
    </sect2>

    <sect2 id="_netbeans">
      <title>NetBeans</title>

      <para id="para_netbeans_has__beta__quality_sc">NetBeans has
      <emphasis>beta</emphasis>-quality Scala plugins. Start at this web page
      for details, <ulink url="http://wiki.netbeans.org/Scala"/>.
      NetBeans 6.5 or a more recent nightly build is required. The Scala
      plugin contains a version of the Scala SDK. The wiki page provides
      instructions for using a different SDK, when desired.<indexterm>
          <primary>NetBeans</primary>

          <secondary>installing Scala plugins</secondary>
        </indexterm><indexterm>
          <primary>IDEs (integrated development environments)</primary>

          <secondary>NetBeans</secondary>

          <tertiary>installing Scala plugins</tertiary>
        </indexterm></para>

      <sect3 id="_installing_the_scala_plugins_2">
        <title>Installing the Scala plugins</title>

        <para id="para_to_install_the_plugin_downloa">To install the plugin,
        download the plugins ZIP file from <ulink url="http://sourceforge.net/project/showfiles.php?group_id=192439&amp;package_id=256544"/>.
        Unzip the file in a convenient directory.</para>

        <para id="para_start_netbeans_and_invoke_the_">Start NetBeans and
        invoke the Tools &#x2192; Plugins menu item. Select the Downloaded tab and
        click the &#x201C;Add Plugins&#x2026;&#x201D; button. Choose the directory where the Scala
        plugins are unzipped, and select all the listed
        <filename>*.nbm</filename> files, as shown in <xref linkend="netbeans-add-plugins"/>. Click Open.</para>

        <figure float="none" id="netbeans-add-plugins">
          <title>Adding the Scala plugins to be installed</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1408.pdf" format="PDF" scale="90"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1408.png" format="PNG" scale="90"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para id="para_back_in_the__plugins__dialog_">Back in the Plugins
        dialog, make sure the checkboxes for all the new plugins are checked.
        Click Install.</para>

        <para id="para_click_through_the_installation">Click through the
        installation dialog and restart NetBeans when finished.</para>
      </sect3>

      <sect3 id="_developing_scala_applications_3">
        <title>Developing Scala applications</title>

        <para id="para_to_create_a_netbeans_scala_project_sta">To create a
        NetBeans Scala Project, start by selecting the File &#x2192; New Project menu
        item or clicking the New Project button. In the pop-up dialog, select
        &#x201C;Scala&#x201D; under Categories and &#x201C;Scala Application&#x201D; under Projects, as
        shown in <xref linkend="netbeans-new-project1"/>. Click
        Next.<indexterm>
            <primary>IDEs (integrated development environments)</primary>

            <secondary>NetBeans</secondary>

            <tertiary>developing Scala applications</tertiary>
          </indexterm><indexterm>
            <primary>NetBeans</primary>

            <secondary>developing Scala applications</secondary>
          </indexterm></para>

        <figure float="none" id="netbeans-new-project1">
          <title>Creating a new NetBeans Scala project</title>

          <mediaobject>
            <imageobject role="print">
              <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1409.pdf" format="PDF"/>
            </imageobject>

            <imageobject role="web">
              <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1409.png" format="PNG"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para id="para_fill_in_the_project_name_loca">Fill in the project
        name, location, etc., and click Finish.</para>

        <para id="para_once_the_project_is_creates_y">Once the project is
        created, you can work with it using most of the same commands you
        would use with a typical Java project. There are some differences. For
        example, when you invoke the New item in the context menu, the submenu
        does not show items for creating new Scala types. Instead, you have
        invoke the Other&#x2026; menu item and work through a dialog. This will be
        changed in a future release.</para>

        <para id="para_despite_some_minor_issues_like">Despite some minor
        issues like this, the NetBeans Scala plugin is mature enough for
        regular use.</para>
      </sect3>
    </sect2>

    <sect2 id="_text_editors">
      <title>Text Editors</title>

      <para id="para_the_sbaz_tool_manages_the_s">The <literal>sbaz</literal>
      tool manages the <literal>scala-tool-support</literal> package that
      includes Scala plugins for several editors, including Emacs, Vim,
      TextMate and others. Like <literal>sbaz</literal>, the
      <literal>scala-tool-support</literal> package is also included with the
      language installation. See the directories in
      <replaceable>scala-home</replaceable><filename>/misc/scala-tool-support</filename>
      for the supported editors. Most of the <phrase role="keep-together">editor-</phrase><phrase role="keep-together">specific</phrase> directories contain instructions
      for installing the plugin. In other cases, consult your editor&#x2019;s
      instructions for installing third-party plugins.<indexterm>
          <primary>Mac OS X</primary>

          <secondary>TextMate editor</secondary>
        </indexterm><indexterm>
          <primary>Vim editor</primary>
        </indexterm><indexterm>
          <primary>Emacs editor</primary>
        </indexterm><indexterm>
          <primary>TextMate editor</primary>
        </indexterm><indexterm>
          <primary>scala-tool-support package</primary>
        </indexterm><indexterm>
          <primary>text editors</primary>
        </indexterm><indexterm>
          <primary>IDEs (integrated development environments)</primary>

          <secondary>text editors</secondary>
        </indexterm></para>

      <para id="para_some_of_the_packages_are_fairl">Some of the packages are
      fairly immature. If you want to contribute to the Scala community,
      please consider improving the quality of the existing plugins or
      contributing new plugins.<indexterm class="endofrange" startref="ch14_IDEs"/></para>

      <note id="para_note_at_the_time_of_this_writ">
        <para>At the time of this writing, there are several variations of a
        Scala &#x201C;bundle&#x201D; for the TextMate editor, which is a popular text editor
        for Mac OS X. These bundles are currently being managed by Paul
        Phillips on the <ulink url="http://github.com/paulp/scala-textmate/tree/master">GitHub
        website</ulink>. Hopefully, the best features of each bundle will be
        unified into an &#x201C;authoritative&#x201D; bundle and integrated back into the
        <literal>scala-tool-support</literal> <phrase role="keep-together">package</phrase>.</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="_test_driven_development_in_scala">
    <title>Test-Driven Development in Scala</title>

    <para id="para_one_of_the_most_important_deve">One of the most important
    developer practices introduced in the last decade is <emphasis>Test-Driven
    Development</emphasis> (TDD). The Scala community has created several
    tools to support TDD.<indexterm class="startofrange" id="ch14_TDD">
        <primary>TDD (Test-Driven Development)</primary>
      </indexterm></para>

    <para id="para_if_you_work_in_a_pure_java">If you work in a &#x201C;pure&#x201D; Java
    shop, consider introducing one or more of these Scala testing tools to
    test-drive your Java code. This approach is a low-risk way to introduce
    Scala to your environment, so you can gain experience with it before
    making the commitment to Scala as your production code language. In
    particular, you might experiment with ScalaTest (see <xref linkend="ScalaTest" xrefstyle="select:nopage"/> next), which can be used
    with JUnit (<link linkend="JUnit" xrefstyle="select:nopage">[JUnit]</link>) and TestNG (<link linkend="TestNG" xrefstyle="select:nopage">[TestNG]</link>). You might
    also consider ScalaCheck or Reductio (see <xref linkend="ScalaCheck"/>),
    which offer innovations that may not be available in Java testing
    frameworks. All of the tools we describe here integrate with Java testing
    and build tools, like JUnit, TestNG, various mocking libraries, Ant (<link linkend="Ant" xrefstyle="select:nopage">[Ant]</link>), and Maven (<link linkend="Maven" xrefstyle="select:nopage">[Maven]</link>). All of them
    also offer convenient Scala DSLs for testing.</para>

    <sect2 id="ScalaTest">
      <title>ScalaTest</title>

      <para id="para_scala_s_version_of_the_venerab">Scala&#x2019;s version of the
      venerable XUnit tool is ScalaTest, available at <ulink url="http://www.artima.com/scalatest/"/>.<indexterm>
          <primary>ScalaTest</primary>
        </indexterm><indexterm>
          <primary>TDD (Test-Driven Development)</primary>

          <secondary>ScalaTest tool</secondary>
        </indexterm></para>

      <para id="para_you_can_drive_your_tests_using">You can drive your tests
      using the built-in <literal>Runner</literal> or use the provided
      integration with JUnit or TestNG. ScalaTest also comes with an Ant task
      and it works with the ScalaCheck testing tool (described later).</para>

      <para id="para_besides_supporting_the_traditi">Besides supporting the
      traditional XUnit-style syntax with test methods and assertions,
      ScalaTest provides a <emphasis>Behavior-Driven Development</emphasis>
      (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>) syntax that
      is becoming increasingly popular. The <ulink url="http://www.artima.com/scalatest/"><emphasis>ScalaTest</emphasis>
      website</ulink> provides examples for these and other options.<indexterm>
          <primary>BDD (Behavior-Driven Development)</primary>

          <secondary>BDD syntax provided by ScalaTest</secondary>
        </indexterm></para>

      <para id="para_here_is_an_example_test_for_th">Here is an example
      ScalaTest test for the simple <literal>Complex</literal> class we used
      in <xref linkend="CommandLineToolDecompilers"/>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-test.scala

import org.scalatest.FunSuite

class ComplexSuite extends FunSuite {

  val c1 = Complex(1.2, 3.4)
  val c2 = Complex(5.6, 7.8)

  test("addition with (0, 0)") {
    assert(c1 + Complex(0.0, 0.0) === c1)
  }

  test("subtraction with (0, 0)") {
    assert(c1 - Complex(0.0, 0.0) === c1)
  }

  test("addition") {
    assert((c1 + c2).real === (c1.real + c2.real))
    assert((c1 + c2).imaginary === (c1.imaginary + c2.imaginary))
  }

  test("subtraction") {
    assert((c1 - c2).real === (c1.real - c2.real))
    assert((c1 - c2).imaginary === (c1.imaginary - c2.imaginary))
  }
}</programlisting>

      <para id="para_this_particular_example_uses_t">This particular example
      uses the &#x201C;function value&#x201D; syntax for each test that is provided by the
      <literal>FunSuite</literal> parent trait. Each call to
      <literal>test</literal> receives as arguments a descriptive string and a
      <emphasis>function literal</emphasis> with the actual test code.</para>

      <para id="para_the_following_commands_compile">The following commands
      compile <filename>complex.scala</filename> and
      <filename>complex-test.scala</filename>, putting the class files in a
      <filename>build</filename> directory, and then run the tests. Note that
      we assume that <filename role="http://github.com/paulp/scala-textmate/tree/master">scalatest-0.9.5.jar</filename>
      (the latest release at the time of this writing) is in the
      <filename>../lib</filename> directory. The downloadable distribution of
      the code examples is organized this way:</para>

      <screen>scalac -classpath ../lib/scalatest-0.9.5.jar -d build complex.scala complex-test.scala
scala -classpath build:../lib/scalatest-0.9.5.jar org.scalatest.tools.Runner \
  -p build -o -s ComplexSuite</screen>

      <para>(We used a <literal>\</literal> to continue the long command on a
      second line.) The output is the following:</para>

      <screen>Run starting. Expected test count is: 4
Suite Starting - ComplexSuite: The execute method of a nested suite is \
   about to be invoked.
Test Starting - ComplexSuite: addition with (0, 0)
Test Succeeded - ComplexSuite: addition with (0, 0)
Test Starting - ComplexSuite: subtraction with (0, 0)
Test Succeeded - ComplexSuite: subtraction with (0, 0)
Test Starting - ComplexSuite: addition
Test Succeeded - ComplexSuite: addition
Test Starting - ComplexSuite: subtraction
Test Succeeded - ComplexSuite: subtraction
Suite Completed - ComplexSuite: The execute method of a nested suite \
  returned normally.
Run completed. Total number of tests run was: 4
All tests passed.</screen>

      <para id="para_again_we_wrapped_the_long_out">Again, we wrapped the long
      output lines with a <literal>\</literal>.</para>
    </sect2>

    <sect2 id="ScalaSpecs">
      <title>Specs</title>

      <para id="para_the__specs__library_http_co">The Specs library (<link linkend="ScalaSpecsTool" xrefstyle="select:nopage">[ScalaSpecsTool]</link>) is a Behavior-Driven
      Development (<link linkend="BDD" xrefstyle="select:nopage">[BDD]</link>)
      testing tool for Scala. It is inspired by Ruby&#x2019;s RSpec (<link linkend="RSpec" xrefstyle="select:nopage">[RSpec]</link>). In a
      nutshell, the goal of BDD is to recast traditional test syntax into a
      form that better emphasizes the role of TDD as a process that drives
      <emphasis>design</emphasis>, which in turn should implement the
      <emphasis>requirements</emphasis> &#x201C;specification.&#x201D; The syntax of
      traditional TDD tools, like the XUnit frameworks, tend to emphasize the
      <emphasis>testing</emphasis> role of TDD. With the syntax realigned, it
      is believed that the developer will be more likely to stay focused on
      the <emphasis>primary</emphasis> role of TDD: driving application
      design.<indexterm>
          <primary>requirements specification</primary>
        </indexterm><indexterm class="startofrange" id="ch14_BDDSpecs">
          <primary>BDD (Behavior-Driven Development)</primary>

          <secondary>Specs library</secondary>
        </indexterm><indexterm class="startofrange" id="ch14_TDDSpecs">
          <primary>TDD (Test-Driven Development)</primary>

          <secondary>Specs library</secondary>
        </indexterm><indexterm class="startofrange" id="ch14_Specs">
          <primary>Specs library</primary>
        </indexterm></para>

      <para id="para_you_can_also_find_documentation">You can also find
      documentation on Specs at <link linkend="ScalaTools" xrefstyle="select:nopage">[ScalaTools]</link>.</para>

      <para id="para_we_have_already_used__specs__i">We have already used
      Specs in several examples in the book, e.g.,
      <literal>ButtonObserverSpec</literal> in <xref linkend="TraitsAsMixins"/>. Here is another example for the simple
      <literal role="keep-together">Complex</literal> class we showed
      previously:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-spec.scala

import org.specs._

object ComplexSpec extends Specification {
  "Complex addition with (0.0, 0.0)" should {
    "return a number N' that is identical to original number N" in {
      val c1 = Complex(1.2, 3.4)
      (c1 + Complex(0.0, 0.0)) mustEqual c1
    }
  }
  "Complex subtraction with (0.0, 0.0)" should {
    "return a number N' that is identical to original number N" in {
      val c1 = Complex(1.2, 3.4)
      (c1 - Complex(0.0, 0.0)) mustEqual c1
    }
  }
  "Complex addition" should {
    """return a new number where
    the real and imaginary parts are the sums of the
    input values' real and imaginary parts, respectively.""" in {
      val c1 = Complex(1.2, 3.4)
      val c2 = Complex(5.6, 7.8)
      (c1 + c2).real mustEqual (c1.real + c2.real)
      (c1 + c2).imaginary mustEqual (c1.imaginary + c2.imaginary)
    }
  }
  "Complex subtraction" should {
    """return a new number where
    the real and imaginary parts are the differences of the
    input values' real and imaginary parts, respectively.""" in {
      val c1 = Complex(1.2, 3.4)
      val c2 = Complex(5.6, 7.8)
      (c1 - c2).real mustEqual (c1.real - c2.real)
      (c1 - c2).imaginary mustEqual (c1.imaginary - c2.imaginary)
    }
  }
}</programlisting>

      <para id="para_an_object_that_extends_spec">An <literal>object</literal>
      that extends <literal>Specification</literal> is the analog of a test
      suite. The next level of grouping, e.g., the clause <literal>"Complex
      addition with (0.0, 0.0)" should {...}</literal>, encapsulates the
      information at the level of the type being tested, or perhaps a
      &#x201C;cluster&#x201D; of behaviors that go together for the type.</para>

      <para id="para_the_next_level_clause__e_g__">The next level clause,
      e.g., the clause <literal>"return a number N' that is identical to
      orig&#x2060;inal number N" in {...}</literal>, is called an &#x201C;example&#x201D; in BDD
      terminology. It is analogous to a single test. Like typical XUnit
      frameworks, the testing is done using &#x201C;representative examples,&#x201D; rather
      than by doing an exhaustive exploration of the entire &#x201C;space&#x201D; of
      possible states. Hence, the term &#x201C;example.&#x201D; (However, see the discussion
      of <phrase role="keep-together">ScalaCheck</phrase> next.)</para>

      <para id="para_statements_like_c1_complex">Statements like <literal>(c1
      + Complex(0.0, 0.0)) mustEqual c1</literal> are called &#x201C;expectations.&#x201D;
      They do the actual verifications that conditions are satisfied. Hence,
      expectations are analogous to assertions in XUnit tools.<indexterm>
          <primary>expectations</primary>
        </indexterm></para>

      <para id="para_there_are_several_ways_to_run_">There are several ways to
      run your specs. After compiling <filename>complex-spec.scala</filename>
      earlier, we can run the specs as follows:</para>

      <screen>scala -classpath ../lib/specs-1.4.3.jar:build ComplexSpec</screen>

      <para id="para_here_as_before_we_assume_the">Here, as before, we assume
      the <filename>Specs</filename> JAR is in the <filename>../lib</filename>
      directory and we assume the compiled class files are in the
      <filename>build</filename> directory. We get the following
      output:</para>

      <screen>Specification "ComplexSpec"
  Complex addition with (0.0, 0.0) should
  + return a number N' that is identical to original number N

  Total for SUT "Complex addition with (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  Complex subtraction with (0.0, 0.0) should
  + return a number N' that is identical to original number N

  Total for SUT "Complex subtraction with (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  Complex addition should
  + return a new number where
        the real and imaginary parts are the sums of the
        input values real and imaginary parts, respectively.

  Total for SUT "Complex addition":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

  Complex subtraction should
  + return a new number where
        the real and imaginary parts are the differences of the
        input values real and imaginary parts, respectively.

  Total for SUT "Complex subtraction":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

Total for specification "ComplexSpec":
Finished in 0 second, 37 ms
4 examples, 6 expectations, 0 failure, 0 error</screen>

      <para id="para_note_that_the_strings_in_the_s">Note that the strings in
      the specification are written in a form that reads somewhat like a
      requirements specification:</para>

      <screen>...
Complex addition with (0.0, 0.0) should
+ return a number N' that is identical to original number N
...</screen>

      <para id="para_there_are_many_ways_to_run_spe">There are many ways to
      run specifications, including using an Ant task or using the built-in
      integration with ScalaTest or JUnit. JUnit is the best approach for
      running specifications in some IDEs. These and other options are
      described in the User&#x2019;s Guide at <ulink url="http://code.google.com/p/specs/wiki/RunningSpecs"/>.<indexterm class="endofrange" startref="ch14_BDDSpecs"/><indexterm>
          <primary>JUnit</primary>

          <secondary>running specifications</secondary>
        </indexterm><indexterm class="endofrange" startref="ch14_TDDSpecs"/><indexterm class="endofrange" startref="ch14_Specs"/></para>
    </sect2>

    <sect2 id="ScalaCheck">
      <title>ScalaCheck</title>

      <para id="para__scalacheck__http_code_goog">ScalaCheck (<link linkend="ScalaCheckTool" xrefstyle="select:nopage">[ScalaCheckTool]</link> is a Scala port of the
      innovative Haskell QuickCheck (<link linkend="QuickCheck" xrefstyle="select:nopage">[QuickCheck]</link>) tool that supports
      <emphasis>Automated Specification-Based Testing</emphasis>, sometimes
      called <emphasis>type-based &#x201C;property&#x201D; testing</emphasis> in the Haskell
      literature (e.g., <link linkend="OSullivan2009" xrefstyle="select:nopage">[O&#x2019;Sullivan2009]</link>).<indexterm>
          <primary>QuickCheck (Haskell)</primary>
        </indexterm><indexterm>
          <primary>Haskell, QuickCheck tool</primary>
        </indexterm><indexterm>
          <primary>ScalaCheck</primary>
        </indexterm><indexterm>
          <primary>TDD (Test-Driven Development)</primary>

          <secondary>ScalaCheck tool</secondary>
        </indexterm></para>

      <para id="para__scalacheck__can_be_installed_">ScalaCheck can be
      installed using <literal>sbaz</literal>, i.e., <literal>sbaz install
      scalacheck</literal>.<indexterm>
          <primary>sbaz tool</primary>

          <secondary>installing ScalaCheck</secondary>
        </indexterm></para>

      <para id="para_using__scalacheck__or__quickc">Using ScalaCheck (or
      QuickCheck for Haskell), conditions for a type are specified that should
      be true for any instances of the type. The tool tries the conditions
      using automatically generated instances of the type and verifies that
      the conditions are satisfied.</para>

      <para id="para_here_is_a__scalacheck__test_fo">Here is a ScalaCheck test
      for <literal>Complex</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-check-script.scala

import org.scalacheck._
import org.scalacheck.Prop._

def toD(i: Int) = i * .1

implicit def arbitraryComplex: Arbitrary[Complex] = Arbitrary {
  Gen.sized {s =&gt;
    for {
      r &lt;- Gen.choose(-toD(s), toD(s))
      i &lt;- Gen.choose(-toD(s), toD(s))
    } yield Complex(r, i)
  }
}

object ComplexSpecification extends Properties("Complex") {
  def additionTest(a: Complex, b: Complex) =
    (a + b).real.equals(a.real + b.real) &amp;&amp;
    (a + b).imaginary.equals(a.imaginary + b.imaginary)

  def subtractionTest(a: Complex, b: Complex) =
    (a - b).real.equals(a.real - b.real) &amp;&amp;
    (a - b).imaginary.equals(a.imaginary - b.imaginary)

  val zero = Complex(0.0, 0.0)

  specify("addition with (0,0)", (a: Complex)  =&gt; additionTest(a, zero))
  specify("subtraction with (0,0)", (a: Complex)  =&gt; subtractionTest(a, zero))

  specify("addition", (a: Complex, b: Complex) =&gt; additionTest(a,b))
  specify("subtraction", (a: Complex, b: Complex) =&gt; subtractionTest(a,b))
}
ComplexSpecification.check</programlisting>

      <para id="para_the_tod_function_just_conver">The <literal>toD</literal>
      function just converts an <literal>Int</literal> to a
      <literal>Double</literal> by dividing by <literal>0.1</literal>. It&#x2019;s
      useful to convert an <literal>Int</literal> index provided by ScalaCheck
      into <literal>Double</literal> values that we will use to construct
      <literal>Complex</literal> instances.</para>

      <para id="para_we_also_need_an_implicit_conve">We also need an implicit
      conversion visible in the scope of the test that generates <phrase role="keep-together">new <literal>Complex</literal> </phrase>values. The
      <literal role="keep-together">arbitraryComplex</literal> function
      provides this generator. An <literal role="keep-together">Arbitrary[Complex]</literal> object (part of the
      ScalaCheck API) is returned by this method. <phrase role="keep-together">ScalaCheck</phrase> invokes another API method,
      <literal>Gen[Complex].sized</literal>. We provide a <emphasis>function
      literal</emphasis> that assigns a passed-in <literal>Int</literal> value
      to a variable <literal>s</literal>. We then use a <literal>for</literal>
      comprehension to return <literal>Complex</literal> numbers with real and
      imaginary parts that range from <literal>-toD(s)</literal> to
      <literal>toD(s)</literal> (i.e., <literal>-(s * .1)</literal> to
      <literal>(s * .1)</literal>). Fortunately, you don&#x2019;t have to define
      implicit conversions or generators for most of the commonly used Scala
      and Java types.</para>

      <para id="para_the_most_interesting_part_is_t">The most interesting part
      is the definition and use of <literal>ComplexSpecification</literal>.
      This object defines a few helper methods,
      <literal>additionTest</literal> and <literal>subtractionTest</literal>,
      that each return <literal>true</literal> if the conditions they define
      are true. For <literal>additionTest</literal>, if a new
      <literal>Complex</literal> number is the sum of two other
      <literal>Complex</literal> numbers, then its <literal>real</literal>
      part must equal the sum of the <literal>real</literal> parts of the two
      original numbers. Likewise, a similar condition must hold for the
      <literal>imaginary</literal> part of the numbers. For
      <literal>subtractionTest</literal>, the same conditions must hold with
      subtraction substituted for addition.</para>

      <para id="para_next_two_specify_clauses_as">Next, two
      <literal>specify</literal> clauses assert that the addition and
      subtraction conditions should hold for any <literal>Complex</literal>
      number when <literal>Complex(0.0, 0.0)</literal> is added to it or
      subtracted from it, respectively. Two more <literal>specify</literal>
      classes assert that the conditions should also hold for any pair of
      <literal>Complex</literal> numbers.</para>

      <para id="para_finally_when_complexspecific">Finally, when
      <literal>ComplexSpecification.check</literal> is called, test runs are
      made with different values of <literal>Complex</literal> numbers,
      verifying that the properties specified are valid for each combination
      of numbers passed to the helper methods.</para>

      <para id="para_we_can_run_the_check_using_the">We can run the check
      using the following command (once again assuming that <literal role="keep-together">Complex</literal> is already compiled into the
      <filename>build</filename> directory):</para>

      <screen>scala -classpath ../lib/scalacheck.jar:build complex-check-script.scala</screen>

      <para id="para_it_produces_the_following_outp">It produces the following
      output:</para>

      <screen>+ Complex.addition with (0,0): OK, passed 100 tests.
+ Complex.addition: OK, passed 100 tests.
+ Complex.subtraction with (0,0): OK, passed 100 tests.
+ Complex.subtraction: OK, passed 100 tests.</screen>

      <para id="para_note_that_by_default__scalach">Note that ScalaCheck tried
      each <literal>specify</literal> case with 100 different inputs.</para>

      <para id="para_it_s_important_to_understand_t">It&#x2019;s important to
      understand the value that ScalaCheck delivers. Rather than going through
      the process of writing enough &#x201C;example&#x201D; test cases with representative
      data, which is tedious and error-prone, we define reusable &#x201C;generators,&#x201D;
      like the <literal>arbitraryComplex</literal> function, to produce an
      appropriate range of instances of the type under test. Then we write
      property specifications that should hold for any instances. ScalaCheck
      does the work of testing the properties against a random sample of the
      instances produced by the generators.</para>

      <para id="para_you_can_find_more_examples_of_">You can find more
      examples of ScalaCheck usage in the online code examples. Some of the
      types used in the payroll example in <xref linkend="InternalDSLs"/>
      were tested with ScalaCheck. These tests were not shown in <xref linkend="InternalDSLs"/>.</para>

      <para id="para_finally_note_that_there_is_an">Finally, note that there
      is another port of QuickCheck called <emphasis>Reductio</emphasis>. It
      is part of the <emphasis>Functional Java</emphasis> project (<link linkend="FunctionalJava" xrefstyle="select:nopage">[FunctionalJava]</link>).
      <emphasis>Reductio</emphasis> is less widely used than ScalaCheck, but
      it offers a &#x201C;native&#x201D; Java API as well as a Scala API, so it would be
      more convenient for &#x201C;pure&#x201D; Java teams.<indexterm>
          <primary>Functional Java project</primary>
        </indexterm><indexterm>
          <primary>Reductio tool</primary>
        </indexterm><indexterm class="endofrange" startref="ch14_TDD"/></para>
    </sect2>
  </sect1>

  <sect1 id="OtherLibraries">
    <title>Other Notable Scala Libraries and Tools</title>

    <para id="para_while_scala_benefits_from_the_">While Scala benefits from
    the rich legacy of Java and .NET libraries, there is a growing collection
    of libraries written specifically for Scala. Here we discuss some of the
    more notable ones.<indexterm>
        <primary>libraries</primary>

        <secondary>notable Scala libraries</secondary>
      </indexterm></para>

    <sect2 id="Lift">
      <title>Lift</title>

      <para id="para__lift__http_liftweb_net_i"><emphasis><ulink url="http://liftweb.net/">Lift</ulink></emphasis> is the leading web
      application framework written in Scala. It recently reached &#x201C;1.0&#x201D;
      status. Lift has been used for a number of commercial websites. You can
      also find documentation on the Lift website.<indexterm>
          <primary>web application frameworks</primary>
        </indexterm><indexterm>
          <primary>Lift web framework</primary>
        </indexterm></para>

      <para id="para_other_web_frameworks_include_s">Other web frameworks
      include <ulink url="http://code.google.com/p/sweetscala/">Sweet</ulink>,
      <ulink url="http://bitbucket.org/pk11/pinky/wiki/Home">Pinky</ulink>,
      and <ulink url="http://code.google.com/p/slinky2/">Slinky</ulink>.</para>
    </sect2>

    <sect2 id="Scalaz">
      <title>Scalaz</title>

      <para id="para__scalaz__http_wiki_workingm"><emphasis><ulink url="http://code.google.com/p/scalaz/">Scalaz</ulink></emphasis> is a
      library that fills in gaps in the standard library. Among its features
      are enhancements to several core Scala types, such as <literal role="keep-together">Boolean</literal>, <literal>Unit</literal>,
      <literal>String</literal>, and <literal>Option</literal>, plus support
      for functional <emphasis>control</emphasis> abstractions, such as
      <literal>FoldLeft</literal>, <literal>FoldRight</literal>, and
      <literal>Monad</literal>, that expand upon what is available in the
      standard library.<indexterm>
          <primary>Scalaz library</primary>
        </indexterm></para>
    </sect2>

    <sect2 id="Scalax">
      <title>Scalax</title>

      <para id="para__scalax__http_scalax_scalaf"><emphasis><ulink url="http://scalax.scalaforge.org/">Scalax</ulink></emphasis> is another
      third-party library effort to supplement the Scala core
      library.<indexterm>
          <primary>Scalax library</primary>
        </indexterm></para>
    </sect2>

    <sect2 id="MetaScala">
      <title>MetaScala</title>

      <para id="para__metascala__http_www_assemb"><emphasis><ulink url="http://www.assembla.com/wiki/show/metascala">MetaScala</ulink></emphasis>
      is an experimental metaprogramming library for Scala. Metaprogramming
      features tend to be weaker in statically typed languages than in
      dynamically typed languages. Also, the JVM and .NET CLR impose their own
      constraints on metaprogramming.<indexterm>
          <primary>MetaScala library</primary>
        </indexterm></para>

      <para id="para_many_of_the_features_of_scala_">Many of the features of
      Scala obviate the need for metaprogramming, compared to languages like
      Ruby, but sometimes metaprogramming is still useful. MetaScala attempts
      to address those needs more fully than Scala&#x2019;s built-in reflection
      support.</para>
    </sect2>

    <sect2 id="JavaRebel">
      <title>JavaRebel</title>

      <para id="para__javarebel__is_a_commercial_to"><emphasis><ulink url="http://www.zeroturnaround.com/javarebel/">JavaRebel</ulink></emphasis>
      is a commercial tool that permits dynamic reloading of classes in a
      running JVM (written in any language), beyond the limited support
      provided natively by the &#x201C;HotSwap&#x201D; feature of the JVM. JavaRebel is
      designed to offer the developer faster turnaround for changes, providing
      an experience more like the rapid turnaround that users of dynamic
      languages enjoy. JavaRebel can be used with Scala code as
      well.<indexterm>
          <primary>JavaRebel tool</primary>
        </indexterm></para>
    </sect2>

    <sect2 id="MiscSmallerLibraries">
      <title>Miscellaneous Smaller Libraries</title>

      <para id="para_finally_here_is_a_list_of_sev">Finally, <xref linkend="misc-scala-libs"/> is a list of several Scala-specific
      libraries you might find useful for your applications.<indexterm>
          <primary>libraries</primary>

          <secondary>miscellaneous smaller Scala libraries</secondary>
        </indexterm></para>

      <table id="misc-scala-libs">
        <title>Miscellaneous Scala libraries</title>

        <tgroup cols="2">
          <thead valign="top">
            <row>
              <entry>Name</entry>

              <entry>Description and URL</entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para>Kestrel</para></entry>

              <entry><para>A tiny, very fast queue system (<ulink url="http://github.com/robey/kestrel/tree/master"/>).</para></entry>
            </row>

            <row>
              <entry><para>ScalaModules</para></entry>

              <entry><para>Scala DSL to ease OSGi development (<ulink url="http://code.google.com/p/scalamodules/"/>).</para></entry>
            </row>

            <row>
              <entry><para>Configgy</para></entry>

              <entry><para>Managing configuration files and logging for
              &#x201C;daemons&#x201D; written in Scala (<ulink url="http://www.lag.net/configgy/"/>).</para></entry>
            </row>

            <row>
              <entry><para>scouchdb</para></entry>

              <entry><para>Scala interface to CouchDB (<ulink url="http://code.google.com/p/scouchdb/"/>).</para></entry>
            </row>

            <row>
              <entry><para>Akka</para></entry>

              <entry><para>A project to implement a platform for building
              fault-tolerant, distributed applications based on REST, Actors,
              etc. (<ulink url="http://akkasource.org/"/>).</para></entry>
            </row>

            <row>
              <entry><para>scala-query</para></entry>

              <entry><para>A type-safe database query API for Scala (<ulink url="http://github.com/szeiger/scala-query/tree/master"/>).</para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_we_ll_discuss_using_scala_with">We&#x2019;ll discuss using Scala
      with several well-known Java libraries after we discuss Java
      interoperability, next.</para>
    </sect2>
  </sect1>

  <sect1 id="JavaInterop">
    <title>Java Interoperability</title>

    <para id="para_of_all_the_alternative_jvm_lan">Of all the alternative JVM
    languages, Scala&#x2019;s interoperability with Java source code is among the
    most seamless. This section begins with a discussion of interoperability
    with code written in Java. Once you understand the details, they can be
    generalized to address interoperability with other JVM languages, such as
    JRuby or Groovy. For example, if you already know how to use JRuby and
    Java together, and you know how to use Java and Scala together, then you
    can generalize to using JRuby and Scala together.<indexterm class="startofrange" id="ch14_JavaScala">
        <primary>Java</primary>

        <secondary>Scala interoperability with</secondary>
      </indexterm></para>

    <para id="para_because_scala_syntax_is_primar">Because Scala syntax is
    primarily a superset of Java syntax, invoking Java code from Scala is
    usually straightforward. Going the other direction requires that you
    understand how some Scala features are encoded in ways that satisfy the
    JVM specification. We discuss several of the interoperability issues here.
    <link linkend="Spiewak2009a" xrefstyle="select:nopage">[Spiewak2009a]</link> and <link linkend="Odersky2008" xrefstyle="select:nopage">[Odersky2008]</link>
    provide additional information.</para>

    <sect2 id="_java_and_scala_generics">
      <title>Java and Scala Generics</title>

      <para id="para_we_have_seen_many_examples_of_">We have seen many
      examples of Scala code that uses Java types, such as
      <literal>java.lang.String</literal> and various java collection classes.
      Instantiating Java generic types is straightforward in Scala (since
      Scala version 2.7.0). Consider the following very simple Java generic
      class, <literal>JStack</literal>:<indexterm>
          <primary>generics</primary>

          <secondary>Java</secondary>

          <tertiary>using from Scala</tertiary>
        </indexterm><indexterm class="startofrange" id="ch14_generics">
          <primary>generics</primary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>Scala interoperability with</secondary>

          <tertiary>Java and Scala generics</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/JStack.java

import java.util.*;

public class JStack&lt;T&gt; {
  private List&lt;T&gt; stack = new ArrayList&lt;T&gt;();
  public void push(T t) {
    stack.add(t);
  }
  public T pop() {
    return stack.remove(stack.size() - 1);
  }
}</programlisting>

      <para id="para_we_can_instantiate_it_from_sca">We can instantiate it
      from Scala, specifying the type parameter, as shown in <xref linkend="example_14-1"/>.</para>

      <example id="example_14-1">
        <title>A Scala &#x201C;spec&#x201D; to test the simple Java stack</title>

        <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/JStack-spec.scala

import org.specs._

object JStackSpec extends Specification {
  "Calling a Java generic type from Scala" should {
    "Support parameterization" in {
      val js = new JStack[String]
      js must notBe(null)  // Dummy check...
    }
    "Support invoking the the type's methods" in {
      val js = new JStack[String]
      js.push("one")
      js.push("two")
      js.pop() mustEqual "two"
      js.pop() mustEqual "one"
    }
  }
}</programlisting>
      </example>

      <para id="para_since_scala_version_2_7_2_you">Since Scala version 2.7.2,
      you can also use Scala generics from Java. Consider the following JUnit
      4 test, which shows some of the idiosyncrasies you might
      encounter:<indexterm>
          <primary>generics</primary>

          <secondary>Scala, using from Java</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/SMapTest.java

import org.junit.*;
import static org.junit.Assert.*;
import scala.*;
import scala.collection.mutable.LinkedHashMap;

public class SMapTest {
  static class Name {
    public String firstName;
    public String lastName;

    public Name(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName  = lastName;
    }
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  @Before
  public void setup() {
    map = new LinkedHashMap&lt;Integer, Name&gt;();
    map.update(1, new Name("Dean", "Wampler"));
    map.update(2, new Name("Alex", "Payne"));
  }

  @Test
  public void usingMapGetWithWarnings() {
    assertEquals(2, map.size());
    Option&lt;Name&gt; n1 = map.get(1);  // warning
    Option&lt;Name&gt; n2 = map.get(2);  // warning
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals("Dean", n1.get().firstName);
    assertEquals("Alex", n2.get().firstName);
  }

  @Test
  public void usingMapGetWithoutWarnings() {
    assertEquals(2, map.size());
    Option&lt;?&gt; n1 = map.get(1);
    Option&lt;?&gt; n2 = map.get(2);
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals("Dean", ((Name) n1.get()).firstName);
    assertEquals("Alex", ((Name) n2.get()).firstName);
 }
}</programlisting>

      <para id="para_on_unix_like_systems_it_is_co">On Unix-like systems, it
      is compiled with the following command line:</para>

      <screen>javac -Xlint:unchecked \
  -cp $SCALA_HOME/lib/scala-library.jar:$JUNIT_HOME/junit-4.4.jar SMapTest.java</screen>

      <para>(Again, we wrapped the long line with <literal>\</literal>.)
      <filename>SCALA_HOME</filename> and <filename>JUNIT_HOME</filename> are
      the installation directories of Scala and JUnit, respectively.</para>

      <para id="para_the_smaptest_class_defines_a">The
      <literal>SMapTest</literal> class defines a nested
      <literal>Name</literal> class that is used as the &#x201C;value&#x201D; type in a
      <literal>scala.collection.mutable.LinkedHashMap</literal>. For
      simplicity, <literal>Name</literal> has public
      <literal>firstName</literal> and <literal>lastName</literal> fields and
      a constructor.</para>

      <para id="para_the_setup_method_creates_a_n">The
      <literal>setup</literal> method creates a new
      <literal>LinkedHashMap&lt;Integer,Name&gt;</literal> and inserts two
      key-value pairs. The two tests,
      <literal>usingMapGetWithWarnings</literal> and
      <literal>usingMapGetWithoutWarnings</literal>, exercise the Java-Scala
      interoperability the same way. However, the first test has two
      compile-time warnings, indicated by the <literal>// warning</literal>
      comments, while the second test compiles without warnings:</para>

      <screen>SMapTest.java:29: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n1 = map.get(1);  // warning
                             ^
SMapTest.java:30: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n2 = map.get(2);  // warning
                             ^
2 warnings</screen>

      <para id="para_the_warnings_occur_because_of_">The warnings occur
      because of type erasure. In the compiled Scala library, the return type
      of <literal>Map.get</literal> is <literal>Option</literal> with no type
      parameter, or effectively <literal>Option&lt;Object&gt;</literal>. So we
      get warnings for the conversion to
      <literal>Option&lt;Name&gt;</literal>.</para>

      <para id="para_the_second_test_usingmapgetw">The second test,
      <literal>usingMapGetWithoutWarnings</literal>, has no warnings, because
      we assign the values returned by <literal>Map.get</literal> to
      <literal>Option&lt;?&gt;</literal> and then do an explicit cast to
      <literal>Name</literal> when we call <literal>Option.get</literal> in
      the final two assertions.<indexterm class="endofrange" startref="ch14_generics"/></para>
    </sect2>

    <sect2 id="FunctionsInJava">
      <title>Using Scala Functions in Java</title>

      <para id="para_continuing_with_our_previous_">Continuing with our
      previous <literal>SMapTest</literal> example, we can explore invoking
      Scala code from Java where Scala functions are required:<indexterm>
          <primary>functions</primary>

          <secondary>Scala, using in Java</secondary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>Scala interoperability with</secondary>

          <tertiary>using Scala functions in Java</tertiary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/SMapTestWithFunctions.java

import org.junit.*;
import static org.junit.Assert.*;
import scala.*;
import scala.collection.mutable.LinkedHashMap;
import static scala.collection.Map.Projection;

public class SMapTestWithFunctions {
  static class Name {
    public String firstName;
    public String lastName;

    public Name(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName  = lastName;
    }

    public static Name emptyName = new Name("","");

    public static Function0&lt;Name&gt; empty = new Function0&lt;Name&gt;() {
      public Name apply() { return emptyName; }

      public int $tag() { return 0; }
    };
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  @Before
  public void setup() {
    map = new LinkedHashMap&lt;Integer, Name&gt;();
    map.update(1, new Name("Dean", "Wampler"));
    map.update(2, new Name("Alex", "Payne"));
  }

  @Test
  public void usingMapGetOrElse() {
    assertEquals(2, map.size());
    assertEquals("Dean", ((Name) map.getOrElse(1, Name.empty)).firstName);
    assertEquals("Alex", ((Name) map.getOrElse(2, Name.empty)).firstName);
  }

  Function1&lt;Integer, Boolean&gt; filter = new Function1&lt;Integer, Boolean&gt;() {
    public Boolean apply(Integer i) { return i.intValue() &lt;= 1; }

    public &lt;A&gt; Function1&lt;A,Boolean&gt; compose(Function1&lt;A,Integer&gt; g) {
      return Function1$class.compose(this, g);
    }

    public &lt;A&gt; Function1&lt;Integer,A&gt; andThen(Function1&lt;Boolean,A&gt; g) {
      return Function1$class.andThen(this, g);
    }

    public int $tag() { return 0; }
  };

  @Test
  public void usingFilterKeys() {
    assertEquals(2, map.size());
    Projection&lt;Integer, Name&gt; filteredMap =
        (Projection&lt;Integer, Name&gt;) map.filterKeys(filter);
    assertEquals(1, filteredMap.size());
    assertEquals("Dean", filteredMap.getOrElse(1, Name.empty).firstName);
    assertEquals("",     filteredMap.getOrElse(2, Name.empty).firstName);
  }
}</programlisting>

      <para id="para_the_smaptestwithfunctions_cl">The
      <literal>SMapTestWithFunctions</literal> class has its own
      <literal>Name</literal> class that adds a static
      <literal>emptyName</literal> object and a static
      <literal>scala.Function0</literal> object <literal>empty</literal>,
      which defines <literal>apply</literal> to return <literal role="keep-together">emptyName</literal>. Note that it is also necessary
      to define the <literal>$tag</literal> method that was discussed
      previously in <xref linkend="CommandLineToolDecompilers"/>.</para>

      <para id="para_the_empty_function_object_is">The
      <literal>empty</literal> function object is needed when we use
      <literal>Map.getOrElse</literal> in the test method,
      <literal>usingMapGetOrElse</literal>. The signature of
      <literal>getOrElse</literal> is the following:</para>

      <programlisting linenumbering="unnumbered">def getOrElse[B2 &gt;: B](key : A, default : =&gt; B2) : B2</programlisting>

      <para id="para_where_a_is_the_key_type_para">Where <literal>A</literal>
      is the key type parameter, <literal>B</literal> is the value type
      parameter, and <literal>B2</literal> is a supertype of
      <literal>B</literal> or the same as <literal>B</literal>. The second
      <literal>default</literal> argument is a <emphasis>by-name
      parameter</emphasis>, which we discussed in <xref linkend="FunctionalProgramming"/>. Note that by-name parameters are
      implemented as <literal>scala.Function0</literal> objects. So, we can&#x2019;t
      simply pass in the static object <literal>emptyName</literal>.</para>

      <para id="para_the_second_test_usingfilterk">The second test,
      <literal>usingFilterKeys</literal>, requires a
      <literal>Function1</literal> object, which has an
      <literal>apply</literal> method that takes one argument. We use this
      <literal>Function1</literal> object as a filter passed to
      <literal>Map.filterKeys</literal>.</para>

      <para id="para_we_define_the_filter_before_">We define the
      <literal>filter</literal> before the test. The Java code here is
      considerably more involved than the equivalent Scala code would be! Not
      only do we have to define the <literal>apply</literal> and
      <literal>$tag</literal> methods, we must also define methods used for
      function composition, <literal>compose</literal> and
      <literal>andThen</literal>. Fortunately, we can delegate to objects that
      are already in the Scala library, as shown. Note that other
      <literal>FunctionN</literal> types, for <literal>N</literal> equals 2 to
      22, have other methods that would have to be implemented using similar
      &#x201C;boilerplate.&#x201D; For example, these types each have a
      <literal>curry</literal> method.</para>

      <para id="para_finally_recall_that_in_comp">Finally, recall that in
      <xref linkend="CompanionObjectsAndJavaStaticMethods"/>, we discussed
      that methods defined in companion objects are not visible as
      <literal>static</literal> methods to Java code. For example,
      <literal>main</literal> methods defined in companion objects can&#x2019;t be
      used to run the application. Instead, you should define such methods in
      <emphasis role="keep-together">singleton</emphasis> objects.<indexterm>
          <primary>methods</primary>

          <secondary>Java static methods and companion objects</secondary>
        </indexterm><indexterm>
          <primary>singleton objects</primary>

          <secondary>methods defined in companion objects</secondary>
        </indexterm><indexterm>
          <primary>companion objects</primary>

          <secondary>methods defined in, visibility to Java code</secondary>
        </indexterm></para>

      <para id="para_so_using_scala_function_objec">So, using Scala function
      objects from Java can be challenging. If you find it necessary to use
      them frequently, you could define Java utility classes that handle the
      boilerplate for all the methods except <literal>apply</literal>.</para>
    </sect2>

    <sect2 id="JavaBeanProperties">
      <title>JavaBean Properties</title>

      <para id="para_we_saw_in_objectorientedprog">We saw in <xref linkend="BasicObjectOrientedProgramming"/> that Scala does not follow
      the JavaBeans (<link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>) conventions for field
      reader and writer methods, for reasons described in <xref linkend="UniformAccessPrinciple"/>. However, there are times when you
      need JavaBeans accessor <phrase role="keep-together">methods</phrase>.
      For example, you need them when you want your Scala instances to be
      configurable by a <emphasis>dependency injection</emphasis> mechanism,
      like the one provided by the Spring Framework (<link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link>). You may also need
      JavaBeans accessor methods for some IDEs that do bean
      &#x201C;introspection.&#x201D;<indexterm>
          <primary>JavaBeans</primary>

          <secondary>conventions for</secondary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>Scala interoperability with</secondary>

          <tertiary>JavaBean properties</tertiary>
        </indexterm></para>

      <para id="para_scala_solves_this_problem_with">Scala solves this problem
      with an annotation that you can apply to a field,
      <literal>@scala.reflect.BeanProperty</literal>, which tells the compiler
      to generate JavaBeans-style <phrase role="keep-together">getter</phrase>
      and setter methods. We introduced this annotation in <xref linkend="Annotations"/>.<indexterm>
          <primary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty
          annotation</primary>
        </indexterm><indexterm>
          <primary>annotations</primary>

          <secondary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty</secondary>
        </indexterm></para>

      <para id="para_recall_the_complex_class_we_">Recall the
      <literal>Complex</literal> class we saw previously. Now we add the
      annotation to each constructor argument, which is a field in the
      <literal>case</literal> class:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-javabean.scala

case class ComplexBean(
  @scala.reflect.BeanProperty real: Double,
  @scala.reflect.BeanProperty imaginary: Double) {

  def +(that: ComplexBean) =
    new ComplexBean(real + that.real, imaginary + that.imaginary)
  def -(that: ComplexBean) =
    new ComplexBean(real - that.real, imaginary - that.imaginary)
}</programlisting>

      <para id="para_if_you_compile_this_class_the">If you compile this class,
      then decompile it with <literal>javap -classpath ...
      ComplexBean</literal>, you get the following output:</para>

      <programlisting linenumbering="unnumbered">public class ComplexBean extends java.lang.Object
  implements scala.ScalaObject,scala.Product,java.io.Serializable{
  public ComplexBean(double, double);
  public java.lang.Object productElement(int);
  public int productArity();
  public java.lang.String productPrefix();
  public boolean equals(java.lang.Object);
  public java.lang.String toString();
  public int hashCode();
  public int $tag();
  public ComplexBean $minus(ComplexBean);
  public ComplexBean $plus(ComplexBean);
  public double imaginary();
  public double real();
  public double getImaginary();
  public double getReal();
}</programlisting>

      <para id="para_now_compare_this_output_with_t">Now compare this output
      with the result of decompiling the original
      <filename>Complex.class</filename> file:</para>

      <programlisting linenumbering="unnumbered">public class Complex extends java.lang.Object
  implements scala.ScalaObject,scala.Product,java.io.Serializable{
  public Complex(double, double);
  public java.lang.Object productElement(int);
  public int productArity();
  public java.lang.String productPrefix();
  public boolean equals(java.lang.Object);
  public java.lang.String toString();
  public int hashCode();
  public int $tag();
  public Complex $minus(Complex);
  public Complex $plus(Complex);
  public double imaginary();
  public double real();
}</programlisting>

      <para id="para_the_order_of_the_methods_shown">The order of the methods
      shown may be different when you run <literal>javap</literal> on these
      files. We reordered them so the two listings would match as closely as
      possible. Note that the only differences are the names of the classes
      and the presence of <literal>getImaginary</literal> and
      <literal>getReal</literal> methods in the <literal>ComplexBean</literal>
      case. We would also have corresponding setter methods if the
      <literal>real</literal> and <literal>imaginary</literal> fields were
      declared as <literal>var</literal>s instead of
      <literal>val</literal>s.</para>

      <warning id="para_warning_the__scaladoc__page_f">
        <para>The Scaladoc page for <literal>@BeanProperty</literal> (version
        2.7) says that you can&#x2019;t call the bean setter methods from Scala. You
        can call them, but as the <phrase role="keep-together">Scaladoc</phrase> page goes on to say, you should
        use the Scala-style writer (and reader) methods instead.</para>
      </warning>
    </sect2>

    <sect2 id="AnyValTypesAndJavaPrimitives">
      <title>AnyVal Types and Java Primitives</title>

      <para id="para_notice_also_in_the_previous_c">Notice also in the
      previous <literal>Complex</literal> example that the
      <literal>Doubles</literal> were converted to Java primitive
      <literal>doubles</literal>. All the <literal>AnyVal</literal> types are
      converted to their corresponding Java primitives. We showed the mapping
      in <xref linkend="AnyVal-value-types"/>. In particular, note that
      <literal>Unit</literal> is mapped to <literal>void</literal>.<indexterm>
          <primary>primitive data types</primary>

          <secondary>Java, conversion of AnyVal types to</secondary>
        </indexterm><indexterm>
          <primary>AnyVal types, conversion to Java primitives</primary>
        </indexterm><indexterm>
          <primary>data types</primary>

          <secondary>AnyVal types, conversion to Java primitives</secondary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>Scala interoperability with</secondary>

          <tertiary>AnyVal types and Java primitives</tertiary>
        </indexterm></para>
    </sect2>

    <sect2 id="ScalaNamesInJavaCode">
      <title>Scala Names in Java Code</title>

      <para id="para_as_we_discussed_in_roundingo">As we discussed in <xref linkend="RoundingOutTheEssentials"/>, Scala allows more flexible
      identifiers, e.g., <emphasis>operator characters</emphasis> like
      <literal>*</literal>, <literal>&lt;</literal>, etc. These characters are
      encoded (or &#x201C;mangled,&#x201D; if you prefer) to satisfy the tighter constraints
      of the JVM specification. They are translated as shown in <xref linkend="char-encoding"/> (adapted from <link linkend="Spiewak2009a" xrefstyle="select:nopage">[Spiewak2009a]</link>).<indexterm>
          <primary>characters</primary>

          <secondary>operator characters, encoding in Java</secondary>
        </indexterm><indexterm>
          <primary>~ (tilde)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary># (pound sign)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>@ (at sign)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>&amp; (ampersand)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>^ (caret)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>% (percent sign)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>: (colon)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>? (question mark)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>! (exclamation point)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>| (vertical bar)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>\ (backslash)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>/ (slash)</primary>

          <secondary>division operator, encoding in Java
          identifiers</secondary>
        </indexterm><indexterm>
          <primary>* (asterisk)</primary>

          <secondary>multiplication operator, encoding in Java
          identifiers</secondary>
        </indexterm><indexterm>
          <primary>- (minus sign)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>+ (plus sign)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>&lt; &gt; (angle brackets)</primary>

          <secondary>&lt; (less than) operator</secondary>

          <tertiary>encoding in Java identifiers</tertiary>
        </indexterm><indexterm>
          <primary>&lt; &gt; (angle brackets)</primary>

          <secondary>&gt; (greater than) operator</secondary>

          <tertiary>encoding in Java identifiers</tertiary>
        </indexterm><indexterm>
          <primary>= (equals sign)</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>operator characters</primary>

          <secondary>encoding in Java identifiers</secondary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>Scala interoperability with</secondary>

          <tertiary>Scala names in Java code</tertiary>
        </indexterm></para>

      <table id="char-encoding">
        <title>Encoding of operator characters</title>

        <tgroup cols="2">
          <thead valign="top">
            <row>
              <entry><phrase role="keep-together">Operator</phrase></entry>

              <entry><phrase role="keep-together">Encoding</phrase></entry>
            </row>
          </thead>

          <tbody valign="top">
            <row>
              <entry><para><literal>=</literal></para></entry>

              <entry><para><literal>$eq</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>&gt;</literal></para></entry>

              <entry><para><literal>$greater</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>&lt;</literal></para></entry>

              <entry><para><literal>$less</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>+</literal></para></entry>

              <entry><para><literal>$plus</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>-</literal></para></entry>

              <entry><para><literal>$minus</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>*</literal></para></entry>

              <entry><para><literal>$times</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>/</literal></para></entry>

              <entry><para><literal>$div</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>\</literal></para></entry>

              <entry><para><literal>$bslash</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>|</literal></para></entry>

              <entry><para><literal>$bar</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>!</literal></para></entry>

              <entry><para><literal>$bang</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>?</literal></para></entry>

              <entry><para><literal>$qmark</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>:</literal></para></entry>

              <entry><para><literal>$colon</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>%</literal></para></entry>

              <entry><para><literal>$percent</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>^</literal></para></entry>

              <entry><para><literal>$up</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>&amp;</literal></para></entry>

              <entry><para><literal>$amp</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>@</literal></para></entry>

              <entry><para><literal>$at</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>#</literal></para></entry>

              <entry><para><literal>$hash</literal></para></entry>
            </row>

            <row>
              <entry><para><literal>~</literal></para></entry>

              <entry><para><literal>$tilde</literal></para></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para id="para_you_can_see_this_at_work_in_th">You can see this at work
      in the following contrived trait, where each character is used to
      declare an abstract method that takes no arguments and returns
      <literal>Unit</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/all-op-chars.scala

trait AllOpChars {
  def == : Unit   // $eq$eq
  def &gt;  : Unit   // $greater
  def &lt;  : Unit   // $less
  def +  : Unit   // $plus
  def -  : Unit   // $minus
  def *  : Unit   // $times
  def /  : Unit   // $div
  def \  : Unit   // $bslash
  def |  : Unit   // $bar
  def !  : Unit   // $bang
  def ?  : Unit   // $qmark
  def :: : Unit   // $colon$colon
  def %  : Unit   // $percent
  def ^  : Unit   // $up
  def &amp;  : Unit   // $amp
  def @@ : Unit   // $at$at
  def ## : Unit   // $hash$hash
  def ~  : Unit   // $tilde
}</programlisting>

      <para id="para_note_that_we_doubled_up_some_o">Note that we doubled up
      some of the characters to get them to compile as method names, where
      using single characters would have been ambiguous. Compiling this file
      and decompiling the resulting class file with <literal>javap
      AllOpChars</literal> yields the following Java interface. (We have
      rearranged the output order of the methods to match the order in the
      original Scala file.)</para>

      <programlisting linenumbering="unnumbered">Compiled from "all-op-chars.scala"
public interface AllOpChars{
  public abstract void $eq$eq();
  public abstract void $greater();
  public abstract void $less();
  public abstract void $plus();
  public abstract void $minus();
  public abstract void $times();
  public abstract void $div();
  public abstract void $bslash();
  public abstract void $bar();
  public abstract void $bang();
  public abstract void $qmark();
  public abstract void $colon$colon();
  public abstract void $percent();
  public abstract void $up();
  public abstract void $amp();
  public abstract void $at$at();
  public abstract void $hash$hash();
  public abstract void $tilde();
}</programlisting>

      <para id="para_to_conclude_interoperability_">To conclude,
      interoperability between Java and Scala works very well, but there are a
      few things you must remember when invoking Scala code from Java. If
      you&#x2019;re uncertain about how a Scala identifier is encoded or a Scala
      method is translated to valid byte code, use <literal>javap</literal> to
      find out.<indexterm class="endofrange" startref="ch14_JavaScala"/></para>
    </sect2>
  </sect1>

  <sect1 id="JavaLibraryInterop">
    <title>Java Library Interoperability</title>

    <para id="para_this_section_specifically_cons">This section specifically
    considers interoperability with several important Java frameworks:
    AspectJ, the Spring Framework, Terracotta, and Hadoop. Because they are
    widely used in &#x201C;enterprise&#x201D; and Internet Java applications, successful
    interoperability with Scala is important.<indexterm class="startofrange" id="ch14_Javalibraries">
        <primary>Java</primary>

        <secondary>libraries, interoperability with Scala</secondary>
      </indexterm><indexterm class="startofrange" id="ch14_librariesJava">
        <primary>libraries</primary>

        <secondary>Java library interoperability</secondary>
      </indexterm></para>

    <sect2 id="AspectJInterop">
      <title>AspectJ</title>

      <para id="para_aspectj_aspectj_is_an_exte">AspectJ (<link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link>) is an
      extension of Java that supports <emphasis>aspect-oriented
      programming</emphasis> (AOP), also known as <emphasis>aspect-oriented
      software development</emphasis> (<link linkend="AOSD" xrefstyle="select:nopage">[AOSD]</link>). The goal of AOP is to enable
      systemic changes of the same kind across many modules, while avoiding
      copying and pasting the same code over and over into each location.
      Avoiding this duplication not only improves productivity, it greatly
      reduces bugs.<indexterm>
          <primary>AOP</primary>

          <see>aspect-oriented programming</see>
        </indexterm><indexterm class="startofrange" id="ch14_librariesJavaAspectJ">
          <primary>libraries</primary>

          <secondary>Java library interoperability</secondary>

          <tertiary>AspectJ</tertiary>
        </indexterm><indexterm class="startofrange" id="ch14_JavaLibrariesAspectJ">
          <primary>Java</primary>

          <secondary>libraries, interoperability with Scala</secondary>

          <tertiary>AspectJ</tertiary>
        </indexterm><indexterm>
          <primary>aspect-oriented programming (AOP)</primary>
        </indexterm><indexterm class="startofrange" id="ch14_AspectJ">
          <primary>AspectJ library</primary>
        </indexterm></para>

      <para id="para_for_example_if_you_want_all_f">For example, if you want
      all field changes to all &#x201C;domain model&#x201D; objects to be persisted
      automatically after the changes occur, you can write an aspect that
      observes those changes and triggers a persistence write after each
      change.</para>

      <para id="para_aspectj_supports_aop_by_provid">AspectJ supports AOP by
      providing a <emphasis>pointcut language</emphasis> for specifying in a
      declarative way all the &#x201C;execution points&#x201D; in a program for which a
      particular behavior modification (called <emphasis>advice</emphasis>) is
      required. In AspectJ parlance, each execution point is called a
      <emphasis>join point</emphasis>, and a particular query over join points
      is a <emphasis>pointcut</emphasis>. Hence the <emphasis>pointcut
      language</emphasis> is a query language, of sorts. For a given pointcut,
      AspectJ incorporates the desired behavior modifications into each join
      point. Manual insertion of these changes is not required. An
      <emphasis>aspect</emphasis> encapsulates pointcuts and advices, much the
      way a class encapsulates member fields and methods.<indexterm>
          <primary>advice (in AOP)</primary>
        </indexterm><indexterm>
          <primary>pointcuts</primary>
        </indexterm><indexterm>
          <primary>join points</primary>
        </indexterm></para>

      <para id="para_for_a_detailed_introduction_to">For a detailed
      introduction to AspectJ with many practical examples, refer to <link linkend="Laddad2009" xrefstyle="select:nopage">[Laddad2009]</link>.</para>

      <para id="para_there_are_two_issues_that_must">There are two issues that
      must be considered when using AspectJ with Scala. The first issue is how
      to reference Scala execution points using AspectJ&#x2019;s pointcut language,
      e.g., Scala types and methods. The second issue is how to invoke Scala
      code as <emphasis>advice</emphasis>.</para>

      <para id="para_let_s_look_at_an_aspect_that_l">Let&#x2019;s look at an aspect
      that logs method calls to the <literal>Complex</literal> class we used
      previously in this chapter. We&#x2019;ll add a package declaration this time to
      provide some scope:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/aspectj/complex.scala

package example.aspectj

case class Complex(real: Double, imaginary: Double) {
  def +(that: Complex) =
    new Complex(real + that.real, imaginary + that.imaginary)
  def -(that: Complex) =
    new Complex(real - that.real, imaginary - that.imaginary)
}</programlisting>

      <para id="para_here_is_an_object_that_uses_">Here is an
      <literal>object</literal> that uses <literal>Complex</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/aspectj/complex-main.scala

package example.aspectj

object ComplexMain {
  def main(args: Array[String]) {
    val c1 = Complex(1.0, 2.0)
    val c2 = Complex(3.0, 4.0)
    val c12 = c1 + c2
    println(c12)
  }
}</programlisting>

      <para id="para_next_here_is_an_aspectj_aspec">Next, here is an AspectJ
      aspect that defines one <emphasis>pointcut</emphasis> for the creation
      of <literal>Complex</literal> instances and another pointcut for
      invocations of the <literal>+</literal> method:</para>

      <?dbfo-need height=”1in”
?>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/aspectj/LogComplex.aj

package example.aspectj;

public aspect LogComplex {
  public pointcut newInstances(double real, double imag):
    execution(Complex.new(..)) &amp;&amp; args(real, imag);

  public pointcut plusInvocations(Complex self, Complex other):
    execution(Complex Complex.$plus(Complex)) &amp;&amp; this(self) &amp;&amp; args(other);

  before(double real, double imag): newInstances(real, imag) {
    System.out.println("new Complex(" + real + "," + imag + ") called.");
  }

  before(Complex self, Complex other): plusInvocations(self, other) {
    System.out.println("Calling " + self + ".+(" + other + ")");
  }

  after(Complex self, Complex other) returning(Complex c):
    plusInvocations(self, other) {
    System.out.println("Complex.+ returned " + c);
  }
}</programlisting>

      <para id="para_we_won_t_explain_all_the_detai">We won&#x2019;t explain all the
      details of AspectJ syntax here. See the AspectJ document at <link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link> and <link linkend="Laddad2009" xrefstyle="select:nopage">[Laddad2009]</link> for
      those details. We&#x2019;ll limit ourselves to a &#x201C;conceptual&#x201D; overview of this
      aspect.</para>

      <para id="para_the_first_pointcut_newinst">The first
      <literal>pointcut</literal>, <literal>newInstances</literal>, matches on
      executions of the constructor calls, using the syntax
      <literal>Complex.new</literal> to refer to the constructor. We expect
      <literal>double</literal> arguments to the constructor call. As we saw
      previously, <literal>scala.Double</literal> occurrences are converted to
      Java primitive <literal>doubles</literal> when generating byte code. The
      <literal>args</literal> clause &#x201C;binds&#x201D; the values of the arguments
      passed in, so we can refer to them in
      <emphasis>advice</emphasis>.</para>

      <para id="para_the_second_pointcut_plusca">The second
      <literal>pointcut</literal>, <literal>plusInvocations</literal>, matches
      on &#x201C;executions&#x201D; of the <literal>+</literal> method, which is actually
      <literal>$plus</literal> in the byte code. The <literal>self</literal>
      and <literal>other</literal> parameters are bound to the object on which
      the <literal>+</literal> method is invoked (using the
      <literal>this</literal> clause) and the argument to it (using the
      <literal>args</literal> clause), respectively.</para>

      <para id="para_the_first_before__advice__is">The first
      <literal>before</literal> advice is executed for the
      <literal>newInstances</literal> pointcut, that is, before we actually
      enter the constructor. We &#x201C;log&#x201D; the call, displaying the actual real and
      imaginary values passed in.</para>

      <para id="para_the_next_before__advice__is_">The next
      <literal>before</literal> advice is executed for the
      <literal>plusInvocations</literal> pointcut, that is, before the
      <literal>+</literal> method is executed. We log the value of
      <literal>self</literal> (i.e., <literal>this</literal> instance) and the
      other <phrase role="keep-together">number</phrase>.</para>

      <para id="para_finally_an_after_returning_">Finally, an <literal>after
      returning</literal> advice is also executed for the
      <literal>plusInvocations</literal> pointcut, that is, after the
      <literal>+</literal> method returns. We capture the return value in the
      variable <literal>c</literal> and we log it.</para>

      <para id="para_if_you_have_aspectj_installed_">If you have AspectJ
      installed in an <replaceable>aspectj-home</replaceable> directory, you
      can compile this file as follows:</para>

      <screen>ajc -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar \
  aspectj/LogComplex.aj</screen>

      <para id="para_this_is_one_line_we_used_the_">This is one line; we used
      the <literal>\</literal> to indicate a line wrap. To run this code with
      the <literal>LogComplex</literal> aspect, we use <emphasis><ulink url="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html">load-time
      weaving</ulink></emphasis>. We&#x2019;ll invoke Java with an
      <emphasis>agent</emphasis> that &#x201C;weaves&#x201D; the advice from
      <literal>LogComplex</literal> into <literal>Complex</literal>. To use
      load-time weaving, we also need the following configuration file,
      <literal>META-INF/aop.xml</literal>:<indexterm>
          <primary>weaving, load-time</primary>
        </indexterm><indexterm>
          <primary>load-time weaving</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">&lt;!-- code-examples/ToolsLibs/META-INF/aop.xml --&gt;

&lt;aspectj&gt;
  &lt;aspects&gt;
    &lt;aspect name="example.aspectj.LogComplex" /&gt;
    &lt;include within="example.aspectj.*" /&gt;
  &lt;/aspects&gt;

  &lt;weaver options="-verbose"&gt;
    &lt;dump within="example.aspectj.*" beforeandafter="true"&gt;
      &lt;include within="example.aspectj.*" /&gt;
    &lt;/dump&gt;
  &lt;/weaver&gt;
&lt;/aspectj&gt;</programlisting>

      <para>(The <filename>META-INF</filename> directory should be on the
      class path; we&#x2019;ll assume it&#x2019;s in the current working directory.) This
      file tells the weaver which aspects to use (the
      <literal>aspect</literal> tag) and which classes to target for weaving
      (the <literal>include</literal> tag), and it also enables verbose
      output, which is useful for debugging purposes. Finally, we can run the
      application with the following command:</para>

      <screen>java -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar \
  -javaagent:aspectj-home/lib/aspectjweaver.jar example.aspectj.ComplexMain</screen>

      <para id="para_you_get_several_lines_of_messa">You get several lines of
      messages logging the weaving process. The output ends with these
      lines:</para>

      <screen>new Complex(1.0,2.0) called.
new Complex(3.0,4.0) called.
Calling Complex(1.0,2.0).+(Complex(3.0,4.0))
new Complex(4.0,6.0) called.
Complex.+ returned Complex(4.0,6.0)
Complex(4.0,6.0)</screen>

      <para id="para_all_but_the_last_line_were_out">All but the last line
      were output by <literal>LogComplex</literal>. We added this additional
      behavior without manually inserting these statements in
      <literal>Complex</literal> itself!</para>

      <para id="para_recall_we_said_that_the_second">Recall we said that the
      second issue you might encounter when using AspectJ is how to invoke
      Scala code from <emphasis>advice</emphasis>. In our
      <literal>LogComplex</literal> aspect, the statements inside our
      different <literal>before</literal> and <literal>after</literal> advices
      are really just Java code. Therefore, we can just as easily invoke Scala
      code, applying the same lessons we have already learned for invoking
      Scala from Java.</para>

      <para id="para_scala_traits__almost__replace_">Scala traits
      <emphasis>almost</emphasis> replace aspects. We saw in Chapters <xref linkend="Traits" xrefstyle="select: labelnumber"/> and <xref linkend="ApplicationDesign" xrefstyle="select: labelnumber"/> how you
      can construct traits that modify the behavior of other traits, then mix
      the behaviors together when you create new classes or instances. This
      powerful technique lets you implement a form of aspect advice. However,
      Scala doesn&#x2019;t have a pointcut language, like AspectJ. When you need to
      affect a set of join points that don&#x2019;t share a common supertype, you&#x2019;ll
      need the capabilities of AspectJ. However, if you find yourself in that
      situation, you should consider if you can refactor your code to extract
      a common trait that provides the &#x201C;hooks&#x201D; you need for advice implemented
      using traits.<indexterm class="endofrange" startref="ch14_JavaLibrariesAspectJ"/><indexterm class="endofrange" startref="ch14_librariesJavaAspectJ"/><indexterm class="endofrange" startref="ch14_AspectJ"/><indexterm>
          <primary>traits</primary>

          <secondary>aspects versus</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="TheSpringFrameworkInterop">
      <title>The Spring Framework</title>

      <para id="para_the_spring_framework_springf">The Spring Framework (see
      <link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link>) is an open source,
      modular Java <phrase role="keep-together">enterprise</phrase> framework
      that provides a &#x201C;pure&#x201D; Java AOP API, integrated support for <phrase role="keep-together">AspectJ</phrase>, a <emphasis>dependency
      injection</emphasis> (DI) container, uniform and well-designed APIs for
      <phrase role="keep-together">invoking</phrase> a variety of other Java
      third-party APIs, and additional components for <phrase role="keep-together">security</phrase>, web development, etc.<indexterm>
          <primary>libraries</primary>

          <secondary>Java library interoperability</secondary>

          <tertiary>Spring Framework</tertiary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>libraries, interoperability with Scala</secondary>

          <tertiary>Spring Framework</tertiary>
        </indexterm><indexterm>
          <primary>Spring Framework</primary>
        </indexterm></para>

      <para id="para_here_we_focus_on_dependency_in">Here we focus on
      dependency injection, as interoperability issues with the other parts of
      the Spring Framework boil down to either Java or AspectJ issues, which
      we covered earlier.<indexterm>
          <primary>dependency injection (DI)</primary>

          <secondary>Spring Framework</secondary>
        </indexterm></para>

      <para id="para_we_discussed_the_concept_of_de">We discussed the concept
      of DI in <xref linkend="DependencyInjectionInScala"/>, where we showed
      elegant patterns for injecting dependencies using Scala itself. However,
      if you are in a mixed Java/Scala environment, it might be necessary to
      use a DI framework like the one provided by Spring to manage
      dependencies.</para>

      <para id="para_in_spring_di_dependencies_are">In Spring DI, dependencies
      are specified using a combination of XML configuration files and
      source-code annotations. The Spring API resolves these dependencies as
      classes are instantiated. Spring expects these classes to follow
      JavaBean conventions (see <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>). Well-designed classes
      will only depend on abstractions, i.e., Java interfaces or Scala traits,
      and the concrete instances satisfying those dependencies will be given
      to the bean through constructor arguments or through JavaBean setter
      methods. Hence, if you use Spring DI with Scala classes, you will need
      to use the <literal>@scala.reflect.BeanProperty</literal> annotation
      when you use setter injection. The annotation is not needed when you use
      constructor injection.<indexterm>
          <primary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty
          annotation</primary>
        </indexterm><indexterm>
          <primary>annotations</primary>

          <secondary sortas="scala.reflect.BeanProperty">@scala.reflect.BeanProperty</secondary>
        </indexterm><indexterm>
          <primary>JavaBeans</primary>

          <secondary>conventions for</secondary>
        </indexterm></para>

      <tip id="para_tip_prefer_constructor_inject">
        <para>Prefer constructor injection, when possible. Not only does this
        choice eliminate the need to use the <literal>@BeanProperty</literal>
        annotation, it leaves each instances in a known good state when the
        construction process is <phrase role="keep-together">finished</phrase>.</para>
      </tip>

      <para id="para_however_if_you_inject_depende">However, if you inject
      dependencies into Scala <literal>objects</literal>, you must use setter
      injection, as you have no way to define constructor parameters and you
      have no control over the construction process.</para>

      <para id="para_one_other_point_remember_that">One other point; remember
      that Spring will expect Java-compatible names, so you must use
      <emphasis>encoded</emphasis> names for methods and
      <literal>objects</literal>, as needed.</para>

      <para id="para_here_is_an_example_that_illust">Here is an example that
      illustrates &#x201C;wiring together&#x201D; objects with Spring:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/spring/object-bean.scala

package example.spring

case class NamedObject(name: String)

trait Factory {
  @scala.reflect.BeanProperty
  var nameOfFactory = "unknown"

  def make(name: String): AnyRef
}

object NamedObjectFactory extends Factory {
  def make(name: String) = NamedObject(name)
}

case class FactoryUsingBean(factory: Factory)</programlisting>

      <para id="para_the_case_class_factoryusingbe">The case class
      <literal>FactoryUsingBean</literal> is a simple type with a dependency
      on a <literal>Factory</literal> abstraction that we want to inject using
      constructor injection.</para>

      <para id="para_the_trait_factory_defines_th">The trait
      <literal>Factory</literal> defines the factory abstraction. It has a
      <literal>make</literal> method to create instances of some kind. To
      demonstrate setter injection on <literal>objects</literal>, we also give
      it a <literal>nameOfFac&#x2060;tory</literal> field. This will demonstrate
      <literal>object</literal> dependency injection because the concrete
      subtype we will actually use, <literal>NamedObjectFactory</literal>, is
      an <literal>object</literal>.</para>

      <para id="para_scala_requires_us_to_initializ">Scala requires us to
      initialize <literal>nameOfFactory</literal> with a value, but we will
      use Spring to set the real value. We have to use the
      <literal>@BeanProperty</literal> annotation to generate the
      <literal>setNameOfFactory</literal> method Spring will expect to
      find.</para>

      <para id="para_the_concrete_make_method_in_">The concrete
      <literal>make</literal> method in <literal>NamedObjectFactory</literal>
      creates a new <literal>NamedObject</literal>. It is a simple case class
      with a <literal>name</literal> field.</para>

      <para id="para_note_that_none_of_these_types_">Note that none of these
      types depend on the Spring API. You can compile this file without any
      Spring JAR files.</para>

      <para id="para_next_we_define_the_dependency">Next, we define the
      dependency &#x201C;wiring&#x201D; using a standard Spring XML configuration
      file:</para>

      <programlisting linenumbering="unnumbered">&lt;!-- code-examples/ToolsLibs/spring/scala-spring.xml --&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

  &lt;bean id="factory" class="example.spring.NamedObjectFactory$"&gt;
    &lt;property name="nameOfFactory" value="Factory for Named Objects" /&gt;
  &lt;/bean&gt;

  &lt;bean id="factoryUsingBean" class="example.spring.FactoryUsingBean"&gt;
    &lt;constructor-arg ref="factory" /&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting>

      <para id="para_we_define_two_beans_our_fac">We define two
      <literal>beans</literal>. Our factory is given the ID
      <literal>factory</literal>. The &#x201C;class&#x201D; is actually the
      <literal>object</literal> <literal>NamedObjectFactory</literal>. Note
      that we have to append a <literal>$</literal> to the end of the name,
      the actual name of the <literal>object</literal> in the byte
      code.</para>

      <para id="para_the_property_tag_sets_the_va">The
      <literal>property</literal> tag sets the value of
      <literal>nameOfFactory</literal>. We can&#x2019;t control instantiation of
      <literal>objects</literal>, so we have to inject the correct dependency
      after construction completes.</para>

      <para id="para_the_second_bean_is_our_simple_">The second bean is our
      simple <literal>FactoryUsingBean</literal>. Since this is a
      <literal>class</literal>, we can use constructor injection. The
      <literal>constructor</literal> tag specifies that the
      <literal>factory</literal> bean is used to satisfy the dependency at
      construction time.</para>

      <para id="para_spring_di_script">Finally, here is a script that uses
      these types to demonstrate Spring DI with Scala:</para>

      <programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/spring/object-bean-script.scala

import example.spring._
import org.springframework.context.support._

val context = new ClassPathXmlApplicationContext("spring/scala-spring.xml");

val bean = context.getBean("factoryUsingBean").asInstanceOf[FactoryUsingBean]
println("Factory Name: " + bean.factory.nameOfFactory)

val obj  = bean.factory.make("Dean Wampler")
println("Object: " + obj)</programlisting>

      <para id="para_we_create_an_instance_of_clas">We create an instance of
      <literal>ClassPathXmlApplicationContext</literal>, specifying our XML
      file. This context object is our gateway to the DI container. We ask it
      for our <literal>factoryUsingBean</literal>. We have to cast the
      returned <literal>AnyRef</literal> (i.e., Java
      <literal>Object</literal>) to the correct type. We print out the
      factory&#x2019;s name, to see if it is correct.</para>

      <para id="para_next_we_ask_the_bean_s_factor">Next, we ask the bean&#x2019;s
      factory to make &#x201C;something&#x201D; with the string <literal>"Dean
      Wampler"</literal>. When we print the returned object, it should be a
      <literal>NamedObject</literal>.</para>

      <para id="para_if_you_have_spring_installed_i">If you have Spring
      installed in a <replaceable>spring-home</replaceable> directory, you can
      run this script with the following command:</para>

      <screen>scala -cp \
  spring-home/dist/spring.jar:spring-home/.../commons-logging.jar:. \
  spring/object-bean-script.scala</screen>

      <?dbfo-need height=”1in”
?>

      <para>(The current working directory &#x201C;<filename>.</filename>&#x201D; is needed
      in the classpath to find the XML file.) There are many lines of logging
      output. The last two lines are what we care about:</para>

      <screen>...
Factory Name: Factory for Named Objects
Object: NamedObject(Dean Wampler)</screen>

      <para id="para_this_example_required_a_number">This example required a
      number of files and configuration details to get working. For a
      moderately large Java application, the effort is justified. However,
      Scala gives you new and simpler ways to implement dependency injection
      in Scala code without configuration files and a DI container.</para>
    </sect2>

    <sect2 id="TerracottaInterop">
      <title>Terracotta</title>

      <para id="para_terracotta_terracotta_is_a">Terracotta (see <link linkend="Terracotta" xrefstyle="select:nopage">[Terracotta]</link>) is
      an open source clustering product that distributes an application over
      several servers by clustering JVMs upon which the application executes.
      For efficiency, not all of the application&#x2019;s heap objects are
      distributed. Instead, the programmer specifies which data structures to
      distribute through configuration files. A benefit of Terracotta is that
      the application does not require code changes to support this clustering
      (at least in principle; some limited customization can be useful for
      performance reasons). Instead, the byte code is instrumented to provide
      the clustering. Terracotta is an alternative to distributed caches that
      require code changes.<indexterm>
          <primary>libraries</primary>

          <secondary>Java library interoperability</secondary>

          <tertiary>Terracotta</tertiary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>libraries, interoperability with Scala</secondary>

          <tertiary>Terracotta</tertiary>
        </indexterm><indexterm>
          <primary>Terracotta library</primary>
        </indexterm></para>

      <para id="para_terracotta_example"><link linkend="Boner2008a" xrefstyle="select:nopage">[Bon&#xE9;r2008a]</link> provides a detailed
      write-up of how to use Terracotta with Scala Actors. A Scala-specific
      Terracotta Integration Module (TIM) must be installed. When configuring
      which objects to distribute, you have to use the encoded names for
      companion objects, method names, etc., as they exist at the byte code
      level. We discussed these encodings in <xref linkend="ScalaNamesInJavaCode"/>. Finally, you have to add some more
      parameters to the <literal>java</literal> invocation command inside the
      <literal>scala</literal> script. Otherwise, clustering Scala
      applications with Terracotta works just like it does for Java <phrase role="keep-together">applications</phrase>.</para>
    </sect2>

    <sect2 id="HadoopInterop">
      <title>Hadoop</title>

      <para id="para_what_is_mapreduce"><emphasis>MapReduce</emphasis> is a
      divide-and-conquer programming model for processing large data sets in
      parallel. In the &#x201C;map&#x201D; phase, a data set is divided into N subsets of
      approximately equal size, where N is chosen to optimize the amount of
      work that can be done in parallel. For example, N might be close to the
      total number of processor cores available. (A few cores might be left
      idle as &#x201C;backups&#x201D; or for doing other processing.) The desired
      computation is performed on each subset. The &#x201C;reduce&#x201D; phase combines the
      results of the subset calculations into a final result.<indexterm>
          <primary>Java</primary>

          <secondary>libraries, interoperability with Scala</secondary>

          <tertiary>Hadoop</tertiary>
        </indexterm><indexterm>
          <primary>libraries</primary>

          <secondary>Java library interoperability</secondary>

          <tertiary>Hadoop</tertiary>
        </indexterm><indexterm>
          <primary>Hadoop library</primary>
        </indexterm></para>

      <para id="para_note_that_mapping_and_reducing">Note that mapping and
      reducing are essentially functional operations. Therefore, a functional
      language like Scala is ideally suited for writing MapReduce
      applications.<indexterm>
          <primary>MapReduce</primary>
        </indexterm></para>

      <?dbfo-need height=”2in”
?>

      <para id="para_mapreduce_frameworks">MapReduce frameworks provide tools
      for mapping and reducing data sets, managing all phases of the
      computation, including the processing nodes, restarting operations that
      fail for some reason, etc. The user of a MapReduce framework only has to
      write the algorithms for mapping (subdividing) the input data, the
      computations with the data subsets, and reducing the results. See <link linkend="MapReduceTutorial" xrefstyle="select:nopage">[MapReduceTutorial]</link> for a succinct
      overview and <link linkend="MapReduce" xrefstyle="select:nopage">[MapReduce]</link> for a description of
      Google&#x2019;s MapReduce framework. The name of the Google framework has
      become a de facto standard for these frameworks.</para>

      <para id="para_hadoop_hadoop_is_an_open_s">Hadoop (see <link linkend="Hadoop" xrefstyle="select:nopage">[Hadoop]</link>) is an open
      source MapReduce framework created and maintained by Yahoo!. There are
      two Scala wrappers around the Hadoop API: <emphasis>SHadoop</emphasis>
      (see <link linkend="SHadoop" xrefstyle="select:nopage">[SHadoop]</link>)
      and <emphasis>SMR</emphasis> (see <link linkend="SMRa" xrefstyle="select:nopage">[SMRa]</link> and (<link linkend="SMRb" xrefstyle="select:nopage">[SMRb]</link>). Both examples demonstrate the
      great reduction in code size when using Scala. <link linkend="SMRa" xrefstyle="select:nopage">[SMRa]</link> attributes this code reduction
      to Scala&#x2019;s support for higher-order and anonymous functions, its
      sophisticated type system and type inference, and the ability of
      <literal>for</literal> comprehensions to generate maps in an elegant and
      succinct way.<indexterm class="endofrange" startref="ch14_librariesJava"/><indexterm class="endofrange" startref="ch14_Javalibraries"/></para>
    </sect2>
  </sect1>

  <sect1 id="_recap_and_what_s_next_5">
    <title>Recap and What&#x2019;s Next</title>

    <para id="para_this_chapter_filled_in_the_det">This chapter filled in the
    details of the Scala command-line tools that you will use every day. We
    also surveyed the available support for Scala in various text editors and
    IDEs. We discussed a number of important libraries, such as testing APIs.
    Finally, we discussed interoperability between Scala and other JVM
    languages and libraries.</para>

    <para id="para_this_completes_our_survey_of_t">This completes our survey
    of the world of Scala programming. The next chapter is a list of
    references for further exploration, followed by a glossary of terms that
    we have used throughout the book.</para>
  </sect1>
</chapter>
  <appendix id="References">
  <title>References</title>

  <para id="Abelson1996">[Abelson1996] Harold Abelson, Gerald Jay Sussman, and
  Julie Sussman, <citetitle>Structure and Interpretation of Computer
  Programs</citetitle>, The MIT Press, 1996.</para>

  <para id="Agha1987">[Agha1987] Gul Agha, <citetitle>Actors</citetitle>, The
  MIT Press, 1987.</para>

  <para id="Akka">[Akka] Akka: RESTful Distributed Persistent Transactional
  Actors, <ulink url="http://akkasource.org">http://akkasource.org</ulink>.</para>

  <para id="Ant">[Ant] <citetitle>The Apache Ant Project</citetitle>, <ulink url="http://ant.apache.org/"/>.</para>

  <para id="Antlr">[Antlr] <citetitle>Antlr</citetitle>, <ulink url="http://www.antlr.org/"/>.</para>

  <para id="AOSD">[AOSD] <citetitle>Aspect-Oriented Software
  Development</citetitle>, <ulink url="http://aosd.net/"/>.</para>

  <para id="AspectJ">[AspectJ] <citetitle>The AspectJ Project</citetitle>,
  <ulink url="http://www.eclipse.org/aspectj/"/>.</para>

  <para id="BDD">[BDD] <citetitle>Behavior-Driven Development</citetitle>,
  <ulink url="http://behaviour-driven.org/"/>.</para>

  <para id="Bloch2008">[Bloch2008] Joshua Bloch, <citetitle>Effective
  Java</citetitle> (Second Edition), Addison-Wesley, 2008.</para>

  <para id="Boner2008a">[Bon&#xE9;r2008a] Jonas Bon&#xE9;r, <citetitle>Clustering Scala
  Actors with Terracotta</citetitle>, <ulink url="http://jonasboner.com/2008/01/25/clustering-scala-actors-with-terracotta.html"/>.</para>

  <para id="Boner2008b">[Bon&#xE9;r2008b] Jonas Bon&#xE9;r, <citetitle>Real-World Scala:
  Dependency Injection (DI)</citetitle>, <ulink url="http://jonasboner.com/2008/10/06/real-world-scala-dependency-injection-di.html"/>.</para>

  <para id="Bruce1998">[Bruce1998] Kim Bruce, Martin Odersky, and Philip
  Wadler, <citetitle>A Statically Safe Alternative to Virtual
  Types</citetitle>, <citetitle>Proc. ECOOP &#x2019;98</citetitle>, E. Jul (Ed.),
  LNCS 1445, pp. 523&#x2013;549, Springer-Verlag, 1998.</para>

  <para id="Buildr">[Buildr] <citetitle>Buildr</citetitle>, <ulink url="http://buildr.apache.org/"/>.</para>

  <para id="Contract4J">[Contract4J] <citetitle>Contract4J: Design by Contract
  for Java</citetitle>, <ulink url="http://contract4j.org/"/>.</para>

  <para id="Cucumber">[Cucumber] <citetitle>Cucumber - Making BDD
  Fun</citetitle>, <ulink url="http://cukes.info"/>.</para>

  <para id="DesignByContract">[DesignByContract] <citetitle>Building bug-free
  O-O software: An introduction to Design by Contract&#x2122;</citetitle>, <ulink url="http://archive.eiffel.com/doc/manuals/technology/contract/"/>.</para>

  <para id="Deursen">[Deursen] Arie van Deursen, Paul Klint, and Joost Visser,
  <citetitle>Domain-Specific Languages: An Annotated Bibliography</citetitle>,
  <ulink url="http://homepages.cwi.nl/~arie/papers/dslbib/"/>.</para>

  <para id="EBNF">[EBNF] <citetitle>Extended Backus-Naur Form</citetitle>,
  <ulink url="http://en.wikipedia.org/wiki/Extended_Backus&#x2013;Naur_Form"/>.</para>

  <para id="Eiffel">[Eiffel] <citetitle>Eiffel Software</citetitle>, <ulink url="http://eiffel.com"/>.</para>

  <para id="Ford">[Ford] Bryan Ford, <citetitle>The Packrat Parsing and
  Parsing Expression Grammars Page</citetitle>, <ulink url="http://pdos.csail.mit.edu/~baford/packrat/"/>.</para>

  <para id="Ford2009">[Ford2009] Neal Ford, <citetitle>Advanced DSLs in
  Ruby</citetitle>, <ulink url="http://github.com/nealford/presentations/tree/master"/>.</para>

  <para id="Fowler2009">[Fowler2009] Martin Fowler, <citetitle>Domain Specific
  Languages</citetitle> (forthcoming), <ulink url="http://martinfowler.com/dslwip/"/>.</para>

  <para id="FunctionalJava">[FunctionalJava] <citetitle>Functional
  Java</citetitle>, <ulink url="http://functionaljava.org"/>.</para>

  <para id="Ghosh2008a">[Ghosh2008a] Debasish Ghosh, <citetitle>External DSLs
  made easy with Scala Parser Combinators</citetitle>, <ulink url="http://debasishg.blogspot.com/2008/04/external-dsls-made-easy-with-scala.html"/>.</para>

  <para id="Ghosh2008b">[Ghosh2008b] Debasish Ghosh, <citetitle>Designing
  Internal DSLs in Scala</citetitle>, <ulink url="http://debasishg.blogspot.com/2008/05/designing-internal-dsls-in-scala.html"/>.</para>

  <para id="GOF1995">[GOF1995] Erich Gamma, Richard Helm, Ralph Johnson, and
  John Vlissides (&#x201C;Gang of Four&#x201D;), <citetitle>Design Patterns: Elements of
  Reusable Object-Oriented Software</citetitle>, Addison-Wesley, 1995.</para>

  <para id="Guice">[Guice] <citetitle>Guice</citetitle>, <ulink url="http://code.google.com/p/google-guice/"/>.</para>

  <para id="Hadoop">[Hadoop] <citetitle>Hadoop</citetitle>, <ulink url="http://hadoop.apache.org"/>.</para>

  <para id="Haller2007">[Haller2007] Philipp Haller and Martin Odersky,
  <citetitle>Actors That Unify Threads and Events</citetitle>, <ulink url="http://lamp.epfl.ch/~phaller/doc/haller07coord.pdf"/>.</para>

  <para id="Hewitt1973">[Hewitt1973] Carl Hewitt, Peter Bishop, and Richard
  Steiger, <citetitle>A Universal Modular Actor Formalism for Artificial
  Intelligence</citetitle>, <ulink url="http://dli.iiit.ac.in/ijcai/IJCAI-73/PDF/027B.pdf"/>,
  1973.</para>

  <para id="Hoare2009">[Hoare2009] Tony Hoare, <citetitle>Null References: The
  Billion Dollar Mistake</citetitle>, <ulink url="http://qconlondon.com/london-2009/speaker/Tony+Hoare"/>.</para>

  <para id="Hofer2008">[Hofer2008] Christian Hofer, Klaus Ostermann, Tillmann
  Rendel, and Adriaan Moors, <citetitle>Polymorphic Embedding of
  DSLs</citetitle>, GPCE &#x2019;08, October 19&#x2013;23, 2008, Nashville, Tennessee,
  <ulink url="http://www.daimi.au.dk/~ko/papers/gpce50_hofer.pdf"/>.</para>

  <para id="HTTP11">[HTTP11] <citetitle>Hypertext Transfer
  Protocol&#x2009;&#x2014;&#x2009;HTTP/1.1</citetitle>, <ulink url="http://www.w3.org/Protocols/rfc2616/rfc2616.html"/>.</para>

  <para id="Hunt2000">[Hunt2000] Andrew Hunt and Dave Thomas, <citetitle>The
  Pragmatic Programmer</citetitle>, Addison-Wesley, 2000.</para>

  <para id="JAD">[JAD] <citetitle>JAva Decompiler (JAD)</citetitle>, <ulink url="http://www.varaneckas.com/jad"/>.</para>

  <para id="Java6API">[Java6API] <citetitle>Java Platform SE 6
  API</citetitle>, <ulink url="http://java.sun.com/javase/6/docs/api/"/>.</para>

  <para id="JavaBeansSpec">[JavaBeansSpec] <citetitle>JavaBeans
  Specification</citetitle>, <ulink url="http://java.sun.com/javase/technologies/desktop/javabeans/docs/spec.html"/>.</para>

  <para id="JPAScala">[JPAScala] <citetitle>Using JPA with Scala</citetitle>,
  <ulink url="http://www.hars.de/2009/03/jpa-with-scala.html"/>.</para>

  <para id="JRuby">[JRuby] <citetitle>JRuby</citetitle>, <ulink url="http://jruby.codehaus.org/"/>.</para>

  <para id="JUnit">[JUnit] <citetitle>JUnit</citetitle>, <ulink url="http://junit.org"/>.</para>

  <para id="Laddad2009">[Laddad2009] Ramnivas Laddad, <citetitle>AspectJ in
  Action</citetitle> (Second Edition), Manning Press, 2009.</para>

  <para id="Mailslot">[Mailslot] <citetitle>Mailslot</citetitle>, <ulink url="http://github.com/stevej/mailslot/"/>.</para>

  <para id="MapReduce">[MapReduce] <citetitle>MapReduce</citetitle>, <ulink url="http://labs.google.com/papers/mapreduce.html"/>.</para>

  <para id="MapReduceTutorial">[MapReduceTutorial] <citetitle>Introduction to
  Parallel Programming and MapReduce</citetitle>, <ulink url="http://code.google.com/edu/parallel/mapreduce-tutorial.html"/>.</para>

  <para id="Martin2003">[Martin2003] Robert C. Martin, <citetitle>Agile
  Software Development: Principles, Patterns, and Practices</citetitle>,
  Prentice Hall, 2003.</para>

  <para id="Maven">[Maven] <citetitle>The Apache Maven Project</citetitle>,
  <ulink url="http://maven.apache.org/"/>.</para>

  <para id="McBeath">[McBeath] Jim McBeath, <citetitle>Scala Syntax
  Primer</citetitle>, <ulink url="http://jim-mcbeath.blogspot.com/2008/09/scala-syntax-primer.html"/>.</para>

  <para id="McIver2009">[McIver2009] David R. MacIver, <citetitle>Scala trivia
  of the day: Traits can extend classes</citetitle>, <ulink url="http://www.drmaciver.com/2009/04/scala-trivia-of-the-day-traits-can-extend-classes/"/>.</para>

  <para id="Meyer1997">[Meyer1997] Bertrand Meyer, <citetitle>Object-Oriented
  Software Construction</citetitle> (Second Edition), Prentice Hall,
  1997.</para>

  <para id="MINA">[MINA] <citetitle>Apache MINA</citetitle>, <ulink url="http://mina.apache.org/"/>.</para>

  <para id="MoneyInJava">[MoneyInJava] Thomas Paul, <citetitle>Working with
  Money in Java</citetitle>, <ulink url="http://www.javaranch.com/journal/2003/07/MoneyInJava.html"/>.</para>

  <para id="Naftalin2006">[Naftalin2006] Maurice Naftalin and Philip Wadler,
  <citetitle>Java Generics and Collections</citetitle>, O&#x2019;Reilly Media,
  2006.</para>

  <para id="Naggati">[Naggati] <citetitle>Naggati</citetitle>, <ulink url="http://github.com/robey/naggati/"/>.</para>

  <para id="Odersky2005">[Odersky2005] Martin Odersky and Matthias Zenger,
  <citetitle>Scalable Component Abstractions</citetitle>, <emphasis>OOPSLA
  &#x2019;05</emphasis>, October 16&#x2013;20, 2005, San Diego, California, USA.</para>

  <para id="Odersky2006">[Odersky2006] Martin Odersky, <citetitle>Pimp My
  Library</citetitle>, <ulink url="http://www.artima.com/weblogs/viewpost.jsp?thread=179766"/>.</para>

  <para id="Odersky2008">[Odersky2008] Martin Odersky, Lex Spoon, and Bill
  Venners, <citetitle>Programming in Scala</citetitle>, Artima Press,
  2008.</para>

  <para id="Odersky2009">[Odersky2009] Martin Odersky, Lex Spoon, and Bill
  Venners, <citetitle>How to Write an Equality Method in Java</citetitle>,
  <ulink url="http://www.artima.com/lejava/articles/equality.html"/>.</para>

  <para id="Okasaki1998">[Okasaki1998] Chris Okasaki, <citetitle>Purely
  Functional Data Structures</citetitle>, Cambridge University Press,
  1998.</para>

  <para id="Ortiz2007">[Ortiz2007] Jorge Ortiz, <citetitle>Fun with Project
  Euler and Scala</citetitle>, <ulink url="http://scala-blogs.org/2007/12/project-euler-fun-in-scala.html"/>.</para>

  <para id="Ortiz2008">[Ortiz2008] Jorge Ortiz, <citetitle>Manifests: Reified
  Types</citetitle>, <ulink url="http://scala-blogs.org/2008/10/manifests-reified-types.html"/>.</para>

  <para id="OSullivan2009">[OSullivan2009] Bryan O&#x2019;Sullivan, John Goerzen, and
  Don Steward, <citetitle>Real World Haskell</citetitle>, O&#x2019;Reilly Media,
  2009.</para>

  <para id="PEG">[PEG] <citetitle>Parsing Expression Grammar</citetitle>,
  <ulink url="http://en.wikipedia.org/wiki/Parsing_expression_grammar"/>.</para>

  <para id="Pierce2002">[Pierce2002] Benjamin C. Pierce, <citetitle>Types and
  Programming Languages</citetitle>, The MIT Press, 2002.</para>

  <para id="Pollak2007">[Pollak2007] David Pollak, <citetitle>The Scala Option
  class and how lift uses it</citetitle>, <ulink url="http://blog.lostlake.org/index.php?/archives/50-The-Scala-Option-class-and-how-lift-uses-it.html"/>.</para>

  <para id="QuickCheck">[QuickCheck] <citetitle>QuickCheck, Automated
  Specification-Based Testing</citetitle>, <ulink url="http://www.cs.chalmers.se/~rjmh/QuickCheck/"/>.</para>

  <para id="Rabhi1999">[Rabhi1999] Fethi Rabhi and Guy Lapalme,
  <citetitle>Algorithms: A Functional Programming Approach</citetitle>,
  Addison-Wesley, 1999.</para>

  <para id="RSpec">[RSpec] <citetitle>RSpec</citetitle>, <ulink url="http://rspec.info/"/>.</para>

  <para id="SBT">[SBT] <citetitle>Simple Build Tool</citetitle>, <ulink url="http://code.google.com/p/simple-build-tool/"/>.</para>

  <para id="Scala">[Scala] <citetitle>The Scala Programming
  Language</citetitle>, <ulink url="http://www.scala-lang.org/"/>.</para>

  <para id="ScalaAPI2008">[ScalaAPI2008] <citetitle>The Scala
  Library</citetitle>, <ulink url="http://www.scala-lang.org/docu/files/api/index.html"/>.</para>

  <para id="ScalaCheckTool">[ScalaCheckTool]
  <citetitle>ScalaCheck</citetitle>, <ulink url="http://code.google.com/p/scalacheck/"/>.</para>

  <para id="ScalaSpec2009">[ScalaSpec2009] <citetitle>The Scala Language
  Specification</citetitle>, <ulink url="http://www.scala-lang.org/sites/default/files/linuxsoft_archives/docu/files/ScalaReference.pdf"/>.</para>

  <para id="ScalaSpecsTool">[ScalaSpecsTool] <citetitle>Specs</citetitle>,
  <ulink url="http://code.google.com/p/specs/"/>.</para>

  <para id="ScalaTestTool">[ScalaTestTool] <citetitle>ScalaTest</citetitle>,
  <ulink url="http://www.artima.com/scalatest/"/>.</para>

  <para id="ScalaTips">[ScalaTips] <citetitle>Scala Tips Blog</citetitle>,
  <ulink url="http://scalatips.tumblr.com/"/>.</para>

  <para id="ScalaTools">[ScalaTools] <citetitle>Scala Tools</citetitle>,
  <ulink url="http://www.scala-tools.org/"/>.</para>

  <para id="ScalaWiki">[ScalaWiki] <citetitle>Scala Wiki</citetitle>, <ulink url="http://scala.sygneca.com/"/>.</para>

  <para id="ScalaWikiPatterns">[ScalaWikiPatterns] <citetitle>Scala Wiki:
  Scala Design Patterns</citetitle>, <ulink url="http://scala.sygneca.com/patterns/start"/>.</para>

  <para id="Scalaz_bibentry">[ScalaZ] <citetitle>Scalaz</citetitle>, <ulink url="http://code.google.com/p/scalaz/"/>.</para>

  <para id="SHadoop">[SHadoop] Jonhnny Weslley (sic), <citetitle>SHadoop: What
  is Scala and Hadoop?</citetitle>, <ulink url="http://jonhnny-weslley.blogspot.com/2008/05/shadoop.html"/>.</para>

  <para id="SleepingBarberProblem">[SleepingBarberProblem] <citetitle>Sleeping
  barber problem</citetitle>, <ulink url="http://en.wikipedia.org/wiki/Sleeping_barber_problem"/>.</para>

  <para id="SMRa">[SMRa] David Hall, <citetitle>A Scalable Language, and a
  Scalable Framework</citetitle>, <ulink url="http://scala-blogs.org/2008/09/scalable-language-and-scalable.html"/>.</para>

  <para id="SMRb">[SMRb] <citetitle>Scala Map Reduce</citetitle>, <ulink url="http://github.com/dlwh/smr/"/>.</para>

  <para id="Smith2009a">[Smith2009a] Eishay Smith, <citetitle>Beware of
  Scala&#x2019;s Type Inference</citetitle>, <ulink url="http://www.eishay.com/2009/05/beware-of-scalas-type-inference.html"/>.</para>

  <para id="Smith2009b">[Smith2009b] Eishay Smith, <citetitle>Unexpected
  repeated execution in Scala</citetitle>, <ulink url="http://www.eishay.com/2009/06/unexpected-repeated-execution-in-scala.html"/>.</para>

  <para id="Spiewak2008">[Spiewak2008] Daniel Spiewak, <citetitle>What is
  Hindley-Milner? (and why is it cool?)</citetitle>, <ulink url="http://www.codecommit.com/blog/scala/what-is-hindley-milner-and-why-is-it-cool"/>.</para>

  <para id="Spiewak2009a">[Spiewak2009a] Daniel Spiewak, <citetitle>Interop
  Between Java and Scala</citetitle>, <ulink url="http://www.codecommit.com/blog/java/interop-between-java-and-scala"/>.</para>

  <para id="Spiewak2009b">[Spiewak2009b] Daniel Spiewak, <citetitle>The Magic
  Behind Parser Combinators</citetitle>, <ulink url="http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators"/>.</para>

  <para id="Spiewak2009c">[Spiewak2009c] Daniel Spiewak,
  <citetitle>Practically Functional</citetitle>, talk at the Chicago-Area
  Scala Enthusiasts, May 21, 2009.</para>

  <para id="SpringFramework">[SpringFramework] <citetitle>The Spring
  Framework</citetitle>, <ulink url="http://springframework.org"/>.</para>

  <para id="SXR">[SXR] <citetitle>A Scala source code browser</citetitle>,
  <ulink url="http://github.com/harrah/browse/tree/master"/>.</para>

  <para id="Szyperski1998">[Szyperski1998] Clemens Szyperski,
  <citetitle>Component Software: Beyond Object-Oriented
  Programming</citetitle>, Addison-Wesley Longman Limited, 1998.</para>

  <para id="TDD">[TDD] <citetitle>Test-Driven Development</citetitle>, <ulink url="http://en.wikipedia.org/wiki/Test-driven_development"/>.</para>

  <para id="Terracotta">[Terracotta] <citetitle>Terracotta</citetitle>, <ulink url="http://terracotta.org/"/>.</para>

  <para id="TestNG">[TestNG] <citetitle>TestNG</citetitle>, <ulink url="http://testng.org/"/>.</para>

  <para id="Turbak2008">[Turbak2008] Franklyn Turbak, David Gifford, and Mark
  A. Sheldon, <citetitle>Design Concepts of Programming Languages</citetitle>,
  The MIT Press, 2008.</para>

  <para id="TypeInference">[TypeInference] <citetitle>Type
  inference</citetitle>, <ulink url="http://en.wikipedia.org/wiki/Type_inference"/>.</para>

  <para id="VanRoy2004">[VanRoy2004] Peter Van Roy and Seif Haridi,
  <citetitle>Concepts, Techniques, and Models of Computer
  Programming</citetitle>, The MIT Press, 2004.</para>

  <para id="Wampler2008">[Wampler2008] Dean Wampler, <citetitle>Traits vs.
  Aspects in Scala</citetitle>, <ulink url="http://blog.objectmentor.com/articles/2008/09/27/traits-vs-aspects-in-scala"/>.</para>

  <para id="WirfsBrock2003">[WirfsBrock2003] Rebecca Wirfs-Brock and Alan
  McKean, <citetitle>Object Design: Roles, Responsibilities, and
  Collaborations</citetitle>, Pearson Education, 2003.</para>
</appendix>
  <glossary id="Glossary">
  <title>Glossary</title>

  <glossentry id="glossentry-tag">
    <glossterm>$tag</glossterm>

    <glossdef>
      <para>A method declared by the <literal>ScalaObject</literal> trait and
      used internally by Scala. It takes no arguments and returns an integer.
      It is currently used to optimize pattern matching, but it may be removed
      in a future release of Scala. While normally invisible to Scala code (it
      is generated automatically by the compiler), Java code that extends some
      Scala traits and classes may need to implement this method.<indexterm>
          <primary sortas="tag method">$tag method (ScalaObject)</primary>
        </indexterm><indexterm>
          <primary>ScalaObject class</primary>

          <secondary>$tag method</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-abstraction">
    <glossterm>Abstraction</glossterm>

    <glossdef>
      <para>The outwardly visible state, state transformations, and other
      operations supported by a type. This is separate from the
      <emphasis>encapsulated</emphasis> implementation (fields and methods) of
      the abstraction. Scala <emphasis>traits</emphasis> and
      <emphasis>abstract classes</emphasis> are often used to define
      abstractions and optionally implement them. <emphasis>Concrete
      types</emphasis> provide complete implementations.<indexterm>
          <primary>abstraction</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-abstract-type">
    <glossterm>Abstract Type</glossterm>

    <glossdef>
      <orderedlist id="glossary_abstract_type" numeration="lowerroman">
        <listitem>
          <para>A <emphasis>class</emphasis> or <emphasis>trait</emphasis>
          with one or more methods, fields, or types declared, but <phrase role="keep-together">undefined</phrase>. Abstract types can&#x2019;t be
          instantiated. Contrast with <emphasis>concrete
          types</emphasis>.<indexterm>
              <primary>abstract types</primary>

              <secondary>defined</secondary>
            </indexterm></para>
        </listitem>

        <listitem>
          <para>A <literal>type</literal> declaration within an
          <emphasis>class</emphasis> or <emphasis>trait</emphasis> that is
          abstract.</para>
        </listitem>
      </orderedlist>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-actor">
    <glossterm>Actor</glossterm>

    <glossdef>
      <para>An autonomous sender and receiver of messages in the
      <emphasis>Actor model of concurrency</emphasis>.<indexterm>
          <primary>Actors</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-actor-model-of-concurrency">
    <glossterm>Actor Model of Concurrency</glossterm>

    <glossdef>
      <para>A concurrency model where autonomous <emphasis>Actors</emphasis>
      coordinate work by exchanging <phrase role="keep-together">messages</phrase>. An Actor&#x2019;s messages are stored
      in a <emphasis>mailbox</emphasis> until the Actor processes
      them.<indexterm>
          <primary>concurrency</primary>

          <secondary>Actor model of</secondary>
        </indexterm><indexterm>
          <primary>Actors</primary>

          <secondary>Actor model of concurrency</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-annotated-type">
    <glossterm>Annotated Type</glossterm>

    <glossdef>
      <para>Any type that has one or more <literal>@</literal> annotations
      applied to it.<indexterm>
          <primary>annotated types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-annotation">
    <glossterm>Annotation</glossterm>

    <glossdef>
      <para>A way of attaching &#x201C;metadata&#x201D; to a declaration that can be
      exploited by the compiler and other tools for code generation,
      verification and validation, etc. In Scala (and Java), an annotation is
      a class. When used, it is prefixed with the <literal>@</literal>
      character.<indexterm>
          <primary>annotations</primary>

          <secondary>defined</secondary>
        </indexterm></para>

      <para id="para_any_explicit_type_declarations">Any explicit type
      declarations are also called <emphasis>type
      annotations</emphasis>.</para>

      <para id="para_one_or_more_additions_to_a_typ">One or more additions to
      a type declaration that specify behaviors like variance under
      inheritance, bounds, and views.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-application">
    <glossterm>Application</glossterm>

    <glossdef>
      <para>In Scala, any <literal>object</literal> with a
      <literal>main</literal> routine that is invoked by the JVM or .NET CLR
      at the start of a new process.<indexterm>
          <primary>applications</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-arity">
    <glossterm>Arity</glossterm>

    <glossdef>
      <para>The number of arguments to a function.<indexterm>
          <primary>arity</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-aspect-oriented-programming">
    <glossterm>Aspect-Oriented Programming</glossterm>

    <glossdef>
      <para>(Sometimes called <emphasis>aspect-oriented software
      development</emphasis>.) An approach to <emphasis>cross-cutting
      concerns</emphasis>, where the concerns are designed and implemented in
      a &#x201C;modular&#x201D; way (that is, with appropriate encapsulation, lack of
      duplication, etc.), then integrated into all the relevant execution
      points in a succinct and robust way, e.g., through declarative or
      programmatic means. In AOP terms, the execution points are called
      <emphasis>join points</emphasis>; a particular set of them is called a
      <emphasis>pointcut</emphasis>; and the new behavior that is executed
      before, after, or &#x201C;around&#x201D; a join point is called
      <emphasis>advice</emphasis>. <emphasis>AspectJ</emphasis> is the best
      known AOP toolkit. Scala <emphasis>traits</emphasis> can be used to
      implement some aspect-like functionality.<indexterm>
          <primary>aspect-oriented programming (AOP)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-aspectj">
    <glossterm>AspectJ</glossterm>

    <glossdef>
      <para>An extension of Java that supports <emphasis>Aspect-Ori&#x2060;ented
      Programming</emphasis>. AspectJ (<link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link>) supports two forms of
      syntax: an extended Java-based syntax, and a &#x201C;pure&#x201D; Java syntax that
      uses Java annotations to indicate the <emphasis>pointcuts</emphasis> and
      <emphasis>advices</emphasis> of an aspect. The aspect behaviors
      (advices) can be incorporated into the target code at compile time, as a
      <phrase role="keep-together">post-</phrase><phrase role="keep-together">compile</phrase> &#x201C;weaving&#x201D; step, or at load
      time.<indexterm>
          <primary>AspectJ library</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-attribute">
    <glossterm>Attribute</glossterm>

    <glossdef>
      <para>Another name for a <emphasis>field</emphasis>, used by <phrase role="keep-together">convention</phrase> in many object-oriented
      programming languages. Scala follows Java&#x2019;s convention of preferring the
      term <emphasis>field</emphasis> over <emphasis role="keep-together">attribute</emphasis>.<indexterm>
          <primary>attributes</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-auxiliary-constructor">
    <glossterm>Auxiliary Constructor</glossterm>

    <glossdef>
      <para>A secondary constructor of a class, declared as a method named
      <literal>this</literal> with no return type. An auxiliary constructor
      must invoke the <emphasis>primary constructor</emphasis> or a previously
      defined <emphasis>auxiliary constructor</emphasis> as the first or only
      statement in its method body.<indexterm>
          <primary>auxiliary constructors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-base-type">
    <glossterm>Base Type</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>parent type</emphasis>.<indexterm>
          <primary>base type</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-behavior-driven-development">
    <glossterm>Behavior-Driven Development</glossterm>

    <glossdef>
      <para>A style of <emphasis>Test-Driven Development</emphasis> (TDD) that
      emphasizes TDD&#x2019;s role in driving the understanding of requirements for
      the code. You follow the same process as in TDD, where the &#x201C;tests&#x201D; are
      written before the code. The difference is that the automated tests are
      written in a format that looks more like a requirements (or behavioral)
      specification and less like a test of the code&#x2019;s conformance to the
      requirements. However, the specification format is still executable and
      it still provides the verification, validation, and regression testing
      service that TDD tests provide.<indexterm>
          <primary>BDD (Behavior-Driven Development)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-bound-variable">
    <glossterm>Bound Variable</glossterm>

    <glossdef>
      <para>A <emphasis>variable</emphasis> that is declared as an argument to
      a <emphasis>function literal</emphasis>. It is &#x201C;bound&#x201D; to a value when
      the <emphasis>closure</emphasis> created from the function literal is
      invoked.<indexterm>
          <primary>bound variables</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-by-name-parameter">
    <glossterm>By-Name Parameter</glossterm>

    <glossdef>
      <para>A <emphasis>by-name parameter</emphasis> looks like a function
      value that takes no parameters, but rather than being declared with the
      signature <literal>p: () &#x21D2; R</literal>, where <literal>R</literal> is
      the return type, it is declared with the signature <literal>p: &#x21D2;
      R</literal>. By-name parameters are evaluated every time they are
      referenced in the function, rather than being evaluated
      <emphasis>once</emphasis> just before the function call, like a
      <emphasis>by-value parameter</emphasis>. For example, they are useful
      for a function that is designed to look like a control construct that
      takes a &#x201C;block,&#x201D; not a function with explicit parameter arguments (think
      of how <literal>while</literal> loops look, for example). The function
      argument that has block-like behavior would be a by-name
      parameter.<indexterm>
          <primary>by-name parameters</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-by-value-parameter">
    <glossterm>By-Value Parameter</glossterm>

    <glossdef>
      <para>A <emphasis>by-value parameter</emphasis> is the usual kind of
      method parameter that is evaluated before it is passed to the method.
      Contrast with <emphasis>by-name parameter</emphasis>.<indexterm>
          <primary>by-value parameters</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-call-by-name">
    <glossterm>Call By Name</glossterm>

    <glossdef>
      <para>See <emphasis>by-name parameter</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-call-by-value">
    <glossterm>Call By Value</glossterm>

    <glossdef>
      <para>See <emphasis>by-value parameter</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-call-site">
    <glossterm>Call Site</glossterm>

    <glossdef>
      <para>See <emphasis>declaration site</emphasis>.<indexterm>
          <primary>call site</primary>

          <see>declaration site</see>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-case">
    <glossterm>Case</glossterm>

    <glossdef>
      <para>The keyword used in <emphasis>pattern matching</emphasis>
      expressions for testing an object against an
      <emphasis>extractor</emphasis>, type check, etc.<indexterm>
          <primary>case keyword</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-case-class">
    <glossterm>Case Class</glossterm>

    <glossdef>
      <para>A class declared with the keyword <literal>case</literal>. The
      Scala compiler automatically defines <literal>equals</literal>,
      <literal>hashCode</literal> and <literal>toString</literal> methods for
      the class and creates a <emphasis>companion object</emphasis> with an
      <literal role="keep-together">apply</literal> factory method and an
      <literal>unapply</literal> extractor method. Case classes are
      particularly convenient for use with <emphasis>pattern
      matching</emphasis> (<emphasis>case</emphasis>) expressions.<indexterm>
          <primary>case classes</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-child-type">
    <glossterm>Child Type</glossterm>

    <glossdef>
      <para>A class or trait that inherits from a <literal>parent</literal>
      class or trait. Sometimes called a <emphasis>subtype</emphasis> or
      <emphasis>derived type</emphasis>. See
      <emphasis>inheritance</emphasis>.<indexterm>
          <primary>derived types</primary>
        </indexterm><indexterm>
          <primary>subtypes</primary>
        </indexterm><indexterm>
          <primary>child types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-client">
    <glossterm>Client</glossterm>

    <glossdef>
      <para>An informal term used throughout the book to indicate a section of
      software that uses another as an API, etc.<indexterm>
          <primary>clients</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-class">
    <glossterm>Class</glossterm>

    <glossdef>
      <para>A template for <emphasis>instances</emphasis> that will have the
      same fields, representing state values, and the same methods. Scala
      classes support single <emphasis>inheritance</emphasis> and zero or more
      <emphasis>mixin</emphasis> traits. Contrast with
      <emphasis>type</emphasis>.<indexterm>
          <primary>classes</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-closure">
    <glossterm>Closure</glossterm>

    <glossdef>
      <para>In Scala, an instance that has been created from a
      <emphasis>function literal</emphasis> with all the <emphasis>free
      variables</emphasis> referenced in the function literal bound to
      variables of the same name in the enclosing scope where the function
      literal was defined. In other words, the instance is &#x201C;closed&#x201D; in the
      sense that the free variables are bound. Because they are instances,
      closures are <emphasis>first-class</emphasis> values. They can be passed
      to other functions to customize their behavior. For example,
      <literal>List.foreach</literal> takes a closure that is applied to each
      element in the list. See also <emphasis>bound variables</emphasis> and
      <emphasis>function literals</emphasis>.<indexterm>
          <primary>closures</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-comments">
    <glossterm>Comments</glossterm>

    <glossdef>
      <para>Scala follows the same comment conventions as Java, C#, C++, etc.
      A <literal>// <replaceable>comment</replaceable></literal> goes to the
      end of a line, while a <literal>/* <replaceable role="keep-together">comment</replaceable> */</literal> can cross line
      boundaries.<indexterm>
          <primary>comments</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-companion-class">
    <glossterm>Companion Class</glossterm>

    <glossdef>
      <para>A <literal>class</literal> declared with the same name as an
      object and defined in the same source file. See also <emphasis>companion
      object</emphasis>.<indexterm>
          <primary>companion classes</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-companion-object">
    <glossterm>Companion Object</glossterm>

    <glossdef>
      <para>An <literal>object</literal> declared with the same name as a
      class (called its <emphasis>companion class</emphasis>) and <phrase role="keep-together">defined</phrase> in the same source file. Companion
      objects are where methods and fields are defined that would be statics
      in Java classes, such as factory methods, <literal>apply</literal> and
      <literal role="keep-together">unapply</literal> for pattern matching,
      etc.<indexterm>
          <primary>companion objects</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-component">
    <glossterm>Component</glossterm>

    <glossdef>
      <para>For our purposes, an aggregation of cohesive types that expose
      services through well-defined abstractions, while encapsulating
      implementation details and minimizing coupling to other components.
      (There is a wide-range of definitions for <emphasis>component</emphasis>
      in computer science and industry.)<indexterm>
          <primary>components</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-compound-type">
    <glossterm>Compound Type</glossterm>

    <glossdef>
      <para>The actual type of a declaration of the form <literal>T1 extends
      T2 with T3 with ... TN { R }</literal>, where <literal>R</literal> is
      the <emphasis>refinement</emphasis> (body). Definitions in
      <literal>R</literal> affect the type.<indexterm>
          <primary>compound types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-concrete-type">
    <glossterm>Concrete Type</glossterm>

    <glossdef>
      <para>A <emphasis>class</emphasis>, <emphasis>trait</emphasis>, or
      <emphasis>object</emphasis> with all methods, fields, and types defined.
      <emphasis>Instances</emphasis> can be created from concrete types.
      Contrast with <emphasis>abstract types</emphasis>.<indexterm>
          <primary>concrete types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-contract">
    <glossterm>Contract</glossterm>

    <glossdef>
      <para>The protocol and requirements that exist between a module (e.g.,
      class, trait, object, or even function or method) and clients of the
      module. More specifically, see <emphasis>Design by
      Contract</emphasis>.<indexterm>
          <primary>contract</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-context-free-grammar">
    <glossterm>Context-Free Grammar</glossterm>

    <glossdef>
      <para>A kind of language grammar for which each
      <emphasis>nonterminal</emphasis> can be specified as a
      <emphasis>production</emphasis> without reference to additional context
      information. That is, each nonterminal can appear by itself on the
      lefthand side of the production the specifies it.<indexterm>
          <primary>grammars</primary>

          <secondary>context-free</secondary>
        </indexterm><indexterm>
          <primary>context-free grammars</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-contravariance-or-contravariant">
    <glossterm>Contravariance or Contravariant</glossterm>

    <glossdef>
      <para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal>A</literal>
      is <emphasis>contravariant</emphasis> in a parameterized type
      <literal>T[-A]</literal>, then the <literal>-</literal> is the
      <emphasis>variance annotation</emphasis>, and a type
      <literal>T[B]</literal> is a <emphasis>supertype</emphasis> of
      <literal>T[A]</literal> if <literal>B</literal> is a
      <emphasis>subtype</emphasis> of <literal>A</literal>. See also
      <emphasis>covariance</emphasis> and
      <emphasis>invariance</emphasis>.<indexterm>
          <primary>contravariance or contravariant</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-covariance-or-covariant">
    <glossterm>Covariance or Covariant</glossterm>

    <glossdef>
      <para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal>A</literal>
      is <emphasis>covariant</emphasis> in a parameterized type
      <literal>T[+A]</literal>, then the <literal>+</literal> is the
      <emphasis>variance annotation</emphasis>, and a type
      <literal>T[B]</literal> is a <emphasis>subtype</emphasis> of
      <literal>T[A]</literal> if <literal>B</literal> is a
      <emphasis>subtype</emphasis> of <literal>A</literal>. See also
      <emphasis>contravariance</emphasis> and
      <emphasis>invariance</emphasis>.<indexterm>
          <primary>covariance or covariant</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-cross-cutting-concerns">
    <glossterm>Cross-Cutting Concerns</glossterm>

    <glossdef>
      <para>&#x201C;Concerns&#x201D; (kinds of requirements, design or coding issues) that
      don&#x2019;t fit in the same boundaries as the primary modularity
      decomposition. The same behaviors must be invoked consistently at
      specific execution points over a range of objects and functions. For
      example, the same ORM (<phrase role="keep-together">Object-</phrase><phrase role="keep-together">Relational</phrase> Mapping) persistence strategy
      needs to be used consistently for a set of classes, not just a single
      class. Hence, such concerns are said to be cross-cutting. Supporting
      these concerns should not involve duplication of code, etc. See also
      <emphasis>aspect-</emphasis><emphasis role="keep-together">oriented
      programming</emphasis>.<indexterm>
          <primary>cross-cutting concerns</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-currying">
    <glossterm>Currying</glossterm>

    <glossdef>
      <para>Converting an N argument function into a sequence of N functions
      of one argument, where each function except for the last <phrase role="keep-together">returns</phrase> a new function that takes a single
      argument that returns a new function, etc., until the last function that
      takes a single <phrase role="keep-together">argument</phrase> and
      returns a value.<indexterm>
          <primary>currying</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-declaration-site">
    <glossterm>Declaration Site</glossterm>

    <glossdef>
      <para>In reference to how the <emphasis>variance</emphasis> behavior of
      parameterized types is specified, in Scala, this is done when types are
      <emphasis>declared</emphasis>, i.e., at the <emphasis>declaration
      site</emphasis>. In Java, it is done when types are
      <emphasis>called</emphasis> (that is, used), i.e., at the <emphasis>call
      site</emphasis>.<indexterm>
          <primary>declaration site</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-declarative-programming">
    <glossterm>Declarative Programming</glossterm>

    <glossdef>
      <para>The quality of many <emphasis>functional</emphasis> programs and
      <emphasis>Domain-Specific Languages</emphasis> where the code consists
      of statements that declare relationships between values and types,
      rather than directing the system to take a particular sequence of
      action. Contrast with <emphasis>imperative
      programming</emphasis>.<indexterm>
          <primary>declarative programming</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-default-argument-value">
    <glossterm>Default Argument Value</glossterm>

    <glossdef>
      <para>(Scala version 2.8.) The ability to define a default value for a
      method argument that will be used if the caller does not specify a
      value. See also <emphasis>implicit argument</emphasis> and
      <emphasis>named argument</emphasis>.<indexterm>
          <primary>default argument value</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-dependency-injection">
    <glossterm>Dependency Injection</glossterm>

    <glossdef>
      <para>A form of <emphasis>inversion of control</emphasis> where an
      object&#x2019;s external dependencies are given to it, either programmatically
      or through a DI framework that is driven by configuration information.
      Hence, the object remains &#x201C;passive,&#x201D; rather than taking an active role
      in resolving dependencies. The injection mechanism uses constructor
      arguments or field setters provided by the object. DI minimizes the
      coupling of objects; they only need to know about the abstractions of
      their dependencies.<indexterm>
          <primary>dependency injection (DI)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-derived-type">
    <glossterm>Derived Type</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>child type</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-design-by-contract">
    <glossterm>Design By Contract</glossterm>

    <glossdef>
      <para>An approach to class and module design invented by Bertrand Meyer
      for the Eiffel language. For each entry point, valid inputs are
      specified in a programmatic way, so they can be validated during
      testing. These specifications are called
      <emphasis>preconditions</emphasis>. Similarly, <phrase role="keep-together">assuming</phrase> the preconditions are specified,
      specifications on the guaranteed results are called
      <emphasis>postconditions</emphasis> and are also specified in an
      executable way. <emphasis>Invariants</emphasis> can also be specified
      that should be true on entry and on exit.<indexterm>
          <primary>Design by Contract</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-design-pattern">
    <glossterm>Design Pattern</glossterm>

    <glossdef>
      <para>A solution to a problem in a context. A code idiom or design
      structure that satisfies the needs of a frequently occurring problem,
      constraint, requirement, etc.<indexterm>
          <primary>design patterns</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-domain-specific-language">
    <glossterm>Domain-Specific Language</glossterm>

    <glossdef>
      <para>A custom programming language that resembles the terms, idioms,
      and expressions of a particular domain. An <emphasis>internal</emphasis>
      DSL is an idiomatic form of a general-purpose programming language. That
      is, no <phrase role="keep-together">special-</phrase><phrase role="keep-together">purpose</phrase> parser is created for the
      language. <phrase role="keep-together">Instead</phrase>, DSL code is
      written in the general-purpose language and parsed just like any other
      code. An <emphasis>external</emphasis> DSL is a language with its own
      grammar and parser.<indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-duck-typing">
    <glossterm>Duck Typing</glossterm>

    <glossdef>
      <para>A term used in languages with <emphasis>dynamic typing</emphasis>
      for the way method resolution works. As long as an object accepts a
      method call (message send), the runtime is satisfied. &#x201C;If it walks like
      a duck and talks like a duck, it&#x2019;s a duck.&#x201D; Contrast with the use of
      <emphasis>structural types</emphasis> in some <emphasis>statically
      typed</emphasis> languages like Scala.<indexterm>
          <primary>duck typing</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-dynamic-typing">
    <glossterm>Dynamic Typing</glossterm>

    <glossdef>
      <para>Loosely speaking, late binding of type information, sometimes
      referred to as binding to the value a reference is assigned to, rather
      than to the reference itself. Contrast with <emphasis>static
      typing</emphasis>.<indexterm>
          <primary>dynamic typing</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-encapsulation">
    <glossterm>Encapsulation</glossterm>

    <glossdef>
      <para>Restricting the visibility of members of a type so they are not
      visible to clients of the type when they shouldn&#x2019;t be. This is a way of
      exposing only the <emphasis>abstraction</emphasis> supported by the
      type, while hiding implementation details, which prevents unwanted
      access to them from clients and keeps the
      <emphasis>abstraction</emphasis> exposed by the type consistent and
      <phrase role="keep-together">minimal</phrase>.<indexterm>
          <primary>encapsulation</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-event">
    <glossterm>Event</glossterm>

    <glossdef>
      <para>The notification of a state change in <emphasis>event-based
      concurrency</emphasis>.<indexterm>
          <primary>events</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-event-based-concurrency">
    <glossterm>Event-Based Concurrency</glossterm>

    <glossdef>
      <para>A high-performance form of concurrency where events are used to
      signal important state changes and handlers are used to <phrase role="keep-together">respond</phrase> to the events.<indexterm>
          <primary>events</primary>

          <secondary>using for concurrency</secondary>
        </indexterm><indexterm>
          <primary>concurrency</primary>

          <secondary>event-based</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-existential-types">
    <glossterm>Existential Types</glossterm>

    <glossdef>
      <para>A way of expressing the presence of a type without knowing its
      concrete value, sometimes, because it can&#x2019;t be known. It is used
      primarily to support aspects of Java&#x2019;s type system within Scala&#x2019;s type
      system, including <emphasis>type erasure</emphasis>, &#x201C;raw&#x201D; types (e.g.,
      pre-Java 5 collections), and <emphasis>call site</emphasis>
      <emphasis>type variance</emphasis>.<indexterm>
          <primary>existential types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-extractor">
    <glossterm>Extractor</glossterm>

    <glossdef>
      <para>An <literal>unapply</literal> method defined in a
      <emphasis>companion object</emphasis> that is used to extract the
      constituent values for fields in an object. They are most commonly used
      in <emphasis>pattern matching</emphasis> <phrase role="keep-together">expressions</phrase>.<indexterm>
          <primary>extractors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-field">
    <glossterm>Field</glossterm>

    <glossdef>
      <para>A <literal>val</literal> or <literal>var</literal> in a type that
      represents part, if not all, of the state of a corresponding instance of
      the type.<indexterm>
          <primary>fields</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-final">
    <glossterm>Final</glossterm>

    <glossdef>
      <para>Keyword for declarations. For types, <literal>final</literal>
      prevents users from subclassing the type. For type members,
      <literal>final</literal> prevents users from overriding the
      members.<indexterm>
          <primary>final keyword</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-first-class">
    <glossterm>First Class</glossterm>

    <glossdef>
      <para>An adjective indicating that the applicable &#x201C;thing&#x201D; is a
      first-class value in the language, meaning you can assign instances to
      variables, pass them as function parameters, and return them from
      functions. Often used to refer to <emphasis>functions</emphasis>, which
      are first-class values in Scala and other <emphasis>functional
      programming</emphasis> languages.<indexterm>
          <primary>first class</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-for-comprehension">
    <glossterm>For Comprehension</glossterm>

    <glossdef>
      <para>Another name for Scala&#x2019;s <literal>for</literal> expression.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-formal-parameter">
    <glossterm>Formal Parameter</glossterm>

    <glossdef>
      <para>Another name for a function argument, used in the context of
      binding the <emphasis>free variables</emphasis> in the
      function.<indexterm>
          <primary>formal parameters</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-free-variable">
    <glossterm>Free Variable</glossterm>

    <glossdef>
      <para>A <emphasis>variable</emphasis> that is referenced in a
      <emphasis>function literal</emphasis> but is not passed in as an
      argument. Therefore, it must be &#x201C;bound&#x201D; to a defined variable of the
      same name in the context where the function literal is defined, to form
      a <emphasis>closure</emphasis>.<indexterm>
          <primary>free variables</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-function">
    <glossterm>Function</glossterm>

    <glossdef>
      <para>In Scala, the term <emphasis>function</emphasis> is used for a
      function that is not tied to a particular object or class. Contrast with
      <emphasis>method</emphasis>. Functions are instances of
      <literal>FunctionN</literal> types, where <literal>N</literal> is the
      <emphasis>arity</emphasis> of the function.<indexterm>
          <primary>functions</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-function-literal">
    <glossterm>Function Literal</glossterm>

    <glossdef>
      <para>Scala&#x2019;s term for an anonymous <emphasis>function</emphasis>
      expression, from which <emphasis>closures</emphasis> are
      created.<indexterm>
          <primary>function literals</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-function-type">
    <glossterm>Function Type</glossterm>

    <glossdef>
      <para>In Scala, all functions are instances of <literal role="keep-together">FunctionN[-T1, T2, ..., TN, +R]</literal> types,
      where <literal>N</literal> is the number of arguments (0 through 22 are
      supported). The type signature syntax <literal>(T1, T2, ..., TN) &#x21D2;
      R</literal> is used for declaring concrete instances, i.e., function
      literals.<indexterm>
          <primary>function types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-functional-programming">
    <glossterm>Functional Programming</glossterm>

    <glossdef>
      <para>A form of programming that mimics the way mathematical functions
      and variables work. Mathematical functions are
      <emphasis>side-effect-free</emphasis>, and they are composable from
      other functions. Variables are assigned once. Functions can be assigned
      to variables and <phrase role="keep-together">returned</phrase> from
      other functions.<indexterm>
          <primary>functional programming</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-generator">
    <glossterm>Generator</glossterm>

    <glossdef>
      <para>Expressions like <literal>i &lt;- listOfInts</literal> in
      <literal>for</literal> expressions. Each pass through the loop
      <emphasis>generates</emphasis> a new <literal>val</literal>
      <literal>i</literal> taken from the list <literal>listOfInts</literal>,
      in this example.<indexterm>
          <primary>generators</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-generics">
    <glossterm>Generics</glossterm>

    <glossdef>
      <para>Another term for <emphasis>parameterized types</emphasis>, used
      more often in Java than Scala.<indexterm>
          <primary>generics</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-higher-order-functions">
    <glossterm>Higher-Order Functions</glossterm>

    <glossdef>
      <para>Functions that take other functions as arguments or return a
      function value.<indexterm>
          <primary>functions</primary>

          <secondary>higher order</secondary>
        </indexterm><indexterm>
          <primary>higher-order functions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-immutable-value">
    <glossterm>Immutable Value</glossterm>

    <glossdef>
      <para>A value that can&#x2019;t be changed after it has been initialized.
      Contrast with <emphasis>mutable value</emphasis>.<indexterm>
          <primary>immutable values</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-imperative-programming">
    <glossterm>Imperative Programming</glossterm>

    <glossdef>
      <para>The quality of many <emphasis>object-oriented</emphasis> and
      &#x201C;procedural&#x201D; programs where the code consists of statements directing
      the system to take a particular sequence of actions. Contrast with
      <emphasis>declarative programming</emphasis>.<indexterm>
          <primary>imperative programming</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-implicit">
    <glossterm>Implicit</glossterm>

    <glossdef>
      <para>A Scala keyword used to mark a method or function value as
      eligible for use as an <emphasis>implicit type conversion</emphasis>.
      The keyword is also used to mark an <emphasis>implicit
      argument</emphasis>.<indexterm>
          <primary>implicit keyword</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-implicit-type-conversion">
    <glossterm>Implicit Type Conversion</glossterm>

    <glossdef>
      <para>A method or function value that is marked with the
      <emphasis>implicit</emphasis> keyword, marking it as eligible for use as
      an <emphasis>implicit type conversion</emphasis>, whenever it is in
      scope and conversion is needed (e.g., for the <emphasis>Pimp My
      Library</emphasis> <phrase role="keep-together">pattern</phrase>).<indexterm>
          <primary>implicit conversions</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-implicit-argument">
    <glossterm>Implicit Argument</glossterm>

    <glossdef>
      <para>Method arguments that are optional for the user to specify and
      indicated with the <literal>implicit</literal> keyword. If the user does
      not specify a value for the argument, a default value is used instead,
      which is either an in-scope value of the same type or the result of
      calling an in-scope, no-argument method that returns an instance of the
      same type. See also <emphasis>default argument
      value</emphasis>.<indexterm>
          <primary>implicit arguments</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-infinite-data-structure">
    <glossterm>Infinite Data Structure</glossterm>

    <glossdef>
      <para>A data structure that represents a non-<phrase role="keep-together">terminating</phrase> collection of values, but
      which is capable of doing so without exhausting system resources. The
      values are not computed until the data structure is asked to produce
      them. As long as only a finite subset of the values are requested,
      resource exhaustion is avoided.<indexterm>
          <primary>infinite data structures</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-infix-notation">
    <glossterm>Infix Notation</glossterm>

    <glossdef>
      <para>A syntax supported by the compiler for methods with one argument.
      The method can be invoked without the period between the object and the
      method name and without the parentheses around the argument. When used
      for methods named with <emphasis>operator characters</emphasis>, the
      syntax provides a form of <emphasis>operator overloading</emphasis>.
      Sometimes also called <emphasis>operator notation</emphasis>. See also
      <emphasis>postfix no&#x2060;tation</emphasis>.<indexterm>
          <primary>operator notation</primary>
        </indexterm><indexterm>
          <primary>infix notation</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-infix-type">
    <glossterm>Infix Type</glossterm>

    <glossdef>
      <para>When a parameterized type of the form <literal>Op[A,B]</literal>
      is used to instantiate a type, it can also be written as <literal>A Op
      B</literal>. For example, <literal>Or[Throwable,Boolean]</literal> can
      be written <literal role="keep-together">Throwable Or
      Boolean</literal>.<indexterm>
          <primary>infix types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-inheritance">
    <glossterm>Inheritance</glossterm>

    <glossdef>
      <para>A strong relationship between one class or trait and another class
      or trait. The <phrase role="keep-together">inheriting</phrase>
      (<emphasis>derived</emphasis>) class or trait incorporates the members
      of the <emphasis>parent</emphasis> class or trait, as if they were
      defined within the derivative. The derivative may override inherited
      members (in most cases). Instances of a derivative are
      <emphasis>substitutable</emphasis> for instances of the
      parent.<indexterm>
          <primary>inheritance</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-instance-or-instantiate">
    <glossterm>Instance or Instantiate</glossterm>

    <glossdef>
      <para>An <emphasis>object</emphasis> created by invoking a
      <emphasis>class</emphasis> constructor. The word
      <emphasis>object</emphasis> is synonymous in most object-oriented
      languages, but we use the term <emphasis>object</emphasis> to refer to
      an explicitly <phrase role="keep-together">declared</phrase> Scala
      <emphasis>object</emphasis>, and we use the term <emphasis role="keep-together">instance</emphasis> (and the verb
      <emphasis>instantiate</emphasis>) for the more general case.<indexterm>
          <primary>instantiate</primary>
        </indexterm><indexterm>
          <primary>instance</primary>
        </indexterm></para>

      <para id="para_instantiation_can_also_refer_t">Instantiation can also
      refer to creating a <emphasis>concrete type</emphasis> from a
      <emphasis>parameterized type</emphasis> <phrase role="keep-together">by
      specifying concrete</phrase> types for the <phrase role="keep-together">parameters</phrase>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-invariance-and-invariant">
    <glossterm>Invariance and Invariant</glossterm>

    <glossdef>
      <para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal>A</literal>
      is <emphasis>invariant</emphasis> in a parameterized type
      <literal>T[A]</literal>, then there is no <emphasis>variance
      annotation</emphasis>, and a type <literal>T[B]</literal> is a
      <emphasis>subtype</emphasis> of <literal>T[A]</literal> if and only if
      <literal>B</literal> equals <literal>A</literal>. That is, the type
      can&#x2019;t be changed. See also <emphasis>covariance</emphasis> and <emphasis role="keep-together">contravariance</emphasis>.<indexterm>
          <primary>invariance and invariant</primary>
        </indexterm></para>

      <para id="para_in_the_context_of__design_by_c">In the context of
      <emphasis>Design by Contract</emphasis>, an assertion that should be
      true before and after a method is executed.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-inversion-of-control">
    <glossterm>Inversion of Control</glossterm>

    <glossdef>
      <para>The idea that an object should not instantiate its own copies of
      external dependencies, but rather rely on other mechanisms to supply
      those dependencies. IoC promotes better decoupling and testability, as
      the object only knows about the abstractions of its dependencies, not
      specific concrete implementers of them. A weak form of IoC is when an
      object calls a factory, service locator, etc., to obtain the dependents.
      Hence, the object still has an active role and it has a dependency on
      the &#x201C;provider.&#x201D; The strongest form of IoC is <emphasis>dependency
      injection</emphasis>, where the object remains &#x201C;passive.&#x201D;<indexterm>
          <primary>inversion of control (IoC)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-lazy">
    <glossterm>Lazy</glossterm>

    <glossdef>
      <para>Immutable variables (<literal>val</literal>s) can be declared
      <literal>lazy</literal>, meaning they will only be evaluated when they
      are read. This feature is useful for expensive evaluations that may not
      be <phrase role="keep-together">needed</phrase>.<indexterm>
          <primary>lazy, defined</primary>
        </indexterm></para>

      <para id="para_lazy_data_structures_can_also_">Lazy data structures can
      also be used to <phrase role="keep-together">define</phrase> infinite
      data structures that won&#x2019;t exhaust system resources as long as only a
      finite subset of the structure is evaluated. The
      <literal>Stream</literal> and <literal>Range</literal> classes are both
      lazy. <phrase role="keep-together">Contrast</phrase> with
      <emphasis>strict</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-linearization">
    <glossterm>Linearization</glossterm>

    <glossdef>
      <para>The algorithm used for a type to resolve member lookup, such as
      overridden methods, including calls to
      <literal>super</literal>.<indexterm>
          <primary>linearization of object hierarchy</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-literal">
    <glossterm>Literal</glossterm>

    <glossdef>
      <para>Used to refer to &#x201C;literal&#x201D; value expressions, such as numbers
      (e.g., <literal>1</literal>, <literal>3.14</literal>), strings (e.g.,
      &#x201C;Hello Scala!&#x201D;), tuples (e.g., <literal>(1, 2, 3)</literal>), and
      <emphasis>function literals</emphasis> (e.g., <literal>(x) &#x21D2; x +
      x</literal>).<indexterm>
          <primary>literals</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-lower-type-bounds">
    <glossterm>Lower Type Bounds</glossterm>

    <glossdef>
      <para>See <emphasis>type bounds</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mailbox">
    <glossterm>Mailbox</glossterm>

    <glossdef>
      <para>The queue where an <emphasis>Actor&#x2019;s</emphasis> messages are
      stored until the Actor processes them in the A<emphasis>ctor model of
      concurrency</emphasis>.<indexterm>
          <primary>mailbox for Actors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-main">
    <glossterm>Main</glossterm>

    <glossdef>
      <para>The entry function for an application that is invoked by the
      runtime is called <literal>main</literal>. The name dates back to the
      <emphasis>C</emphasis> language. In Scala, a <literal>main</literal>
      <emphasis>method</emphasis> must be defined in an
      <literal>object</literal>. Java, by way of contrast, requires a
      <literal>main</literal> method to be defined as a static method of a
      <literal>class</literal>.<indexterm>
          <primary>main method</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mapreduce">
    <glossterm>MapReduce</glossterm>

    <glossdef>
      <para>A divide-and-conquer strategy for processing large data sets in
      parallel. In the &#x201C;map&#x201D; phase, the data sets are subdivided. The desired
      computation is performed on each subset. The &#x201C;reduce&#x201D; phase combines the
      results of the subset calculations into a final result. MapReduce
      frameworks handle the details of managing the operations and the nodes
      they run on, including restarting <phrase role="keep-together">operations</phrase> that fail for some reason. The
      user of the framework only has to write the algorithms for mapping and
      reducing <phrase role="keep-together">the data sets and</phrase>
      computing with the <phrase role="keep-together">subsets</phrase>.<indexterm>
          <primary>MapReduce</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-member">
    <glossterm>Member</glossterm>

    <glossdef>
      <para>A generic term for a <emphasis>type</emphasis>,
      <emphasis>field</emphasis>, or <emphasis>method</emphasis> declared in a
      <emphasis>class</emphasis> or <emphasis>trait</emphasis>.<indexterm>
          <primary>members</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-memoization">
    <glossterm>Memoization</glossterm>

    <glossdef>
      <para>A form of caching that optimizes function invocations. The results
      from a function&#x2019;s invocations are saved so that when repeated
      invocations with the same inputs are made, the cached results can be
      returned instead of reinvoking the function.<indexterm>
          <primary>memoization</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-message">
    <glossterm>Message</glossterm>

    <glossdef>
      <para>In the <emphasis>Actor model of concurrency</emphasis>, messages
      are exchanged between Actors to coordinate their work.<indexterm>
          <primary>messages</primary>
        </indexterm></para>

      <para id="para_in_object_oriented_programming">In object-oriented
      programming, method invocation is sometimes referred to as &#x201C;sending a
      message to an object,&#x201D; especially in certain languages, like Smalltalk
      and, to some extent, Ruby.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-method">
    <glossterm>Method</glossterm>

    <glossdef>
      <para>A <emphasis>function</emphasis> that is associated exclusively
      with an instance, either defined in a <emphasis>class</emphasis>,
      <emphasis>trait</emphasis>, or <emphasis>object</emphasis> definition.
      Methods can only be invoked using the <literal>object.method</literal>
      syntax.<indexterm>
          <primary>methods</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mixin">
    <glossterm>Mixin</glossterm>

    <glossdef>
      <para>A narrowly focused encapsulation of state and behavior that is
      more useful as an adjunct to another object&#x2019;s state and behavior, rather
      than standing on its own. Mixins in Scala are implemented using
      <emphasis>traits</emphasis>.<indexterm>
          <primary>mixins</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-multiple-inheritance">
    <glossterm>Multiple Inheritance</glossterm>

    <glossdef>
      <para>In some languages, but not Scala, a type can extend more than one
      parent class. Compare to <emphasis>single
      inheritance</emphasis>.<indexterm>
          <primary>multiple inheritance</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mutable-value">
    <glossterm>Mutable Value</glossterm>

    <glossdef>
      <para>A value that can be changed after it has been initialized.
      Contrast with <emphasis>immutable value</emphasis>.<indexterm>
          <primary>mutable values</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-named-argument">
    <glossterm>Named Argument</glossterm>

    <glossdef>
      <para>(Scala version 2.8.) The ability to refer to a method argument by
      name when calling the method. It is useful in combination with
      <emphasis>default argument values</emphasis> for minimizing the number
      of arguments that have to be specified by the caller.<indexterm>
          <primary>named arguments</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-nonterminal">
    <glossterm>Nonterminal</glossterm>

    <glossdef>
      <para>An item in a grammar that requires further decomposition into one
      or more <emphasis>nonterminals</emphasis> (including possibly a
      recursive reference to itself) and
      <emphasis>terminals</emphasis>.<indexterm>
          <primary>nonterminals</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-object">
    <glossterm>Object</glossterm>

    <glossdef>
      <para>A cohesive unit with a particular state, possible state
      transitions, and behaviors. In Scala, the keyword
      <literal>object</literal> is used to declare a
      <emphasis>singleton</emphasis> explicitly, using the same syntax as
      <emphasis>class</emphasis> declarations, except for the lack of
      constructor parameters and auxiliary parameters (because
      <literal>objects</literal> are instantiated by the Scala runtime, not by
      user code). To avoid confusion with <literal>objects</literal>, we use
      the term <emphasis>instance</emphasis> to refer to
      <emphasis>instances</emphasis> of <emphasis>classes</emphasis> and
      <literal>objects</literal> generically.<indexterm>
          <primary>objects</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-object-oriented-programming">
    <glossterm>Object-Oriented Programming</glossterm>

    <glossdef>
      <para>A form of programming that encapsulates state values and
      operations on that state, exposing a cohesive abstraction to clients of
      the object while hiding internal implementation details. OOP also
      supports subtyping to define specializations and &#x201C;family&#x201D; relationships
      between types.<indexterm>
          <primary>object-oriented programming (OOP)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-operator-characters">
    <glossterm>Operator Characters</glossterm>

    <glossdef>
      <para>Characters like <literal>&lt;</literal>, <literal>*</literal>,
      etc. that are not letters, nor digits, nor reserved characters, like
      left and right parentheses, curly braces, square brackets, the
      semicolon, colon, or comma. These characters can be used in method names
      to implement a form of <emphasis>operator</emphasis> <emphasis role="keep-together">overloading</emphasis>.<indexterm>
          <primary>operator characters</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-operator-notation">
    <glossterm>Operator Notation</glossterm>

    <glossdef>
      <para>See <emphasis>infix notation</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-operator-overloading">
    <glossterm>Operator Overloading</glossterm>

    <glossdef>
      <para>The feature in some languages where standard mathematical
      operators, like <literal>*</literal>, <literal>/</literal>,
      <literal>&lt;</literal>, etc., can be defined by users for custom types.
      In Scala, a form of operator overloading is supported by allowing
      operator characters to be used as normal method names and by allowing
      methods with one argument to be invoked with <emphasis>infix
      notation</emphasis>. The &#x201C;operator precedence&#x201D; for these methods is
      determined by the first character, e.g., method <literal>*&lt;</literal>
      will have higher precedence than method
      <literal>+&lt;</literal>.<indexterm>
          <primary>operator overloading</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-overloaded-functions">
    <glossterm>Overloaded Functions</glossterm>

    <glossdef>
      <para>Two or more functions defined in the same scope (e.g., as methods
      in a type or as &#x201C;bare&#x201D; functions) that have the same name but different
      <emphasis>signatures</emphasis>.<indexterm>
          <primary>functions</primary>

          <secondary>overloaded</secondary>
        </indexterm><indexterm>
          <primary>overloaded functions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-package-objects">
    <glossterm>Package Objects</glossterm>

    <glossdef>
      <para>A special kind of object declaration that declares members that
      should be visible at the scope of the named package. For example, for
      the declaration <literal>package object math { type Complex = ...
      }</literal>, the <literal>Complex</literal> type can be referenced as
      <literal>math.Complex</literal>. (Scala version 2.8.)<indexterm>
          <primary>package objects</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-packrat-parsers">
    <glossterm>Packrat Parsers</glossterm>

    <glossdef>
      <para>Parsers for <emphasis>parsing expression grammars</emphasis>
      (PEGs; see <link linkend="Ford" xrefstyle="select:nopage">[Ford]</link>). They have several benefits,
      such as lack of ambiguity and good performance characteristics. The
      forthcoming Scala version 2.8 parser combinator library will add support
      for creating packrat <phrase role="keep-together">parsers</phrase>.<indexterm>
          <primary>packrat parsers</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-parameterized-types">
    <glossterm>Parameterized Types</glossterm>

    <glossdef>
      <para>Scala&#x2019;s analog of <emphasis>generics</emphasis> in Java.
      Parameterized types are defined with placeholder parameters for types
      they use. When an instance of a parameterized type is created, specific
      types must be specified to replace <phrase role="keep-together">all the
      type</phrase> parameters. See also <emphasis>type</emphasis> <emphasis role="keep-together">constructor</emphasis>.<indexterm>
          <primary>parameterized types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-parent-type">
    <glossterm>Parent Type</glossterm>

    <glossdef>
      <para>A class or trait from which another class or trait is
      <emphasis>derived</emphasis>. Also called a
      <emphasis>supertype</emphasis> or <emphasis>base type</emphasis>. See
      <emphasis>inheritance</emphasis>.<indexterm>
          <primary>parent classes</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-parsing-expression-grammars-pegs">
    <glossterm>Parsing expression grammars (PEGs)</glossterm>

    <glossdef>
      <para>An alternative to <emphasis>context-free grammars</emphasis> that
      provide guaranteed linear-time parsing <phrase role="keep-together">using</phrase> <emphasis>memoization</emphasis> and
      unambiguous <phrase role="keep-together">grammars</phrase> (<link linkend="PEG" xrefstyle="select:nopage">[PEG]</link>).<indexterm>
          <primary>PEGs (parsing expression grammars)</primary>
        </indexterm><indexterm>
          <primary>grammars</primary>

          <secondary>parsing expression grammars (PEGs)</secondary>
        </indexterm><indexterm>
          <primary>parsing expression grammars (PEGs)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-partial-application">
    <glossterm>Partial Application</glossterm>

    <glossdef>
      <para>Associated with <emphasis>currying</emphasis>, where a subset of a
      curried function&#x2019;s arguments are applied, yielding a new function that
      takes the remaining arguments.<indexterm>
          <primary>partial application</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-partial-function">
    <glossterm>Partial Function</glossterm>

    <glossdef>
      <para>A function that is not valid over the whole range of its
      arguments. Pattern matching expressions can be converted to partial
      functions by the compiler in some contexts.<indexterm>
          <primary>partial functions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-path-dependent-type">
    <glossterm>Path-Dependent Type</glossterm>

    <glossdef>
      <para>A nested type T is unique based on its &#x201C;path,&#x201D; the hierarchical,
      period-delimited list of the enclosing packages, the enclosing types,
      and finally the type T itself. Instances of T can have different,
      incompatible types. For example, if T is nested in a trait and the trait
      appears in the <emphasis>linearizations</emphasis> of different types,
      then the instances in those Ts will have different types.<indexterm>
          <primary>path-dependent types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-pattern-matching">
    <glossterm>Pattern Matching</glossterm>

    <glossdef>
      <para>Case expressions, usually in a match expression, that compare an
      object against <phrase role="keep-together">possible</phrase> types,
      type extractors, regular expressions, etc., to determine the appropriate
      handling.<indexterm>
          <primary>pattern matching</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-pimp-my-library">
    <glossterm>Pimp My Library</glossterm>

    <glossdef>
      <para>The name of a design pattern that appears to add new methods to a
      type. It uses an <emphasis>implicit type conversion</emphasis> to
      automatically wrap the type in a wrapper type, where the wrapper type
      has the desired methods.<indexterm>
          <primary>Pimp My Library design pattern</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-precondition">
    <glossterm>Precondition</glossterm>

    <glossdef>
      <para>An assertion that should be true on entry to a method or other
      entry point. See <emphasis>Design by Contract</emphasis>.<indexterm>
          <primary>preconditions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-postcondition">
    <glossterm>Postcondition</glossterm>

    <glossdef>
      <para>An assertion that should be true on exit from a method or other
      boundary point. See <emphasis>Design by Contract</emphasis>.<indexterm>
          <primary>postconditions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-postfix-notation">
    <glossterm>Postfix Notation</glossterm>

    <glossdef>
      <para>A syntax supported by the compiler for methods with no argument,
      sometimes called <emphasis>nullary</emphasis> methods. The method can be
      invoked without the period between the <phrase role="keep-together">object</phrase> and the method name. See also
      <emphasis>infix no&#x2060;tation</emphasis>.<indexterm>
          <primary>postfix notation</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-primary-constructor">
    <glossterm>Primary Constructor</glossterm>

    <glossdef>
      <para>The main constructor of a class, consisting of the class body with
      the parameter list specified after the name of the class. See also
      <emphasis>auxiliary constructor</emphasis>.<indexterm>
          <primary>primary constructor</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-primitive-type">
    <glossterm>Primitive Type</glossterm>

    <glossdef>
      <para>A non-object type on the underlying runtime platform (e.g., JVM
      and .NET). Scala does not have primitive types at the source code level.
      Rather, it uses <emphasis>value types</emphasis>, which are subclasses
      of <literal>AnyVal</literal>, to wrap runtime primitives, providing
      object semantics at the code level, while using boxing and unboxing of
      primitives at the byte code level to optimize performance.<indexterm>
          <primary>primitive data types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-production">
    <glossterm>Production</glossterm>

    <glossdef>
      <para>A term used for each part of a grammar that decomposes a specific
      <emphasis>nonterminal</emphasis> into other nonterminals (perhaps
      including a <phrase role="keep-together">recursive</phrase> reference to
      the original nonterminal) and <emphasis>terminals</emphasis>.<indexterm>
          <primary>production</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-pure">
    <glossterm>Pure</glossterm>

    <glossdef>
      <para>Used in the context of functions to mean that they are
      <emphasis>side-effect-free</emphasis>. See also <emphasis>referential
      transparency</emphasis>.<indexterm>
          <primary>pure (side-effect-free functions)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-recursion">
    <glossterm>Recursion</glossterm>

    <glossdef>
      <para>When a function calls itself as part of its computation. A
      termination condition is required to prevent an infinite recursion. See
      also <emphasis>tail-call recursion</emphasis>.<indexterm>
          <primary>recursion</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-reference-type">
    <glossterm>Reference Type</glossterm>

    <glossdef>
      <para>A type whose instances are implemented as objects on the runtime
      platform. All reference types subtype
      <literal>AnyRef</literal>.<indexterm>
          <primary>reference types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-referential-transparency">
    <glossterm>Referential Transparency</glossterm>

    <glossdef>
      <para>The property of an expression, such as a function, where it can be
      replaced with its value without changing the behavior of the code. This
      can be done with <emphasis>side-effect-free</emphasis> functions when
      the inputs are the same. The primary benefit of referential transparency
      is that it is easy to reason about the behavior of a function, without
      having to understand the context in which it is invoked. That makes the
      function easier to test, refactor, and reuse.<indexterm>
          <primary>referential transparency</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-refinement">
    <glossterm>Refinement</glossterm>

    <glossdef>
      <para>The term used for adding or overriding members in a type body for
      a <emphasis>compound type</emphasis>.<indexterm>
          <primary>refinement in compound type declarations</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-reified-types">
    <glossterm>Reified Types</glossterm>

    <glossdef>
      <para>Where the specific types used when instantiating a generic type
      are retained in the byte code, so the information is available at
      runtime. This is a property of .NET byte code, but not JVM byte code,
      which uses <emphasis>type erasure</emphasis>. To minimize
      incompatibilities, both the Java and .NET Scala versions use
      <emphasis>type erasure.<indexterm>
          <primary>reified types</primary>
        </indexterm></emphasis></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-repl">
    <glossterm>REPL</glossterm>

    <glossdef>
      <para>A name given to interactive language interpreters, like the
      <literal>scala</literal> command in interpreter mode. REPL is an acronym
      for <emphasis>Read, Evaluate, Print, Loop</emphasis>.<indexterm>
          <primary>REPL (Read, Evaluate, Print, Loop)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-scaladocs">
    <glossterm>Scaladocs</glossterm>

    <glossdef>
      <para>The API documentation generated from Scala source code using the
      <literal>scaladoc</literal> tool, analogous to Java&#x2019;s
      Javadocs.<indexterm>
          <primary>Scaladocs</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-scope">
    <glossterm>Scope</glossterm>

    <glossdef>
      <para>A defined boundary of <emphasis>visibility</emphasis>,
      constraining what types and their members are visible within
      it.<indexterm>
          <primary>scope</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-sealed">
    <glossterm>Sealed</glossterm>

    <glossdef>
      <para>Keyword for parent classes when <emphasis>all</emphasis> the
      direct subclasses allowed are defined in the same source
      <emphasis>file</emphasis>.<indexterm>
          <primary>sealed keyword</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-self-type-annotation">
    <glossterm>Self-Type Annotation</glossterm>

    <glossdef>
      <para>A declaration in a trait or class that changes its type, sometimes
      with an alias for <literal>this</literal> defined
      (<literal>self</literal> is conventional). A self type can be used to
      indicate dependencies on other traits that will have to be mixed into a
      concrete instance to resolve the dependency. In some cases, these
      dependencies are used to ensure that an instance of the current type can
      be used as an instance of a dependent type in certain contexts (e.g., as
      used in the Observer Pattern in <xref linkend="SelfTypeAnnotationsAndAbstractTypeMembers"/>).<indexterm>
          <primary>self-type annotations</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-side-effect-free">
    <glossterm>Side-Effect-Free</glossterm>

    <glossdef>
      <para>Functions or expressions that have no side effects, meaning they
      modify no global or &#x201C;object&#x201D; state.<indexterm>
          <primary>side-effect-free</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-signature">
    <glossterm>Signature</glossterm>

    <glossdef>
      <para>For a function: the name, parameter list types, and return value.
      For a <emphasis>method</emphasis>: also includes the type that defines
      the method.<indexterm>
          <primary>signature</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-single-inheritance">
    <glossterm>Single Inheritance</glossterm>

    <glossdef>
      <para>A class, object, or trait can extend one parent class. Compare to
      <emphasis>multiple inheritance</emphasis>.<indexterm>
          <primary>single inheritance</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-singleton">
    <glossterm>Singleton</glossterm>

    <glossdef>
      <para>A class that has only one instance. In Scala, singletons are
      declared using the keyword <literal>object</literal> instead of
      <literal>class</literal>.<indexterm>
          <primary>singletons</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-singleton-types">
    <glossterm>Singleton Types</glossterm>

    <glossdef>
      <para>The unique type designator that excludes path dependencies. If
      <literal>p1</literal> and <literal>p2</literal> are two different
      path-dependent types, their singleton types are
      <literal>p1.type</literal> and <literal>p2.type</literal>, which may be
      the same. Contrast with <emphasis>singleton</emphasis> objects.
      Singleton types are not specifically the types of singleton objects, but
      singleton objects do have singleton types.<indexterm>
          <primary>singleton types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-stable-types">
    <glossterm>Stable Types</glossterm>

    <glossdef>
      <para>Used in the context of <emphasis>path-dependent types</emphasis>,
      all but the last elements in the path must be
      <emphasis>stable</emphasis>, which roughly means that they are either
      packages, singleton objects, or type declarations that alias the
      same.<indexterm>
          <primary>stable types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-state">
    <glossterm>State</glossterm>

    <glossdef>
      <para>As in, &#x201C;the state of an object,&#x201D; where it informally means the set
      of all the current values of an object&#x2019;s
      <emphasis>fields</emphasis>.<indexterm>
          <primary>state</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-static-typing">
    <glossterm>Static Typing</glossterm>

    <glossdef>
      <para>Loosely speaking, early binding of type information, sometimes
      referred to as binding to a reference, rather than the value to which
      the reference is assigned.<indexterm>
          <primary>static typing</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-strict">
    <glossterm>Strict</glossterm>

    <glossdef>
      <para>Used to refer to data structures that are not
      <emphasis>lazy</emphasis>, i.e., they are defined &#x201C;eagerly&#x201D; by the
      expressions used to construct them.<indexterm>
          <primary>strict</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-structural-type">
    <glossterm>Structural Type</glossterm>

    <glossdef>
      <para>A <emphasis>structural type</emphasis> is like an anonymous type,
      where only the &#x201C;structure&#x201D; a candidate type must support is specified,
      such as <emphasis>members</emphasis> that must be present. Structural
      types do not name the candidate types that can match, nor do any
      matching types need to share a common <emphasis>parent trait</emphasis>
      or <emphasis>class</emphasis> with the structural type. Hence,
      structural types are a type-safe analog to <emphasis>duck
      typing</emphasis> in dynamically typed languages, like Ruby.<indexterm>
          <primary>structural types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-subtype">
    <glossterm>Subtype</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>derived type</emphasis>.<indexterm>
          <primary>subtypes</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-supertype">
    <glossterm>Supertype</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>parent type</emphasis>.<indexterm>
          <primary>supertype</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-symbol">
    <glossterm>Symbol</glossterm>

    <glossdef>
      <para>An interned string. Literal symbols are written starting with a
      single &#x201C;right quote,&#x201D; e.g., <literal>'name</literal>.<indexterm>
          <primary>symbols</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-tail-call-recursion">
    <glossterm>Tail-Call Recursion</glossterm>

    <glossdef>
      <para>A form of recursion where a function calls itself as the
      <emphasis>last</emphasis> thing it does, i.e., it does no additional
      computations with the result of the recursive call. The Scala compiler
      will optimize <emphasis>tail-call</emphasis> recursions into a
      loop.<indexterm>
          <primary>tail-call recursion</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-test-driven-development">
    <glossterm>Test-Driven Development</glossterm>

    <glossdef>
      <para>A development discipline where no new functionality is implemented
      until a test has been written that will pass once the functionality is
      implemented. See also <emphasis>Behavior-Driven
      Development</emphasis>.<indexterm>
          <primary>TDD (Test-Driven Development)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-terminal">
    <glossterm>Terminal</glossterm>

    <glossdef>
      <para>A token in a grammar, such as a keyword, that requires no further
      decomposition. See also <emphasis>nonterminal</emphasis>.<indexterm>
          <primary>terminals</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-test-double">
    <glossterm>Test Double</glossterm>

    <glossdef>
      <para>When testing the behavior of one object, a test double is another
      object that satisfies a dependency in the object under test. The test
      double may assist in the testing process, provide controlled test data
      and behaviors, and modify the interaction between the object under test
      and the test double. Specific types of test doubles include &#x201C;fakes,&#x201D;
      &#x201C;mocks,&#x201D; and &#x201C;stubs.&#x201D;<indexterm>
          <primary>test double</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-trait">
    <glossterm>Trait</glossterm>

    <glossdef>
      <para>A class-like encapsulation of state (fields) and behavior
      (methods) that is used for <emphasis>mixin</emphasis> composition. Zero
      or more traits can be mixed into class declarations or when creating
      instances directly, effectively creating an anonymous class.<indexterm>
          <primary>traits</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-trampoline">
    <glossterm>Trampoline</glossterm>

    <glossdef>
      <para>A loop that iterates through a list of functions, invoking each in
      turn. The metaphor of bouncing the functions off a trampoline is the
      source of the name. It can be used to rewrite a form of recursion where
      a function doesn&#x2019;t call itself, but rather calls a different function
      that invokes the original function, and so forth, back and forth. There
      is a proposal for the Scala version 2.8 compiler to include a trampoline
      implementation.<indexterm>
          <primary>trampolines</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-tuple">
    <glossterm>Tuple</glossterm>

    <glossdef>
      <para>A grouping of two or more items of arbitrary types into a
      &#x201C;Cartesian product,&#x201D; without first defining a class to hold them.
      Literal tuple values are written in parentheses and separated by commas,
      e.g., <literal>(x1, x2, ...)</literal>. They are
      <emphasis>first-class</emphasis> values, so you can assign them to
      variables, pass them as values, and return them from functions. Tuples
      are represented by <literal>TupleN</literal> classes, for N between 2
      and 22, inclusive.<indexterm>
          <primary>tuples</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type">
    <glossterm>Type</glossterm>

    <glossdef>
      <para>A categorization of allowed states and operations on those states,
      including transformations from one state to another. The type of an
      instance is the combination of its declared <emphasis>class</emphasis>
      (explicitly named or anonymous), mixed-in <emphasis>traits</emphasis>,
      and the specific types used to resolve any parameters if the class or
      traits are <emphasis>parameterized types</emphasis>. In Scala,
      <literal>type</literal> is also a keyword. When indicated in the text,
      we sometimes use the term type to refer to a <emphasis>class</emphasis>,
      <emphasis>object</emphasis>, or <emphasis>trait</emphasis>
      generically.<indexterm>
          <primary>types</primary>

          <secondary>defined</secondary>
        </indexterm><indexterm>
          <primary>data types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-annotation">
    <glossterm>Type Annotation</glossterm>

    <glossdef>
      <para>An explicit declaration of the type of a value, e.g.,
      <literal>count: Int</literal>, where <literal>Int</literal> is the
      <emphasis>type annotation</emphasis>. A type annotation is required when
      <emphasis>type inference</emphasis> can&#x2019;t be used. In Scala, function
      parameters require type annotations, and annotations are required in
      some other contexts where the type can&#x2019;t be inferred, e.g., for return
      values of some functions.<indexterm>
          <primary>type annotations</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-bounds">
    <glossterm>Type Bounds</glossterm>

    <glossdef>
      <para>Constraints on the allowed types that can be used for a parameter
      in a <emphasis>parameterized type</emphasis> or assigned to an
      <emphasis>abstract type</emphasis>. In Scala, the expression <literal>A
      &lt;: B</literal> defines an <emphasis>upper bound</emphasis> on
      <literal>A</literal>; it must be a <emphasis>subtype</emphasis> or the
      same as <literal>B</literal>. The expression <literal>A &gt;:
      B</literal> defines a <emphasis>lower bound</emphasis> on
      <literal>A</literal>; it must be a <emphasis>supertype</emphasis> or the
      same as <literal>B</literal>.<indexterm>
          <primary>type bounds</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-constructor">
    <glossterm>Type Constructor</glossterm>

    <glossdef>
      <para>Informally, a <emphasis>parameterized type</emphasis> is sometimes
      called a type constructor, although a &#x201C;non-parameterized&#x201D; type is really
      a type constructor too, just with zero parameters! The analogy with an
      instance constructor is that you specify specific concrete types for the
      parameters to create a new concrete type, just as you specify values to
      an instance constructor to create an instance.<indexterm>
          <primary>type constructors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-designators">
    <glossterm>Type Designators</glossterm>

    <glossdef>
      <para>The conventional type IDs commonly used, e.g., <literal>class
      Person</literal>, <literal>object O { type t }</literal>. They are
      actually a shorthand syntax for <emphasis>type
      projections</emphasis>.<indexterm>
          <primary>type designators</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-erasure">
    <glossterm>Type Erasure</glossterm>

    <glossdef>
      <para>A property of the generics type model on the JVM. When a type is
      created from a generic, the information about the specific types
      substituted for the type parameters is not stored in the byte code and
      is therefore not available at runtime. Scala must follow the same model.
      So, for example, instances of <literal>List[String]</literal> and
      <literal>List[Int]</literal> are indistinguishable. Contrast with
      <emphasis>reified types</emphasis>.<indexterm>
          <primary>type erasure</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-inference">
    <glossterm>Type Inference</glossterm>

    <glossdef>
      <para>Inferring the type of a value based on the context in which it is
      used, rather than <phrase role="keep-together">relying</phrase> on
      explicit type <emphasis>annotations</emphasis>. Sometimes called
      <emphasis>implicit typing</emphasis>.<indexterm>
          <primary>implicit typing</primary>
        </indexterm><indexterm>
          <primary>type inference</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-projections">
    <glossterm>Type Projections</glossterm>

    <glossdef>
      <para>A way to refer to a type nested within another type. For example,
      if a type <literal>t</literal> is declared in a class
      <literal>C</literal>, then the type projection for <literal>t</literal>
      is <literal>C#t</literal>.<indexterm>
          <primary>type projections</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-variance">
    <glossterm>Type Variance</glossterm>

    <glossdef>
      <para>When a <emphasis>parameterized type</emphasis> is declared, the
      variance behavior under inheritance of each type parameter can be
      specified using a <emphasis>type variance annotation</emphasis> on the
      type symbol.<indexterm>
          <primary>type variance</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-variance-annotation">
    <glossterm>Type Variance Annotation</glossterm>

    <glossdef>
      <para>On a type parameter in a parameterized types, a
      <literal>+</literal> prefixed to the type symbol is used to indicate
      <emphasis>covariance</emphasis>. A <literal>-</literal> prefix on the
      type symbol is used to indicate <emphasis>contravariance</emphasis>. No
      variance annotation is used to indicate <emphasis>invariance</emphasis>
      (the default).<indexterm>
          <primary>type variance annotations</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-upper-type-bounds">
    <glossterm>Upper Type Bounds</glossterm>

    <glossdef>
      <para>See <emphasis>type bounds</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-value">
    <glossterm>Value</glossterm>

    <glossdef>
      <para>The actual state of an instance, usually in the context of a
      variable that refers to the instance. See also <emphasis>value
      type</emphasis>.<indexterm>
          <primary>values</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-value-object">
    <glossterm>Value Object</glossterm>

    <glossdef>
      <para>An immutable instance or object.<indexterm>
          <primary>Value object</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-value-type">
    <glossterm>Value Type</glossterm>

    <glossdef>
      <para>A subclass of <literal>AnyVal</literal> that wraps a corresponding
      non-object &#x201C;primitive&#x201D; type on the runtime platform (e.g., JVM and
      .NET). The value types are <literal>Boolean</literal>,
      <literal>Char</literal>, <literal>Byte</literal>, <literal role="keep-together">Double</literal>, <literal>Float</literal>,
      <literal>Long</literal>, <literal>Int</literal>, and
      <literal>Short</literal>. (<literal>Unit</literal> is also a value
      type.) All are declared <literal>abstract final</literal> so they can&#x2019;t
      be used in <literal>new V</literal> expressions. Instead, programs
      specify literal values, e.g., <literal>3.14</literal> for a
      <literal>Double</literal> or use methods that return new values. The
      Scala runtime handles instantiation. All the instances of value types
      are immutable <emphasis>value objects</emphasis>.<indexterm>
          <primary>value types</primary>

          <secondary>defined</secondary>
        </indexterm></para>

      <para id="para_the_term__value_type__is_also_">The term <emphasis>value
      type</emphasis> is also used to mean the categories of types for
      instances. That is, the type of every instance must fall into one
      <phrase role="keep-together">of several</phrase> categories:
      <emphasis>annotated types</emphasis>, <emphasis role="keep-together">compound types</emphasis>, <emphasis>function
      types</emphasis>, <emphasis>infix types</emphasis>,
      <emphasis>parameterized types</emphasis>, <emphasis>tuples</emphasis>,
      <emphasis>type designators</emphasis>, <emphasis>type
      projections</emphasis>, and <emphasis>singleton types</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-variable">
    <glossterm>Variable</glossterm>

    <glossdef>
      <para>A named reference to a value. If the variable is declared with the
      <literal>val</literal> keyword, a new value can&#x2019;t be assigned to the
      variable. If the variable is declared with the <literal>var</literal>
      keyword, a new value can be assigned to the variable. The value a
      variable references must be type-compatible with the declared or
      inferred type of the variable.<indexterm>
          <primary>variables</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-view">
    <glossterm>View</glossterm>

    <glossdef>
      <para>An implicit value of function type that converts a type
      <literal>A</literal> to <literal>B</literal>. The function has the type
      <literal>A =&gt; B</literal> or <literal>(=&gt; A) =&gt; B</literal>.
      (In the later case, the <literal>(=&gt; A)</literal> is a
      <emphasis>by-name parameter</emphasis>.) An in-scope <emphasis>implicit
      type conversion</emphasis> method with the same signature can also be
      used as a view.<indexterm>
          <primary>views</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-view-bounds">
    <glossterm>View Bounds</glossterm>

    <glossdef>
      <para>A type specification of the form <literal>A &lt;% B</literal>,
      which says that any type can be used for <literal>A</literal> as long as
      an in-scope <emphasis>view</emphasis> exists that can convert an
      <literal>A</literal> to a <literal>B</literal>.<indexterm>
          <primary>view bounds</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-visibility">
    <glossterm>Visibility</glossterm>

    <glossdef>
      <para>The <emphasis>scope</emphasis> in which a declared
      <emphasis>type</emphasis> or type <emphasis>member</emphasis> is visible
      to other types and <phrase role="keep-together">members</phrase>.<indexterm>
          <primary>visibility</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>
</glossary>
  <index/>
  <colophon id="colophon">
  <title>Colophon</title>

  <para>The animal on the cover of <citetitle>Programming Scala</citetitle> is
  a Malayan tapir (<emphasis>Tapirus indicus</emphasis>), also called an Asian
  tapir. It is a black-and-white hoofed mammal with a round, stocky body
  similar to that of a pig. At 6&#x2013;8 feet long and 550&#x2013;700 pounds, the Malayan
  is the largest of the four tapir species. It lives in tropical rain forests
  in Southeast Asia.</para>

  <para>The Malayan tapir&#x2019;s appearance is striking: its front half and hind
  legs are solid black, and its midsection is marked with a white saddle. This
  pattern provides perfect camouflage for the tapir in a moonlit jungle. Other
  physical characteristics include a thick hide, a stumpy tail, and a short,
  flexible snout. Despite its body shape, the Malayan tapir is an agile
  climber and a fast runner.</para>

  <para>The tapir is a solitary and mainly nocturnal animal. It tends to have
  very poor vision, so it relies on smell and hearing as it roams large
  territories in search of food, tracking other tapirs&#x2019; scents and
  communicating via high-pitched whistles. The Malayan tapir&#x2019;s predators are
  tigers, leopards, and humans, and it is considered endangered due to habitat
  destruction and overhunting.</para>

  <para>The cover image is from the Dover Pictorial Archive. The cover font is
  Adobe ITC Garamond. The text font is Linotype Birka; the heading font is
  Adobe Myriad Condensed; and the code font is LucasFont&#x2019;s <phrase role="keep-together">TheSansMonoCondensed</phrase>.</para>
</colophon>
</book>
