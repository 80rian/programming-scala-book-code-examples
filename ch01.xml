<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="IntroducingScala">
  <title>Zero to Sixty: Introducing Scala</title>

  <sect1 id="_why_scala">
    <title>Why Scala?</title>

    <para id="para_why_scala1">Today’s enterprise and Internet applications
    must balance a number of concerns. They must be implemented quickly and
    reliably. New features must be added in short, incremental cycles. Beyond
    simply providing business logic, applications must support secure access,
    persistence of data, transactional behavior, and other advanced features.
    Applications must be highly available and scalable, requiring designs that
    support concurrency and distribution. Applications are networked and
    provide interfaces for both people and other applications to use.</para>

    <para id="para_why_scala2">To meet these challenges, many developers are
    looking for new languages and tools. Venerable standbys like Java, C#, and
    C++ are no longer optimal for developing the next generation of
    applications.</para>

    <sect2 id="_if_you_are_a_java_programmer_8230">
      <title>If You Are a Java Programmer…</title>

      <para id="para_java_was_officially_introduced">Java was officially
      introduced by Sun Microsystems in May of 1995, at the advent of
      widespread interest in the Internet. Java was immediately hailed as an
      ideal language for writing browser-based applets, where a secure,
      portable, and developer-friendly application language was needed. The
      reigning language of the day, C++, was not suitable for this
      domain.<indexterm>
          <primary>Java</primary>
        </indexterm></para>

      <para id="para_today_java_is_more_often_used">Today, Java is more often
      used for server-side applications. It is one of the most popular
      languages in use for the development of web and enterprise
      applications.</para>

      <para id="para_however_java_was_a_child_of_i">However, Java was a child
      of its time. Now it shows its age. In 1995, Java provided a syntax
      similar enough to C++ to entice C++ developers, while avoiding many of
      that language’s deficiencies and “sharp edges”. Java adopted the most
      useful ideas for the development problems of its era, such as
      object-oriented programming (OOP), while discarding more troublesome
      techniques, such as manual memory management. These design choices
      struck an excellent balance that minimized complexity and maximized
      developer productivity, while trading-off performance compared to
      natively compiled code. While Java has evolved since its birth, many
      people believe it has grown too complex without adequately addressing
      some newer development challenges.</para>

      <para id="para_developers_want_languages_that">Developers want languages
      that are more succinct and flexible to improve their productivity. This
      is one reason why so-called “scripting” languages like Ruby and Python
      have become more popular recently.<indexterm>
          <primary>scripting languages, popularity of</primary>
        </indexterm></para>

      <para id="para_the_never_ending_need_to_scale">The never-ending need to
      scale is driving architectures toward pervasive concurrency. However,
      Java’s concurrency model, which is based on synchronized access to
      shared, mutable state, results in complex and error-prone
      programs.<indexterm>
          <primary>concurrency</primary>

          <secondary>Java and</secondary>
        </indexterm></para>

      <para id="para_while_the_java_language_is_sho">While the Java language
      is showing its age, the Java Virtual Machine (JVM) on which it runs
      continues to shine. The optimizations performed by today’s JVM are
      extraordinary, allowing byte code to outperform natively compiled code
      in many cases. Today, many developers believe that using the JVM with
      new languages is the path forward. Sun is embracing this trend by
      employing many of the lead developers of JRuby and Jython, which are JVM
      ports of Ruby and Python, respectively.<indexterm>
          <primary>JVM (Java Virtual Machine)</primary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>JVM (Java Virtual Machine)</secondary>
        </indexterm></para>

      <para id="para_the_appeal_of_scala_for_the_ja">The appeal of Scala for
      the Java developer is that it gives you a newer, more modern language,
      while leveraging the JVM’s amazing performance and the wealth of Java
      libraries that have been developed for over a decade.</para>
    </sect2>

    <sect2 id="_if_you_are_a_ruby_python_etc_programmer_8230">
      <title>If You Are a Ruby, Python, etc. Programmer…</title>

      <para id="para__dynamically_typed__languages_"><emphasis>Dynamically
      typed</emphasis> languages like Ruby, Python, Groovy, JavaScript, and
      Smalltalk <phrase role="keep-together">offer</phrase> very high
      productivity due to their flexibility, powerful metaprogramming, and
      <phrase role="keep-together">elegance</phrase>.<indexterm>
          <primary>Ruby</primary>

          <secondary>dynamic typing</secondary>
        </indexterm><indexterm>
          <primary>dynamically typed languages</primary>
        </indexterm></para>

      <sidebar>
        <title>Statically Typed Versus Dynamically Typed Languages</title>

        <para id="para_one_of_the_fundamental_languag">One of the fundamental
        language design choices is <emphasis>static versus dynamic</emphasis>
        typing.<indexterm>
            <primary>data types</primary>

            <secondary>static versus dynamic typing</secondary>
          </indexterm><indexterm>
            <primary>static typing versus dynamic typing</primary>
          </indexterm></para>

        <para id="para_the_word_typing_is_used_in">The word “typing” is used
        in many contexts in software. The following is a “plausible”
        definition that is useful for our purposes.<indexterm>
            <primary>typing</primary>
          </indexterm></para>

        <blockquote>
          <attribution>Benjamin C. Pierce, <citetitle>Types and Programming
          Languages</citetitle> (MIT Press, 2002)</attribution>

          <para>A type system is a tractable syntactic method for preserving
          the absence of certain program behaviors by classifying phrases
          according to the kinds of values they compute.</para>
        </blockquote>

        <para id="para_note_the_emphasis_on_how_a_typ">Note the emphasis on
        how a type system allows reasoning about what a system
        <emphasis>excludes</emphasis> from happening. That’s generally easier
        than trying to determine the set of all allowed possibilities. A type
        system is used to catch various errors, like unsupported operations on
        particular data structures, attempting to combine data in an undefined
        way (e.g., trying to add an integer to a string), breaking
        abstractions, etc.<indexterm>
            <primary>type system</primary>
          </indexterm></para>

        <para id="para_informally_in_static_typing_">Informally, in static
        typing, a <emphasis>variable</emphasis> is bound to a particular type
        for its lifetime. Its type can’t be changed and it can only reference
        type-compatible instances. That is, if a variable refers to a value of
        type <literal>A</literal>, you can’t assign a value of a different
        type <literal>B</literal> to it, unless <literal>B</literal> is a
        subtype of <literal>A</literal>, for some reasonable definition of
        “subtype.”<indexterm>
            <primary>variables</primary>

            <secondary sortas="static and dynamic typing">in static and
            dynamic typing</secondary>
          </indexterm></para>

        <para id="para_in_dynamic_typing_the_type_is">In dynamic typing, the
        type is bound to the <emphasis>value</emphasis>, not the
        <emphasis>variable</emphasis>. So, a variable might refer to a value
        of type <literal>A</literal>, then be reassigned later to a value of
        an unrelated type <literal>X</literal>.</para>

        <para id="para_the_term__dynamically_typed__i">The term
        <emphasis>dynamically typed</emphasis> is used because the type of a
        <emphasis>variable</emphasis> is evaluated when it is used during
        runtime, while in a statically typed language the type is evaluated at
        parse time.</para>

        <para id="para_this_may_seem_like_a_small_dis">This may seem like a
        small distinction, but it has a pervasive impact on the philosophy,
        design, and implementation of a language. We’ll explore some of these
        implications as we go through the book.</para>

        <para id="para_scala_and_java_are_statically_">Scala and Java are
        statically typed languages, whereas Ruby, Python, Groovy, JavaScript,
        and Smalltalk are dynamically typed languages.<indexterm>
            <primary>Java</primary>

            <secondary>static typing</secondary>
          </indexterm></para>

        <para id="para_for_simplicity_we_will_often_">For simplicity, we will
        often use the terms <emphasis>static language</emphasis> and
        <emphasis>dynamic language</emphasis> as shorthands for
        <emphasis>statically typed language</emphasis> and
        <emphasis>dynamically typed language</emphasis>, respectively.</para>

        <para id="para_an__orthogonal__design_conside">An
        <emphasis>orthogonal</emphasis> design consideration is
        <emphasis>strong versus weak</emphasis> typing. In strong typing,
        every variable (for static typing) or value (for dynamic typing) must
        have an unambiguous type. In weak typing, a specific type is not
        required. While most languages allow some mixture of strong versus
        weak typing, Scala, Java, and Ruby are
        <emphasis>predominantly</emphasis> strongly typed languages. Some
        languages, like C and Perl, are more weakly typed.<indexterm>
            <primary>weak versus string typing</primary>
          </indexterm><indexterm>
            <primary>strong versus weak typing</primary>
          </indexterm></para>
      </sidebar>

      <para id="para_despite_their_productivity_adv">Despite their
      productivity advantages, <emphasis>dynamic</emphasis> languages may not
      be the best choices for all applications, particularly for very large
      code bases and high-performance applications. There is a longstanding,
      spirited debate in the programming community about the relative merits
      of dynamic versus static typing. Many of the points of comparison are
      somewhat subjective. We won’t go through all the arguments here, but we
      will offer a few thoughts for consideration.</para>

      <para id="para_optimizing_the_performance_of_">Optimizing the
      performance of a dynamic language is more challenging than for a static
      language. In a static language, optimizers can exploit the type
      information to make decisions. In a dynamic language, fewer such clues
      are available for the optimizer, making optimization choices harder.
      While recent advancements in optimizations for dynamic languages are
      promising, they lag behind the state of the art for static languages.
      So, if you require very high performance, static languages are probably
      a safer choice.</para>

      <para id="para_static_languages_can_also_bene">Static languages can also
      benefit the development process. Integrated development environment
      (IDE) features like <emphasis>autocompletion</emphasis> (sometimes
      called <emphasis>code sense</emphasis>) are easier to implement for
      static languages, again because of the extra type information available.
      The more explicit type information in static code promotes better
      “self-documentation,” which can be important for communicating intent
      among developers, especially as a project grows.</para>

      <para id="para_when_using_a_static_language_">When using a static
      language, you have to think about appropriate type choices more often,
      whi**ch forces you to weigh design choices more carefully. While this
      may slow down daily design decisions, thinking through the types in the
      application can result in a more coherent design over time.</para>

      <para id="para_another_small_benefit_of_stati">Another small benefit of
      static languages is the extra checking the compiler performs. We think
      this advantage is often oversold, as type mismatch errors are a small
      fraction of the runtime errors you typically see. The compiler can’t
      find <emphasis>logic</emphasis> errors, which are far more significant.
      Only a comprehensive, automated test suite can find logic errors. For
      dynamically typed languages, the tests must cover possible type errors,
      too. If you are coming from a dynamically typed language, you may find
      that your test suites are a little smaller as a result, but not
      <emphasis>that much</emphasis> smaller.</para>

      <para id="para_many_developers_who_find_stati">Many developers who find
      static languages too verbose often blame static typing for the verbosity
      when the real problem is a lack of <emphasis>type inference</emphasis>.
      In type inference, the compiler infers the types of values based on the
      context. For example, the compiler will recognize that <literal>x = 1 +
      3</literal> means that <literal>x</literal> must be an integer. Type
      inference reduces verbosity significantly, making the code feel more
      like code written in a dynamic <phrase
      role="keep-together">language</phrase>.</para>

      <para id="para_we_have_worked_with_both_stati">We have worked with both
      static and dynamic languages, at various times. We find both kinds of
      languages compelling for different reasons. We believe the modern
      software developer must master a range of languages and tools.
      Sometimes, a dynamic language will be the right tool for the job. At
      other times, a static language like Scala is just what you need.</para>
    </sect2>

    <sect2 id="_introducing_scala">
      <title>Introducing Scala</title>

      <para
      id="para__scala__is_a_language_that_add"><emphasis>Scala</emphasis> is a
      language that addresses the major needs of the modern developer. It is a
      statically typed, mixed-paradigm, JVM language with a succinct, elegant,
      and flexible syntax, a sophisticated type system, and idioms that
      promote scalability from small, interpreted scripts to large,
      sophisticated applications. That’s a mouthful, so let’s look at each of
      those ideas in more detail:<indexterm>
          <primary>Scala</primary>

          <secondary>introduction to</secondary>
        </indexterm></para>

      <variablelist id="para_scala_characteristics">
        <varlistentry id="varlistentry-statically-typed">
          <term>Statically typed</term>

          <listitem>
            <para>As we described in the previous section, a statically typed
            language binds the type to a <emphasis>variable</emphasis> for the
            lifetime of that variable. In contrast, <emphasis>dynamically
            typed</emphasis> languages bind the type to the actual
            <emphasis>value</emphasis> referenced by a variable, meaning that
            the type of a <emphasis>variable</emphasis> can change along with
            the value it references.</para>

            <para id="para_of_the_set_of_newer_jvm_langua">Of the set of newer
            JVM languages, Scala is one of the few that is statically typed,
            and it is the best known among them.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-mixed-paradigm-object-oriented-programming">
          <term>Mixed paradigm—object-oriented programming</term>

          <listitem>
            <para>Scala fully supports <emphasis>object-oriented
            programming</emphasis> (OOP). Scala improves upon Java’s support
            for OOP with the addition of <emphasis>traits</emphasis>, a clean
            way of implementing classes using <emphasis>mixin
            composition</emphasis>. Scala’s traits work much like Ruby’s
            <emphasis>modules</emphasis>. If you’re a Java programmer, think
            of traits as unifying interfaces with their <phrase
            role="keep-together">implementations</phrase>.<indexterm>
                <primary>object-oriented programming (OOP)</primary>

                <secondary>mixed paradigm in Scala</secondary>
              </indexterm><indexterm>
                <primary>mixin composition</primary>
              </indexterm><indexterm>
                <primary>traits</primary>
              </indexterm></para>

            <para id="para_everything_is_object">In Scala, everything is
            <emphasis>really</emphasis> an object. Scala does not have
            primitive types, like Java. Instead, all numeric types are true
            objects. However, for optimal <phrase
            role="keep-together">performance</phrase>, Scala uses the
            underlying primitives types of the runtime whenever possible.
            Also, Scala does not support “static” or class-level members of
            types, since they are not associated with an actual instance.
            Instead, Scala supports a singleton object construct to support
            those cases where exactly one instance of a type is
            needed.<indexterm>
                <primary>FP</primary>

                <see>functional programming</see>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-mixed-paradigm-functional-programming">
          <term>Mixed paradigm—functional programming</term>

          <listitem>
            <para>Scala fully supports f<emphasis>unctional
            programming</emphasis> (FP). FP is a programming paradigm that is
            older than OOP, but it has been sheltered in the ivory towers of
            academia until recently. Interest in FP is increasing because of
            the ways it simplifies certain design problems, especially
            concurrency. “Pure” functional languages don’t allow for any
            mutable state, thereby avoiding the need for synchronization on
            shared access to mutable state. Instead, programs written in pure
            functional languages communicate by passing messages between
            concurrent, autonomous processes. Scala supports this model with
            its <emphasis>Actors</emphasis> library, but it allows for both
            mutable and immutable variables.<indexterm>
                <primary>immutable variables</primary>
              </indexterm><indexterm>
                <primary>Actors</primary>
              </indexterm><indexterm>
                <primary>variables</primary>

                <secondary>mutable and immutable</secondary>
              </indexterm><indexterm>
                <primary>functional programming</primary>

                <secondary>mixed paradigm in Scala</secondary>
              </indexterm></para>

            <para id="para_functions_are_first_class_">Functions are
            “first-class” citizens in FP, meaning they can be assigned to
            variables, passed to other functions, etc., just like other
            values. This feature promotes composition of advanced behavior
            using primitive operations. Because Scala adheres to the dictum
            that <emphasis>everything is an object</emphasis>, functions are
            themselves objects in Scala.<indexterm>
                <primary>objects</primary>

                <secondary sortas="Scala">in Scala</secondary>
              </indexterm></para>

            <para id="para_scala_also_offers__closures__">Scala also offers
            <emphasis>closures</emphasis>, a feature that dynamic languages
            like Python and Ruby have adopted from the functional programming
            world, and one sadly absent from recent versions of Java. Closures
            are functions that reference variables from the scope enclosing
            the function definition. That is, the variables aren’t passed in
            as arguments or defined as local variables within the function. A
            closure “closes around” these references, so the function
            invocation can safely refer to the variables even when the
            variables have gone out of scope! Closures are such a powerful
            abstraction that object systems and fundamental control structures
            are often implemented using them.<indexterm>
                <primary>closures</primary>

                <secondary>defined</secondary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-a-jvm-and-net-language">
          <term>A JVM and .NET language</term>

          <listitem>
            <para>While Scala is primarily known as a JVM language, meaning
            that Scala generates JVM byte code, a .NET version of Scala that
            generates Common Language Runtime (CLR) byte code is also under
            development. When we refer to the underlying “runtime,” we will
            usually discuss the JVM, but most of what we will say applies
            equally to both runtimes. When we discuss JVM-specific details,
            they generalize to the .NET version, except where noted.<indexterm>
                <primary>CLR (Common Language Runtime), Scala running
                on</primary>
              </indexterm><indexterm>
                <primary>JVM version of Scala</primary>
              </indexterm><indexterm>
                <primary sortas="NET version of Scala">.NET version of
                Scala</primary>
              </indexterm></para>

            <para id="para_the_scala_parser_uses_clever_t">The Scala compiler
            uses clever techniques to map Scala extensions to valid byte code
            idioms. From Scala, you can easily invoke byte code that
            originated as Java source (for the JVM) or C# source (for .NET).
            Conversely, you can invoke Scala code from Java, C#, etc. Running
            on the JVM and CLR allows the Scala developer to leverage
            available libraries and to interoperate with other languages
            hosted on those runtimes.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-a-succinct-elegant-and-flexible-syntax">
          <term>A succinct, elegant, and flexible syntax</term>

          <listitem>
            <para>Java syntax can be verbose. Scala uses a number of
            techniques to minimize unnecessary syntax, making Scala code as
            succinct as code in most dynamically typed languages.
            <emphasis>Type inference</emphasis> minimizes the need for
            explicit type information in many contexts. Declarations of types
            and functions are very concise.</para>

            <para id="para_scala_allows_function_names_to">Scala allows
            function names to include non-alphanumeric characters. Combined
            with some syntactic sugar, this feature permits the user to define
            methods that look and behave like operators. As a result,
            libraries outside the core of the language can feel “native” to
            users.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-a-sophisticated-type-system">
          <term>A sophisticated type system</term>

          <listitem>
            <para>Scala extends the type system of Java with more flexible
            generics and a number of more advanced typing constructs. The type
            system can be intimidating at first, but most of the time you
            won’t need to worry about the advanced constructs. Type inference
            helps by automatically inferring type signatures, so that the user
            doesn’t have to provide trivial type information manually. When
            you need them, though, the advanced type features provide you with
            greater flexibility for solving design problems in a type-safe
            way.<indexterm>
                <primary>type system</primary>

                <secondary>Scala</secondary>
              </indexterm><indexterm>
                <primary>data types</primary>

                <secondary>Scala's sophisticated type system</secondary>
              </indexterm></para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-scalable-architectures">
          <term>Scalable—architectures</term>

          <listitem>
            <para>Scala is designed to scale from small, interpreted scripts
            to large, distributed applications. Scala provides four language
            mechanisms that promote scalable composition of systems: 1)
            explicit <emphasis>selftypes</emphasis>; 2) abstract type members
            and generics; 3) nested classes; and 4) <emphasis>mixin</emphasis>
            composition using <emphasis>traits</emphasis>.<indexterm>
                <primary>scalability, Scala support for</primary>
              </indexterm><indexterm>
                <primary>generics</primary>
              </indexterm><indexterm>
                <primary>abstract type members</primary>
              </indexterm><indexterm>
                <primary>selftypes</primary>
              </indexterm><indexterm>
                <primary>mixin composition</primary>

                <secondary>using traits</secondary>
              </indexterm></para>

            <para id="para_no_other_language_provides_all">No other language
            provides all these mechanisms. Together, they allow applications
            to be constructed from reusable “components” in a type-safe and
            succinct manner. As we will see, many common design patterns and
            architectural techniques like dependency injection are easy to
            implement in Scala without the boilerplate code or lengthy XML
            configuration files that can make Java development tedious.</para>
          </listitem>
        </varlistentry>

        <varlistentry id="varlistentry-scalable-performance">
          <term>Scalable—performance</term>

          <listitem>
            <para>Because Scala code runs on the JVM and the CLR, it benefits
            from all the performance optimizations provided by those runtimes
            and all the third-party tools that support performance and
            scalability, such as profilers, distributed cache libraries,
            clustering mechanisms, etc. If you trust Java’s and C#’s
            performance, you can trust Scala’s performance. Of course, some
            particular constructs in the language and some parts of the
            library may perform significantly better or worse than alternative
            options in other languages. As always, you should profile your
            code and optimize it when necessary.<indexterm>
                <primary>performance</primary>
              </indexterm></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <para id="para_it_might_appear_that_oop_and_f">It might appear that OOP
      and FP are incompatible. In fact, a design philosophy of Scala is that
      OOP and FP are more synergistic than opposed. The features of one
      approach can enhance the other.</para>

      <para id="para_in_fp_functions_have_no_side_">In FP, functions have no
      side effects and variables are immutable, while in OOP, mutable state
      and side effects are common, even encouraged. Scala lets you choose the
      approach that best fits your design problems. Functional programming is
      especially useful for concurrency, since it eliminates the need to
      synchronize access to mutable state. However, “pure” FP can be
      restrictive. Some design problems are easier to solve with mutable
      objects.</para>

      <para id="para_the_name__scala__is_a_contract">The name
      <emphasis>Scala</emphasis> is a contraction of the words
      <emphasis>scalable language</emphasis>. While this suggests that the
      pronunciation should be <emphasis>scale-ah</emphasis>, the creators of
      Scala actually pronounce it <emphasis>scah-lah</emphasis>, like the
      Italian word for “stairs.” That is, the two “a”s are pronounced the
      same.<indexterm>
          <primary>scalable language (Scala)</primary>
        </indexterm></para>

      <para id="para_scala_was_started_by_martin_od">Scala was started by
      Martin Odersky in 2001. Martin is a professor in the School of Computer
      and Communication Sciences at the Ecole Polytechnique Fédérale de
      Lausanne (EPFL). He spent his graduate years working in the group headed
      by Niklaus Wirth, of Pascal fame. Martin worked on Pizza, an early
      functional language on the JVM. He later worked on GJ, a prototype of
      what later became Generics in Java, with Philip Wadler of Haskell fame.
      Martin was hired by Sun Microsystems to produce the reference
      implementation of <literal>javac</literal>, the Java compiler that ships
      with the Java Developer Kit (JDK) today.<indexterm>
          <primary>Odersky, Martin</primary>
        </indexterm><indexterm>
          <primary>Java</primary>

          <secondary>JDK (Java Development Kit)</secondary>
        </indexterm><indexterm>
          <primary>javac compiler</primary>
        </indexterm><indexterm>
          <primary>JDK (Java Development Kit)</primary>
        </indexterm><indexterm>
          <primary>Odersky, Martin</primary>
        </indexterm></para>

      <para id="para_martin_odersky_s_background_an">Martin Odersky’s
      background and experience are evident in the language. As you learn
      Scala, you come to understand that it is the product of carefully
      considered design decisions, exploiting the state of the art in type
      theory, OOP, and FP. Martin’s experience with the JVM is evident in
      Scala’s elegant integration with that platform. The synthesis it creates
      between OOP and FP is an excellent “best of both worlds”
      solution.</para>
    </sect2>

    <sect2 id="_the_seductions_of_scala">
      <title>The Seductions of Scala</title>

      <para id="para_today_our_industry_is_fortuna">Today, our industry is
      fortunate to have a wide variety of language options. The power,
      flexibility, and elegance of dynamically typed languages have made them
      very popular again. Yet the wealth of Java and .NET libraries and the
      performance of the JVM and CLR meet many practical needs for enterprise
      and Internet projects.<indexterm>
          <primary>Scala</primary>

          <secondary>benefits of</secondary>
        </indexterm></para>

      <para id="para_scala_is_compelling_because_it">Scala is compelling
      because it feels like a dynamically typed scripting language, due to its
      succinct syntax and type inference. Yet Scala gives you all the benefits
      of static typing, a modern object model, functional programming, and an
      advanced type system. These tools let you build scalable, modular
      applications that can reuse legacy Java and .NET APIs and leverage the
      performance of the JVM and CLR.</para>

      <para id="para_scala_is_a_language_for__profe">Scala is a language for
      <emphasis>professional</emphasis> developers. Compared to languages like
      Java and Ruby, Scala is a more difficult language to master because it
      requires competency with OOP, FP, and static typing to use it most
      effectively. It is tempting to prefer the relative simplicity of
      dynamically typed languages. Yet this simplicity can be deceptive. In a
      dynamically typed language, it is often necessary to use metaprogramming
      features to implement advanced designs. While metaprogramming is
      powerful, using it well takes experience and the resulting code tends to
      be hard to understand, maintain, and debug. In Scala, many of the same
      design goals can be achieved in a type-safe manner by exploiting its
      type system and mixin composition through
      <emphasis>traits</emphasis>.<indexterm>
          <primary>metaprogramming</primary>
        </indexterm></para>

      <para id="para_we_feel_that_the_extra_effort_">We feel that the extra
      effort required day to day to use Scala will promote more careful
      reflection about your designs. Over time, this discipline will yield
      more coherent, modular, and maintainable applications. Fortunately, you
      don’t need all of the sophistication of Scala all of the time. Much of
      your code will have the simplicity and clarity of code written in your
      favorite dynamically typed language.</para>

      <para id="para_an_alternative_strategy_is_to_">An alternative strategy
      is to combine several, simpler languages, e.g., Java for object-oriented
      code and Erlang for functional, concurrent code. Such a decomposition
      can work, but only if your system decomposes cleanly into such discrete
      parts and your team can manage a heterogeneous environment. Scala is
      attractive for situations in which a single, all-in-one language is
      preferred. That said, Scala code can happily coexist with other
      languages, especially on the JVM or .NET.<indexterm>
          <primary>Scala</primary>

          <secondary>combining with other languages</secondary>
        </indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="InstallingScala">
    <title>Installing Scala</title>

    <para id="para_to_get_up_and_running_as_quick">To get up and running as
    quickly as possible, this section describes how to install the
    command-line tools for Scala, which are all you need to work with the
    examples in the book. For details on using Scala in various editors and
    IDEs, see <xref linkend="IntegrationWithIDEs" />. The examples used in
    this book were written and compiled using Scala version 2.7.5.final, the
    latest release at the time of this writing, and “nightly builds” of Scala
    version 2.8.0, which may be finalized by the time you read this.<indexterm>
        <primary>Scala</primary>

        <secondary>installing</secondary>
      </indexterm></para>

    <note id="para_v28_new_features">
      <para>Version 2.8 introduces many new features, which we will highlight
      throughout the book.</para>
    </note>

    <para id="para_we_will_work_with_the_jvm_vers">We will work with the JVM
    version of Scala in this book. First, you must have Java 1.4 or greater
    installed (1.5 or greater is recommended). If you need to install Java, go
    to <ulink url="http://www.java.com/en/download/manual.jsp"></ulink> and
    follow the instructions to install Java on your machine.<indexterm>
        <primary>JVM version of Scala</primary>

        <secondary>installing</secondary>
      </indexterm></para>

    <para id="para_the_official_scala_web_site_is">The official Scala website
    is <ulink url="http://www.scala-lang.org/"></ulink>. To install Scala, go
    to the <ulink url="http://www.scala-lang.org/downloads">downloads
    page</ulink>. Download the installer for your environment and follow the
    instructions on the downloads page.<indexterm>
        <primary>Scala</primary>

        <secondary>official website</secondary>
      </indexterm></para>

    <para id="para_the_easiest_installer_to_use_f">The easiest cross-platform
    installer is the <emphasis>IzPack</emphasis> installer. Download the Scala
    JAR file, either <filename>scala-2.7.5.final-installer.jar</filename> or
    <filename>scala-2.8.0.N-installer.jar</filename>, where
    <replaceable>N</replaceable> is the latest release of the 2.8.0 version.
    Go to the download directory in a terminal <phrase
    role="keep-together">window</phrase>, and install Scala with the
    <literal>java</literal> command. Assuming you downloaded <filename
    role="keep-together">scala-2.8.0.final-</filename><filename>in⁠staller.jar</filename>,
    run the following command, which will guide you through the
    process:<indexterm>
        <primary>Mac OS X</primary>

        <secondary>installing Scala</secondary>
      </indexterm><indexterm>
        <primary>cross-platform installer (lzPack)</primary>
      </indexterm></para>

    <screen>java -jar scala-2.8.0.final-installer.jar</screen>

    <tip id="para_tip_on_mac_os_x_the_easiest_">
      <para>On Mac OS X, the easiest route to a working Scala installation is
      via MacPorts. Follow the installation instructions at <ulink
      url="http://www.macports.org/"></ulink>, then <literal>sudo port install
      scala</literal>. You’ll be up and running in a few minutes.</para>
    </tip>

    <para id="para_throughout_this_book_we_will_">Throughout this book, we
    will use the symbol <replaceable>scala-home</replaceable> to refer to the
    “root” directory of your Scala installation.</para>

    <note id="para_note_on_unix_linux_and_maco">
      <para>On Unix, Linux, and Mac OS X systems, you will need to run this
      <phrase role="keep-together">command</phrase> as the
      <literal>root</literal> user or using the <literal>sudo</literal>
      command if you want to <phrase role="keep-together">install
      Scala</phrase> under a system directory, e.g.,
      <replaceable>scala-home</replaceable> <filename>=
      /usr/local/scala-2.8.0.final</filename>.</para>
    </note>

    <para id="para_as_an_alternative_you_can_dow">As an alternative, you can
    download and expand the compressed TAR file (e.g.,
    <filename>scala-2.8.0.final.tgz</filename>) or ZIP file
    (<filename>scala-2.8.0.final.zip</filename>). On Unix-like systems, expand
    the compressed file into a location of your choosing. Afterward, add the
    <replaceable>scala-home</replaceable><filename>/bin</filename>
    subdirectory in the new directory to your <literal>PATH</literal>. For
    example, if you installed into <filename
    role="keep-together">/usr/local/scala-2.8.0.final</filename>, then add
    <filename>/usr/local/scala-2.8.0.final/bin</filename> to your
    <literal>PATH</literal>.</para>

    <para id="para_to_test_your_installation_run">To test your installation,
    run the following command on the command line:</para>

    <screen>scala -version</screen>

    <para id="para_we_ll_learn_more_about_the_sc">We’ll learn more about the
    <literal>scala</literal> command-line tool later. You should get something
    like the following output:</para>

    <screen>Scala code runner version 2.8.0.final -- Copyright 2002-2009, LAMP/EPFL</screen>

    <para id="para_of_course_the_version_number_">Of course, the version
    number you see will be different if you installed a different release.
    From now on, when we show command output that contains the version number,
    we’ll show it as <literal>version 2.8.0.final</literal>.<indexterm>
        <primary>versions, Scala</primary>
      </indexterm></para>

    <para id="para_congratulations_you_have_installed_scala">Congratulations,
    you have installed Scala! If you get an error message along the lines of
    <literal>scala: command not found</literal>, make sure your environment’s
    <literal>PATH</literal> is set properly to include the correct
    <filename>bin</filename> directory.<indexterm>
        <primary>classes</primary>

        <secondary>JDK and .NET, use in Scala</secondary>
      </indexterm></para>

    <note id="para_note_scala_versions_2_7_x_and">
      <para>Scala versions 2.7.X and earlier are compatible with JDK 1.4 and
      later. Scala version 2.8 drops 1.4 compatibility. Note that Scala uses
      many JDK classes as its own, for example, the <literal>String</literal>
      class. On .NET, Scala uses the corresponding .NET classes.</para>
    </note>

    <para id="para_you_can_also_find_downloads_fo">You can also find downloads
    for the API documentation and the sources for Scala itself on the same
    downloads page.</para>
  </sect1>

  <sect1 id="ForMoreInformation">
    <title>For More Information</title>

    <para id="para_as_you_explore_scala_you_will">As you explore Scala, you
    will find other useful resources that are available on <ulink
    url="http://scala-lang.org"></ulink>. You will find links for development
    support tools and libraries, tutorials, the language specification <link
    linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>,
    and academic papers that describe features of the language.<indexterm>
        <primary>Scala</primary>

        <secondary>resources for more information</secondary>
      </indexterm></para>

    <para id="para_the_documentation_for_the_scal">The documentation for the
    Scala tools and APIs are especially useful. You can browse the API at
    <ulink url="http://www.scala-lang.org/docu/files/api/index.html"></ulink>.
    This documentation was generated using the <literal>scaladoc</literal>
    tool, analogous to Java’s <literal>javadoc</literal> tool. See <xref
    linkend="CommandLineToolScaladoc" /> for more information.<indexterm>
        <primary>documentation</primary>

        <secondary>Scala tools and APIs</secondary>
      </indexterm><indexterm>
        <primary>scaladoc tool</primary>
      </indexterm></para>

    <para id="para_you_can_also_download_a_compre">You can also download a
    compressed file of the API documentation for local browsing using the
    appropriate link on the <ulink
    url="http://www.scala-lang.org/downloads">downloads page</ulink>, or you
    can install it with the <literal>sbaz</literal> package tool, as
    follows:<indexterm>
        <primary>sbaz tool</primary>
      </indexterm></para>

    <screen>sbaz install scala-devel-docs</screen>

    <para id="para__sbaz_is_installed_in_the_sam"><literal>sbaz</literal> is
    installed in the same <filename>bin</filename> directory as the
    <literal>scala</literal> and <literal>scalac</literal> command-line tools.
    The installed documentation also includes details on the scala tool chain
    (including <literal>sbaz</literal>) and code examples. For more
    information on the Scala command-line tools and other resources, see <xref
    linkend="ScalaToolsLibs" />.<indexterm>
        <primary>command-line tools</primary>

        <secondary>information on</secondary>
      </indexterm><indexterm>
        <primary>scalac compiler</primary>
      </indexterm><indexterm>
        <primary>scala command</primary>
      </indexterm></para>
  </sect1>

  <sect1 id="ATasteOfScala">
    <title>A Taste of Scala</title>

    <para id="para_it_s_time_to_whet_your_appetit">It’s time to whet your
    appetite with some real Scala code. In the following examples, we’ll
    describe just enough of the details so you understand what’s going on. The
    goal is to give you a sense of what programming in Scala is like. We’ll
    explore the details of the features in subsequent chapters.<indexterm
        class="startofrange" id="ch01_Scalaexamples">
        <primary>Scala</primary>

        <secondary>code examples</secondary>
      </indexterm></para>

    <para id="para_for_our_first_example_you_cou">For our first example, you
    could run it one of two ways: interactively, or as a “script.”<indexterm>
        <primary>scala command</primary>

        <secondary>interactive mode</secondary>
      </indexterm><indexterm>
        <primary>interpreter, starting</primary>
      </indexterm></para>

    <para id="para_let_s_start_with_the_interacti">Let’s start with the
    interactive mode. Start the scala interpreter by typing
    <literal>scala</literal> and the return key on your command line. You’ll
    see the following output. (Some of the version numbers may vary.)</para>

    <screen>Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt;</screen>

    <para id="para_the_last_line_is_the_prompt_th">The last line is the prompt
    that is waiting for your input. The interactive mode of the
    <literal>scala</literal> command is very convenient for experimentation
    (see <xref linkend="CommandLineToolScala" /> for more details). An
    interactive interpreter like this is called a REPL: <emphasis>Read,
    Evaluate, Print, Loop</emphasis>.<indexterm>
        <primary>interactive mode, scala command</primary>
      </indexterm></para>

    <?dbfo-need height=”2in”
?>

    <para id="para_type_in_the_following_two_line">Type in the following two
    lines of code:</para>

    <screen>val book = "Programming Scala"
println(book)</screen>

    <para id="para_the_actual_input_and_output_sh">The actual input and output
    should look like the following:</para>

    <screen>scala&gt; val book = "Programming Scala"
book: java.lang.String = Programming Scala

scala&gt; println(book)
Programming Scala

scala&gt;</screen>

    <para id="para_the_first_line_used_the_val_">The first line uses the
    <literal>val</literal> keyword to declare a read-only variable named
    <literal>book</literal>. Note that the output returned from the
    interpreter shows you the type and value of <literal>book</literal>. This
    can be very handy for understanding complex declarations. The second line
    prints the value of <literal>book</literal>, which is “Programming
    Scala”.<indexterm>
        <primary>val keyword</primary>

        <secondary sortas="declaration">in declaration of read-only
        variable</secondary>
      </indexterm></para>

    <tip id="para_note_experimenting_with_the_">
      <para>Experimenting with the <literal>scala</literal> command in the
      interactive mode (REPL) is a great way to learn the details of
      Scala.</para>
    </tip>

    <para id="para_many_of_the_examples_in_this_b">Many of the examples in
    this book can be executed in the interpreter like this. However, it’s
    often more convenient to use the second option we mentioned, writing Scala
    scripts in a text editor or IDE and executing them with the same
    <literal>scala</literal> command. We’ll do that for most of the remaining
    examples in this chapter.</para>

    <para id="para_in_your_text_editor_of_choice_">In your text editor of
    choice, save the Scala code in the following example to a file named
    <filename>upper1-script.scala</filename> in a directory of your
    choosing:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/upper1-script.scala

class Upper {
  def upper(strings: String*): Seq[String] = {
    strings.map((s:String) =&gt; s.toUpperCase())
  }
}

val up = new Upper
Console.println(up.upper("A", "First", "Scala", "Program"))</programlisting>

    <para id="para_this_scala_script_converts_str">This Scala script converts
    strings to uppercase.</para>

    <para id="para_by_the_way_that_s_a_comment_o">By the way, that’s a comment
    on the first line (with the name of the source file for the code example).
    Scala follows the same comment conventions as Java, C#, C++, etc. A
    <literal>// <replaceable>comment</replaceable></literal> goes to the end
    of a line, while a <literal>/* <replaceable>comment</replaceable>
    */</literal> can cross line boundaries.<indexterm>
        <primary>/ (slash)</primary>

        <secondary>/* */ in multi-line comments</secondary>
      </indexterm><indexterm>
        <primary>/ (slash)</primary>

        <secondary>// in single-line comments</secondary>
      </indexterm><indexterm>
        <primary>comments</primary>
      </indexterm></para>

    <?dbfo-need height=”2in”
?>

    <para id="para_to_run_this_script_go_to_a_co">To run this script, go to a
    command window, change to the same directory, and run the following
    command:</para>

    <screen>scala upper1-script.scala</screen>

    <para id="para_the_file_is_interpreted_meani">The file is interpreted,
    meaning it is compiled and executed in one step. You should get the
    following output:</para>

    <programlisting linenumbering="unnumbered">Array(A, FIRST, SCALA, PROGRAM)</programlisting>

    <sidebar>
      <title>Interpreting Versus Compiling and Running Scala Code</title>

      <para id="para_to_summarize_if_you_type_sca">To summarize, if you type
      <literal>scala</literal> on the command line without a file argument,
      the interpreter runs in interactive mode. You type in definitions and
      statements that are evaluated on the fly. If you give the command a
      scala source file argument, it compiles and runs the file as a script,
      as in our <literal>scala upper1-script.scala</literal> example. Finally,
      you can compile Scala files separately and execute the
      <literal>class</literal> file, as long as it has a
      <literal>main</literal> method, just as you would normally do with the
      <literal>java</literal> command. (We’ll show an example
      shortly.)<indexterm>
          <primary>scala command</primary>
        </indexterm><indexterm>
          <primary>compiling versus interpreting</primary>
        </indexterm><indexterm>
          <primary>interpreting versus compiling</primary>
        </indexterm></para>

      <para id="para_there_are_some_subtleties_you_">There are some subtleties
      you’ll need to understand about the limitations of using the interpreter
      modes versus separate compilation and execution steps. We discuss these
      subtleties in <xref linkend="CommandLineTools" />.</para>

      <para id="para_whenever_we_refer_to__executin">Whenever we refer to
      <emphasis>executing a script</emphasis>, we mean running a Scala source
      file with the <literal>scala</literal> command.<indexterm>
          <primary>executing a script</primary>
        </indexterm></para>
    </sidebar>

    <para id="para_in_this_example_the_upper_m">In the current example, the
    <literal>upper</literal> method in the <literal>Upper</literal> class (no
    pun intended) converts the input strings to uppercase and returns them in
    an array. The last line in the example converts four strings and prints
    the resulting <literal>Array</literal>.</para>

    <para id="para_let_s_examine_the_code_in_deta">Let’s examine the code in
    detail, so we can begin to learn Scala syntax. There are a lot of details
    in just six lines of code! We’ll explain the general ideas here. All the
    ideas used in this example will be explained more thoroughly in later
    sections of the book.<indexterm>
        <primary>classes</primary>

        <secondary>Upper class (example)</secondary>
      </indexterm></para>

    <para id="para_in_the_example_the_upper_cl">In the example, the
    <literal>Upper</literal> class begins with the <literal>class</literal>
    keyword. The class body is inside the outermost curly braces
    <literal>{...}</literal>.<indexterm>
        <primary>class keyword</primary>
      </indexterm><indexterm>
        <primary>{ } (curly braces)</primary>

        <secondary>enclosing class body</secondary>
      </indexterm></para>

    <para id="para_the_upper_method_definition_">The <literal>upper</literal>
    method definition begins on the second line with the
    <literal>def</literal> keyword, followed by the method name and an
    argument list, the return type of the method, an equals sign
    (<literal>=</literal>), and then the method body.<indexterm>
        <primary>methods</primary>

        <secondary>defining</secondary>
      </indexterm><indexterm>
        <primary>def keyword</primary>
      </indexterm></para>

    <para id="para_the_argument_list_in_parenthes">The argument list in
    parentheses is actually a <emphasis>variable-length argument
    list</emphasis> of <literal>String</literal>s, indicated by the
    <literal>String*</literal> type following the colon. That is, you can pass
    in as many comma-separated strings as you want (including an empty list).
    These strings are stored in a parameter named <literal>strings</literal>.
    Inside the method, <literal>strings</literal> is actually an
    <literal>Array</literal>.<indexterm>
        <primary>: (colon)</primary>

        <secondary>separator between identifiers and type
        annotations</secondary>
      </indexterm><indexterm>
        <primary>type annotations</primary>
      </indexterm><indexterm>
        <primary>variable-length argument lists</primary>
      </indexterm></para>

    <note id="para_note_when_explicit_type_infor">
      <para>When explicit type information for variables is written in the
      code, these <emphasis>type annotations</emphasis> follow the colon after
      the item name (i.e., Pascal-like syntax). Why doesn’t Scala follow Java
      conventions? Recall that type information is often
      <emphasis>inferred</emphasis> in Scala (unlike Java), meaning we don’t
      always show type annotations explicitly. Compared to Java’s <literal
      role="keep-together">type item</literal> convention, the <literal>item:
      type</literal> convention is easier for the compiler to analyze
      unambiguously when you omit the colon and the type annotation and just
      write <literal>item</literal>.</para>
    </note>

    <para id="para_the_method_return_type_appears">The method return type
    appears after the argument list. In this case, the return type is
    <literal>Seq[String]</literal>, where <literal>Seq</literal> (“sequence”)
    is a particular kind of collection. It is a <emphasis>parameterized
    type</emphasis> (like a <emphasis>generic</emphasis> type in Java),
    parameterized here with <literal>String</literal>. Note that Scala uses
    square brackets <literal>[...]</literal> for parameterized types, whereas
    Java uses angle brackets <literal>&lt;...&gt;</literal>.<indexterm>
        <primary>&lt; &gt; (angle brackets)</primary>

        <secondary sortas="method names">in method names</secondary>
      </indexterm><indexterm>
        <primary>[ ] (square brackets)</primary>

        <secondary>enclosing parameterized types in Scala</secondary>
      </indexterm><indexterm>
        <primary>parameterized types</primary>
      </indexterm></para>

    <note id="para_note_scala_allows_angle_brack">
      <para>Scala allows angle brackets to be used in method names, e.g.,
      naming a “less than” method <literal>&lt;</literal> is common. So, to
      avoid ambiguities, Scala uses square brackets instead for parameterized
      types. They can’t be used in method names. Allowing
      <literal>&lt;</literal> and <literal>&gt;</literal> in method names is
      why Scala doesn’t follow Java’s convention for angle brackets.</para>
    </note>

    <para id="para_the_body_of_the_upper_method">The body of the
    <literal>upper</literal> method comes after the equals sign
    (<literal>=</literal>). Why an equals sign? Why not just curly braces
    <literal>{...}</literal>, like in Java? Because semicolons, function
    return types, method arguments lists, and even the curly braces are
    sometimes omitted, using an equals sign prevents several possible parsing
    ambiguities. Using an equals sign also reminds us that even functions are
    values in Scala, which is consistent with Scala’s support of
    <emphasis>functional programming</emphasis>, described in more detail in
    <xref linkend="FunctionalProgramming" />.<indexterm>
        <primary>= (equals sign)</primary>

        <secondary sortas="method definitions">in method
        definitions</secondary>
      </indexterm></para>

    <para id="para_the_method_body_calls_the_map">The method body calls the
    <literal>map</literal> method on the <literal>strings</literal> array,
    which takes a <emphasis>function literal</emphasis> as an argument.
    Function literals are “anonymous” functions. They are similar to
    <emphasis>lambdas</emphasis>, <emphasis>closures</emphasis>,
    <emphasis>blocks</emphasis>, or <emphasis>procs</emphasis> in other
    languages. In Java, you would have to use an anonymous inner class here
    that implements a method defined by an interface, etc.<indexterm>
        <primary>function literals</primary>

        <secondary>defined</secondary>
      </indexterm></para>

    <para id="para_in_this_case_the_function_lit">In this case, we passed in
    the following function literal:</para>

    <programlisting linenumbering="unnumbered">(s:String) =&gt; s.toUpperCase()</programlisting>

    <para id="para_takes_a_single_string_argume">It takes an argument list
    with a single <literal>String</literal> argument named
    <literal>s</literal>. The body of the function literal is after the
    “arrow,” <literal>=&gt;</literal>. It calls
    <literal>toUpperCase()</literal> on <literal>s</literal>. The result of
    this call is returned by the function literal. In Scala, the last
    <emphasis>expression</emphasis> in a function is the return value,
    although you can have <literal>return</literal> statements elsewhere, too.
    The <literal>return</literal> keyword is optional here and is rarely used,
    except when returning out of the middle of a block (e.g., in an
    <literal>if</literal> statement).<indexterm>
        <primary>return keyword</primary>
      </indexterm></para>

    <note id="para_note_the_value_of_the_last_ex">
      <para>The value of the last expression is the default return value of a
      function. No <literal>return</literal> is required.</para>
    </note>

    <para id="para_so_map_passes_each_string_">So, <literal>map</literal>
    passes each <literal>String</literal> in <literal>strings</literal> to the
    function literal and builds up a new collection with the results returned
    by the function literal.</para>

    <para id="para_to_exercise_the_code_we_creat">To exercise the code, we
    create a new <literal>Upper</literal> instance and assign it to a variable
    named <literal>up</literal>. As in Java, C#, and similar languages, the
    syntax <literal>new Upper</literal> creates a new instance. The
    <literal>up</literal> variable is declared as a read-only “value” using
    the <literal>val</literal> keyword.<indexterm>
        <primary>println function</primary>
      </indexterm><indexterm>
        <primary>new operator</primary>
      </indexterm><indexterm>
        <primary>val keyword</primary>
      </indexterm></para>

    <para id="para_finally_we_call_the_upper_m">Finally, we call the
    <literal>upper</literal> method on a list of strings, and print out the
    result with <literal>Console.println(...)</literal>, which is equivalent
    to Java’s <literal>System.out.println(...)</literal>.<indexterm>
        <primary>Console.println( ) method</primary>
      </indexterm></para>

    <para id="para_we_can_actually_simplify_this_">We can actually simplify
    our script even further. Consider this simplified version of the
    script:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/upper2-script.scala

object Upper {
  def upper(strings: String*) = strings.map(_.toUpperCase())
}

println(Upper.upper("A", "First", "Scala", "Program"))</programlisting>

    <para id="para_this_code_does_exactly_the_sam">This code does exactly the
    same thing, but with a third fewer characters.<indexterm>
        <primary>singleton objects</primary>
      </indexterm><indexterm>
        <primary>objects</primary>

        <secondary sortas="Scala">in Scala</secondary>

        <tertiary>versus class-level members</tertiary>
      </indexterm></para>

    <para id="para_on_the_first_line_upper_is_">On the first line,
    <literal>Upper</literal> is now declared as an <literal>object</literal>,
    which is a <emphasis>singleton</emphasis>. We are declaring a class, but
    the Scala runtime will only ever create one instance of
    <literal>Upper</literal>. (You can’t write <literal>new Upper</literal>,
    for example.) Scala uses <literal>objects</literal> for situations where
    other languages would use “class-level” members, like
    <literal>static</literal>s in Java. We don’t really need more than one
    <emphasis>instance</emphasis> here, so a singleton is fine.</para>

    <note id="para_note_why_doesn_t_scala_suppor">
      <para>Why doesn’t Scala support <literal>static</literal>s? Since
      <emphasis>everything</emphasis> is an object in Scala, the
      <literal>object</literal> construct keeps this policy consistent. Java’s
      <literal>static</literal> methods and fields are not tied to an actual
      instance.</para>
    </note>

    <para id="para_note_that_this_code_is_fully_t">Note that this code is
    fully thread-safe. We don’t declare any variables that might cause
    thread-safety issues. The API methods we use are also thread-safe.
    Therefore, we don’t need multiple instances. A singleton
    <literal>object</literal> works fine.</para>

    <para id="para_the_implementation_of_upper_">The implementation of
    <literal>upper</literal> on the second line is also simpler. Scala can
    usually infer the return type of the method (but not the types of the
    method arguments), so we drop the explicit declaration. Also, because
    there is only one expression in the method body, we drop the braces and
    put the entire method definition on one line. The equals sign before the
    method body tells the compiler, as well as the human reader, where the
    method body begins.</para>

    <para id="para_we_have_also_exploited_a_short">We have also exploited a
    shorthand for the function literal. Previously we wrote it as
    follows:</para>

    <programlisting linenumbering="unnumbered">(s:String) =&gt; s.toUpperCase()</programlisting>

    <para id="para_we_can_shorten_it_to_the_follo">We can shorten it to the
    following expression:</para>

    <programlisting linenumbering="unnumbered">_.toUpperCase()</programlisting>

    <para id="para_because_map_takes_one_argume">Because
    <literal>map</literal> takes one argument, a function, we can use the
    “placeholder” indicator <literal>_</literal> instead of a named parameter.
    That is, the <literal>_</literal> acts like an anonymous variable, to
    which each string will be assigned before <literal>toUpperCase</literal>
    is called. Note that the <literal>String</literal> type is inferred for
    us, too. As we will see, Scala uses <literal>_</literal> as a “wildcard”
    in several contexts.<indexterm>
        <primary>_ (underscore)</primary>

        <secondary>placeholder in imports, function literals, etc.</secondary>
      </indexterm></para>

    <para id="para_you_can_also_use_this_short_ha">You can also use this
    shorthand syntax in some more complex function literals, as we will see in
    <xref linkend="RoundingOutTheEssentials" />.</para>

    <para id="para_on_the_last_line_using_an_ob">On the last line, using an
    <literal>object</literal> rather than a <literal>class</literal>
    simplifies the code. Instead of creating an instance with <literal>new
    Upper</literal>, we can just call the <literal>upper</literal> method on
    the <literal>Upper</literal> object directly (note how this looks like the
    syntax you would use when calling static methods in a Java class).</para>

    <para id="para_finally_scala_automatically_i">Finally, Scala automatically
    imports many methods for I/O, like <literal>println</literal>, so we don’t
    need to call <literal>Console.println()</literal>. We can just use
    <literal>println</literal> by itself. (See <xref linkend="PredefObject" />
    for details on the types and methods that are automatically imported or
    defined.)<indexterm>
        <primary>println function</primary>
      </indexterm><indexterm>
        <primary>I/O (input/output)</primary>

        <secondary>automatic importation of methods by Scala</secondary>
      </indexterm></para>

    <para id="para_let_s_do_one_last__refactoring">Let’s do one last
    <emphasis>refactoring</emphasis>. Convert the script into a compiled,
    command-line tool:<indexterm>
        <primary>main method</primary>
      </indexterm><indexterm>
        <primary>compiled, command-line tool, converting script to</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/upper3.scala

object Upper {
  def main(args: Array[String]) = {
    args.map(_.toUpperCase()).foreach(printf("%s ",_))
    println("")
  }
}</programlisting>

    <para id="para_now_the_upper_method_has_bee">Now the
    <literal>upper</literal> method has been renamed <literal>main</literal>.
    Because <literal>Upper</literal> is an <literal>object</literal>, this
    <literal>main</literal> method works exactly like a <literal>static
    main</literal> method in a Java class. It is the entry point to the
    <literal>Upper</literal> <emphasis>application</emphasis>.</para>

    <note id="para_note_in_scala_main_must_be">
      <para>In Scala, <literal>main</literal> must be a method in an
      <literal>object</literal>. (In Java, <literal>main</literal> must be a
      <literal>static</literal> method in a <literal>class</literal>.) The
      command-line arguments for the application are passed to
      <literal>main</literal> in an array of strings, e.g., <literal>args:
      Array[String]</literal>.</para>
    </note>

    <para id="para_the_first_line_inside_the_mai">The first line inside the
    <literal>main</literal> method uses the same shorthand notation for
    <literal>map</literal> that we just examined:</para>

    <programlisting linenumbering="unnumbered">args.map(_.toUpperCase())...</programlisting>

    <para id="para_the_call_to_map_returns_a_ne">The call to
    <literal>map</literal> returns a new collection. We iterate through it
    with <literal>foreach</literal>. We use a <literal>_</literal> placeholder
    shortcut again in another <emphasis>function literal</emphasis> that we
    pass to <literal>foreach</literal>. In this case, each string in the
    collection is passed as an argument to
    <literal>printf</literal>:<indexterm>
        <primary>function literals</primary>

        <secondary>passing to foreach</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">...foreach(printf("%s ",_))</programlisting>

    <para id="para_to_be_clear_these_two_uses_of">To be clear, these two uses
    of <literal>_</literal> are completely independent of each other. Method
    chaining and function-literal shorthands, as in this example, can take
    some getting used to, but once you are comfortable with them, they yield
    very readable code with minimal use of temporary variables.<indexterm>
        <primary>_ (underscore)</primary>

        <secondary>method chaining and function-literal shorthands</secondary>
      </indexterm></para>

    <para id="para_the_last_line_in_main_adds_a">The last line in
    <literal>main</literal> adds a final line feed to the output.</para>

    <para id="para_this_time_you_must_first_comp">This time, you must first
    compile the code to a JVM <filename>.class</filename> file using
    <literal>scalac</literal>:<indexterm>
        <primary>classes</primary>

        <secondary>compiling Java class</secondary>
      </indexterm><indexterm>
        <primary>scalac compiler</primary>

        <secondary>compiling code into JVM .class file</secondary>
      </indexterm></para>

    <screen>scalac upper3.scala</screen>

    <para id="para_you_should_now_have_a_file_nam">You should now have a file
    named <filename>Upper.class</filename>, just as if you had just compiled a
    Java class.</para>

    <note id="para_note_you_may_have_noticed_tha">
      <para>You may have noticed that the compiler did not complain when the
      <phrase role="keep-together">file was</phrase> named
      <filename>upper3.scala</filename> and the <literal>object</literal> was
      named <literal>Upper</literal>. Unlike <phrase
      role="keep-together">Java, the</phrase> file name doesn’t have to match
      the name of the type with <literal>public</literal> scope. (We’ll
      explore the visibility rules in <xref linkend="VisibilityRules" />.) In
      fact, unlike Java, you can have as many public types in a single file as
      you want. Furthermore, the directory location of a file doesn’t have to
      match the package declaration. However, you can certainly follow the
      Java conventions, if you want to.</para>
    </note>

    <para id="para_now_you_can_execute_this_comm">Now, you can execute this
    command for any list of strings. Here is an example:<indexterm>
        <primary>scala command</primary>

        <secondary>-cp option</secondary>
      </indexterm></para>

    <screen>scala -cp . Upper Hello World!</screen>

    <para id="para_the_cp_option_adds_he_cur">The <literal>-cp .</literal>
    option adds the current directory to the search “class path.” You should
    get the following output:</para>

    <screen> HELLO WORLD!</screen>

    <para id="para_therefore_we_have_met_the_req">Therefore, we have met the
    requirement that a programming language book must start with a “hello
    world” program.<indexterm class="endofrange"
    startref="ch01_Scalaexamples"></indexterm></para>
  </sect1>

  <sect1 id="ATasteOfConcurrency">
    <title>A Taste of Concurrency</title>

    <para id="para_there_are_many_reasons_to_be_s">There are many reasons to
    be seduced by Scala. One reason is the Actors API included in the Scala
    library, which is based on the robust Actors concurrency model built into
    Erlang (see <link linkend="Haller2007"
    xrefstyle="select:nopage">[Haller2007]</link>). Here is an example to whet
    your appetite.<indexterm class="startofrange" id="ch01_concurrency">
        <primary>concurrency</primary>
      </indexterm></para>

    <para id="para_in_the_actor_model_of_concurre">In the Actor model of
    concurrency (<link linkend="Agha1987"
    xrefstyle="select:nopage">[Agha1987]</link>), independent software
    entities called <emphasis>Actors</emphasis> share no state information
    with each other. Instead, they communicate by <phrase
    role="keep-together">exchanging</phrase> messages. By eliminating the need
    to synchronize access to shared, mutable state, it is far easier to write
    robust, concurrent applications.<indexterm class="startofrange"
        id="ch01_actors">
        <primary>Actors</primary>

        <secondary>example</secondary>
      </indexterm></para>

    <para id="para_in_this_example_instances_in_a_">In this example, instances
    in a geometric <literal>Shape</literal> hierarchy are sent to an Actor for
    drawing on a display. Imagine a scenario where a rendering “farm”
    generates scenes in an animation. As the rendering of a scene is
    completed, the shape “primitives” that are part of the scene are sent to
    an Actor for a display subsystem.</para>

    <para id="para_to_begin_we_define_a_shape_">To begin, we define a
    <literal>Shape</literal> class hierarchy:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/shapes.scala

package shapes {
  class Point(val x: Double, val y: Double) {
    override def toString() = "Point(" + x + "," + y + ")"
  }

  abstract class Shape() {
    def draw(): Unit
  }

  class Circle(val center: Point, val radius: Double) extends Shape {
    def draw() = println("Circle.draw: " + this)
    override def toString() = "Circle(" + center + "," + radius + ")"
  }

  class Rectangle(val lowerLeft: Point, val height: Double, val width: Double)
        extends Shape {
    def draw() = println("Rectangle.draw: " + this)
    override def toString() =
      "Rectangle(" + lowerLeft + "," + height + "," + width + ")"
  }

  class Triangle(val point1: Point, val point2: Point, val point3: Point)
        extends Shape {
    def draw() = println("Triangle.draw: " + this)
    override def toString() =
      "Triangle(" + point1 + "," + point2 + "," + point3 + ")"
  }
}</programlisting>

    <para id="para_the_shape_class_hierarchy_is">The <literal>Shape</literal>
    class hierarchy is defined in a <literal>shapes</literal> package. You can
    declare the package using Java syntax, but Scala also supports a syntax
    similar to C#’s “namespace” syntax, where the entire declaration is scoped
    using curly braces, as used here. The Java-style package declaration
    syntax is far more commonly used, however, being both compact and
    readable.</para>

    <para id="para_the_point_class_represents_a">The <literal>Point</literal>
    class represents a two-dimensional point on a plane. Note the argument
    list after the class name. Those are constructor parameters. In Scala, the
    <emphasis>whole</emphasis> class body is the constructor, so you list the
    arguments for the <emphasis>primary</emphasis> constructor after the class
    name and before the class body. (We’ll see how to define auxiliary
    constructors in <xref linkend="Constructors" />.) Because we put the
    <literal>val</literal> keyword before each parameter declaration, they are
    automatically converted to read-only fields with the same names with
    public reader methods of the same name. That is, when you instantiate a
    <literal>Point</literal> instance, e.g., <literal>point</literal>, you can
    read the fields using <literal>point.x</literal> and
    <literal>point.y</literal>. If you want <emphasis>mutable</emphasis>
    fields, then use the keyword <literal>var</literal>. We’ll explore
    variable declarations and the <literal>val</literal> and
    <literal>var</literal> keywords in <xref
    linkend="VariableDeclarationsAndDefinitions" />.<indexterm>
        <primary>fields</primary>

        <secondary>mutable</secondary>
      </indexterm><indexterm>
        <primary>mutable fields</primary>
      </indexterm><indexterm>
        <primary>var keyword</primary>
      </indexterm><indexterm>
        <primary>constructors</primary>
      </indexterm></para>

    <para id="para_the_body_of_point_defines_on">The body of
    <literal>Point</literal> defines one method, an
    <emphasis>override</emphasis> of the familiar <literal>toString</literal>
    method in Java (like <literal>ToString</literal> in C#). Note that Scala,
    like C#, requires the <literal>override</literal> keyword whenever you
    override a concrete method. Unlike C#, you don’t have to use a <literal
    role="keep-together">virtual</literal> keyword on the original concrete
    method. In fact, there is no <literal>virtual</literal> keyword in Scala.
    As before, we omit the curly braces “<literal>{...}</literal>” around the
    body of <literal>toString</literal>, since it has only one
    expression.<indexterm>
        <primary>C#</primary>

        <secondary>override keyword for concrete methods</secondary>
      </indexterm><indexterm>
        <primary>override keyword</primary>
      </indexterm><indexterm>
        <primary>classes</primary>

        <secondary>abstract</secondary>
      </indexterm><indexterm>
        <primary>abstract classes</primary>
      </indexterm></para>

    <para id="para__shape_is_an_abstract_class_"><literal>Shape</literal> is
    an abstract class. Abstract classes in Scala are similar to those in Java
    and C#. We can’t instantiate instances of abstract classes, even when all
    their field and method members are concrete.</para>

    <para id="para_in_this_case_shape_declares_a">In this case, Shape declares
    an <emphasis>abstract</emphasis> <literal>draw</literal> method. We know
    it is abstract because it has no body. No <literal>abstract</literal>
    keyword is required on the method. Abstract methods in Scala are just like
    abstract methods in Java and C#. (See <xref linkend="OverridingMembers" />
    for more details.)<indexterm>
        <primary>C#</primary>

        <secondary>abstract methods</secondary>
      </indexterm></para>

    <para>The <literal>draw</literal> method returns <literal>Unit</literal>,
    which is a type that is roughly equivalent to <literal>void</literal> in
    C-derived languages like Java, etc. (See <xref
    linkend="ScalaTypeHierarchy" /> for more details.)</para>

    <para id="para__circle_is_declared_as_a_conc"><literal>Circle</literal> is
    declared as a concrete subclass of <literal>Shape</literal>. It defines
    the <literal>draw</literal> method to simply print a message to the
    console. <literal>Circle</literal> also overrides
    <literal>toString</literal>.</para>

    <para id="para__rectangle_is_also_a_concrete"><literal>Rectangle</literal>
    is also a concrete subclass of <literal>Shape</literal> that defines
    <literal>draw</literal> and overrides <literal>toString</literal>. For
    simplicity, we assume it is not rotated relative to the
    <emphasis>x</emphasis> and <emphasis>y</emphasis> axes. Hence, all we need
    is one point, the lower lefthand point will do, and the height and width
    of the rectangle.</para>

    <para id="para__triangle_follows_the_same_pa"><literal>Triangle</literal>
    follows the same pattern. It takes three <literal>Points</literal> as its
    constructor arguments.<indexterm>
        <primary>this keyword</primary>
      </indexterm></para>

    <para id="para_both_draw_methods_in_circle">Both <literal>draw</literal>
    methods in <literal>Circle</literal>, <literal>Rectangle</literal>, and
    <literal>Triangle</literal> use <literal>this</literal>. As in Java and
    C#, <literal>this</literal> is how an instance refers to itself. In this
    context, where <literal>this</literal> is the righthand side of a String
    concatenation expression (using the plus sign),
    <literal>this.toString</literal> is invoked implicitly.<indexterm>
        <primary>C#</primary>

        <secondary>this keyword</secondary>
      </indexterm></para>

    <note id="para_note_of_course_in_a_real_app">
      <para>Of course, in a real application, you would not implement drawing
      in “domain model” classes like this, since the implementations would
      depend on details like the operating system platform, graphics API, etc.
      We will see a better design approach when we discuss
      <emphasis>traits</emphasis> in <xref linkend="Traits" />.</para>
    </note>

    <para id="para_now_that_we_have_defined_our_s">Now that we have defined
    our shapes types, let’s return to Actors. We define an
    <literal>Actor</literal> that receives “messages” that are shapes to
    draw:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/shapes-actor.scala

package shapes {
  import scala.actors._
  import scala.actors.Actor._

  object ShapeDrawingActor extends Actor {
    def act() {
      loop {
        receive {
          case s: Shape =&gt; s.draw()
          case "exit"   =&gt; println("exiting..."); exit
          case x: Any   =&gt; println("Error: Unknown message! " + x)
        }
      }
    }
  }
}</programlisting>

    <para id="para_the_actor_is_declared_to_be_pa">The Actor is declared to be
    part of the <literal>shapes</literal> package. Next, we have two import
    <phrase role="keep-together">statements</phrase>.<indexterm>
        <primary>import statements</primary>
      </indexterm></para>

    <para id="para_the_first_import_statement_imp">The first import statement
    imports all the types in the <literal>scala.actors</literal> package. In
    Scala, the underscore <literal>_</literal> is used the way the star
    <literal>*</literal> is used in Java.<indexterm>
        <primary>_ (underscore)</primary>

        <secondary>wildcard character in Scala</secondary>
      </indexterm></para>

    <note id="para_note_because_is_a_valid_cha">
      <para>Because <literal>*</literal> is a valid character for a function
      name, it can’t be used as the <literal>import</literal> wildcard.
      Instead, <literal>_</literal> is reserved for this purpose.</para>
    </note>

    <para id="para_all_the_methods_and_public_fie">All the methods and public
    fields from <literal>Actor</literal> are imported by the second
    <literal>import</literal>. These are not <literal>static</literal> imports
    from the <literal>Actor</literal> type, as they would be in Java. Rather,
    they are imported from an <literal>object</literal> that is also named
    <literal>Actor</literal>. The <literal>class</literal> and
    <literal>object</literal> can have the same name, as we will see in <xref
    linkend="CompanionObjects" />.<indexterm>
        <primary>Actors</primary>

        <secondary>Actor class and object</secondary>
      </indexterm></para>

    <para id="para_our_actor_class_definition_s">Our Actor class definition,
    <literal>ShapeDrawingActor</literal>, is an <literal>object</literal> that
    extends <literal>Actor</literal> (the type, not the
    <literal>object</literal>). The <literal>act</literal> method is
    overridden to do the unique work of the Actor. Because
    <literal>act</literal> is an abstract method, we don’t need to explicitly
    override it with the <literal>override</literal> keyword. Our Actor loops
    indefinitely, waiting for incoming messages.</para>

    <para id="para_during_each_pass_in_the_loop_">During each pass in the
    loop, the <literal>receive</literal> method is called. It blocks until a
    new message arrives. Why is the code after <literal>receive</literal>
    enclosed in curly braces (<literal>{...}</literal>) and not parentheses
    (<literal>(...)</literal>)? We will learn later that there are cases where
    this substitution is allowed and is quite useful (see <xref
    linkend="RoundingOutTheEssentials" />). For now, what you need to know is
    that the expressions inside the braces constitute a single
    <emphasis>function literal</emphasis> that is passed to
    <literal>receive</literal>. This function literal does a <emphasis>pattern
    match</emphasis> on the message instance to decide how to handle the
    message. Because of the <literal>case</literal> clauses, it looks like a
    typical switch statement in Java, for example, and the behavior is very
    similar.<indexterm>
        <primary>function literals</primary>

        <secondary>passing to method for pattern matching</secondary>
      </indexterm><indexterm>
        <primary>{ } (curly braces)</primary>

        <secondary>substituting for parentheses in method call</secondary>
      </indexterm><indexterm>
        <primary>( ) (parentheses)</primary>

        <secondary>substituting curly braces for in method call</secondary>
      </indexterm><indexterm>
        <primary>pattern matching</primary>
      </indexterm></para>

    <para id="para_the_first_case_does_a_type_c">The first
    <literal>case</literal> does a type comparison with the message. (There is
    no explicit variable for the message instance in the code; it is
    inferred.) If the message is of type <literal>Shape</literal>, the first
    <literal>case</literal> matches. The message instance is cast to a
    <literal>Shape</literal> and assigned to the variable
    <literal>s</literal>, and then the <literal>draw</literal> method is
    called on it.</para>

    <para id="para_if_the_message_is_not_a_shape">If the message is not a
    <literal>Shape</literal>, the second <literal>case</literal> is tried. If
    the message is the string <literal>"exit"</literal>, the Actor prints a
    message and terminates execution. Actors should usually have a way to exit
    gracefully!</para>

    <para id="para_the_last_case_handles_any_ot">The last
    <literal>case</literal> clause handles any other message instance, thereby
    functioning as the <emphasis>default</emphasis> case. The Actor reports an
    error and then drops the message. <literal>Any</literal> is the parent of
    all types in the Scala type hierarchy, like <literal>Object</literal> is
    the root type in Java and other languages. Hence, this case clause will
    match any message of any type. Pattern matching is eager; we have to put
    this case clause at the end, so it doesn’t consume the messages we are
    expecting!</para>

    <para id="para_recall_that_we_declared_draw_">Recall that we declared
    <literal>draw</literal> as an abstract method in <literal>Shape</literal>
    and we implemented <literal>draw</literal> in the concrete subclasses.
    Hence, the code in the first <literal>case</literal> statement invokes a
    polymorphic operation.</para>

    <sidebar>
      <title>Pattern Matching Versus Polymorphism</title>

      <para id="para__pattern_matching__plays_a_cen"><emphasis>Pattern
      matching</emphasis> plays a central role in functional programming just
      as polymorphism plays a central role in object-oriented programming.
      Functional pattern matching is much more important and sophisticated
      than the corresponding <literal>switch/case</literal> statements found
      in most <emphasis>imperative</emphasis> languages, like Java. We will
      examine Scala’s support for pattern matching in more detail in <xref
      linkend="FunctionalProgramming" />. In our example here, we can begin to
      see that joining functional-style pattern matching with object-oriented
      polymorphic dispatching is a powerful combination that is a benefit of
      mixed paradigm languages like Scala.<indexterm>
          <primary>imperative languages</primary>
        </indexterm><indexterm>
          <primary>pattern matching</primary>

          <secondary>polymorphism versus</secondary>
        </indexterm><indexterm>
          <primary>polymorphism</primary>

          <secondary>pattern matching versus</secondary>
        </indexterm></para>
    </sidebar>

    <para id="para_finally_here_is_a_script_that">Finally, here is a script
    that uses the <literal>ShapeDrawingActor</literal> Actor:</para>

    <programlisting linenumbering="unnumbered">// code-examples/IntroducingScala/shapes-actor-script.scala

import shapes._

ShapeDrawingActor.start()

ShapeDrawingActor ! new Circle(new Point(0.0,0.0), 1.0)
ShapeDrawingActor ! new Rectangle(new Point(0.0,0.0), 2, 5)
ShapeDrawingActor ! new Triangle(new Point(0.0,0.0),
                                 new Point(1.0,0.0),
                                 new Point(0.0,1.0))
ShapeDrawingActor ! 3.14159

ShapeDrawingActor ! "exit"</programlisting>

    <para id="para_the_shapes_in_the_shapes_pac">The shapes in the
    <literal>shapes</literal> package are imported.</para>

    <para id="para_the_shapedrawingactor_actor_">The
    <literal>ShapeDrawingActor</literal> Actor is started. By default, it runs
    in its own thread (there are alternatives we will discuss in <xref
    linkend="Concurrency" />), waiting for messages.</para>

    <para id="para_five_messages_are_sent_to_the_">Five messages are sent to
    the Actor, using the syntax <literal>actor ! message</literal>. The first
    message sends a <literal>Circle</literal> instance. The Actor “draws” the
    circle. The second message sends a <literal>Rectangle</literal> message.
    The Actor “draws” the rectangle. The third message does the same thing for
    a <literal>Triangle</literal>. The fourth message sends a
    <literal>Double</literal> that is approximately equal to
    <emphasis>Pi</emphasis>. This is an unknown message for the Actor, so it
    just prints an error message. The final message sends an “exit” string,
    which causes the Actor to terminate.<indexterm>
        <primary>! (exclamation point)</primary>

        <secondary>! method, sending messages to Actors</secondary>
      </indexterm></para>

    <para id="para_to_try_out_the_actor_example_">To try out the Actor
    example, start by compiling the first two files. You can get the sources
    from the <ulink url="http://examples.oreilly.com/9780596155964/">O’Reilly
    download site</ulink> (see <xref linkend="GettingCodeExamples" /> for
    details) or you can create them yourself.</para>

    <para id="para_use_the_following_command_to_c">Use the following command
    to compile the files:</para>

    <screen> scalac shapes.scala shapes-actor.scala</screen>

    <para id="para_while_the_source_file_names_an">While the source file names
    and locations don’t have to match the file contents, you will notice that
    the generated class files are written to a <filename>shapes</filename>
    directory and there is one class file for each class we defined. The class
    file names and locations must conform to the JVM requirements.</para>

    <para id="para_now_you_can_run_the_script_to_">Now you can run the script
    to see the Actor in action:</para>

    <screen> scala -cp . shapes-actor-script.scala</screen>

    <para id="para_you_should_see_the_following_o">You should see the
    following output:</para>

    <screen>Circle.draw: Circle(Point(0.0,0.0),1.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,5.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))
Error: Unknown message! 3.14159
exiting...</screen>

    <para id="para_for_more_on_actors_see_co">For more on
    <literal>Actors</literal>, see <xref linkend="Concurrency" />.<indexterm
    class="endofrange" startref="ch01_actors"></indexterm><indexterm
    class="endofrange" startref="ch01_concurrency"></indexterm></para>
  </sect1>

  <sect1 id="_recap_and_what_8217_s_next">
    <title>Recap and What’s Next</title>

    <para id="para_we_made_the_case_for_scala_and">We made the case for Scala
    and got you started with two sample Scala programs, one of which gave you
    a taste of Scala’s <emphasis>Actors</emphasis> library for concurrency.
    Next, we’ll dive into more Scala syntax, emphasizing various
    keystroke-economical ways of getting lots of work done.</para>
  </sect1>
</chapter>