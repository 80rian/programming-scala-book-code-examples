<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="RoundingOutTheEssentials">
<title>Rounding Out the Essentials</title>
<para id="para_before_we_dive_into_scala_s_su">Before we dive into Scala’s support for object-oriented and functional programming, let’s finish our discussion of the essential features you’ll use in most of your programs.</para>
<sect1 id="_operator_operator">
<title>Operator? Operator?</title>
<para id="para_an_important_fundamental_conce">An important fundamental concept in Scala is that all operators are actually methods. Consider this most basic of examples:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/one-plus-two-script.scala

1 + 2</programlisting>
<para id="para_that_plus_sign_between_the_num">That plus sign between the numbers? It’s a method. First, Scala allows non-alphanumeric method
names. You can call methods <literal>+</literal>, <literal>-</literal>, <literal>_$_</literal>, or whatever you desire. Second, this expression is identical to <literal>1.+(2)</literal>.  When a method takes one argument, Scala lets you drop both the period and the parentheses, so the method invocation looks like an operator invocation. This is called “infix” notation, where the operator is between the instance and the argument. We’ll find out more about this shortly.</para>
<para id="para_actually_you_could_also_wrap_"/>
<para id="para_similarly_a_method_with_no_ar">Similarly, a method with no arguments can be invoked without the period. This is called “postfix” notation.</para>
<para id="para_ruby_and_smalltalk_programmers">Ruby and Smalltalk programmers should now feel right at home. As users of those languages know, these simple rules have far-reaching benefits when it comes to creating programs that flow naturally and elegantly.</para>
<para id="para_here_is_a_summary_of_the_rules">So, what characters can you use in identifiers? Here is a summary of the rules for identifiers, used for method and type names, variables, <emphasis>etc.</emphasis> For the precise details, see <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>. Scala allows all the printable ASCII characters, such as letters, digits, the underscore ‘_’, and the dollar sign ‘$’, with the exceptions of the “parenthetical” characters, ‘(’, ‘)’, ‘[’, ‘]’, ‘{’, ‘}’, and the “delimiter” characters ‘`’, ‘’’, ‘'’, ‘"’, ‘.’, ‘;’, and ‘,’.  Scala allows the other characters between \u0020-\u007F that are not in the sets above, such as mathematical symbols and “other” symbols. These remaining characters are called <emphasis>operator characters</emphasis> and they include characters such as ‘/’, ‘&lt;’, <emphasis>etc.</emphasis></para>
<variablelist id="para_identifier_rules">
<varlistentry id="varlistentry-reserved-words-can-8217-t-be-used">
<term>
Reserved Words Can’t Be Used
</term>
<listitem>
<para>
  As in most languages, you can’t reuse reserved words for identifiers. We listed the reserved words in <xref linkend="ReservedWords"/> in <xref linkend="TypeLessDoMore"/>. Recall that some of them are combinations of operator and punctuation characters. For example, a single underscore (‘_’) is a reserved word!
</para>
</listitem>
</varlistentry>
<varlistentry id="varlistentry-plain-identifiers-combinations-of-letters-digits-8216-8217-8216-_-8217-and-operators">
<term>
Plain Identifiers - Combinations of Letters, Digits, ‘$’, ‘_’ and Operators
</term>
<listitem>
<para>
  Like Java and many languages, a <emphasis>plain identifier</emphasis> can begin with a letter or underscore, followed by more letters, digits, underscores, and dollar signs. Unicode equivalent characters are also allowed. However, like Java, Scala reserves the dollar sign for internal use, so you shouldn’t use it in your own identifiers. After an underscore, you can have either letters and digits <emphasis>or</emphasis> a sequence of operator characters. The underscore is important. It tells the compiler to treat all the characters up to the next whitespace as part of the identifier. For example <literal>val xyz_++= = 1</literal> assigns the variable <literal>xyz_++=</literal> the value <literal>1</literal>, while the expression <literal>val xyz++= = 1</literal> won’t compile, because the “identifier” could also be interpreted as <literal>xyz ++=</literal>, which looks like an attempt to “append” something to <literal>xyz</literal>. Similarly, if you have operator characters after the underscore, you can’t mix them with letters and digits. This restriction prevents ambiguous expressions like this: <literal>abc_=123</literal>. Is that an identifier <literal>abc_=123</literal> or an assignment of the value <literal>123</literal> to <literal>abc_</literal>?
</para>
</listitem>
</varlistentry>
<varlistentry id="varlistentry-plain-identifiers-operators">
<term>
Plain Identifiers - Operators
</term>
<listitem>
<para>
  If an identifier begins with an operator character, the rest of the characters must be operator characters.
</para>
</listitem>
</varlistentry>
<varlistentry id="varlistentry-8220-back-quote-8221-literals">
<term>
“Back-quote” Literals
</term>
<listitem>
<para>
  An identifier can also be an arbitrary string (subject to platform limitations) between two back quote characters, <emphasis>e.g.,</emphasis> <literal>val `this is a valid identifier` = "Hello World!"</literal>. Recall that this syntax is also the way to invoke a method on a Java or .NET class when the method’s name is identical to a Scala reserved word, <emphasis>e.g.,</emphasis> <literal>java.net.Proxy.‵type‵()</literal>.
</para>
</listitem>
</varlistentry>
<varlistentry id="varlistentry-pattern-matching-identifiers">
<term>
Pattern Matching Identifiers
</term>
<listitem>
<para>
  In pattern matching expressions, tokens that being with a lower-case letter are parsed as <emphasis>variable identifiers</emphasis>, while tokens that being with an upper-case letter are parsed as <emphasis>constant identifiers</emphasis>. This restriction prevents some ambiguities because of the very succinct variable syntax that is used, <emphasis>e.g.,</emphasis> no <literal>val</literal> keyword is present.
</para>
</listitem>
</varlistentry>
</variablelist>
<sect2 id="para_pattern_matching_identifiers_">
<title>Syntactic Sugar</title>
<para id="para_once_you_know_that_all_operato">Once you know that all operators are methods, it’s easier to reason about unfamiliar Scala code. You don’t have to worry about special cases when you see new operators. When working with Actors in <xref linkend="ATasteOfConcurrency"/> in <xref linkend="IntroducingScala"/>, you’ll notice that we use an exclamation point (<literal>!</literal>) to send a message to an Actor. Now you know that the <literal>!</literal> is just another method, as are the other handy shortcut operators you can use to talk to Actors.  Similarly, Scala’s XML library provides the <literal>\</literal> and <literal>\\</literal> operators to dive into document structures. These are just methods on the <literal>scala.xml.NodeSeq</literal> class.</para>
<para id="para_this_flexible_method_naming_gi">This flexible method naming gives you the power to write libraries that feel like a natural extension of Scala itself. You could write a new math library with numeric types that accept addition, subtraction, and all the usual mathematical operators. You could write a new concurrent messaging layer that behaves just like Actors. The possibilities are constrained only by Scala’s method naming limitations.</para>
<caution id="para_caution_just_because_you__can"><para>Just because you <emphasis>can</emphasis> doesn’t mean you <emphasis>should</emphasis>.  When designing your own libraries and APIs in Scala, keep in mind that obscure punctuational operators are hard for programmers to remember. Overuse of these can contribute a “line noise” quality of unreadability to your code.  Stick to conventions and err on the side of spelling method names out when a shortcut doesn’t come readily to mind.</para></caution>
</sect2>
</sect1>
<sect1 id="_methods_without_parentheses_and_dots">
<title>Methods Without Parentheses and Dots</title>
<para id="para_to_facilitate_a_variety_of_rea">To facilitate a variety of readable programming styles, Scala is flexible about the use of parentheses in methods. If a method takes no parameters, you can define it without parentheses. Callers must invoke the method without parentheses. If you add empty parentheses, then callers may optionally add parentheses. For example, the <literal>size</literal> method for <literal>List</literal> has no parentheses, so you write <literal>List(1, 2, 3).size</literal>. If you try <literal>List(1, 2, 3).size()</literal>, you’ll get an error. However, the <literal>length</literal> method for <literal>String</literal> does have parentheses in its definition, so both <literal>"hello".length()</literal> and <literal>"hello".length</literal> will compile.</para>
<para id="para_the_convention_in_the_scala_co">The convention in the Scala community is to omit parentheses when calling a method that has no <emphasis>side-effects</emphasis>. So, asking for the size of a sequence is fine without parentheses, but defining a method that transforms the elements in the sequence should be written with parentheses. This convention signals a potentially tricky method for users of your code.</para>
<para id="para_it_s_also_possible_to_omit_the">It’s also possible to omit the dot (period) when calling a parameterless method or one that takes only one argument. With this in mind, our <literal>List(1, 2, 3).size</literal> example above could be written as:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/no-dot-script.scala

List(1, 2, 3) size</programlisting>
<para id="para_neat_but_confusing_when_does">Neat, but confusing. When does this syntactical flexibility become useful? When chaining method calls together into expressive, self-explanatory “sentences” of code:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/no-dot-better-script.scala

def isEven(n: Int) = (n % 2) == 0

List(1, 2, 3, 4) filter isEven foreach println</programlisting>
<para id="para_as_you_might_guess_running_th">As you might guess, running the above produces the output:</para>
<screen>2
4</screen>
<para id="para_scala_s_liberal_approach_to_pa">Scala’s liberal approach to parentheses and dots on methods provides one building block for writing <emphasis>Domain-Specific Languages</emphasis>. We’ll learn more about them after a brief discussion of operator precedence.</para>
<sect2 id="_precedence_rules">
<title>Precedence Rules</title>
<para id="para_so_if_an_expression_like_2_0">So, if an expression like <literal>2.0 * 4.0 / 3.0 * 5.0</literal> is actually a series of method calls on <literal>Doubles</literal>, what are the <emphasis>operator precedence</emphasis> rules?  Here they are in order from lowest to highest precedence <link linkend="ScalaSpec2009" xrefstyle="select:nopage">[ScalaSpec2009]</link>.</para>
<itemizedlist>
<listitem>
<para>
<emphasis>all letters</emphasis>
</para>
</listitem>
<listitem>
<para>
|
</para>
</listitem>
<listitem>
<para>
^
</para>
</listitem>
<listitem>
<para>
&amp;
</para>
</listitem>
<listitem>
<para>
&lt; &gt;
</para>
</listitem>
<listitem>
<para>
= !
</para>
</listitem>
<listitem>
<para>
:
</para>
</listitem>
<listitem>
<para>
+ -
</para>
</listitem>
<listitem>
<para>
* / %
</para>
</listitem>
<listitem>
<para>
<emphasis>all other special characters</emphasis>
</para>
</listitem>
</itemizedlist>
<para id="para_characters_on_the_same_line_ha">Characters on the same line have the same precedence. An exception is <literal>=</literal> when used for assignment, when it has the lowest precedence.</para>
<para id="para_since_042_and_have_the_sa">Since * and / have the same precedence, the two lines in the following <userinput>scala</userinput> session behave the same.</para>
<programlisting linenumbering="unnumbered">scala&gt; 2.0 * 4.0 / 3.0 * 5.0
res2: Double = 13.333333333333332

scala&gt; (((2.0 * 4.0) / 3.0) * 5.0)
res3: Double = 13.333333333333332</programlisting>
<para id="para_in_a_sequence_of_left_associat">In a sequence of left-associative method invocations, they simply bind in left-to-right order. “Left-associative” you say? In Scala, any method with a name that ends with a colon ‘:’ actually binds to the <emphasis>right</emphasis>, while all other methods bind to the left. For example, you can prepend an element to a <literal>List</literal> using the <literal>::</literal> method (called “cons”, short for “constructor”).</para>
<programlisting linenumbering="unnumbered">scala&gt; val list = List('b', 'c', 'd')
list: List[Char] = List(b, c, d)

scala&gt; 'a' :: list
res4: List[Char] = List(a, b, c, d)</programlisting>
<para id="para_the_second_expression_is_equiv">The second expression is equivalent to <literal>list.::(<replaceable>a</replaceable>)</literal>. In a sequence of right-associative method invocations, they bind from right to left. What about a mixture of left-binding and right-binding expressions?</para>
<programlisting linenumbering="unnumbered">scala&gt; 'a' :: list ++ List('e', 'f')
res5: List[Char] = List(a, b, c, d, e, f)</programlisting>
<para>(The <literal>++</literal> method appends two lists.) In this case, <literal>list</literal> is added to the <literal>List(<replaceable>e</replaceable>, <replaceable>f</replaceable>)</literal>, then <literal><replaceable>a</replaceable></literal> is prepended to create the final list. It’s usually better to add parentheses to remove any potential uncertainty.</para>
<tip id="para_tip_any_method_whose_name_end"><para>Any method whose name ends with a <literal>:</literal> binds to the <emphasis>right</emphasis>, not the <emphasis>left</emphasis>.</para></tip>
<note id="para_note_when_you_use_the_scala_"><para>When you use the <userinput>scala</userinput> command, either interactively or with scripts, it may appear that you can define “global” variables and methods outside of types. This is actually an illusion; the interpreter wraps all definitions in an anonymous type before generating JVM or .NET CLR byte code.</para></note>
</sect2>
</sect1>
<sect1 id="_domain_specific_languages">
<title>Domain-Specific Languages</title>
<para id="para_domain_specific_languages_or_"><emphasis>Domain-Specific Languages</emphasis>, or DSLs, provide a convenient syntactical means for expressing goals in a given problem domain. For example, SQL provides just enough of a programming language to handle the problems of working with databases, making it a domain-specific language.</para>
<para id="para_while_some_dsls_like_sql_are_s">While some DSLs like SQL are self-contained, it’s become popular to implement DSLs as subsets of full-fledged programming languages. This allows programmers to leverage the entirety of the host language for edge cases that the DSL does not cover, and saves the work of writing lexers, parsers, and the other building blocks of a language.</para>
<para id="para_scala_s_rich_flexible_syntax_">Scala’s rich, flexible syntax makes writing DSLs a breeze. Consider this example of a style of test writing called <emphasis>Behavior-Driven Development</emphasis> <link linkend="BDD" xrefstyle="select:nopage">[BDD]</link> using the <emphasis>Specs</emphasis> library (see  <xref linkend="ScalaSpecs"/>).</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/specs-script.scala

"nerd finder" should {
  "identify nerds from a List" in {
    val actors = List("Rick Moranis", "James Dean", "Woody Allen")
    val finder = new NerdFinder(actors)
    finder.findNerds mustEqual List("Rick Moranis", "Woody Allen")
  }
}</programlisting>
<para id="para_notice_how_much_this_code_read">Notice how much this code reads like English: “this should test that in the following scenario”, “this value must equal that value”, and so forth.  This example uses the superb Specs library, which effectively provides a DSL for the behavior-driven development testing and engineering methodology. By making maximum use of Scala’s liberal syntax and rich methods, Specs test suites are readable even by non-developers.</para>
<para id="para_remember_when_we_said_you_coul"/>
<para id="para_this_is_just_a_taste_of_the_po">This is just a taste of the power of DSLs in Scala. We’ll see other examples later and learn how to write our own as we get more advanced (see <xref linkend="DomainSpecificLanguages"/>).</para>
</sect1>
<sect1 id="IfStatements">
<title>Scala if Statements</title>
<para id="para_even_the_most_familiar_languag">Even the most familiar language features are supercharged in Scala, let’s have a look at the lowly <literal>if</literal> statement. As in most every language, Scala’s <literal>if</literal> evaluates a conditional expression, then proceeds to a block if the result is <literal>true</literal> or branches to an alternate block if the result is <literal>false</literal>. A simple example:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/if-script.scala

if (2 + 2 == 5) {
  println("Hello from 1984.")
} else if (2 + 2 == 3) {
    println("Hello from Remedial Math class?")
} else {
  println("Hello from a non-Orwellian future.")
}</programlisting>
<para id="para_what_s_different_in_scala_is_t">What’s different in Scala is that <literal>if</literal> and almost all other statements are actually expressions themselves. So, we can assign the result of an <literal>if</literal> expression, as shown in this example:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/assigned-if-script.scala

val configFile = new java.io.File("~/.myapprc")

val configFilePath = if (configFile.exists()) {
  configFile.getAbsolutePath()
} else {
  configFile.createNewFile()
  configFile.getAbsolutePath()
}</programlisting>
<para id="para_note_that_if_statements_are_">Note that <literal>if</literal> statements are expressions, meaning they have values. In this example, the value <literal>configFilePath</literal> is the result of an <literal>if</literal> expression that handles the case of a configuration file not existing internally, then returns the absolute path to that file.  This value can now be reused throughout an application, and the <literal>if</literal> expression won’t be re-evaluated when the value is used.</para>
<para id="para_because_if_statements_are_ex">Because <literal>if</literal> statements are expressions in Scala, there is no need for the special-case ternary conditional expressions that exists in C-derived languages. You won’t see <literal>x ? doThis() : doThat()</literal> in Scala. Scala provides a mechanism that’s just as powerful and more readable.</para>
<para id="para_what_if_we_forget_the_els">What if we omit the <literal>else</literal> clause in the previous example? Typing the code in the <userinput>scala</userinput> interpreter will tell us what happens.</para>
<programlisting linenumbering="unnumbered">scala&gt; val configFile = new java.io.File("~/.myapprc")
configFile: java.io.File = ~/.myapprc

scala&gt; val configFilePath = if (configFile.exists()) {
     |   configFile.getAbsolutePath()
     | }
configFilePath: Unit = ()

scala&gt;</programlisting>
<para id="para_note_that_configfilepath_is_">Note that <literal>configFilePath</literal> is now <literal>Unit</literal>. (It was <literal>String</literal> before.) The type inference picks a type that works for all outcomes of the if expression. <literal>Unit</literal> is the only possibility, since no value is one possible outcome.</para>
</sect1>
<sect1 id="ForComprehensions">
<title>Scala for Comprehensions</title>
<para id="para_another_familiar_control_struc">Another familiar control structure that’s particularly feature-rich in Scala is the <literal>for</literal> loop, referred to in the Scala community as a <literal>for</literal> <emphasis>comprehension</emphasis> or <literal>for</literal> <emphasis>expression</emphasis>. This corner of the language deserves at least one fancy name, because it can do some great party tricks.</para>
<para id="para_comprehension_description">Actually, the term <literal>comprehension</literal> comes from functional programming. It expresses the idea that we are traversing a set of some kind, “comprehending” what we find, and computing something new from it.</para>
<sect2 id="_a_dog_simple_example">
<title>A Dog-Simple Example</title>
<para id="para_let_s_start_with_a_basic_for_">Let’s start with a basic <literal>for</literal> expression:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/basic-for-script.scala

val dogBreeds = List("Doberman", "Yorkshire Terrier", "Dachshund",
                     "Scottish Terrier", "Great Dane", "Portuguese Water Dog")

for (breed &lt;- dogBreeds)
  println(breed)</programlisting>
<para id="para_as_you_might_guess_this_code_">As you might guess, this code says “for every element in the List <literal>dogBreeds</literal>, create a temporary variable called <literal>breed</literal> with the value of that element, then print it.” Think of the <literal>&lt;-</literal> operator as an arrow directing elements of a collection, one-by-one, to the scoped variable by which we’ll refer to them inside the <literal>for</literal> expression. The left-arrow operator is called a <emphasis>generator</emphasis>, so named because it’s <emphasis>generating</emphasis> individual values from a collection for use in an expression.</para>
</sect2>
<sect2 id="_filtering">
<title>Filtering</title>
<para id="para_what_if_we_want_to_get_more_gr">What if we want to get more granular? Scala’s <literal>for</literal> expressions allow for <emphasis>filters</emphasis> that let us specify which elements of a collection we want to work with.  So to find all Terriers in our list of dog breeds, we could modify the above example to the following:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/filtered-for-script.scala

for (breed &lt;- dogBreeds
  if breed.contains("Terrier")
) println(breed)</programlisting>
<para id="para_to_add_more_than_one_filter_to">To add more than one filter to a <literal>for</literal> expression, separate the filters with semicolons:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/double-filtered-for-script.scala

for (breed &lt;- dogBreeds
  if breed.contains("Terrier");
  if !breed.startsWith("Yorkshire")
) println(breed)</programlisting>
<para id="para_you_ve_now_found_all_the_terri">You’ve now found all the Terriers that don’t hail from Yorkshire, and hopefully learned just how useful filters can be in the process.</para>
</sect2>
<sect2 id="Yielding">
<title>Yielding</title>
<para id="para_what_if_rather_than_printing_">What if, rather than printing your filtered collection, you needed to hand it off to another part of your program? The <literal>yield</literal> keyword is your ticket to generating new collections with <literal>for</literal> expressions. In the following example, note that we’re wrapping up the <literal>for</literal> expression in curly braces, as we would when defining any block.</para>
<tip id="para_tip_for_expressions_may_be_"><para><literal>for</literal> expressions may be defined with parenthesis or curly braces, but using curly braces means you don’t have to separate your filters with semicolons. Most of the time, you’ll prefer using curly braces when you have more than one filter, assignment, <emphasis>etc.</emphasis></para></tip>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/yielding-for-script.scala

val filteredBreeds = for {
  breed &lt;- dogBreeds
  if breed.contains("Terrier")
  if !breed.startsWith("Yorkshire")
} yield breed</programlisting>
<para id="para_every_time_through_the_for_e">Every time through the <literal>for</literal> expression, the filtered result is yielded as a value named <literal>breed</literal>.  These results accumulate with every run, and the resulting collection is assigned to the value <literal>filteredBreeds</literal> (as we did with <literal>if</literal> statements above). The type of the collection resulting from a <literal>for-yield</literal> expression is inferred from the type of the collection being iterated over. In this case, <literal>filteredBreeds</literal> is of type <literal>List[String]</literal>, since it is a subset of the <literal>dogBreeds</literal> list, which is also of type <literal>List[String]</literal>.</para>
</sect2>
<sect2 id="_expanded_scope">
<title>Expanded Scope</title>
<para id="para_one_final_useful_feature_of_sc">One final useful feature of Scala’s <literal>for</literal> comprehensions is the ability to define variables inside the first part of your <literal>for</literal> expressions that can be used in the latter part.  This is best illustrated with an example:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/scoped-for-script.scala

for {
  breed &lt;- dogBreeds
  upcasedBreed = breed.toUpperCase()
} println(upcasedBreed)</programlisting>
<para id="para_note_that_without_declaring_u">Note that without declaring <literal>upcasedBreed</literal> as a <literal>val</literal> you can reuse it within the body of your <literal>for</literal> expression. This approach is ideal for transforming elements in a collection as you loop through them.</para>
<para id="para_finally_in_optionsandforcom">Finally, in <xref linkend="OptionsAndForComprehensions"/> in <xref linkend="ApplicationDesign"/>, we’ll see how using <literal>Options</literal> with <literal>for</literal> comprehensions can greatly reduce code size by eliminating unnecessary “null” and “missing” checks.</para>
</sect2>
</sect1>
<sect1 id="OtherLoopingConstructs">
<title>Other Looping Constructs</title>
<sect2 id="_scala_while_loops">
<title>Scala while Loops</title>
<para id="para_familiar_in_many_languages_th">Familiar in many languages, the <literal>while</literal> loop executes a block of code as long as a condition is true. For example, the following code prints out a complaint once a day until the next Friday the 13th has arrived:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/while-script.scala
// WARNING: This script runs for a LOOOONG time!

import java.util.Calendar

def isFridayThirteen(cal: Calendar): Boolean = {
  val dayOfWeek = cal.get(Calendar.DAY_OF_WEEK)
  val dayOfMonth = cal.get(Calendar.DAY_OF_MONTH)

  // Scala returns the result of the last expression in a method
  (dayOfWeek == Calendar.FRIDAY) &amp;&amp; (dayOfMonth == 13)
}

while (!isFridayThirteen(Calendar.getInstance())) {
  println("Today isn't Friday the 13th. Lame.")
  // sleep for a day
  Thread.sleep(86400000)
}</programlisting>
<para id="para_you_can_find_a_table_of_the_co">You can find a table of the conditional operators that work in <literal>while</literal> loops below.</para>
</sect2>
<sect2 id="_scala_do_while_loops">
<title>Scala do-while Loops</title>
<para id="para_like_the_while_loop_above_a">Like the <literal>while</literal> loop above, a <literal>do-while</literal> loop executes some code while a conditional expression is true. The only difference that a <literal>do-while</literal> checks to see if the condition is true <emphasis>after</emphasis> running the block. To count up to ten, we could write this:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/do-while-script.scala

var count = 0

do {
  count += 1
  println(count)
} while (count &lt; 10)</programlisting>
<para id="para_as_it_turns_out_there_s_a_mor">As it turns out, there’s a more elegant way to loop through collections in Scala, as we’ll see in the next section.</para>
</sect2>
<sect2 id="GeneratorExpressions">
<title>Generator Expressions</title>
<para id="para_remember_the_arrow_operator_">Remember the arrow operator (<literal>&lt;-</literal>) from the discussion above about <literal>for</literal> loops? We can put it to work here, too. Let’s clean up the <literal>do-while</literal> example above:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/generator-script.scala

for (i &lt;- 1 to 10) println(i)</programlisting>
<para id="para_yup_that_s_all_that_s_necessa">Yup, that’s all that’s necessary. This clean one-liner is possible because Scala’s <literal>RichInt</literal> class defines a <literal>to</literal> method that takes another integer and returns an instance of <literal>Range.Inclusive</literal>. That is, <literal>Inclusive</literal> is a nested class in the <literal>Range</literal> <emphasis>companion object</emphasis> (a concept we introduced briefly in <xref linkend="IntroducingScala"/>, which we will explore in depth in <xref linkend="AdvancedObjectOrientedProgramming"/>). This subclass of the <emphasis>class</emphasis> <literal>Range</literal> inherits a number of methods for working with sequences and iterable data structures, including those necessary to use it in a <literal>for</literal> loop.</para>
<para id="para_by_the_way_if_you_wanted_to_c">By the way, if you wanted to count from 1 up to, but not including 10, you could use <literal>until</literal> instead of <literal>to</literal>, for example <literal>for (i ← 0 until 10)</literal>.</para>
<para id="para_this_should_paint_a_clearer_pi">This should paint a clearer picture of how Scala’s internal libraries compose to form easy-to-use language constructs.</para>
<note id="para_note_when_working_with_loops_"><para>When working with loops in most languages, you can <literal>break</literal> out of a loop or <literal>continue</literal> the iterations. Scala doesn’t have either of these statements, but when writing idiomatic Scala code, they’re not necessary. Use conditional expressions to test if a loop should continue, or make use of recursion. Better yet, filter your collections ahead of time to eliminate complex conditions within your loops.</para></note>
<para id="para_however_because_of_demand_for">However, because of demand for it, Scala version 2.8 includes support for <literal>break</literal>, implemented as a library method, rather than a built-in break keyword.</para>
</sect2>
</sect1>
<sect1 id="_conditional_operators">
<title>Conditional Operators</title>
<para id="para_scala_borrows_most_of_the_cond">Scala borrows most of the conditional operators from Java and its predecessors. You’ll find the following in <literal>if</literal> statements, <literal>while</literal> loops, and everywhere else conditions apply.</para>
<table id="conditional-operators" frame="none" rowsep="1" colsep="1">
<title>Conditional Operators</title>
<tgroup cols="3">
<colspec colwidth="57pt" align="left"/>
<colspec colwidth="57pt" align="left"/>
<colspec colwidth="267pt" align="left"/>
<thead valign="top">
<row>
<entry> Operator </entry>
<entry> Operation </entry>
<entry> Description</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry><para><literal>&amp;&amp;</literal></para></entry>
<entry><para>and</para></entry>
<entry><para>The values on the left and right of the operator are true. The right-hand side is <emphasis>only</emphasis> evaluated if the left-hand side is <emphasis>true</emphasis>.</para></entry>
</row>
<row>
<entry><para><literal>||</literal></para></entry>
<entry><para>or</para></entry>
<entry><para>At least one of the values on the left or right is true. The right-hand side is <emphasis>only</emphasis> evaluated if the left-hand side is <emphasis>false</emphasis>.</para></entry>
</row>
<row>
<entry><para><literal>&gt;</literal></para></entry>
<entry><para>greater than</para></entry>
<entry><para>The value on the left is greater than the value on the right.</para></entry>
</row>
<row>
<entry><para><literal>&lt;</literal></para></entry>
<entry><para>less than</para></entry>
<entry><para>The value on the left is less than the value on the right.</para></entry>
</row>
<row>
<entry><para><literal>==</literal></para></entry>
<entry><para>equals</para></entry>
<entry><para>The value on the left is the same as the value on the right.</para></entry>
</row>
<row>
<entry><para><literal>!=</literal></para></entry>
<entry><para>not equal</para></entry>
<entry><para>The value on the left is not the same as the value on the right.</para></entry>
</row>
</tbody>
</tgroup>
</table>
<para id="para_note_that_and_are_">Note that <literal>&amp;&amp;</literal> and <literal>||</literal> are “short-circuiting” operators. They stop evaluating expressions as soon as the answer is known.</para>
<para id="para_we_ll_discuss_object_equality_">We’ll discuss object equality in more detail in <xref linkend="EqualityOfObjects"/> in <xref linkend="AdvancedObjectOrientedProgramming"/>. For example, we’ll see that <literal>==</literal> has a different meaning in Scala <emphasis>vs.</emphasis> Java. Otherwise, these operators should all be familiar, so let’s move on to something new and exciting.</para>
</sect1>
<sect1 id="PatternMatching">
<title>Pattern Matching</title>
<para id="para_an_idea_borrowed_from_function">An idea borrowed from functional languages, <emphasis>pattern matching</emphasis> is a powerful yet concise way to make a programmatic choice between multiple conditions. Pattern matching is the familiar <literal>case</literal> statement from your favorite C-like language, but on steroids. In the typical <literal>case</literal> statement you’re limited to matching against values of ordinal types, yielding trivial expressions like this: “in the case that <literal>i</literal> is 5, print a message; in the case that <literal>i</literal> is 6, exit the program”. With Scala’s pattern matching, your cases can include types, wild-cards, sequences, and even deep inspections of an object’s variables.</para>
<sect2 id="ASimpleMatch">
<title>A Simple Match</title>
<para id="para_to_begin_with_let_s_simulate_">To begin with, let’s simulate flipping a coin by matching the value of a boolean:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-boolean-script.scala

val bools = List(true, false)

for (bool &lt;- bools) {
  bool match {
    case true =&gt; println("heads")
    case false =&gt; println("tails")
    case _ =&gt; println("something other than heads or tails (yikes!)")
  }
}</programlisting>
<para id="para_it_looks_just_like_a_c_style_">It looks just like a C-style <literal>case</literal> statement, right? The only difference is the last <literal>case</literal> with the underscore ‘_’ wild card. It matches anything not defined in the cases above it, so it serves the same purpose as the <literal>default</literal> keyword in Java and C# <literal>switch</literal> statements.</para>
<para id="para_pattern_matching_is__eager__t">Pattern matching is <emphasis>eager</emphasis>; the first match wins. So, if you try to put a <literal>case _</literal> clause before any other <literal>case</literal> clauses, the compiler will throw an “unreachable code” error on the next clause, because nothing will get past the default clause!</para>
<tip id="para_tip_use_case___for_the_defa"><para>Use <literal>case _</literal> for the default, “catch-all” match.</para></tip>
<para id="para_what_if_we_want_to_work_with_m">What if we want to work with matches as variables?</para>
</sect2>
<sect2 id="VariablesInMatches">
<title>Variables in Matches</title>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-variable-script.scala

import scala.util.Random

val randomInt = new Random().nextInt(10)

randomInt match {
  case 7 =&gt; println("lucky seven!")
  case otherNumber =&gt; println("boo, got boring ol' " + otherNumber)
}</programlisting>
<para id="para_in_this_example_we_assign_the">In this example, we assign the wild card case to a variable called <literal>otherNumber</literal>, then print it in the subsequent expression. If we generate a seven, we’ll extoll that number’s virtues. Otherwise, we’ll curse fate for making us suffer an unlucky number.</para>
</sect2>
<sect2 id="MatchingOnType">
<title>Matching on Type</title>
<para id="para_these_simple_examples_don_t_ev">These simple examples don’t even begin to scratch the surface of Scala’s pattern matching features. Let’s try matching based on type:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-type-script.scala

val sundries = List(23, "Hello", 8.5, 'q')

for (sundry &lt;- sundries) {
  sundry match {
    case i: Int =&gt; println("got an Integer: " + i)
    case s: String =&gt; println("got a String: " + s)
    case f: Double =&gt; println("got a Double: " + f)
    case other =&gt; println("got something else: " + other)
  }
}</programlisting>
<para id="para_here_we_pull_each_element_out_">Here we pull each element out of a <literal>List</literal> of <literal>Any</literal> type of element, in this case containing a <literal>String</literal>, a <literal>Double</literal>, an <literal>Int</literal>, and a <literal>Char</literal>. For the first three of those types, we let the user know specifically which type we got and what the value was. When we get something else (the <literal>Char</literal>), we just let the user know the value. We could add further elements to the list of other types and they’d be caught by the <literal>other</literal> wild card case.</para>
</sect2>
<sect2 id="MatchingOnSequences">
<title>Matching on Sequences</title>
<para id="para_since_working_in_scala_often_m">Since working in Scala often means working with sequences, wouldn’t it be handy to be able to match against the length and contents of lists and arrays? The following example does just that, testing two lists to see if they contain four elements, the second of which is the integer <literal>3</literal>.</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-seq-script.scala

val willWork = List(1, 3, 23, 90)
val willNotWork = List(4, 18, 52)
val empty = List()

for (l &lt;- List(willWork, willNotWork, empty)) {
  l match {
    case List(_, 3, _, _) =&gt; println("Four elements, with the 2nd being '3'.")
    case List(_*) =&gt; println("Any other list with 0 or more elements.")
  }
}</programlisting>
<para id="para_in_the_second_case_of_we_ve_">In the second <literal>case</literal> of we’ve used a special wild card pattern to match a <literal>List</literal> of any size, even zero elements, and any element values. You can use this pattern at the end of any sequence match to remove length as a condition.</para>
<para id="para_recall_that_we_mentioned_the_">Recall that we mentioned the “cons” method for List, <literal>::</literal>. The expression <literal>a :: list</literal> prepends <literal>a</literal> to a list. You can also use this operator to extract the head and tail of a list.</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-list-script.scala

val willWork = List(1, 3, 23, 90)
val willNotWork = List(4, 18, 52)
val empty = List()

def processList(l: List[Any]): Unit = l match {
  case head :: tail =&gt;
    format("%s ", head)
    processList(tail)
  case Nil =&gt; println("")
}

for (l &lt;- List(willWork, willNotWork, empty)) {
  print("List: ")
  processList(l)
}</programlisting>
<para id="para_the_processlist_method_match">The <literal>processList</literal> method matches on the <literal>List</literal> argument l. It may look strange to start the method definition like the following.</para>
<programlisting linenumbering="unnumbered">def processList(l: List[Any]): Unit = l match {
  ...
}</programlisting>
<para id="para_hopefully_hiding_the_details_w">Hopefully hiding the details with the ellipsis makes the meaning a little clearer. The <literal>processList</literal> method is actually one statement that crosses several lines.</para>
<para id="para_it_first_matches_on_head_05">It first matches on <literal>head :: tail</literal>, where <literal>head</literal> will be assigned the first element in the list and <literal>tail</literal> will be assigned the rest of the list. That is, we’re extracting the head and tail from the list using. When this case matches, it prints the <literal>head</literal> and calls <literal>processList</literal> recursively to process the tail.</para>
<para id="para_the_second_case_matches_the_em">The second case matches the empty list, <literal>Nil</literal>. It does is print an end of line and terminates the recursion.</para>
</sect2>
<sect2 id="MatchingOnTuples">
<title>Matching on Tuples (and Guards)</title>
<para id="para_alternately_if_we_just_wanted">Alternately, if we just wanted to test that we have a tuple of two items, we could do a tuple match:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-tuple-script.scala

val tupA = ("Good", "Morning!")
val tupB = ("Guten", "Tag!")

for (tup &lt;- List(tupA, tupB)) {
  tup match {
    case (thingOne, thingTwo) if thingOne == "Good" =&gt;
        println("A two-tuple starting with 'Good'.")
    case (thingOne, thingTwo) =&gt;
        println("This has two things: " + thingOne + " and " + thingTwo)
  }
}</programlisting>
<para id="para_in_the_second_case_in_this_e">In the second <literal>case</literal> in this example, we’ve extracted the values inside the tuple to scoped variables, then reused these variables in the resulting expression.</para>
<para id="para_in_the_first_case_we_ve_added_">In the first case we’ve added a new concept: <emphasis>guards</emphasis>. The <literal>if</literal> condition after the tuple is a guard. The guard is evaluated when matching, but only extracting any variables in the preceding part of the case. Guards provide additional granularity when constructing cases. In this example, the only difference between the two patterns is the guard expression, but that’s enough for the compiler to differentiate them.</para>
<tip id="para_tip_the_cases_in_a_pattern_ma"><para>Recall that the cases in a pattern match are evaluated in order. If your first case is broader than your second case, the second case will never be evaluated. Always construct pattern matches with the most general cases at the bottom. You may include a catch-all case at the end of a series of cases, either via the underscore wild card character or a meaningfully-named variable. It must be last, as it will match before any other case statements, causing a compiler error when any cases are unreachable.</para></tip>
</sect2>
<sect2 id="MatchingOnCaseClasses">
<title>Matching on Case Classes</title>
<para id="para_finally_let_s_try_a__deep_mat">Let’s try a <emphasis>deep match</emphasis>, examining the contents of objects in our pattern match.</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-deep-script.scala

case class Person(name: String, age: Int)

val alice = new Person("Alice", 25)
val bob = new Person("Bob", 32)
val charlie = new Person("Charlie", 32)

for (person &lt;- List(alice, bob, charlie)) {
  person match {
    case Person("Alice", 25) =&gt; println("Hi Alice!")
    case Person("Bob", 32) =&gt; println("Hi Bob!")
    case Person(name, age) =&gt;
      println("Who are you, " + age + " year-old person named " + name + "?")
  }
}</programlisting>
<para id="para_poor_charlie_gets_the_cold_sho">Poor Charlie gets the cold shoulder, as we can see in the output for the above example:</para>
<screen>Hi Alice!
Hi Bob!
Who are you, 32 year-old person named Charlie?</screen>
<para id="para_we_first_define_a__case_class_">We first define a <emphasis>case class</emphasis>, a special type of class that we’ll learn more about in <xref linkend="CaseClasses"/> in <xref linkend="AdvancedObjectOrientedProgramming"/>. For now, it will suffice to say that a case class allows for very terse construction of simple objects with some pre-defined methods. Our pattern match then looks for Alice and Bob by inspecting the values passed to the constructor of the <literal>Person</literal> case class. Charlie falls through to the catch-all case; even though he has the same <literal>age</literal> value as Bob, we’re matching on the <literal>name</literal> property as well.</para>
<para id="para_this_type_pattern_match_become">This type of pattern match becomes extremely useful when working with Actors, as we’ll see later on. Case classes are frequently sent to Actors as messages, and deep pattern matching on an object’s contents is an convenient way to “parse” those messages.</para>
</sect2>
<sect2 id="MatchingOnRegularExpressions">
<title>Matching on Regular Expressions</title>
<para id="para_regular_expressions_are_conven">Regular expressions are convenient for extracting data from strings that have an informal structure, but are not “structured data” (that is, in a format like XML or JSON, for example). Commonly referred to as <emphasis>regexes</emphasis>, regular expressions are a feature of nearly all modern programming languages. They provide a terse syntax for specifying complex matches, one which is typically translated into a state machine behind the scenes for optimum performance.</para>
<para id="para_regexes_in_scala_should_contai">Regexes in Scala should contain no surprises if you’ve used them in other programming languages. Let’s see an example.</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-regex-script.scala

val BookExtractorRE = """Book: title=([^,]+),\s+authors=(.+)""".r
val MagazineExtractorRE = """Magazine: title=([^,]+),\s+issue=(.+)""".r

val catalog = List(
  "Book: title=Programming Scala, authors=Dean Wampler, Alex Payne",
  "Magazine: title=The New Yorker, issue=January 2009",
  "Book: title=War and Peace, authors=Leo Tolstoy",
  "Magazine: title=The Atlantic, issue=February 2009",
  "BadData: text=Who put this here??"
)

for (item &lt;- catalog) {
  item match {
    case BookExtractorRE(title, authors) =&gt;
      println("Book \"" + title + "\", written by " + authors)
    case MagazineExtractorRE(title, issue) =&gt;
      println("Magazine \"" + title + "\", issue " + issue)
    case entry =&gt; println("Unrecognized entry: " + entry)
  }
}</programlisting>
<para id="para_this_example_starts_with_two_r">We start with two regular expressions, one for records of books and another for records of magazines. Calling <literal>.r</literal> on a string turns it into a regular expression; we use raw (triple-quoted) strings here to avoid having to double-escape backslashes. Should you find the <literal>.r</literal> transformation method on strings unclear, you can also define regexes by creating new instances of the <literal>Regex</literal> class, as in: <literal>new Regex("""\W""")</literal>.</para>
<para id="para_notice_that_each_of_our_regexe">Notice that each of our regexes defines two <emphasis>capture groups</emphasis>, connoted by parentheses. Each group captures the value of a single field in the record, such as a book’s title or author. Regexes in Scala translate those capture groups to <emphasis>extractors</emphasis>. Every match sets a field to the captured result; every miss is set to <literal>null</literal>.</para>
<para id="para_the_case_clauses_look_similar_">What does this mean in practice? If the text fed to the regular expression matches, <literal>case BookExtractorRE(title, authors)</literal> will assign the first capture group to <literal>title</literal> and the second to <literal>authors</literal>. We can then use those values on the right-hand side of the <literal>case</literal> clause, as we have in the above example. The variable names <literal>title</literal> and <literal>author</literal> within the extractor are arbitrary; matches from capture groups are simply assigned from left to right, and you can call them whatever you’d like.</para>
<para id="para_that_s_regexes_in_scala_in_nut">That’s regexes in Scala in nutshell. The <literal>scala.util.matching.Regex</literal> class supplies several handy methods for finding and replacing matches in strings, both all occurrences of a match and just the first occurrence, so be sure to make use of them.</para>
<para id="para_we_won_t_cover_the_details_of_">What we won’t cover in this section is the details of writing regular expressions. Scala’s <literal>Regex</literal> class uses the underlying platform’s regular expression APIs (that is, Java’s or .NET’s). Consult references on those APIs for the hairy details, as they may be subtly different than the regex support in your language of choice.</para>
</sect2>
<sect2 id="BindingNestedVariablesInCaseClauses">
<title>Binding Nested Variables in Case Clauses</title>
<para id="para_finally_lets_bind_inner_variables">Sometimes you want to bind a variable to an object enclosed in a match, where you are also specifying match criteria on the nested object. Suppose we modify the previous example so we’re matching on the key-value pairs from a map. We’ll store our same <literal>Person</literal> objects as the values and use an employee id as the key. We’ll also add another attribute to <literal>Person</literal>, a <literal>role</literal> field that points to an instance from a type hierarchy.</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/match-deep-pair-script.scala

class Role
case object Manager extends Role
case object Developer extends Role

case class Person(name: String, age: Int, role: Role)

val alice = new Person("Alice", 25, Developer)
val bob = new Person("Bob", 32, Manager)
val charlie = new Person("Charlie", 32, Developer)

for (item &lt;- Map(1 -&gt; alice, 2 -&gt; bob, 3 -&gt; charlie)) {
  item match {
    case (id, p @ Person(_, _, Manager)) =&gt; format("%s is overpaid.\n", p)
    case (id, p @ Person(_, _, _)) =&gt; format("%s is underpaid.\n", p)
  }
}</programlisting>
<para id="para_the_case_objects_are_just_si">The <literal>case objects</literal> are just singleton objects like we’ve seen before, but with the special <literal>case</literal> behavior. We’re most interested in the embedded <literal>p @ Person(…)</literal> inside the case clause. We’re matching on particular kinds of <literal>Person</literal> objects inside the enclosing tuple. We also want to assign the <literal>Person</literal> to a variable p, so we can use it for printing.</para>
<screen>Person(Alice,25,Developer) is underpaid.
Person(Bob,32,Manager) is overpaid.
Person(Charlie,32,Developer) is underpaid.</screen>
<para id="para_if_we_weren_t_using_matching_c">If we weren’t using matching criteria in <literal>Person</literal> itself, we could just write <literal>p: Person</literal>. For example, the previous <literal>match</literal> clause could be written this way.</para>
<programlisting linenumbering="unnumbered">item match {
  case (id, p: Person) =&gt; p.role match {
    case Manager =&gt; format("%s is overpaid.\n", p)
    case _ =&gt; format("%s is underpaid.\n", p)
  }
}</programlisting>
<para id="para_note_that_the_p_person_">Note that the <literal>p @ Person(…)</literal> syntax gives us a way to flatten this nesting of match statements into one statement. It is analogous to using “capture groups” in a regular expression to pull out substrings we want, instead of splitting the string in several successive steps to extract the substrings we want. Use whichever technique you prefer.</para>
</sect2>
<sect2 id="TryCatchFinally">
<title>Using try, catch, and finally Clauses</title>
<para id="para_through_its_use_of_functional_">Through its use of functional constructs and strong typing, Scala encourages a coding style that lessens the need for exceptions and exception handling. But where Scala interacts with Java, exceptions are still prevalent.</para>
<note id="para_note_scala_does_not_have_chec"><para>Scala does not have checked exceptions, like Java. Even Java’s checked exceptions are treated as unchecked by Scala. There is also no <literal>throws</literal> clause on method declarations. However, there is a <literal>@throws</literal> annotation that is useful for Java interoperability. See <xref linkend="Annotations"/> in <xref linkend="ApplicationDesign"/>.</para></note>
<para id="para_thankfully_scala_treats_excep">Thankfully, Scala treats exception handling as just another pattern match, allowing us to make smart choices when presented with a multiplicity of potential exceptions. Let’s see this in action:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/try-catch-script.scala

import java.util.Calendar

val then = null
val now = Calendar.getInstance()

try {
  now.compareTo(then)
} catch {
  case e: NullPointerException =&gt; println("One was null!"); System.exit(-1)
  case unknown =&gt; println("Unknown exception " + unknown); System.exit(-1)
} finally {
  println("It all worked out.")
  System.exit(0)
}</programlisting>
<para id="para_in_the_above_example_we_expli">In the above example, we explicitly catch the <literal>NullPointerException</literal> thrown when trying to compare a <literal>Calendar</literal> instance with <literal>null</literal>. We also define <literal>unknown</literal> as a catch-all case, just to be safe. If we weren’t hard-coding this program to fail, the <literal>finally</literal> block would be reached and the user would be informed that everything worked out just fine.</para>
<note id="para_note_you_can_use_an_underscor"><para>You can use an underscore (Scala’s standard wild card character) as a placeholder to catch any type of exception (really, to match any case in a pattern matching expression). However, you won’t be able to refer to the exception in the subsequent expression. Name the exception variable if you need it, for example, if you need to print the exception as we do in the catch-all case of the previous example. <literal>e</literal> or <literal>ex</literal> are fine names.</para></note>
<para id="para_pattern_matching_aside_scala_">Pattern matching aside, Scala’s treatment of exception handling should be familiar to those fluent in Java, Ruby, Python, and most other mainstream languages. And yes, you throw an exception by writing <literal>throw new MyBadException(…)</literal>. That’s all there is to it.</para>
</sect2>
<sect2 id="ConcludingRemarksOnPatternMatching">
<title>Concluding Remarks on Pattern Matching</title>
<para id="para_pattern_matching_is_a_powerful">Pattern matching is a powerful and elegant way of extracting information from objects, when used appropriately. Recall from <xref linkend="IntroducingScala"/> that we highlighted the synergy between pattern matching and polymorphism. Most of the time, you want to avoid the problems of “switch” statements that know a class hierarchy, because they have to be modified every time the hierarchy is changed.</para>
<para id="para_in_our_drawing_actor_example_">In our drawing actor example, we used pattern matching to separate different “categories” of messages, but we used polymorphism to draw the shapes sent to it. We could change the <literal>Shape</literal> hierarchy and the actor code would not require changes.</para>
<para id="para_pattern_matching_is_also_usefu">Pattern matching is also useful for the design problem where you need to get at data inside an object, but only in special circumstances. One of the unintended consequences of the <emphasis>JavaBeans</emphasis> <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link> specification was it encouraged people to expose fields in their objects through getters and setters. This should <emphasis>never</emphasis> be a default decision. Access to “state information” should be encapsulated and exposed only in ways that make logical sense for the type, as viewed from the abstraction it exposes.</para>
<para id="para_instead_consider_using_patter">Instead, consider using pattern matching for those “rare” times when you need to extract information in a controlled way. An <literal>unapply</literal> method can hide the implementation details of the objects it is decomposing. In fact, the information returned by <literal>unapply</literal> might be a transformation of the actual information in the type.</para>
<para id="para_note_be_wary_of_relying_on_a_">Finally, when designing pattern matching statements, be wary of relying on a default case clause. Under what circumstances would “none of the above” be the correct answer? It may indicate that the design should be refined so you know more precisely all the possible matches that might occur. We’ll learn one technique that helps when we discuss <emphasis>sealed</emphasis> class hierarchies in <xref linkend="SealedClassHierarchies"/> in <xref linkend="ScalaObjectSystem"/>.</para>
</sect2>
</sect1>
<sect1 id="Enumerations">
<title>Enumerations</title>
<para id="para_remember_our_examples_above_in">Remember our examples above involving various breeds of dog? In thinking about the types in these programs, we might want a top-level <literal>Breed</literal> type that keeps track of a number of breeds. Such a type is called an <emphasis>enumerated type</emphasis>, and the values it contains are called <emphasis>enumerations</emphasis>.</para>
<para id="para_while_enumerations_are_a_built">While enumerations are a built-in part of many programming languages, Scala takes a different route and implements them as a class in its standard library. This means there is no special syntax for enumerations in Scala, as in Java and C#. Instead, you just define an object that extends the <literal>Enumeration</literal> class. Hence, at the byte code level, there is no connection between Scala enumerations and the <literal>enum</literal> constructs in Java and C#.</para>
<para id="para_enumeration_example">Here is in example:</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/enumeration-script.scala

object Breed extends Enumeration {
  val doberman = Value("Doberman Pinscher")
  val yorkie = Value("Yorkshire Terrier")
  val scottie = Value("Scottish Terrier")
  val dane = Value("Great Dane")
  val portie = Value("Portuguese Water Dog")
}

// print a list of breeds and their IDs
println("ID\tBreed")
for (breed &lt;- Breed) println(breed.id + "\t" + breed)

// print a list of Terrier breeds
println("\nJust Terriers:")
Breed.filter(_.toString.endsWith("Terrier")).foreach(println)</programlisting>
<para id="para_when_run_you_ll_get_the_follo">When run, you’ll get the following output:</para>
<screen>ID      Breed
0       Doberman Pinscher
1       Yorkshire Terrier
2       Scottish Terrier
3       Great Dane
4       Portuguese Water Dog

Just Terriers:
Yorkshire Terrier
Scottish Terrier</screen>
<para id="para_we_can_see_in_the_source_that_">We can see that our <literal>Breed</literal> enumerated type contains several variables of type <literal>Value</literal>, as in the following example.</para>
<screen>val doberman = Value("Doberman Pinscher")</screen>
<para id="para_value_method_with_name_arg_for_enumerations">Each declaration is actually calling a method named <literal>Value</literal> that takes a string argument. We use this method to assign a long-form breed name to each enumeration value, which is what the <literal>Value.toString</literal> method returned in the output above.</para>
<para id="para_value_methods_for_enumerations">Note that there is no name space collision between the type and method that both have the name <literal>Value</literal>. There are other overloaded versions of the <literal>Value</literal> method. One of them takes no arguments, another one takes an <literal>Int</literal> id value, and another one takes both an <literal>Int</literal> and <literal>String</literal>. These <literal>Value</literal> methods return a <literal>Value</literal> object and they add the value to the enumeration’s collection of values.</para>
<para id="para_since_scala_s_enumeration_cl">In fact, Scala’s <literal>Enumeration</literal> class supports the usual methods for working with collections, so we can easily iterate through the breeds with a <literal>for</literal> loop and <literal>filter</literal> them by name. The output above also demonstrated that every <literal>Value</literal> in an enumeration is automatically assigned a numeric identifier, unless you call one of the <literal>Value</literal> methods where you specify your own id value explicitly.</para>
<para id="para_enumeration_no_name_values">You’ll often want to give your enumeration values human readable names, as we did here. However, sometimes you may not need them. Here’s another enumeration example adapted from the <emphasis>scaladoc</emphasis> entry for <literal>Enumeration</literal>.</para>
<programlisting linenumbering="unnumbered">// code-examples/Rounding/days-enumeration-script.scala

object WeekDay extends Enumeration {
  type WeekDay = Value
  val Mon, Tue, Wed, Thu, Fri, Sat, Sun = Value
}
import WeekDay._

def isWorkingDay(d: WeekDay) = ! (d == Sat || d == Sun)

WeekDay filter isWorkingDay foreach println</programlisting>
<para id="para_days_enumeration_scala_output">Running this script with <userinput>scala</userinput> yields the following output.</para>
<screen>Main$$anon$1$WeekDay(0)
Main$$anon$1$WeekDay(1)
Main$$anon$1$WeekDay(2)
Main$$anon$1$WeekDay(3)
Main$$anon$1$WeekDay(4)</screen>
<para id="para_enumeration_no_name_tostring">When a name isn’t assigned using one of the <literal>Value</literal> methods that takes a <literal>String</literal> argument, <literal>Value.toString</literal> prints the name of the type that is synthesized by the compiler, along with the id value that was generated automatically.</para>
<para id="para_note_that_we_imported_weekday">Note that we imported <literal>WeekDay._</literal>. This made each enumeration value, <emphasis>e.g.,</emphasis> <literal>Mon</literal>, <literal>Tues</literal>, <emphasis>etc.</emphasis> in scope. Otherwise, you would have to write <literal>WeekDay.Mon</literal>, <literal>WeekDay.Tues</literal>, <emphasis>etc.</emphasis></para>
<para id="para_also_the_import_made_the__typ">Also, the import made the <emphasis>type alias</emphasis>, <literal>type Weekday = Value</literal> in scope, which we used as the type for the argument for the <literal>isWorkingDay</literal> method. If you don’t define a type alias like this, then you would declare the method as <literal>def isWorkingDay(d: WeekDay.Value)</literal>.</para>
<para id="para_enumerations_vs_objects_with_vals">Since Scala enumerations are just regular objects, you could use any object with <literal>vals</literal> to indicate different “enumeration values”. However, extending <literal>Enumeration</literal> has several advantages. It automatically manages the values as a collection that you can iterate over, <emphasis>etc.</emphasis>, as in our examples. It also automatically assigns unique integer ids to each value.</para>
<para id="para_we_ll_revisit_enumerations_in_">Case classes (see <xref linkend="CaseClasses"/> in <xref linkend="AdvancedObjectOrientedProgramming"/> are often used instead of enumerations in Scala, because the “use case” for them often involves pattern matching. We’ll  revisit this topic in <xref linkend="EnumerationsVsPatternMatching"/> in <xref linkend="ApplicationDesign"/>.</para>
</sect1>
<sect1 id="_recap_and_what_8217_s_next_3">
<title>Recap and What’s Next</title>
<para id="para_we_ve_covered_a_lot_of_ground_">We’ve covered a lot of ground in this chapter. We learned how flexible Scala’s syntax can be, and how it facilitates the creation of Domain-Specific Languages. Then we explored Scala’s enhancements to looping constructs and conditional expressions. We experimented with different uses for pattern matching, a powerful improvement on the familiar <literal>case-switch</literal> statement. Finally, we learned how to encapsulate values in enumerations.</para>
<para id="para_you_should_now_be_prepared_to_">You should now be prepared to read a fair bit of Scala code, but there’s plenty more about the language to put in your tool belt. In the next two chapters, we’ll explore Scala’s approach to object-oriented programming.</para>
</sect1>
</chapter>
