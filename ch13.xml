<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="ApplicationDesign">
  <title>Application Design</title>

  <para id="para_in_this_chapter_we_take_a_pra">In this chapter, we take a
  pragmatic look at developing applications in Scala. We discuss a few
  language and API features that we haven’t covered before, examine common
  design patterns and idioms, and revisit <emphasis>traits</emphasis> with an
  eye toward structuring our code effectively.<indexterm class="startofrange"
      id="ch13_appdesign">
      <primary>application design</primary>
    </indexterm></para>

  <sect1 id="Annotations">
    <title>Annotations</title>

    <para id="para_like_java_and_net_scala_supp">Like Java and .NET, Scala
    supports <emphasis>annotations</emphasis> for adding
    <emphasis>metadata</emphasis> to declarations. Annotations are used by a
    variety of tools in typical enterprise and Internet applications. For
    example, there are annotations that provide directives to the compiler,
    and some Object-Relational Mapping (ORM) frameworks use annotations on
    types and type members to indicate persistence mapping information. While
    some uses for annotations in the Java and .NET worlds can be accomplished
    through other means in Scala, annotations can be essential for
    interoperating with Java and .NET libraries that rely heavily on them.
    Fortunately, Java and .NET annotations can be used in Scala
    code.<indexterm class="startofrange" id="ch13_declarationsannotations">
        <primary>declarations</primary>

        <secondary>annotations in</secondary>
      </indexterm><indexterm class="startofrange"
        id="ch13_appdesignannotations">
        <primary>application design</primary>

        <secondary>annotations</secondary>
      </indexterm><indexterm>
        <primary>metadata</primary>

        <secondary>adding to declarations</secondary>
      </indexterm><indexterm class="startofrange" id="ch13_annotations">
        <primary>annotations</primary>
      </indexterm></para>

    <para id="para_the_interpretation_of_scala_an">The interpretation of Scala
    annotations depends on the runtime environment. In this section, we will
    focus on the JDK environment.</para>

    <para id="para_in_java_annotations_are_decla">In Java, annotations are
    declared using special conventions, e.g., declaring annotations with the
    <literal>@interface</literal> keyword instead of the
    <literal>class</literal> or <literal>interface</literal> keyword. Here is
    the declaration of an annotation taken from a toolkit called Contract4J
    (see <link linkend="Contract4J"
    xrefstyle="select:nopage">[Contract4J]</link>) that uses annotations to
    support <emphasis>Design by Contract</emphasis> programming in Java (see
    also <xref linkend="DesignByContractExample" />). Some of the comments
    have been removed for clarity:<indexterm>
        <primary sortas="interface keyword">@interface keyword
        (Java)</primary>
      </indexterm><indexterm>
        <primary>Java</primary>

        <secondary>annotations</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/Pre.java

package org.contract4j5.contract;
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
public @interface Pre {
  /**
   * The "value" is the test expression, which must evaluate to true or false.
   * It must be a valid expression in the scripting language you are using.
   */
  String value() default "";

  /**
   * An optional message to print with the standard message when the contract
   * fails.
   */
  String message() default "";
}</programlisting>

    <para id="para_the_pre_annotation_is_used_">The <literal>@Pre</literal>
    annotation is used to specify “preconditions” that must be satisfied when
    <emphasis>entering</emphasis> a method or constructor, or
    <emphasis>before</emphasis> using a parameter passed to a method or
    constructor. The conditions are specified as a string that is actually a
    snippet of source code that evaluates to <literal>true</literal> or
    <literal>false</literal>. The source <emphasis>languages</emphasis>
    supported for these snippets are scripting languages like Groovy and
    JRuby. The name of the variable for this string, <literal>value</literal>,
    is a conventional name for the most important field in the
    annotation.<indexterm>
        <primary>metadata</primary>

        <seealso>annotations</seealso>
      </indexterm><indexterm>
        <primary sortas="Pre annotation">@Pre annotation</primary>
      </indexterm></para>

    <para id="para_the_other_field_is_an_optional">The other field is an
    optional <literal>message</literal> to use when reporting failures.</para>

    <para id="para_the_declaration_has_other_anno">The declaration has other
    annotations applied to it—for example, the <literal>@Retention</literal>
    annotation with the value <literal>RetentionPolicy.RUNTIME</literal> means
    that when <literal>@Pre</literal> is used, its information will be
    retained in the class file for runtime use.<indexterm>
        <primary sortas="Retention annotation">@Retention annotation</primary>
      </indexterm></para>

    <para id="para_here_is_a_scala_example_that_u">Here is a Scala example
    that uses <literal>@Pre</literal> and shows several ways to specify the
    <literal>value</literal> and <literal>message</literal> parameters:</para>

    <screen>// code-examples/AppDesign/annotations/pre-example.scala

import org.contract4j5.contract._

class Person(
  @Pre( "name != null &amp;&amp; name.length() &gt; 0" )
  val name: String,
  @Pre{ val value = "age &gt; 0", val message = "You're too young!" }
  val age: Int,
  @Pre( "ssn != null" )
  val ssn: SSN)

class SSN(
  @Pre( "valid(ssn)" ) { val message = "Format must be NNN-NN-NNNN." }
  val ssn: String) {

  private def valid(value: String) =
    value.matches("""^\s*\d{3}-\d{2}-\d{4}\s*$""")
}</screen>

    <para id="para_in_the_person_class_the_p">In the <literal>Person</literal>
    class, the <literal>@Pre</literal> annotation on <literal>name</literal>
    has a simple string argument: the “precondition” that users must satisfy
    when passing in a name. This value can’t be <literal>null</literal>, and
    it can’t be of zero length. As in Java, if a single argument is given to
    the annotation, it is assigned to the <literal>value</literal>
    field.</para>

    <para id="para_a_similar_pre_annotation_is">A similar
    <literal>@Pre</literal> annotation is used for the third argument, the
    <literal>ssn</literal> (Social Security number). In both cases, the
    <literal>message</literal> defaults to the empty string specified in the
    definition of <literal>Pre</literal>.</para>

    <para id="para_the_pre_annotation_for_the_">The <literal>@Pre</literal>
    annotation for the age shows one way to specify values for more than one
    field. Instead of parentheses, curly braces are used. The syntax for each
    field looks like a <literal>val</literal> declaration, without any type
    information, since the types can always be inferred! This syntax allows
    you to use the shorthand syntax for the <literal>value</literal> and still
    specify values for other fields.</para>

    <note id="para_note_if_person_were_a_java_">
      <para>If <literal>Person</literal> were a Java class, this annotation
      expression would look identical, except there would be no
      <literal>val</literal> keywords and parentheses would be used.</para>
    </note>

    <para id="para_the_pre_annotation_on_the_c">The <literal>@Pre</literal>
    annotation on the constructor parameter for the <literal>SSN</literal>
    class shows the alterna<phrase role="keep-together">tive syntax</phrase>
    for specifying values for more than one field. The
    <literal>value</literal> field is specified as before with a one-element
    parameter list. The <literal>message</literal> is initialized in a
    follow-on block in curly braces.</para>

    <para id="para_testing_this_code_would_requir">Testing this code would
    require the <emphasis>Contract4J</emphasis> library, build setup, etc. We
    won’t cover those steps here. Refer to <link linkend="Contract4J"
    xrefstyle="select:nopage">[Contract4J]</link> for more information.</para>

    <para id="para_scala_annotations_don_t_use_a_">Scala annotations don’t use
    a special declaration syntax. They are declared as normal classes. This
    approach eliminates a “special case” in the language, but it also means
    that some of the features provided by Java annotations aren’t supported,
    as we will see. Here is an example annotation from the Scala library,
    <literal>SerialVersionUID</literal> (again with the comments removed for
    clarity):</para>

    <programlisting linenumbering="unnumbered">package scala

class SerialVersionUID(uid: Long) extends StaticAnnotation</programlisting>

    <para id="para_the_serialversionuid_annota">The
    <literal>@SerialVersionUID</literal> annotation is applied to a class to
    define a globally unique ID as a <literal>Long</literal>. When the
    annotation is used, the ID is specified as a constructor argument. This
    annotation serves the same purpose as a <literal>static</literal> field
    named <literal>serialVersionUID</literal> in a Java class. This is one
    example of a Scala annotation that maps to a “non-annotation” construct in
    Java.<indexterm>
        <primary sortas="serialVersionUID">@serialVersionUID
        annotation</primary>
      </indexterm></para>

    <para id="para_the_parent_of_serialversionui">The parent of
    <literal>SerialVersionUID</literal> is the trait
    <literal>scala.StaticAnnotation</literal>, which is used as the parent for
    all annotations that should be visible to the type checker, even across
    compilation units. The parent class of
    <literal>scala.StaticAnnotation</literal> is
    <literal>scala.Annotation</literal>, which is the parent of all Scala
    annotations.<indexterm>
        <primary>Annotation class</primary>
      </indexterm><indexterm>
        <primary>StaticAnnotation class</primary>
      </indexterm></para>

    <para id="para_did_you_notice_that_there_is_n">Did you notice that there
    is no <literal>val</literal> on <literal>uid</literal>? Why isn’t
    <literal>uid</literal> a field? The reason is that the annotation’s data
    is not intended for use by the program. Recall that it is metadata
    designed for external tools to use, such as <literal>scalac</literal>.
    This also means that Scala annotations have no way to define default
    values in version 2.7.X, as implicit arguments don’t work. However, the
    new default arguments feature in version 2.8.0 may work. (It is not yet
    implemented at the time of this writing.)<indexterm>
        <primary>metadata</primary>

        <secondary>default values and</secondary>
      </indexterm></para>

    <para id="para_like_java_and_net_annotatio">Like Java (and .NET)
    annotations, a Scala annotation clause applies to the definition it
    precedes. You can have as many annotation clauses as you want, and the
    order in which they appear is not significant.</para>

    <para id="para_like_java_annotations_scala_a">Like Java annotations, Scala
    annotation clauses are written using the syntax <literal
    role="keep-together">@MyAnnotation</literal> if the annotation constructor
    takes no parameters, or <literal>@MyAnnotation(arg1, .., argN)</literal>
    if the constructor takes parameters. The annotation must be a subclass of
    <literal>scala.Annotation</literal>.</para>

    <para id="para_all_the_constructor_parameters">All the constructor
    parameters must be constant expressions, including strings, class
    literals, Java enumerations, numerical expressions and one-dimensional
    arrays of the same. However, the compiler also allows annotation clauses
    with other arguments, such as boolean values and maps, as shown in this
    example:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/anno-example.scala

import scala.StaticAnnotation

class Persist(tableName: String, params: Map[String,Any])
  extends StaticAnnotation

// Doesn't compile:
//@Persist("ACCOUNTS", Map("dbms" -&gt; "MySql", "writeAutomatically" -&gt; true))
@Persist("ACCOUNTS", Map(("dbms", "MySql"), ("writeAutomatically", true)))
class Account(val balance: Double)</programlisting>

    <para id="para_curiously_if_you_attempt_to_u">Curiously, if you attempt to
    use the standard <literal>Map</literal> literal syntax that is shown in
    the comments, you get a compilation error that the
    <literal>-&gt;</literal> method doesn’t exist for
    <literal>String</literal>. The implicit conversion to
    <literal>ArrowAssoc</literal> that we discussed in <xref
    linkend="PredefObject" /> isn’t invoked. Instead, you have to use a list
    of <literal>Tuples</literal>, which <literal>Map.apply</literal> actually
    expects.<indexterm>
        <primary>ClassfileAnnotation class</primary>
      </indexterm></para>

    <para id="para_another_child_of_scala_annota">Another child of
    <literal>scala.Annotation</literal> that is intended to be a parent of
    other annotations is the trait
    <literal>scala.ClassfileAnnotation</literal>. It is supposed to be used
    for annotations that should have runtime retention, i.e., the annotations
    should be visible in the class file so they are available at runtime.
    However, actually using it with the JDK version of Scala results in
    compiler errors like the following:</para>

    <screen>...: warning: implementation restriction: subclassing Classfile does not
make your annotation visible at runtime.  If that is what
you want, you must write the annotation class in Java.
...</screen>

    <para id="para_hence_if_you_want_runtime_vis">Hence, if you want runtime
    visibility, you have to implement the annotation in Java. This works fine,
    since you can use any Java annotation in Scala code. The Scala library
    currently defines no annotations derived from
    <literal>ClassfileAnnotation</literal>, perhaps for obvious
    reasons.</para>

    <warning id="para_warning_avoid_classfileannot">
      <para>Avoid <literal>ClassfileAnnotation</literal>. Implement
      annotations that require runtime retention in Java instead.</para>
    </warning>

    <para id="para_for_scala_version_2_7_x_anoth">For Scala version 2.7.X,
    another important limitation to keep in mind is that annotations can’t be
    nested. This causes problems when using JPA annotations in Scala code, for
    example, as discussed in <link linkend="JPAScala"
    xrefstyle="select:nopage">[JPAScala]</link>. However, Scala version 2.8
    removes this <phrase role="keep-together">limitation</phrase>.<indexterm>
        <primary>annotations</primary>

        <secondary>nesting</secondary>
      </indexterm></para>

    <warning id="para_warning_annotations_can_only_">
      <para>Annotations can only be nested in Scala version 2.8.</para>
    </warning>

    <para id="para_the_following_tables_describe_">Tables <xref
    linkend="scala-annotations" xrefstyle="select: labelnumber" /> and <xref
    linkend="scala-static-annotations" xrefstyle="select: labelnumber" />
    describe all the annotations defined in the Scala library (adapted and
    expanded from <ulink url="http://www.scala-lang.org/node/106"></ulink>).
    We start with the direct children of <literal>Annotation</literal>,
    followed by the children of <literal>StaticAnnotation</literal>.<indexterm>
        <primary>Annotation class</primary>

        <secondary>Scala annotations derived from</secondary>
      </indexterm><indexterm>
        <primary>annotations</primary>

        <secondary>Scala annotations derived from Annotation</secondary>
      </indexterm></para>

    <table id="scala-annotations">
      <title>Scala annotations derived from Annotation</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry>Java equivalent</entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal
            role="keep-together">ClassfileAnnotation</literal></para></entry>

            <entry><para>Annotate with <literal>@Retention<?lb ?>(RetentionPolicy.RUNTIME)</literal></para></entry>

            <entry><para>The parent trait for annotations that should be
            retained in the class file for runtime access, but it doesn’t
            actually work on the JDK!</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanDescription</literal></para></entry>

            <entry><para><literal
            role="keep-together">BeanDescriptor</literal>
            (class)</para></entry>

            <entry><para>An annotation for <emphasis>JavaBean</emphasis> types
            or members that associates a short description (provided as the
            annotation argument) that will be included when generating bean
            information.</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanDisplayName</literal></para></entry>

            <entry><para><literal>BeanDescriptor</literal>
            (class)</para></entry>

            <entry><para>An annotation for <emphasis>JavaBean</emphasis> types
            or members that associates a name (provided as the annotation
            argument) that will be included when generating bean
            information.</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanInfo</literal></para></entry>

            <entry><para><literal>BeanInfo</literal> (class)</para></entry>

            <entry><para>A marker that indicates that a <literal
            role="keep-together">BeanInfo</literal> class should be generated
            for the marked Scala class. A <literal>val</literal> <phrase
            role="keep-together">becomes</phrase> a read-only property. A
            <literal>var</literal> <phrase
            role="keep-together">becomes</phrase> a read-write property. A
            <literal>def</literal> becomes a method.</para></entry>
          </row>

          <row>
            <entry><para><literal>BeanInfoSkip</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker that indicates that bean information should
            not be generated for the annotated member.</para></entry>
          </row>

          <row>
            <entry><para><literal>StaticAnnotation</literal></para></entry>

            <entry><para>Static fields, <?lb ?><literal
            role="keep-together">@Target(ElementType.TYPE)</literal></para></entry>

            <entry><para>The parent trait of annotations that should be
            visible across compilation units and define “static”
            metadata.</para></entry>
          </row>

          <row>
            <entry><para><literal>TypeConstraint</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>An annotation trait that can be applied to other
            annotations that define constraints on a type, relying only on
            information defined within the type itself, as opposed to external
            context information where the type is defined or used. The
            compiler can exploit this restriction to rewrite the constraint.
            There are currently no library annotations that use this
            trait.</para></entry>
          </row>

          <row>
            <entry><para><literal>unchecked</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker annotation for the selector in a match
            statement (e.g., the <literal>x</literal> in <literal>x match
            {...}</literal>) that suppresses a compiler warning if the
            <literal>case</literal> clauses are not “exhaustive.” You can
            still have a runtime <literal>MatchError</literal> occur if a
            value of <literal>x</literal> fails to match any of the
            <literal>case</literal> clauses. See the example
            later.</para></entry>
          </row>

          <row>
            <entry><para><literal>unsealed</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>Deprecated, use <literal>@unchecked</literal> <phrase
            role="keep-together">instead</phrase>.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <table id="scala-static-annotations">
      <title>Scala annotations derived from StaticAnnotation</title>

      <tgroup cols="3">
        <thead valign="top">
          <row>
            <entry>Name</entry>

            <entry><phrase role="keep-together">Java
            equivalent</phrase></entry>

            <entry><phrase role="keep-together">Description</phrase></entry>
          </row>
        </thead>

        <tbody valign="top">
          <row>
            <entry><para><literal>BeanProperty<indexterm>
                <primary>StaticAnnotation class</primary>

                <secondary>annotations derived from</secondary>
              </indexterm><indexterm>
                <primary>annotations</primary>

                <secondary>Scala annotations derived from
                StaticAnnotation</secondary>
              </indexterm></literal></para></entry>

            <entry><para><emphasis>JavaBean</emphasis>
            convention</para></entry>

            <entry><para>A marker for a field (including a constructor
            argument with the <literal>val</literal> or <literal>var</literal>
            keyword) that tells the compiler to generate a JavaBean-style
            “getter” and “setter” method. The setter is only generated for
            <literal>var</literal> declarations. See the discussion in <xref
            linkend="JavaBeanProperties" />.</para></entry>
          </row>

          <row>
            <entry><para><literal>cloneable</literal></para></entry>

            <entry><para><literal
            role="keep-together">java.lang.Cloneable</literal> (<phrase
            role="keep-together">interface</phrase>)</para></entry>

            <entry><para>A class marker indicating that a class can be
            cloned.</para></entry>
          </row>

          <row>
            <entry><para><literal>cps</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) Generate byte code using continuation
            passing style.</para></entry>
          </row>

          <row>
            <entry><para><literal>deprecated</literal></para></entry>

            <entry><para><literal
            role="keep-together">java.lang.Deprecated</literal></para></entry>

            <entry><para>A marker for any definition indicating that the
            defined “item” is obsolete. The compiler will issue a warning when
            the item is used.</para></entry>
          </row>

          <row>
            <entry><para><literal>inline</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A method marker telling the compiler that it should
            try “<phrase role="keep-together">especially</phrase> hard” to
            inline the method.</para></entry>
          </row>

          <row>
            <entry><para><literal>native</literal></para></entry>

            <entry><para><literal>native</literal> (keyword)</para></entry>

            <entry><para>A method marker indicating the method is implemented
            as “native” code. The method body will not be generated by the
            compiler, but usage of the method will be type
            checked.</para></entry>
          </row>

          <row>
            <entry><para><literal>noinline</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A method marker that prevents the compiler from
            inlining the method, even when it appears to be safe to do
            so.</para></entry>
          </row>

          <row>
            <entry><para><literal>remote</literal></para></entry>

            <entry><para><literal>java.rmi.Remote</literal> (<phrase
            role="keep-together">interface</phrase>)</para></entry>

            <entry><para>A class marker indicating that the class can be
            invoked from a remote JVM.</para></entry>
          </row>

          <row>
            <entry><para><literal>serializable</literal></para></entry>

            <entry><para><literal
            role="keep-together">java.io.Serializable</literal> (<phrase
            role="keep-together">interface</phrase>)</para></entry>

            <entry><para>A class marker indicating that the class can be
            serialized.</para></entry>
          </row>

          <row>
            <entry><para><literal
            role="keep-together">SerialVersionUID</literal></para></entry>

            <entry><para><literal>serialVersionUID</literal>
            <emphasis>static</emphasis> <phrase role="keep-together">field in
            a class</phrase></para></entry>

            <entry><para>Defines a globally unique ID for serialization
            purposes. The annotation’s constructor takes a
            <literal>Long</literal> argument for the UID.</para></entry>
          </row>

          <row>
            <entry><para><literal>switch</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) An annotation to be applied to a match
            expression, e.g., <literal>(x: @switch) match {...}</literal>.
            When present, the compiler will verify that the match has been
            compiled to a table-based or lookup-based
            <literal>switch</literal> statement. If not, it will issue an
            error if it instead compiles into a series of conditional
            expressions, which are less efficient.</para></entry>
          </row>

          <row>
            <entry><para><literal>specialized</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) An annotation applied to type
            parameters in parameterized types and methods. It tells the
            compiler to generate optimized versions of the type or method for
            the <literal>AnyVal</literal> types corresponding to platform
            primitive types. Optionally, you can limit the
            <literal>AnyVal</literal> types for which specialized
            implementations will be generated. See the discussion
            below.</para></entry>
          </row>

          <row>
            <entry><para><literal>tailRec</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>(version 2.8) A method annotation that tells the
            compiler to verify that the method will be compiled with
            <emphasis>tail-call optimization</emphasis>. If it is present, the
            compiler will issue an error if the method cannot be optimized
            into a loop. This happens, for example, when the method is not
            <literal>private</literal> or <literal>final</literal>, when it
            could be overridden, and when recursive invocations are not true
            tail calls.</para></entry>
          </row>

          <row>
            <entry><para><literal>throws</literal></para></entry>

            <entry><para><literal>throws</literal> (keyword)</para></entry>

            <entry><para>Indicates which exceptions are thrown by the
            annotated method. See the discussion later.</para></entry>
          </row>

          <row>
            <entry><para><literal>transient</literal></para></entry>

            <entry><para><literal>transient</literal> (keyword)</para></entry>

            <entry><para>Marks a method as “transient.”</para></entry>
          </row>

          <row>
            <entry><para><literal>uncheckedStable</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker for a value that is assumed to be stable
            even though its type is volatile (i.e., annotated with
            <literal>@volatile</literal>).</para></entry>
          </row>

          <row>
            <entry><para><literal
            role="keep-together">uncheckedVariance</literal></para></entry>

            <entry><para><emphasis>N.A.</emphasis></para></entry>

            <entry><para>A marker for a type argument that is volatile, when
            it is used in a parameterized type, to suppress variance
            checking.</para></entry>
          </row>

          <row>
            <entry><para><literal>volatile</literal></para></entry>

            <entry><para><literal>volatile</literal> (keyword, <phrase
            role="keep-together">for fields only</phrase>)</para></entry>

            <entry><para>A marker for an individual field or a whole type,
            which affects all fields, indicating that the field may be
            modified by a separate thread.</para></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <para id="para_28_annotations">The annotations marked with “(version 2.8)”
    are only available in Scala version 2.8 or later. Consider
    <literal>@tailrec</literal>, as used in the following example:<indexterm>
        <primary>annotations</primary>

        <secondary>available only in Scala version 2.8 or later</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">import scala.annotation.tailrec

@tailrec
def fib(i: Int): Int = i match {
  case _ if i &lt;= 1 =&gt; i
  case _ =&gt; fib(i-1) + fib(i-2)
}
println(fib(5))</programlisting>

    <para id="para_fib_tailrec_annotation">Note that <literal>fib</literal>,
    which calculates Fibonacci numbers, is recursive, but it isn’t tail-call
    recursive, because the call to itself is not the very last thing that
    happens in the second case clause. Rather, after calling itself twice, it
    does an addition. Hence, a tail-call optimization can’t be performed on
    this method. When the compiler sees the <literal>@tailrec</literal>
    annotation, it throws an error if it can’t apply the tail-call
    optimization. Attempting to run this script produces the following
    error:<indexterm>
        <primary>tail calls</primary>

        <secondary>@tailRec annotation and</secondary>
      </indexterm><indexterm>
        <primary sortas="tailRec annotation">@tailRec annotation</primary>
      </indexterm></para>

    <screen>... 4: error: could not optimize @tailrec annotated method
def fib(i: Int): Int = i match {
     ^
one error found</screen>

    <para id="para_switch_annotation">We can also use the same method to
    demonstrate the new <literal>@switch</literal> annotation available in
    version 2.8:<indexterm>
        <primary sortas="switch annotation">@switch annotation</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">import scala.annotation.switch

def fib(i: Int): Int = (i: @switch) match {
  case _ if i &lt;= 1 =&gt; i
  case _ =&gt; fib(i-1) + fib(i-2)
}
println(fib(5))</programlisting>

    <para id="para_fib_switch_annotation">This time we annotate the
    <literal>i</literal> in the <literal>match</literal> statement. This
    annotation causes the compiler to raise an error if it can’t generate a
    switch construct in byte code from the cases in the match statement.
    Switches are generally more efficient than conditional logic. Running this
    script produces this output:</para>

    <screen>... 3: error: could not emit switch for @switch annotated match
def fib(i: Int): Int = (i: @switch) match {
                                     ^
one error found</screen>

    <para id="para_fib_switch_annotation2">Conditional blocks have to be
    generated instead. The reason a switch can’t be generated is because of
    the condition guard clause we put in the first case clause, <literal>if i
    &lt;= 1</literal>.</para>

    <para id="para_let_s_look_at_an_example_of_">Let’s look at an example of
    <literal>@unchecked</literal> in use (adapted from the Scaladoc entry for
    <literal>@unchecked</literal>). Consider the following code
    fragement:<indexterm>
        <primary>exceptions</primary>

        <secondary>@unchecked annotation and</secondary>
      </indexterm><indexterm>
        <primary sortas="unchecked annotation">@unchecked annotation</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">...
def process(x: Option[int]) = x match {
  case Some(value) =&gt; ...
}
...</programlisting>

    <para id="para_if_you_compile_it_you_will_ge">If you compile it, you will
    get the following warning:</para>

    <screen>...: warning: does not cover case {object None}
  def f(x: Option[int]) = x match {
                          ^
one warning found</screen>

    <para id="para_normally_you_would_want_to_ad">Normally, you would want to
    add a case for <literal>None</literal>. However, if you want to suppress
    the warning message in situations like this, change the method as
    follows:</para>

    <programlisting linenumbering="unnumbered">...
def process(x: Option[int]) = (x: @unchecked) match {
  case Some(value) =&gt; ...
}
...</programlisting>

    <para id="para_with_the_unchecked_annotati">With the
    <literal>@unchecked</literal> annotation applied to <literal>x</literal>
    as shown, the warning will be suppressed. However, if <literal>x</literal>
    is ever <literal>None</literal>, then a <literal>MatchError</literal> will
    be thrown.</para>

    <para id="para_the_specialized_annotation_">The
    <literal>@specialized</literal> annotation is another optimization-related
    annotation added in <phrase role="keep-together">version</phrase> 2.8. It
    is a pragmatic solution to a tradeoff between space efficiency and
    performance. In Java and Scala, the implementation of a parameterized type
    or method is generated at the point of the declaration (as we discussed in
    <xref linkend="ParameterizedTypes" />). In contrast, in C++, a
    <emphasis>template</emphasis> is used to generate an implementation for
    the actual type parameters where the template is used. The <phrase
    role="keep-together">C++</phrase> approach has the advantage of allowing
    optimized implementations to be generated for primitive types, while it
    has the disadvantage of resulting in code bloat from all the
    instantiations of templates.<indexterm>
        <primary sortas="specialized annotation">@specialized
        annotation</primary>
      </indexterm><indexterm>
        <primary>C++</primary>

        <secondary>templates</secondary>
      </indexterm></para>

    <para id="para_in_jvm_related_languages_the_">In JVM-related languages,
    the “on-demand” generation of implementations isn’t suitable, primarily
    because there is no “link” step as in compiled languages, where every
    required instantiation of a template can be determined. This creates a
    dilemma. By default, a Scala parameterized type or method will be
    translated to a single implementation assuming <literal>Any</literal> for
    the type parameters (in part due to type erasure at the byte code level).
    Java generics work the same way. However, if a particular use of the type
    or method uses one of the <literal>AnyVal</literal> types, say
    <literal>Int</literal>, then we get inefficient boxing and unboxing
    operations in the implementation.</para>

    <para id="para_the_alternative_would_be_to_ge">The alternative would be to
    generate a separate implementation for every <literal>AnyVal</literal>
    corresponding to a primitive type, but this would lead to code bloat,
    especially since it would be rare that an application would use all those
    implementations. So, we are faced with a dilemma.</para>

    <para id="para_the_specialized_annotation_is_pragmatic">The
    <literal>@specialized</literal> annotation is a pragmatic compromise. It
    lets the user tell the compiler that runtime efficiency is more important
    than space efficiency, so the compiler will generate the separate
    implementations for each primitive corresponding to an
    <literal>AnyVal</literal>. Here is an example of how the annotation is
    used:</para>

    <programlisting linenumbering="unnumbered">class SpecialCollection[@specialized +T](...) {
  ...
}</programlisting>

    <para id="para_at_the_time_of_this_writing_t">At the time of this writing,
    the implementation in the version 2.8 “nightly” build only supports
    generation of specialized implementations for <literal>Int</literal> and
    <literal>Double</literal>. For the final version 2.8 library, it is
    planned that the other <literal>AnyVal</literal> types will be supported.
    There are also plans to allow the user to specify the types for which
    optimized implementations are generated so that unused implementations for
    the other <literal>AnyVals</literal> are avoided. See the final 2.8
    Scaladocs for details on the final feature set.</para>

    <para id="para_another_planned_version_2_8_an">Another planned version 2.8
    annotation is <literal>@cps</literal>, which stands for
    <emphasis>continuation passing style</emphasis>. It will be a directive
    interpreted by a compiler plugin that will trigger generation of
    continuation-based byte code for method invocation, rather than the
    default stack frame byte code. The annotation will have no effect unless
    the corresponding <literal>scalac</literal> plugin is used. Consult the
    release documentation for more information on this feature, when it
    becomes available.<indexterm>
        <primary sortas="cps">@cps (continual passing style)
        annotation</primary>
      </indexterm></para>

    <para id="para_to_understand_the_throws_an">To understand the
    <literal>@throws</literal> annotation, it’s important to remember that
    Scala does not have checked exceptions, in contrast with Java. There is
    also no <literal>throws</literal> clause available for Scala method
    declarations. This is not a problem if a Scala method calls a Java method
    that is declared to throw a checked exception. The exception is treated as
    unchecked in Scala. However, suppose the Scala method in question doesn’t
    catch the exception, but lets it pass through. What if this Scala method
    is called by other Java code?<indexterm>
        <primary>exceptions</primary>

        <secondary>@throws annotation and</secondary>
      </indexterm><indexterm>
        <primary sortas="throws annotation">@throws annotation</primary>
      </indexterm></para>

    <para id="para_let_s_look_at_an_example_invol">Let’s look at an example
    involving <literal>java.io.IOException</literal>, which is a checked
    exception. The following Scala class prints out the contents of a
    <literal>java.io.File</literal>:<indexterm>
        <primary>java.io.IOException class</primary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/file-printer.scala

import java.io._

class FilePrinter(val file: File) {

  @throws(classOf[IOException])
  def print() = {
    var reader: LineNumberReader = null
    try {
      reader = new LineNumberReader(new FileReader(file))
      loop(reader)
    } finally {
      if (reader != null)
        reader.close
    }
  }

  private def loop(reader: LineNumberReader): Unit = {
    val line = reader.readLine()
    if (line != null) {
      format("%3d: %s\n", reader.getLineNumber, line)
      loop(reader)
    }
  }
}</programlisting>

    <para id="para_note_the_throws_annotation_">Note the
    <literal>@throws</literal> annotation applied to the
    <literal>print</literal> method. The argument to the annotation
    constructor is a single <literal>java.lang.Class[Any]</literal> object, in
    this case, <literal>classOf[IO⁠Exception]</literal>. The Java IO API
    methods used by <literal>print</literal> and the private method
    <literal>loop</literal> might throw this exception.</para>

    <para id="para_by_the_way_notice_that_loop_">By the way, notice that
    <literal>loop</literal> uses functional-style tail recursion, rather than
    a loop. No variables were mutated during the production of this output!
    (Well, we don’t actually know what’s happening inside the Java IO
    classes....)</para>

    <?dbfo-need height=”1in”
?>

    <para id="para_here_is_a_java_class_that_uses">Here is a Java class that
    uses <literal>FilePrinter</literal>. It provides the
    <literal>main</literal> routine:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/annotations/FilePrinterMain.java

import java.io.*;

public class FilePrinterMain {
  public static void main(String[] args) {
    for (String fileName: args) {
      try {
        File file = new File(fileName);
        new FilePrinter(file).print();
      } catch (IOException ioe) {
        System.err.println("IOException for file " + fileName);
        System.err.println(ioe.getMessage());
      }
    }
  }
}</programlisting>

    <para id="para_these_classes_compile_without_">These classes compile
    without error. You can try them out with the following command (which
    assumes that <literal>FilePrinterMain.java</literal> is in the
    <filename>annotations</filename> directory, as in the example code
    distribution):</para>

    <screen>scala -cp build FilePrinterMain annotations/FilePrinterMain.java</screen>

    <para id="para_you_should_get_the_following_o">You should get the
    following output:</para>

    <screen> 1: import java.io.*;
 2:
 3: public class FilePrinterMain {
 4:   public static void main(String[] args) {
 5:     for (String fileName: args) {
 6:       try {
 7:         File file = new File(fileName);
 8:         new FilePrinter(file).print();
 9:       } catch (IOException ioe) {
10:         System.err.println("IOException for file " + fileName);
11:         System.err.println(ioe.getMessage());
12:       }
13:     }
14:   }
15: }</screen>

    <para id="para_now_returning_to_file_print">Now, returning to the
    <literal>FilePrinter</literal> class, suppose you comment out the
    <literal>@throws</literal> line. This file will continue to compile, but
    when you compile <literal>FilePrinterMain.java</literal>, you will get the
    following error:</para>

    <screen>annotations/FilePrinterMain.java:9: exception java.io.IOException is never
thrown in body of corresponding try statement
      } catch (IOException ioe) {
        ^
1 error</screen>

    <para id="para_even_though_java_io_ioexcepti">Even though
    <literal>java.io.IOException</literal> may get thrown by
    <literal>FilePrinter</literal>, that information isn’t in the byte code
    generated by <literal>scalac</literal>, so the analysis done by
    <literal>javac</literal> mistakenly concludes that
    <literal>IOException</literal> is never thrown.</para>

    <para id="para_so_the_purpose_of_throws_i">So, the purpose of
    <literal>@throws</literal> is to insert the information on thrown checked
    exceptions into the byte code that <literal>javac</literal> will
    read.<indexterm class="endofrange"
    startref="ch13_declarationsannotations"></indexterm><indexterm
    class="endofrange"
    startref="ch13_appdesignannotations"></indexterm><indexterm
    class="endofrange" startref="ch13_annotations"></indexterm></para>

    <tip id="para_tip_in_a_mixed_java_scala_env">
      <para>In a mixed Java-Scala environment, consider adding the
      <literal>@throws</literal> <phrase
      role="keep-together">annotation</phrase> for all your Scala methods that
      can throw Java checked exceptions. Eventually, some Java code will
      probably call one of those <phrase
      role="keep-together">methods</phrase>.</para>
    </tip>
  </sect1>

  <sect1 id="EnumerationsVsPatternMatching">
    <title>Enumerations Versus Pattern Matching</title>

    <para id="para_enumerations_are_a_way_of_defi">Enumerations are a way of
    defining a finite set of constant values. They are a lightweight
    alternative to case classes. You can reference the values directly,
    iterate through them, index into them with integer indices, etc.<indexterm>
        <primary>case classes</primary>

        <secondary>enumerations as alternative to</secondary>
      </indexterm><indexterm class="startofrange" id="ch13_enumerations">
        <primary>enumerations</primary>
      </indexterm><indexterm class="startofrange" id="ch13_appdesignenumvpm">
        <primary>application design</primary>

        <secondary>enumerations versus pattern matching</secondary>
      </indexterm></para>

    <para id="para_just_as_for_annotations_scala">Just as for annotations,
    Scala’s form of enumerations are class-based, with a particular set of
    idioms, rather than relying on special keywords for defining them, as is
    used for enumerations in Java and .NET. However, you can also use
    enumerations defined in those languages.</para>

    <para id="para_scala_enumerations_are_defined">Scala enumerations are
    defined by subclassing the abstract <literal>scala.Enumeration</literal>
    class. There are several ways to construct and use an enumeration. We’ll
    demonstrate one idiom that most closely matches the Java and .NET forms
    you may already know.<indexterm>
        <primary>enumerations</primary>

        <secondary>scala.Enumeration class</secondary>
      </indexterm></para>

    <para id="para_recall_http_methods_script_">Recall the HTTP methods
    scripts we wrote in <xref linkend="SealedClassHierarchies" />. We defined
    the set of HTTP 1.1 methods using a sealed case class hierarchy:</para>

    <programlisting linenumbering="unnumbered">// code-examples/ObjectSystem/sealed/http-script.scala

sealed abstract class HttpMethod()
case class Connect(body: String) extends HttpMethod
case class Delete (body: String) extends HttpMethod
case class Get    (body: String) extends HttpMethod
case class Head   (body: String) extends HttpMethod
case class Options(body: String) extends HttpMethod
case class Post   (body: String) extends HttpMethod
case class Put    (body: String) extends HttpMethod
case class Trace  (body: String) extends HttpMethod

def handle (method: HttpMethod) = method match {
  case Connect (body) =&gt; println("connect: " + body)
  case Delete  (body) =&gt; println("delete: "  + body)
  case Get     (body) =&gt; println("get: "     + body)
  case Head    (body) =&gt; println("head: "    + body)
  case Options (body) =&gt; println("options: " + body)
  case Post    (body) =&gt; println("post: "    + body)
  case Put     (body) =&gt; println("put: "     + body)
  case Trace   (body) =&gt; println("trace: "   + body)
}

val methods = List(
  Connect("connect body..."),
  Delete ("delete body..."),
  Get    ("get body..."),
  Head   ("head body..."),
  Options("options body..."),
  Post   ("post body..."),
  Put    ("put body..."),
  Trace  ("trace body..."))

methods.foreach { method =&gt; handle(method) }</programlisting>

    <para id="para_in_that_example_each_method_h">In that example, each method
    had a <literal>body</literal> attribute for the message body. We’ll assume
    here that the body is handled through other means and we only care about
    identifying the kind of HTTP method. So, here is a Scala
    <literal>Enumeration</literal> class for the HTTP 1.1 <phrase
    role="keep-together">methods</phrase>:<indexterm class="startofrange"
        id="ch13_enumsHttpMethod">
        <primary>enumerations</primary>

        <secondary>HttpMethod object (example)</secondary>
      </indexterm></para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-enum-script.scala

object HttpMethod extends Enumeration {
  type Method = Value
  val Connect, Delete, Get, Head, Options, Post, Put, Trace = Value
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println("Connect: " + method.id)
  case Delete  =&gt; println("Delete: "  + method.id)
  case Get     =&gt; println("Get: "     + method.id)
  case Head    =&gt; println("Head: "    + method.id)
  case Options =&gt; println("Options: " + method.id)
  case Post    =&gt; println("Post: "    + method.id)
  case Put     =&gt; println("Put: "     + method.id)
  case Trace   =&gt; println("Trace: "   + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println( HttpMethod )</programlisting>

    <para id="para_this_script_produces_the_follo">This script produces the
    following output:</para>

    <screen>Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Main$$anon$1$HttpMethod(0), Main$$anon$1$HttpMethod(1),
Main$$anon$1$HttpMethod(2), Main$$anon$1$HttpMethod(3),
Main$$anon$1$HttpMethod(4), Main$$anon$1$HttpMethod(5),
Main$$anon$1$HttpMethod(6), Main$$anon$1$HttpMethod(7)}</screen>

    <para>(We wrapped the lines for the output between the
    <literal>{...}</literal>.) There are two uses of <literal>Value</literal>
    in the definition of <literal>HttpMethod</literal>. The first usage is
    actually a reference to an abstract class,
    <literal>Enumeration.Value</literal>, which encapsulates some useful
    operations for the “values” in the enumeration. We define a new
    <literal>type</literal>, <literal>Method</literal>, that functions as an
    alias for <literal>Value</literal>. We see it used in the type of the
    argument passed to the <literal>handle</literal> method, which
    demonstrates <literal>HttpMethod</literal> in use.
    <literal>HttpMethod.Method</literal> is a more meaningful name to the
    reader than the generic <literal>HttpMethod.Value</literal>. Note that one
    of the fields in <literal>Enumeration.Value</literal> is
    <literal>id</literal>, which we also use in
    <literal>handle</literal>.<indexterm>
        <primary>Value class</primary>
      </indexterm><indexterm>
        <primary>Enumeration.Value class</primary>
      </indexterm></para>

    <para id="para_the_second_use_of_value_is_a">The second use of
    <literal>Value</literal> is actually a call to a method. There is no
    namespace collision between these two names. The line <literal>val
    Connect, Delete, Get, Head, Options, Post, Put, Trace = Value</literal>
    defines the set of values for the enumeration. The
    <literal>Value</literal> method is called for each one. It creates a new
    <literal>Enumeration.Value</literal> for each one and adds it to the
    managed set of values.</para>

    <para id="para_in_the_code_below_the_definiti">In the code below the
    definition, we import the definitions in <literal>HttpMethod</literal> and
    we define a <literal>handle</literal> method that pattern matches on
    <literal>HttpMethod.Method</literal> objects. It simply prints a message
    for each value along with its <literal>id</literal>. Note that while the
    example has no “default” case clause (e.g. <literal>case _ ⇒
    ...</literal>), none is required in this case. However, the compiler
    doesn’t actually know that all the possible values are covered, in
    contrast to a sealed case class hierarchy. If you comment out one of the
    case statements in <literal>handle</literal>, you will get no warnings,
    but you will get a <literal>MatchError</literal>.<indexterm>
        <primary>pattern matching</primary>

        <secondary sortas="enumerations">on enumerations</secondary>
      </indexterm></para>

    <warning id="para_warning_when_pattern_matching">
      <para>When pattern matching on enumeration values, the compiler can’t
      tell if the match is “exhaustive.”</para>
    </warning>

    <para id="para_you_might_wonder_why_we_hard_c">You might wonder why we
    hardcoded strings like “Connect” in the <literal>println</literal>
    statements in the case clauses. Can’t we get the name from the
    <literal>HttpMethod.Method</literal> object itself? And why didn’t the
    output of <literal>println(HttpMethod)</literal> include those names,
    instead of the ugly internal object names?</para>

    <para id="para_you_are_probably_accustomed_to">You are probably accustomed
    to using such names with Java or .NET enumerations. Unfortunately, we
    can’t get those names from the values in the Scala enumeration, at least
    given the way that we declared <literal>HttpMethod</literal>. However,
    there are two ways we can change the implementation to get name strings.
    In the first approach, we pass the name to <literal>Value</literal> when
    creating the fields:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-enum2-script.scala

object HttpMethod extends Enumeration {
  type Method = Value
  val Connect = Value("Connect")
  val Delete  = Value("Delete")
  val Get     = Value("Get")
  val Head    = Value("Head")
  val Options = Value("Options")
  val Post    = Value("Post")
  val Put     = Value("Put")
  val Trace   = Value("Trace")
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println( HttpMethod )</programlisting>

    <para id="para_redundant_connect">It is a bit redundant to have to use the
    same word twice in declarations like <literal>val Connect =
    Value("Connect")</literal>.</para>

    <para id="para_http-enum2-script_output">Running this script produces the
    following nicer output:</para>

    <screen>Connect: 0
Delete: 1
Get: 2
Head: 3
Options: 4
Post: 5
Put: 6
Trace: 7
{Connect, Delete, Get, Head, Options, Post, Put, Trace}</screen>

    <para id="para_in_the_second_approach_we_pas">In the second approach, we
    pass the list of names to the <literal>Enumeration</literal>
    constructor:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-enum3-script.scala

object HttpMethod extends Enumeration(
    "Connect", "Delete", "Get", "Head", "Options", "Post", "Put", "Trace") {
  type Method = Value
  val Connect, Delete, Get, Head, Options, Post, Put, Trace = Value
}

import HttpMethod._

def handle (method: HttpMethod.Method) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

HttpMethod foreach { method =&gt; handle(method) }
println( HttpMethod )</programlisting>

    <para id="para_note_that_we_have_a__redundant">This script produces
    identical output. Note that we have a <emphasis>redundant</emphasis> list
    of name strings and names of the <literal>vals</literal>. <emphasis>It is
    up to you to keep the items in the list and their order consistent with
    the declared values!</emphasis> This version has fewer characters, but it
    is more error-prone. Internally, <literal>Enumeration</literal> pairs the
    strings with the corresponding <literal>Value</literal> instances as they
    are created.</para>

    <para id="para_on_the_plus_side_the_output_i">The output when printing the
    whole <literal>HttpMethod</literal> object is better for either
    alternative implementation. When the values have names, their
    <literal>toString</literal> returns the name. In fact, our final two
    examples have become quite artificial because we now have identical
    statements for each case clause! Of course, in a real implementation, you
    would handle the different HTTP methods differently.<indexterm
    class="endofrange" startref="ch13_enumerations"></indexterm><indexterm
    class="endofrange" startref="ch13_enumsHttpMethod"></indexterm><indexterm
    class="endofrange" startref="ch13_appdesignenumvpm"></indexterm></para>
  </sect1>

  <sect1 id="ThoughtsOnAnnotationsAndEnumerations">
    <title>Thoughts On Annotations and Enumerations</title>

    <para id="para_for_both_annotations_and_enume">For both annotations and
    enumerations, there are advantages and disadvantages to the Scala
    approach, where we use regular class-based mechanisms, rather than
    inventing custom keywords and syntax. The advantages include fewer special
    cases in the language. Classes and traits are used in more or less the
    same ways they are used for “normal” code. The disadvantages include the
    need to understand and use ad hoc conventions that are not always as
    convenient to use as the custom syntax mechanisms required in Java and
    .NET. Also, Scala’s implementations are not as full-featured.<indexterm>
        <primary>enumerations</primary>

        <secondary>advantages and disadvantages of</secondary>
      </indexterm><indexterm>
        <primary>annotations</primary>

        <secondary>advantages and disadvantages of</secondary>
      </indexterm></para>

    <para id="para_so_should_the_scala_community">So, should the Scala
    community relent and implement ad hoc, but more full-featured mechanisms
    for annotations and enumerations? Maybe not. Scala is a more flexible
    language than most languages. Many of the features provided by Java and
    .NET annotations and enumerations can be implemented in Scala by other
    means.</para>

    <para id="para_some_use_cases_for_the_mor">Some use cases for the more
    advanced features of Java annotations can be implemented more elegantly
    with “normal” Scala code, as we will discuss in <xref
    linkend="DesignPatterns" />. For enumerations, sealed case classes and
    pattern matching provide a more flexible solution, in many
    cases.<indexterm>
        <primary>pattern matching</primary>

        <secondary>using with case classes, enumerations versus</secondary>
      </indexterm><indexterm>
        <primary>case classes</primary>

        <secondary>enumerations versus</secondary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>enumerations vs. case classes and pattern
        matching</secondary>
      </indexterm><indexterm>
        <primary>enumerations</primary>

        <secondary>case classes and pattern matching versus</secondary>
      </indexterm></para>

    <sect2 id="EnumerationsVsCaseClassesAndPatternMatching">
      <title>Enumerations Versus Case Classes and Pattern Matching</title>

      <para id="para_let_s_revisit_http_methods_s">Let’s revisit the HTTP
      method script, which uses a sealed case class hierarchy versus the
      version we wrote previously that uses an <literal>Enumeration</literal>.
      Since the enumeration version doesn’t handle the message body, let’s
      write a modified version of the sealed case class version that is closer
      to the enumeration version, i.e., it also doesn’t hold the message body
      and it has <literal>name</literal> and <literal>id</literal>
      methods:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/enumerations/http-case-script.scala

sealed abstract class HttpMethod(val id: Int) {
  def name = getClass getSimpleName
  override def toString = name
}

case object Connect extends HttpMethod(0)
case object Delete  extends HttpMethod(1)
case object Get     extends HttpMethod(2)
case object Head    extends HttpMethod(3)
case object Options extends HttpMethod(4)
case object Post    extends HttpMethod(5)
case object Put     extends HttpMethod(6)
case object Trace   extends HttpMethod(7)

def handle (method: HttpMethod) = method match {
  case Connect =&gt; println(method + ": " + method.id)
  case Delete  =&gt; println(method + ": " + method.id)
  case Get     =&gt; println(method + ": " + method.id)
  case Head    =&gt; println(method + ": " + method.id)
  case Options =&gt; println(method + ": " + method.id)
  case Post    =&gt; println(method + ": " + method.id)
  case Put     =&gt; println(method + ": " + method.id)
  case Trace   =&gt; println(method + ": " + method.id)
}

List(Connect, Delete, Get, Head, Options, Post, Put, Trace) foreach {
  method =&gt; handle(method)
}</programlisting>

      <para id="para_note_that_we_used_case_object">Note that we used
      <literal>case object</literal> for all the concrete subclasses, to have
      a true set of constants. To mimic the enumeration <literal>id</literal>,
      we added a field explicitly, but now it’s up to us to pass in valid,
      unique values! The <literal>handle</literal> methods in the two
      implementations are nearly identical.</para>

      <para id="para_this_script_outputs_the_follow">This script outputs the
      following:</para>

      <screen>Main$$anon$1$Connect$: 0
Main$$anon$1$Delete$: 1
Main$$anon$1$Get$: 2
Main$$anon$1$Head$: 3
Main$$anon$1$Options$: 4
Main$$anon$1$Post$: 5
Main$$anon$1$Put$: 6
Main$$anon$1$Trace$: 7</screen>

      <para id="para_the_object_names_are_ugly_but">The object names are ugly,
      but we could parse the string and remove the substring we really care
      about.</para>

      <para id="para_both_approaches_support_the_co">Both approaches support
      the concept of a finite and fixed set of values, as long as the case
      class hierarchy is sealed. An additional advantage of a sealed case
      class hierarchy is the fact that the compiler will warn you if pattern
      matching statements aren’t <phrase
      role="keep-together">exhaustive</phrase>. Try removing one of the case
      clauses and you’ll get the usual warning. The compiler can’t do this
      with enumerations, as we saw.</para>

      <para id="para_the_enumeration_format_is_more">The enumeration format is
      more succinct, despite the name duplication we had to use, and it also
      supports the ability to iterate through the values. We had to do that
      manually in the case clause implementation.</para>

      <para id="para_the_case_class_implementation_">The case class
      implementation naturally accommodates other fields, e.g., the
      <literal>body</literal>, as in the original implementation, while
      enumerations can only accommodate constant <literal>Values</literal>
      with associated names and IDs.</para>

      <tip id="para_tip_for_cases_where_you_need_">
        <para>For cases where you need only a simple list of constants by name
        or ID number, use enumerations. Be careful to follow the usage idioms.
        For fixed sets of more complex, constant objects, use sealed case
        objects.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="UsingNullsVsOptions">
    <title>Using Nulls Versus Options</title>

    <para id="para_when_we_introduced_option_in">When we introduced
    <literal>Option</literal> in <xref linkend="OptionSomeNone" />, we briefly
    discussed how it encourages avoiding <literal>null</literal> references in
    your code, which Tony Hoare, who introduced the concept of
    <literal>null</literal> in 1965, called his “billion dollar mistake” (see
    <link linkend="Hoare2009"
    xrefstyle="select:nopage">[Hoare2009]</link>).<indexterm>
        <primary>Option class</primary>

        <secondary>nulls versus</secondary>
      </indexterm><indexterm>
        <primary>nulls</primary>

        <secondary>Options versus</secondary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>nulls versus Options</secondary>
      </indexterm></para>

    <para id="para_scala_has_to_support_null_b">Scala has to support
    <literal>null</literal>, because <literal>null</literal> is supported on
    both the JVM and .NET and other libraries use <literal>null</literal>. In
    fact, <literal>null</literal> is used by some Scala libraries.</para>

    <para id="para_what_if_null_were_not_availa">What if
    <literal>null</literal> were not available? How would that change your
    designs? The <literal>Map</literal> API offers some useful examples.
    Consider these two <literal>Map</literal> methods:</para>

    <programlisting linenumbering="unnumbered">trait Map[A,+B] {
  ...
  def get(key: A) : Option[B]
  def getOrElse [B2 &gt;: B](key : A, default : =&gt; B2) : B2 = ...
  ...
}</programlisting>

    <para id="para_a_map_may_not_have_a_value_for">A map may not have a value
    for a particular key. Both of these methods avoid returning
    <literal>null</literal> in that case. Concrete implementations of
    <literal>get</literal> in subclasses return a <literal>None</literal> if
    no value exists for the key. Otherwise, they return a
    <literal>Some</literal> wrapping the value. The method signature tells you
    that a value might not exist, and it forces you to handle that situation
    gracefully:</para>

    <programlisting linenumbering="unnumbered">val stateCapitals = Map("Alabama" -&gt; "Montgomery", ...)
...

stateCapitals.get("North Hinterlandia") match {
  case None =&gt; println ("No such state!")
  case Some(x) =&gt; println(x)
}</programlisting>

    <para id="para_similarly_getorelse_forces_">Similarly,
    <literal>getOrElse</literal> forces you to design defensively. You have to
    specify a default value for when a key isn’t in the map. Note that the
    default value can actually be an instance of a supertype relative to the
    map’s value type:</para>

    <programlisting linenumbering="unnumbered">println(stateCapitals.getOrElse("North Hinterlandia", "No such state!"))</programlisting>

    <para id="para_a_lot_of_java_and_net_apis_al">A lot of Java and .NET APIs
    allow <literal>null</literal> method arguments and can return
    <literal>null</literal> values. You can write Scala wrappers around them
    to implement an appropriate strategy for handling
    <literal>nulls</literal>.</para>

    <para id="para_for_example_let_s_revisit_our">For example, let’s revisit
    our previous file printing example from <xref linkend="Annotations" />.
    We’ll refactor our <literal>FilePrinter</literal> class and the Java
    driver into a combined script. We’ll address two issues: 1) wrap
    <literal>LineNumberReader.readLine</literal> with a method that returns an
    <literal>Option</literal> instead of <literal>null</literal>, and 2) wrap
    checked <literal>IOExceptions</literal> in our own unchecked exception,
    called <literal>ScalaIOException</literal>:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/options-nulls/file-printer-refactored-script.scala

import java.io._

class ScalaIOException(cause: Throwable) extends RuntimeException(cause)

class ScalaLineNumberReader(in: Reader) extends LineNumberReader(in) {
  def inputLine() = readLine() match {
    case null =&gt; None
    case line =&gt; Some(line)
  }
}

object ScalaLineNumberReader {
  def apply(file: File) = try {
     new ScalaLineNumberReader(new FileReader(file))
  } catch {
    case ex: IOException =&gt; throw new ScalaIOException(ex)
  }
}

class FilePrinter(val file: File) {
  def print() = {
    val reader = ScalaLineNumberReader(file)
    try {
      loop(reader)
    } finally {
      if (reader != null)
        reader.close
    }
  }

  private def loop(reader: ScalaLineNumberReader): Unit = {
    reader.inputLine() match {
      case None =&gt;
      case Some(line) =&gt; {
        format("%3d: %s\n", reader.getLineNumber, line)
        loop(reader)
      }
    }
  }
}

// Process the command-line arguments (file names):
args.foreach { fileName =&gt;
  new FilePrinter(new File(fileName)).print();
}</programlisting>

    <para id="para_the_scalabufferedreader_clas">The
    <literal>ScalaLineNumberReader</literal> class defines a new method
    <literal>inputLine</literal> that calls <literal
    role="keep-together">LineNumberReader.readLine</literal> and pattern
    matches the result. If <literal>null</literal>, then
    <literal>None</literal> is returned. <phrase
    role="keep-together">Otherwise</phrase>, the line is returned wrapped in a
    <literal>Some[String]</literal>.</para>

    <para
    id="para__scalaioexception_is_a_subcla"><literal>ScalaIOException</literal>
    is a subclass of <literal>RuntimeException</literal>, so it is unchecked.
    We use it to wrap any <literal>IOExceptions</literal> thrown in
    <literal>ScalaLineNumberReader.apply</literal>.</para>

    <para id="para_the_refactored_fileprinter_c">The refactored
    <literal>FilePrinter</literal> class uses
    <literal>ScalaLineNumberReader.apply</literal> in its
    <literal>print</literal> method. It uses
    <literal>ScalaLineNumberReader.inputLine</literal> in its
    <literal>loop</literal> method. While the original version properly
    handled the case of <literal>LineNumberReader.readLine</literal> returning
    <literal>null</literal>, now the user of
    <literal>ScalaLineNumberReader</literal> has no choice but to handle a
    <literal>None</literal> return value.</para>

    <para id="para_the_script_ends_with_a_loop_ov">The script ends with a loop
    over the input arguments, which are stored automatically in the
    <literal>args</literal> variable. Each argument is treated as a file name
    to be printed. The script will print itself with the following
    command:</para>

    <screen>scala file-printer-refactored-script.scala file-printer-refactored-script.scala</screen>

    <sect2 id="OptionsAndForComprehensions">
      <title>Options and for Comprehensions</title>

      <para id="para_one_other_benefit_of_option_with_for_comps">There is one
      other benefit of using <literal>Options</literal> with
      <literal>for</literal> comprehensions, automatic <phrase
      role="keep-together">removal</phrase> of <literal>None</literal>
      elements from comprehensions, under most conditions (refer to <link
      linkend="Pollak2007" xrefstyle="select:nopage">[Pollak2007]</link> and
      <link linkend="Spiewak2009c"
      xrefstyle="select:nopage">[Spiewak2009c]</link>). Consider this first
      version of a script that uses <literal>Options</literal> in a
      <literal>for</literal> <phrase
      role="keep-together">comprehension</phrase>:<indexterm>
          <primary>for comprehensions</primary>

          <secondary>using Options with</secondary>
        </indexterm><indexterm>
          <primary>Option class</primary>

          <secondary>using with for comprehensions</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/options-nulls/option-for-comp-v1-script.scala

case class User(userName: String, name: String, email: String, bio: String)

val newUserProfiles = List(
  Map("userName" -&gt; "twitspam", "name" -&gt; "Twit Spam"),
  Map("userName" -&gt; "bucktrends", "name" -&gt; "Buck Trends",
      "email" -&gt; "thebuck@stops.he.re", "bio" -&gt; "World's greatest bloviator"),
  Map("userName" -&gt; "lonelygurl", "name" -&gt; "Lonely Gurl",
      "bio" -&gt; "Obviously fake..."),
  Map("userName" -&gt; "deanwampler", "name" -&gt; "Dean Wampler",
      "email" -&gt; "dean@....com", "bio" -&gt; "Scala passionista"),
  Map("userName" -&gt; "al3x", "name" -&gt; "Alex Payne",
      "email" -&gt; "al3x@....com", "bio" -&gt; "Twitter API genius"))

// Version #1

var validUsers = for {
  user     &lt;- newUserProfiles
  if (user.contains("userName") &amp;&amp; user.contains("name") &amp;&amp;   // #1
      user.contains("email") &amp;&amp; user.contains("bio"))         // #1
  userName &lt;- user get "userName"
  name     &lt;- user get "name"
  email    &lt;- user get "email"
  bio      &lt;- user get "bio" }
    yield User(userName, name, email, bio)

validUsers.foreach (user =&gt; println(user))</programlisting>

      <para id="para_imagine_this_code_is_used_in_s">Imagine this code is used
      in some sort of social networking site. New users submit profile data,
      which is passed to this service in bulk for processing. For example, we
      hardcoded a list of submitted profiles, where each profile data set is a
      map. The map might have been copied from an HTTP session.</para>

      <para id="para_the_service_filters_out_incomp">The service filters out
      incomplete profiles (missing fields), shown with the #1 comments, and
      creates new user objects from the complete profiles.</para>

      <para id="para_3_of_5_users_printed">Running the script prints out three
      new users from the five submitted profiles:</para>

      <screen>User(bucktrends,Buck Trends,thebuck@stops.he.re,World's greatest bloviator)
User(deanwampler,Dean Wampler,dean@....com,Scala passionista)
User(al3x,Alex Payne,al3x@....com,Twitter API genius)</screen>

      <para id="para_now_comment_out_the_two_lines">Now, delete the two lines
      with the #1 comment:</para>

      <programlisting linenumbering="unnumbered">...
var validUsers = for {
  user     &lt;- newUserProfiles
  userName &lt;- user get "userName"
  name     &lt;- user get "name"
  email    &lt;- user get "email"
  bio      &lt;- user get "bio" }
    yield User(userName, name, email, bio)

validUsers.foreach (user =&gt; println(user))</programlisting>

      <para id="para_before_you_rerun_the_script_w">Before you rerun the
      script, what do you expect to happen? Will it print five lines with some
      fields empty (or containing other kinds of values)?</para>

      <para id="para_same_3_of_5_users_printed">It prints the same thing! How
      did it do the filtering we wanted without the explicit
      conditional?</para>

      <para id="para_the_answer_lies_in_the_way_tha">The answer lies in the
      way that <literal>for</literal> comprehensions are implemented. Here are
      a couple of simple for comprehensions followed by their translations
      (see <link linkend="ScalaSpec2009"
      xrefstyle="select:nopage">[ScalaSpec2009]</link>). First, we’ll look at
      a single <emphasis>generator</emphasis> with a
      <literal>yield</literal>:<indexterm>
          <primary>generators</primary>

          <secondary sortas="for comprehensions">in for
          comprehensions</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1) yield e2          // for comprehension

e1 map ( case p1 =&gt; e2 )         // translation</programlisting>

      <para id="para_here_s_the_translation_a_singl">Here’s the translation of
      a single generator followed by an arbitrary expression (which could be
      several expressions in braces, etc.):</para>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1) e2                // for comprehension

e1 foreach ( case p1 =&gt; e2 )     // translation</programlisting>

      <para id="para_with_more_than_one__generator_">With more than one
      generator, <literal>map</literal> is replaced with
      <literal>flatMap</literal> in the <literal>yield</literal> expressions,
      but <literal>foreach</literal> is unchanged:</para>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1; p2 &lt;- e2 ...) yield eN       // for comprehension

e1 flatMap ( case p1 =&gt; for (p2 &lt;- e2 ...) yield eN )  // translation</programlisting>

      <programlisting linenumbering="unnumbered">for (p1 &lt;- e1; p2 &lt;- e2 ...) eN             // for comprehension

e1 foreach ( case p1 =&gt; for (p2 &lt;- e2 ...) eN )       // translation</programlisting>

      <para id="para_note_that_the_second_through_t">Note that the second
      through the N<superscript>th</superscript> generators become nested for
      comprehensions that need translating.</para>

      <para id="para_there_are_similar_translations">There are similar
      translations for conditional statements (which become calls to <literal
      role="keep-together">filter</literal>) and <literal>val</literal>
      assignments. We won’t show them here, since our primary purpose is to
      describe just enough of the implementation details so you can understand
      how <literal>Options</literal> and <literal>for</literal> comprehensions
      work together. The additional details are described in <link
      linkend="ScalaSpec2009"
      xrefstyle="select:nopage">[ScalaSpec2009]</link>, with examples.</para>

      <para id="para_if_you_follow_this_translation">If you follow this
      translation process on our example, you get the following
      expansion:</para>

      <programlisting linenumbering="unnumbered">var validUsers = newUserProfiles flatMap {
  case user =&gt; user.get("userName") flatMap {
    case userName =&gt; user.get("name") flatMap {
      case name =&gt; user.get("email") flatMap {
        case email =&gt; user.get("bio") map {
          case bio =&gt; User(name, userName, email, bio)    // #1
        }
      }
    }
  }
}</programlisting>

      <para id="para_note_that_we_have_flatmap_ca">Note that we have
      <literal>flatMap</literal> calls until the most nested case, where
      <literal>map</literal> is used (<literal>flatMap</literal> and
      <literal>map</literal> behave equivalently in this case).</para>

      <para id="para_now_we_can_understand_why_the_">Now we can understand why
      the big conditional was unnecessary. Recall that <literal>user</literal>
      is a <literal>Map</literal> and <literal>user.get("...")</literal>
      returns an <literal>Option</literal>, either <literal>None</literal> or
      <literal>Some(value)</literal>. The key is the behavior of
      <literal>flatMap</literal> defined on <literal>Option</literal>, which
      lets us treat <literal>Options</literal> like other collections. Here is
      the definition of <literal>flatMap</literal>:</para>

      <programlisting linenumbering="unnumbered">def flatMap[B](f: A =&gt; Option[B]): Option[B] =
  if (isEmpty) None else f(this.get)</programlisting>

      <para id="para_if_user_get_returns_">If
      <literal>user.get("...")</literal> returns <literal>None</literal>, then
      <literal>flatMap</literal> simply returns <literal>None</literal> and
      never evaluates the function literal. Hence, the nested iterations
      simply stop and never get to the line marked with the comment #1, where
      the <literal>User</literal> is created.</para>

      <para id="para_the_outer_most_flatmap_is_on">The outermost
      <literal>flatMap</literal> is on the input <literal>List</literal>,
      <literal>newUserProfiles</literal>. On a multi-element <phrase
      role="keep-together">collection</phrase> like this, the behavior of
      <literal>flatMap</literal> is similar to <literal>map</literal>, but it
      flattens the new <phrase role="keep-together">collection</phrase> and
      doesn’t require the resulting map to have the same number of elements as
      the original collection, like <literal>map</literal> does.</para>

      <para id="para_finally_recall_from_partial">Finally, recall from <xref
      linkend="PartialFunctions" /> that the <literal>case user =&gt;
      ...</literal> statements, for example, cause the compiler to generate a
      <literal>PartialFunction</literal> to pass to <literal>flatMap</literal>
      and <literal>map</literal>, so no corresponding <literal>foo match
      {...}</literal> style wrappers are necessary.</para>

      <tip id="para_tip_using_options_with_for">
        <para>Using <literal>Options</literal> with <literal>for</literal>
        comprehensions eliminate the need for most “null/empty” checks.</para>
      </tip>
    </sect2>
  </sect1>

  <sect1 id="ExceptionsAndTheAlternatives">
    <title>Exceptions and the Alternatives</title>

    <para id="para_if_nulls_are_the_billion_d">If <literal>nulls</literal> are
    the “billion dollar mistake” as we discussed in <xref
    linkend="OptionSomeNone" />, then what about exceptions? You can argue
    that <literal>nulls</literal> should never occur and you can design a
    language and libraries that never use them. However, exceptions have a
    legitimate place because they <emphasis>separate the con⁠cerns</emphasis>
    of normal program flow from “exceptional” program flow. The divide isn’t
    always clear-cut. For example, if a user mistypes his username, is that
    normal or exceptional?<indexterm>
        <primary>application design</primary>

        <secondary>exceptions and alternatives</secondary>
      </indexterm><indexterm>
        <primary>exceptions</primary>

        <secondary>and alternatives to</secondary>
      </indexterm></para>

    <para id="para_another_question_is_where_shou">Another question is where
    should the exception be caught and handled? Java’s checked exceptions were
    designed to document for the API user what exceptions might be thrown by a
    method. The flaw was that it encouraged handling of the exception in ways
    that are often suboptimal. If one method calls another method that might
    throw a checked exception, the calling method is forced to either handle
    the exception or declare that it also throws the exception. More often
    than not, the calling method is the wrong place to handle the exception.
    It is too common for methods to simply “eat” an exception that should
    really be passed up the stack and handled in a more appropriate context.
    Otherwise, <literal>throws</literal> declarations are required up the
    stack of method calls. This is not only tedious, but it pollutes the
    intermediate contexts with exception names that often have no connection
    to the local context.</para>

    <para id="para_as_we_have_seen_scala_doesn_t_">As we have seen, Scala
    doesn’t have checked exceptions. Any exception can propagate to the point
    where it is most appropriate to handle it. However, design discipline is
    required to implement handlers in the appropriate places for all
    exceptions for which recovery is possible!</para>

    <para id="para_every_now_and_then_an_argumen">Every now and then, an
    argument erupts among developers in a particular language community about
    whether or not it’s OK to use exceptions as a control-flow mechanism for
    normal processing. Sometimes this use of exceptions is seen as a useful
    <literal role="keep-together">longjump</literal> or non-local
    <literal>goto</literal> mechanism for exiting out of a deeply nested
    scope. One reason this debate pops up is that this use of exceptions is
    sometimes more efficient than a more “conventional” implementation.</para>

    <para id="para_for_example_you_might_impleme">For example, you might
    implement <literal>Iterable.foreach</literal> to blindly traverse a
    collection and stop when it catches whatever exception indicates it went
    past the end of the <phrase
    role="keep-together">collection</phrase>.</para>

    <para id="para_when_it_comes_to_application_d">When it comes to
    application design, communicating <emphasis>intent</emphasis> is very
    important. Using exceptions as a <literal>goto</literal> mechanism breaks
    the <emphasis>principle of least surprise</emphasis>. It will be rare that
    the performance gain will justify the loss of clarity, so we encourage you
    to use exceptions only for truly “exceptional” conditions. Note that Ruby
    actually provides a non-local <literal>goto</literal>-like mechanism. In
    Ruby the keywords <literal>throw</literal> and <literal>catch</literal>
    are actually reserved for this purpose, while <literal>raise</literal> and
    <literal>rescue</literal> are the keywords for raising an exception and
    handling it.<indexterm>
        <primary>Ruby</primary>

        <secondary>exceptions</secondary>
      </indexterm></para>

    <para id="para_whatever_your_view_on_the_prop">Whatever your view on the
    proper use of exceptions, when you design APIs, minimizing the possibility
    of raising an exception will benefit your users. This is the flip side of
    an exception handling strategy, preventing them in the first place.
    <literal>Option</literal> can help.<indexterm>
        <primary>Option class</primary>

        <secondary>alternatives to exceptions</secondary>
      </indexterm></para>

    <para id="para_consider_two_methods_on_seq_">Consider two methods on
    <literal>Seq</literal>, <literal>first</literal> and
    <literal>firstOption</literal>:<indexterm>
        <primary>Seq class, first and firstOption methods</primary>
      </indexterm></para>

    <screen>trait Seq[+A] {
  ...
  def first : A = ...
  def firstOption : Option[A] = ...
  ...
}</screen>

    <para id="para_the_first_method_throws_a_p">The <literal>first</literal>
    method throws a <literal>Predef.UnsupportedOperationException</literal> if
    the sequence is empty. Returning <literal>null</literal> in this case
    isn’t an option, because the sequence could have <literal>null</literal>
    elements! In contrast, the <literal>firstOption</literal> method returns
    an <literal>Option</literal>, so it returns <literal>None</literal> if the
    sequence is empty, which is unambiguous.</para>

    <para id="para_you_could_argue_that_the_seq_">You could argue that the
    <literal>Seq</literal> API would be more robust if it only had a “first”
    method that returned an <literal>Option</literal>. It’s useful to ask
    yourself, “How can I prevent the user from ever failing?” When “failure”
    can’t be prevented, use <literal>Option</literal> or a similar construct
    to document for the user that a failure mode is possible. Thinking in
    terms of valid state transformations, the <literal>first</literal> method,
    while convenient, isn’t really valid for a sequence in an empty state.
    Should the “first” methods not exist for this reason? This choice is
    probably too draconian, but by returning <literal>Option</literal> from
    <literal>firstOption</literal>, the API communicates to the user that
    there are circumstances when the method can’t satisfy the request and it’s
    up to the user to recover gracefully. In this sense,
    <literal>firstOption</literal> treats an empty sequence as a
    non-exceptional situation.</para>

    <para id="para_recall_that_we_saw_another_exa">Recall that we saw another
    example of this decision tradeoff in <xref linkend="OptionSomeNone" />. We
    discussed two methods on <literal>Option</literal> for retrieving the
    value an instance wraps (when the instance is actually a
    <literal>Some</literal>). The <literal>get</literal> method throws an
    exception if there is no value, i.e., the <literal>Option</literal>
    instance is actually <literal>None</literal>. The other method,
    <literal>getOrElse</literal>, takes a second argument, a default value to
    return if the <literal>Option</literal> is actually
    <literal>None</literal>. In this case, no exception is thrown.</para>

    <para id="para_of_course_it_is_impossible_to">Of course, it is impossible
    to avoid all exceptions. Part of the original intent of checked versus
    unchecked exceptions was to distinguish between potentially recoverable
    problems and catastrophic failures, like out-of-memory errors.</para>

    <para id="para_however_the_alternative_metho">However, the alternative
    methods in <literal>Seq</literal> and <literal>Option</literal> show a way
    to “encourage” the user of an API to consider the consequences of a
    possible failure, like asking for the first element in an empty sequence.
    The user can specify the contingency in the event that a failure occurs.
    Minimizing the possibility of exceptions will improve the robustness of
    your Scala libraries and the applications that use them.</para>
  </sect1>

  <sect1 id="ScalableAbstractions">
    <title>Scalable Abstractions</title>

    <para id="para_it_has_been_a_goal_for_some_ti">It has been a goal for some
    time in our industry to create reusable <emphasis>components</emphasis>.
    Unfortunately, there is little agreement on the meaning of the term
    <emphasis>component</emphasis>, nor on a related term,
    <emphasis>module</emphasis> (which some people consider synonymous with
    <emphasis>component</emphasis>). Proposed definitions usually start with
    assumptions about the platform, granularity, deployment and configuration
    scenarios, versioning issues, etc. (see <link linkend="Szyperski1998"
    xrefstyle="select:nopage">[Szyperski1998]</link>).<indexterm
    class="startofrange" id="ch13_components"></indexterm><indexterm>
        <primary>modules</primary>

        <secondary>components and</secondary>
      </indexterm><indexterm>
        <primary>components</primary>

        <secondary>defined</secondary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>scalable abstractions</secondary>
      </indexterm></para>

    <para id="para_we_ll_avoid_that_discussion_an">We’ll avoid that discussion
    and use the term <emphasis>component</emphasis> informally to refer to a
    grouping of types and packages that exposes coherent abstractions
    (preferably just one) for the services it offers, that has minimal
    coupling to other components, and that is internally cohesive.<indexterm>
        <primary>scalable abstractions</primary>

        <see>components</see>
      </indexterm></para>

    <para id="para_all_languages_offer_mechanisms">All languages offer
    mechanisms for defining components, at least to some degree. Objects are
    the primary encapsulation mechanism in object-oriented languages. However,
    objects alone aren’t enough, because we quickly find that objects
    naturally cluster together into more coarse-grained aggregates, especially
    as our applications grow. Generally speaking, an object isn’t necessarily
    a component, and a component may contain many objects. Scala and Java
    offer packages for aggregating types. Ruby modules serve a similar
    purpose, as do C# and C++ namespaces.</para>

    <para id="para_however_these_packaging_mecha">However, these packaging
    mechanisms still have limitations. A common problem is that they don’t
    clearly define what is publicly visible outside the component boundary and
    what is internal to the component. For example, in Java, any public type
    or public method on a public type is visible outside the package boundary
    to every other component. You can make types and methods “package
    private,” but then they are invisible to other packages encapsulated in
    the component. Java doesn’t have a clear sense of component
    boundaries.</para>

    <para id="para_scala_provides_several_mechani">Scala provides a number of
    mechanisms that improve this situation. We have seen many of them
    already.</para>

    <sect2 id="FineGrainedVisibilityRules">
      <title>Fine-Grained Visibility Rules</title>

      <para id="para_we_saw_in_visibilityrules_">We saw in <xref
      linkend="VisibilityRules" /> that Scala provides more fine-grained
      visibility rules than most other languages. You can control the
      visibility of types and methods outside type and package
      boundaries.<indexterm>
          <primary>components</primary>

          <secondary>fine-grained visibility rules in Scala</secondary>
        </indexterm><indexterm>
          <primary>visibility</primary>

          <secondary>fine-grained visibility rules in Scala</secondary>
        </indexterm></para>

      <para id="para_consider_the_following_encodedstring_component">Consider
      the following example of a component in package
      <literal>encodedstring</literal>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/encoded-string.scala

package encodedstring {

  trait EncodedString {
    protected[encodedstring] val string: String
    val separator: EncodedString.Separator.Delimiter

    override def toString = string

    def toTokens = string.split(separator.toString).toList
  }

  object EncodedString {
    object Separator extends Enumeration {
      type Delimiter = Value
      val COMMA = Value(",")
      val TAB   = Value("\t")
    }

    def apply(s: String, sep: Separator.Delimiter) = sep match {
      case Separator.COMMA =&gt; impl.CSV(s)
      case Separator.TAB   =&gt; impl.TSV(s)
    }

    def unapply(es: EncodedString) = Some(Pair(es.string, es.separator))
  }

  package impl {
    private[encodedstring] case class CSV(override val string: String)
        extends EncodedString {
      override val separator = EncodedString.Separator.COMMA
    }

    private[encodedstring] case class TSV(override val string: String)
        extends EncodedString {
      override val separator = EncodedString.Separator.TAB
    }
  }
}</programlisting>

      <para id="para_encapsulates_encoded_strings">This example encapsulates
      handling of strings encoding comma-separated values (CSVs) or
      tab-separated values (TSVs). The <literal>encodedstring</literal>
      package exposes a trait <literal>EncodedString</literal> that is visible
      to clients. The concrete classes implementing CSVs and TSVs are declared
      <literal>private[encodedstring]</literal> in the
      <literal>encodedstring.impl</literal> package. The trait defines two
      abstract <literal>val</literal> fields: one to hold the encoded
      <literal>string</literal>, which is protected from client access, and
      the other to hold the <literal>separator</literal> (e.g., a comma).
      Recall from <xref linkend="AdvancedObjectOrientedProgramming" /> that
      abstract fields, like abstract types and methods, must be initialized in
      concrete instances. In this case, <literal>string</literal> will be
      defined through a concrete constructor, and the
      <literal>separator</literal> is defined explicitly in the concrete
      classes, <literal>CSV</literal> and <literal>TSV</literal>.</para>

      <para id="para_the_tostring_method_on_enco">The
      <literal>toString</literal> method on <literal>EncodedString</literal>
      prints the string as a “normal” string. By hiding the
      <literal>string</literal> value and the concrete classes, we have
      complete freedom in how the string is actually stored. For example, for
      extremely large strings, we might want to split them on the delimiter
      and store the tokens in a data structure. This could save space if the
      strings are large enough and we can share tokens between strings. Also,
      we might find this storage useful for various searching, sorting, and
      other manipulation tasks. All these implementation issues are
      transparent to the client.</para>

      <para id="para_exposes_encoded_strings_abstractions">The package also
      exposes an object with an <literal>Enumeration</literal> for the known
      separators, an <literal>apply</literal> factory method to construct new
      encoded strings, and an <literal>unapply</literal> extractor method to
      decompose the encoded string into its enclosed string and the delimiter.
      In this case, the <literal>unapply</literal> method looks trivial, but
      if we stored the strings in a different way, this method could
      transparently reconstitute the original string.</para>

      <para id="para_clients_of_encoded_strings">So, clients of this component
      only know about the <literal>EncodedString</literal> abstraction and the
      enumeration representing the supported types of encoded strings. All the
      actual implementation types and details are private to the
      <literal>encodedstring</literal> package. (We put them in the same file
      for convenience, but normally you would kept them separate.) Hence, the
      boundary is clear between the exposed abstractions and the internal
      implementation details.</para>

      <para id="para_encoded_strings_script">The following script demonstrates
      the component in use:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/encoded-string-script.scala

import encodedstring._
import encodedstring.EncodedString._

def p(s: EncodedString) = {
  println("EncodedString: " + s)
  s.toTokens foreach (x =&gt; println("token: " + x))
}

val csv = EncodedString("Scala,is,great!", Separator.COMMA)
val tsv = EncodedString("Scala\tis\tgreat!", Separator.TAB)

p(csv)
p(tsv)

println( "\nExtraction:" )
List(csv, "ProgrammingScala", tsv, 3.14159) foreach {
  case EncodedString(str, delim) =&gt;
    println( "EncodedString: \"" + str + "\", delimiter: \"" + delim + "\"" )
  case s: String =&gt; println( "String: " + s )
  case x =&gt; println( "Unknown Value: " + x )
}</programlisting>

      <para id="para_encoded_strings_script_output">It produces the following
      output:</para>

      <screen>EncodedString: Scala,is,great!
token: Scala
token: is
token: great!
EncodedString: Scala    is      great!
token: Scala
token: is
token: great!

Extraction:
EncodedString: "Scala,is,great!", delimiter: ","
String: ProgrammingScala
EncodedString: "Scala   is      great!", delimiter: "   "
Unknown Value: 3.14159</screen>

      <para id="para_cant_access_CSV">However, if we try to use the
      <literal>CSV</literal> class directly, for example, we get the following
      error:</para>

      <screen>scala&gt; import encodedstring._
import encodedstring._

scala&gt; val csv = impl.CSV("comma,separated,values")
&lt;console&gt;:6: error: object CSV cannot be accessed in package encodedstring.impl
       val csv = impl.CSV("comma,separated,values")
                      ^

scala&gt;</screen>

      <para id="para_was_it_necessary_to_make_the_c">In this simple example,
      it wasn’t essential to make the concrete types private to the component.
      However, we have a very minimal interface to clients of the component,
      and we are free to modify the implementation as we see fit with little
      risk of forcing client code modifications. A common cause of maintenance
      paralysis in mature applications is the presence of too many
      dependencies between concrete types, which become difficult to modify
      since they force changes to client code. So, for larger, more
      sophisticated components, this clear separation of abstraction from
      implementation can keep the code maintainable and reusable for a long
      time.</para>
    </sect2>

    <sect2 id="MixinComposition">
      <title>Mixin Composition</title>

      <para id="para_we_saw_in_traits_in_obje">We saw in <xref
      linkend="Traits" /> how traits promote mixin composition. A class can
      focus on its <emphasis>primary domain</emphasis>, and other
      responsibilities can be implemented separately in traits. When instances
      are constructed, classes and traits can be combined to compose the full
      range of required behaviors.<indexterm>
          <primary>traits</primary>

          <secondary>promotion of mixin composition</secondary>
        </indexterm><indexterm>
          <primary>mixin composition</primary>
        </indexterm></para>

      <para id="para_in_overridingabstracttypes_">For example, in <xref
      linkend="OverridingAbstractTypes" />, we discussed our second version of
      the Observer Pattern:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/observer/observer2.scala

package observer

trait AbstractSubject {
  type Observer

  private var observers = List[Observer]()
  def addObserver(observer:Observer) = observers ::= observer
  def notifyObservers = observers foreach (notify(_))

  def notify(observer: Observer): Unit
}

trait SubjectForReceiveUpdateObservers extends AbstractSubject {
  type Observer = { def receiveUpdate(subject: Any) }

  def notify(observer: Observer): Unit = observer.receiveUpdate(this)
}

trait SubjectForFunctionalObservers extends AbstractSubject {
  type Observer = (AbstractSubject) =&gt; Unit

  def notify(observer: Observer): Unit = observer(this)
}</programlisting>

      <para id="para_we_used_this_version_to_observ">We used this version to
      observe button “clicks” in a UI. Let’s revisit this implementation and
      resolve a few limitations, using our next tool for scalable
      abstractions, <emphasis>self-type annotations</emphasis> combined with
      abstract type members.<indexterm>
          <primary>abstract types</primary>

          <secondary>combined with self-type annotations</secondary>
        </indexterm><indexterm>
          <primary>self-type annotations</primary>

          <secondary>and abstract type members</secondary>
        </indexterm></para>
    </sect2>

    <sect2 id="SelfTypeAnnotationsAndAbstractTypeMembers">
      <title>Self-Type Annotations and Abstract Type Members</title>

      <para id="para_there_are_a_few_things_that_are_unsatisfying1">There are
      a few things that are unsatisfying about the implementation of
      <literal>AbstractSub⁠ject</literal> in our second version of the
      Observer Pattern. The first occurs in
      <literal>SubjectForRe⁠ceiveUpdateObservers</literal>, where the
      <literal>Observer</literal> type is defined to be the structural type
      <literal>{ def receiveUpdate(subject: Any) }</literal>. It would be nice
      to narrow the type of <literal role="keep-together">subject</literal> to
      something more specific than <literal>Any</literal>.</para>

      <para id="para_there_are_a_few_things_that_are_unsatisfying2">The second
      issue, which is really the same problem in a different form, occurs in
      <literal>SubjectForFunctionalObservers</literal>, where the
      <literal>Observer</literal> type is defined to be the type
      <literal>(AbstractSubject) =&gt; Unit</literal>. We would like the
      argument to the function to be something more specific than
      <literal>AbstractSubject</literal>. Perhaps this drawback wasn’t so
      evident before, because our simple examples never needed to access
      <literal>Button</literal> state information or methods.<indexterm>
          <primary>polymorphism</primary>

          <secondary>family polymorphism</secondary>
        </indexterm><indexterm>
          <primary>family polymorphism</primary>
        </indexterm><indexterm>
          <primary>covariant specialization</primary>
        </indexterm></para>

      <para id="para_in_fact_we_expect_the_actual_">In fact, we expect the
      actual types of the subject and observer to be specialized <emphasis
      role="keep-together">covariantly</emphasis>. For example, when we’re
      observing <literal>Buttons</literal>, we expect our observers to be
      specialized for <literal>Buttons</literal>, so they can access
      <literal>Button</literal> state and methods. This
      <emphasis>covariant</emphasis> specialization is sometimes called
      <emphasis>family polymorphism</emphasis> (see <link
      linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>).
      Let’s fix our design to support this covariance.</para>

      <para id="para_to_simplify_the_example_let_s">To simplify the example,
      let’s focus on just the <literal>receiveUpdate</literal> form of the
      <literal>Observer</literal>, which we implemented with
      <literal>SubjectForReceiveUpdateObservers</literal> before. Here is a
      reworking of our pattern, loosely following an example in <link
      linkend="Odersky2005" xrefstyle="select:nopage">[Odersky2005]</link>.
      (Note that the Scala syntax has changed somewhat since that paper was
      written.)</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/observer3-wont-compile.scala
// WON'T COMPILE

package observer

abstract class SubjectObserver {
  type S &lt;: Subject
  type O &lt;: Observer

  trait Subject {
    private var observers = List[O]()
    def addObserver(observer: O) = observers ::= observer
    def notifyObservers = observers foreach (_.receiveUpdate(this)) // ERROR
  }

  trait Observer {
    def receiveUpdate(subject: S)
  }
}</programlisting>

      <para id="para_type_and_parents">We’ll explain the error in a minute.
      Note how the types <literal>S</literal> and <literal>O</literal> are
      declared. As we saw in <xref linkend="ParameterizedTypes" />, the
      expression <literal>type S &lt;: Subject</literal> defines an abstract
      type <literal>S</literal> where the only allowed concrete types will be
      subtypes of <literal>Subject</literal>. The declaration of
      <literal>O</literal> is similar. To be clear, <literal>S</literal> and
      <literal>O</literal> are “placeholders” at this point, while
      <literal>Subject</literal> and <literal>Observer</literal> are abstract
      traits defined in <literal>SubjectObserver</literal>.</para>

      <para id="para_subjectobserver_as_abstract_class_or_trait">By the way,
      declaring <literal>SubjectObserver</literal> as an abstract class versus
      a trait is somewhat arbitrary. We’ll derive concrete objects from it
      shortly. We need <literal>SubjectObserver</literal> primarily so we have
      a type to “hold” our abstract type members <literal>S</literal> and
      <literal>O</literal>.</para>

      <para id="para_if_you_attempt_to_compile_this">However, if you attempt
      to compile this code as currently written, you get the following
      error:</para>

      <screen>... 10: error: type mismatch;
 found   : SubjectObserver.this.Subject
 required: SubjectObserver.this.S
      def notifyObservers = observers foreach (_.receiveUpdate(this))
                                                               ^
one error found</screen>

      <para id="para_in_the_nested_observer_trait">In the nested
      <literal>Observer</literal> trait, <literal>receiveUpdate</literal> is
      expecting an instance of type <literal>S</literal>, but we are passing
      it <literal>this</literal>, which is of type <literal>Subject</literal>.
      In other words, we are passing an instance of a parent type of the type
      expected. One solution would be to change the signature to just expect
      the parent type, <literal>Subject</literal>. That’s undesirable. We just
      mentioned that our concrete observers need the more specific type, the
      actual concrete type we’ll eventually define for <literal>S</literal>,
      so they can call methods on it. For example, when observing UI <literal
      role="keep-together">CheckBoxes</literal>, the observers will want to
      read whether or not a box is checked. We don’t want to force the
      observers to use unsafe casts.</para>

      <para id="para_a__self_type_annotation__ode">We looked at composition
      using <emphasis>self-type annotations</emphasis> in <xref
      linkend="SelfTypeAnnotations" />. Let’s use this feature now to solve
      our current compilation problem. Here is the same code again with a
      self-type annotation:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/observer3.scala

package observer

abstract class SubjectObserver {
  type S &lt;: Subject
  type O &lt;: Observer

  trait Subject {
    self: S =&gt;    // #1
    private var observers = List[O]()
    def addObserver(observer: O) = observers ::= observer
    def notifyObservers = observers foreach (_.receiveUpdate(self))  // #2
  }

  trait Observer {
    def receiveUpdate(subject: S)
  }
}</programlisting>

      <para id="para_comment_1_shows_the_self_type">Comment #1 shows the
      self-type annotation, <literal>self: S =&gt;</literal>. We can now use
      <literal>self</literal> as an alias for <literal>this</literal>, but
      whenever it appears, the type will be assumed to be
      <literal>S</literal>, not <literal>Subject</literal>. It is as if we’re
      telling <literal>Subject</literal> to impersonate another type, but in a
      type-safe way, as we’ll see.<indexterm>
          <primary>this keyword</primary>

          <secondary>self versus, in self-type annotations</secondary>
        </indexterm></para>

      <para id="para_actually_we_could_have_used_">Actually, we could have
      used <literal>this</literal> instead of <literal>self</literal> in the
      annotation, but <literal>self</literal> is somewhat conventional. A
      different name also reminds us that we’re working with a different
      type.</para>

      <para id="para_when_an_actual_concrete_subje">Are self-type annotations
      a safe thing to use? When an actual concrete
      <literal>SubjectOb⁠server</literal> is defined, <literal>S</literal> and
      <literal>O</literal> will be specified and type checking will be
      performed to ensure that the concrete <literal>S</literal> and
      <literal>O</literal> are compatible with <literal>Subject</literal> and
      <literal>Observer</literal>. In this case, because we also defined
      <literal>S</literal> to be a subtype of <literal>Subject</literal> and
      <literal>O</literal> to be a subtype of <literal>Observer</literal>, any
      concrete types derived from <literal>Subject</literal> and
      <literal>Observer</literal>, respectively, will work.</para>

      <para id="para_comment_2_shows_that_we_now_p">Comment #2 shows that we
      pass <literal>self</literal> instead of <literal>this</literal> to
      <literal>receiveUpdate</literal>.</para>

      <para id="para_to_be_continued_">Now that we have a generic
      implementation of the pattern, let’s specialize it for observing button
      clicks:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/button-observer3.scala

package ui
import observer._

object ButtonSubjectObserver extends SubjectObserver {
  type S = ObservableButton
  type O = ButtonObserver

  class ObservableButton(name: String) extends Button(name) with Subject {
    override def click() = {
      super.click()
      notifyObservers
    }
  }

  trait ButtonObserver extends Observer {
    def receiveUpdate(button: ObservableButton)
  }
}</programlisting>

      <para id="para_we_declare_an_object_buttonsubjectobserver">We declare an
      object <literal>ButtonSubjectObserver</literal> where we define
      <literal>S</literal> and <literal>O</literal> to be
      <literal>ObservableButton</literal> and
      <literal>ButtonObserver</literal>, respectively, both of which are
      defined in the object. We use an <literal>object</literal> now so that
      we can refer to the nested types easily, as we’ll see shortly.</para>

      <para
      id="para_observablebutton_is_a_concrete_class"><literal>ObservableButton</literal>
      is a concrete class that overrides <literal>click</literal> to notify
      observers, similar to our previous implementations in <xref
      linkend="Traits" />. However, <literal>ButtonObserver</literal> is still
      an abstract trait, because <literal>receiveUpdate</literal> is not
      defined. Notice that the argument to <literal
      role="keep-together">receiveUpdate</literal> is now an
      <literal>ObservableButton</literal>, the value assigned to
      <literal>S</literal>.</para>

      <para id="para_the_final_piece_of_the_puzzle_">The final piece of the
      puzzle is to define a concrete observer. As before, we’ll count button
      clicks. However, to emphasize the value of having the specific type of
      instance passed to the observer, a <literal>Button</literal> in this
      case, we’ll enhance the observer to track clicks for multiple buttons
      using a hash map with the button labels as the keys. No type casts are
      required!</para>

      <screen>// code-examples/AppDesign/abstractions/button-click-observer3.scala

package ui
import observer._

class ButtonClickObserver extends ButtonSubjectObserver.ButtonObserver {
  val clicks = new scala.collection.mutable.HashMap[String,Int]()

  def receiveUpdate(button: ButtonSubjectObserver.ObservableButton) = {
    val count = clicks.getOrElse(button.label, 0) + 1
    clicks.update(button.label, count)
  }
}</screen>

      <para id="para_every_time_buttonclickobserve">Every time
      <literal>ButtonClickObserver.receiveUpdate</literal> is called, it
      fetches the current count for the button, if any, and updates the map
      with an incremented count. Note that it is now impossible to call
      <literal>receiveUpdate</literal> with a normal
      <literal>Button</literal>. We have to use an <literal
      role="keep-together">ObservableButton</literal>. This restriction
      eliminates bugs where we don’t get the notifications we expected. We
      also have access to any “enhanced” features that
      <literal>ObservableButton</literal> may have.</para>

      <para id="para_finally_here_is_a_specificati">Finally, here is a
      specification that exercises the code:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/button-observer3-spec.scala

package ui
import org.specs._
import observer._
<?dbfo-need height="1in"
?>
object ButtonObserver3Spec extends Specification {
  "An Observer counting button clicks" should {
    "see all clicks" in {
      val button1 = new ButtonSubjectObserver.ObservableButton("button1")
      val button2 = new ButtonSubjectObserver.ObservableButton("button2")
      val button3 = new ButtonSubjectObserver.ObservableButton("button3")
      val buttonObserver = new ButtonClickObserver
      button1.addObserver(buttonObserver)
      button2.addObserver(buttonObserver)
      button3.addObserver(buttonObserver)
      clickButton(button1, 1)
      clickButton(button2, 2)
      clickButton(button3, 3)
      buttonObserver.clicks("button1") mustEqual 1
      buttonObserver.clicks("button2") mustEqual 2
      buttonObserver.clicks("button3") mustEqual 3
    }
  }

  def clickButton(button: Button, nClicks: Int) =
    for (i &lt;- 1 to nClicks)
      button.click()
}</programlisting>

      <para id="para_we_create_three_buttons_and_on">We create three buttons
      and one observer for all of them. We then click the buttons different
      numbers of times. Finally, we confirm that the clicks were properly
      counted for each button.</para>

      <para id="para_abstract_types_and_self_types_conclusion_">We see again
      how abstract types combined with self-type annotations provide a
      reusable abstraction that is easy to extend in a type-safe way for
      particular needs. Even though we defined a general protocol for
      observing an “event” after it happened, we were able to define subtypes
      specific to <literal>Buttons</literal> without resorting to unsafe casts
      from <literal>Subject</literal> abstractions.</para>

      <para id="para_modular_scala_compiler">The Scala compiler itself is
      implemented using these mechanisms (see <link linkend="Odersky2005"
      xrefstyle="select:nopage">[Odersky2005]</link>) to make it modular in
      useful ways. For example, it is relatively straightforward to implement
      compiler plugins.</para>

      <para id="para_revisit_in_di">We’ll revisit these idioms in <xref
      linkend="DependencyInjectionInScala" />.<indexterm class="endofrange"
      startref="ch13_components"></indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="EffectiveTraitsDesign">
    <title>Effective Design of Traits</title>

    <para id="para_one_of_the_reasons_that_java_d">One of the reasons that
    many languages (like Java) do not implement multiple inheritance is
    because of the problems observed with multiple inheritance in C++. One of
    those problems is the so-called <emphasis>diamond of death</emphasis>,
    which is illustrated in <xref linkend="diamond-of-death" />.<indexterm>
        <primary>C++</primary>

        <secondary>multiple inheritance</secondary>
      </indexterm><indexterm>
        <primary>inheritance</primary>

        <secondary>multiple, problems with</secondary>
      </indexterm><indexterm>
        <primary>diamond of death (problem with multiple
        inheritance)</primary>
      </indexterm><indexterm class="startofrange" id="ch13_appdesigntraits">
        <primary>application design</primary>

        <secondary>effective trait design</secondary>
      </indexterm><indexterm class="startofrange" id="ch13_traitseffective">
        <primary>traits</primary>

        <secondary>effective design of</secondary>
      </indexterm></para>

    <figure float="none" id="diamond-of-death">
      <title>Diamond of death in languages with multiple inheritance</title>

      <mediaobject>
        <imageobject role="print">
          <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1301.pdf"
                     format="PDF" />
        </imageobject>

        <imageobject role="web">
          <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1301.png"
                     format="PNG" />
        </imageobject>
      </mediaobject>
    </figure>

    <para id="para_in_c_each_constructor_for_">In C++, each constructor for
    <literal>C</literal> will invoke a constructor for <literal>B1</literal>
    and a constructor for <literal>B2</literal> (explicitly or implicitly).
    Each constructor for <literal>B1</literal> and <literal>B2</literal> will
    invoke a constructor for <literal>A</literal>. Hence, in a
    <emphasis>naïve</emphasis> implementation of multiple inheritance, the
    fields of <literal>A</literal>, <literal>a1</literal> and
    <literal>a2</literal>, could be initialized <emphasis>twice</emphasis> and
    possibly initialized in an inconsistent way or there might be two
    different <literal>A</literal> “pieces” in the <literal>C</literal>
    instance, one for <literal>B1</literal> and one for <literal>B2</literal>!
    C++ has mechanisms to clarify what should happen, but it’s up to the
    developer to understand the details and to do the correct thing.</para>

    <para id="para_scala_s_single_inheritance_wit">Scala’s single inheritance
    and support for traits avoid these problems, while providing the most
    important benefit of multiple inheritance: <emphasis>mixin</emphasis>
    composition. The order of construction is unambiguous (see <xref
    linkend="Linearization" />). Traits can’t have constructor argument lists,
    but Scala ensures that their fields are properly initialized when
    instances are created, as we saw in <xref linkend="ConstructingTraits" />
    and <xref linkend="OverridingFieldsInTraits" />. We saw another example of
    initializing <literal>vals</literal> in a trait in <xref
    linkend="FineGrainedVisibilityRules" />. There we defined concrete classes
    that overrode the definitions of the two abstract fields in the
    <literal>EncodedString</literal> trait.<indexterm>
        <primary>inheritance</primary>

        <secondary>single inheritance plus traits in Scala</secondary>
      </indexterm><indexterm>
        <primary>mixin composition</primary>
      </indexterm></para>

    <para id="para_however_since_a_trait_can_con">So, Scala handles many
    potential issues that arise when mixing the contributions of different
    traits into the set of possible states of an instance. Still, it’s
    important to consider how the contributions of different traits interact
    with each other.</para>

    <para id="para_when_considering_the_state_of_">When considering the state
    of an instance, it is useful to consider the instance as possessing a
    <emphasis>state machine</emphasis>, where <emphasis>events</emphasis>
    (e.g., method calls and field writes) cause transitions from one state to
    another. The set of all possible states form a <emphasis>space</emphasis>.
    You can think of each <emphasis>field</emphasis> as contributing one
    <emphasis>dimension</emphasis> to this space.</para>

    <para id="para_for_example_recall_our_vetoa">For example, recall our
    <literal>VetoableClicks</literal> trait in <xref
    linkend="StackableTraits" />, where button clicks were counted and
    additional clicks were vetoed after a certain number of clicks occurred.
    Our simple <literal>Button</literal> class contributed only a
    <literal>label</literal> <emphasis
    role="keep-together">dimension</emphasis>, while
    <literal>VetoableClicks</literal> contributed a <literal>count</literal>
    <emphasis>dimension</emphasis> and a <literal>maxAllowed</literal>
    constant. Here is a recap of these types, collected together into a single
    script that also exercises the code:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/vetoable-clicks1-script.scala

trait Clickable {
  def click()
}

class Widget
class Button(val label: String) extends Widget with Clickable {
  def click() = println("click!")
}

trait VetoableClicks extends Clickable {
  val maxAllowed = 1
  private var count = 0
  abstract override def click() = {
    if (count &lt; maxAllowed) {
      count += 1
      super.click()
    }
  }
}

val button1 = new Button("click me!")
println("new Button(...)")
for (i &lt;- 1 to 3 ) button1.click()

val button2 = new Button("click me!") with VetoableClicks
println("new Button(...) with VetoableClicks")
for (i &lt;- 1 to 3 ) button2.click()</programlisting>

    <para id="ui2-vetoable-clicks-recap-output">This script prints the
    following output:</para>

    <screen>new Button(...)
click!
click!
click!
new Button(...) with VetoableClicks
click!</screen>

    <para id="para_maxallowed_is_a_constant">Note that
    <literal>maxAllowed</literal> is a constant, but it can be overridden when
    instantiating each instance. So, two instances could differ only by the
    value of <literal>maxAllowed</literal>. Therefore,
    <literal>maxAllowed</literal> also contributes a dimension to the state,
    but with only one value per <phrase
    role="keep-together">instance</phrase>!</para>

    <para id="para_so_for_a_button_labeled_sub">So, for a button labeled
    “Submit,” with <literal>maxAllowed</literal> set to 3, and which has been
    clicked twice (so <literal>count</literal> equals 2), its state can be
    represented by the tuple <literal>("Submit", 2, 3)</literal>.</para>

    <para id="para_in_general_a_single_trait_can">In general, a single trait
    can either be stateless, i.e., it contributes no new dimensions of state
    to the instance, or it can contribute <emphasis>orthogonal</emphasis>
    state dimensions to the instance, i.e., dimensions that are independent of
    the state contributions from other traits and the parent class. In the
    script, <literal>Clickable</literal> is trivially stateless (ignoring the
    button’s label), while <literal>VetoableClicks</literal> contributes
    <literal>maxAllowed</literal> and <literal>count</literal>. Traits with
    orthogonal state often have orthogonal methods, too. For example, the
    Observer Pattern traits we used in <xref linkend="Traits" /> contained
    methods for managing their lists of observers.</para>

    <para id="para_independent_of_these_two_possi">Independent of whether a
    trait contributes state dimensions, a trait can also modify the possible
    values for a dimension contributed by a different trait or the parent
    class. To see an example, let’s refactor the script to move the click
    <literal>count</literal> to the <literal
    role="keep-together">Clickable</literal> trait:</para>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/abstractions/vetoable-clicks2-script.scala

trait Clickable {
  private var clicks = 0
  def count = clicks

  def click() = { clicks += 1 }
}

class Widget
class Button(val label: String) extends Widget with Clickable {
  override def click() = {
    super.click()
    println("click!")
  }
}

trait VetoableClicks extends Clickable {
  val maxAllowed = 1
  abstract override def click() = {
    if (count &lt; maxAllowed)
      super.click()
  }
}

val button1 = new Button("click me!")
println("new Button(...)")
for (i &lt;- 1 to 3 ) button1.click()

val button2 = new Button("click me!") with VetoableClicks
println("new Button(...) with VetoableClicks")
for (i &lt;- 1 to 3 ) button2.click()</programlisting>

    <para id="para_now_clickable_contributes_th">This script prints the same
    output as before. Now <literal>Clickable</literal> contributes one state
    dimension for <literal>count</literal> (which is now a method that returns
    the value of the private <literal>clicks</literal> field).
    <literal>VetoableClicks</literal> <emphasis>modifies</emphasis> this
    dimension by reducing the number of possible values for
    <literal>count</literal> from <literal>0</literal> to infinity down to
    just <literal>0</literal> and <literal>1</literal>. Therefore, one trait
    affects the <emphasis>behavior</emphasis> of another. We might say that
    <literal>VetoableClicks</literal> is <emphasis>invasive</emphasis>,
    because it changes the behavior of other mixins.<indexterm>
        <primary>mixins</primary>

        <secondary>invasive</secondary>
      </indexterm></para>

    <para id="para_why_is_all_this_important_whi">Why is all this important?
    While the problems of multiple-inheritance are eliminated in Scala’s model
    of single inheritance plus traits, care is required when mixing state and
    behavior contributions to create well-behaved applications. For example,
    if you have a test suite that <literal>Button</literal> passes, will a
    <literal>Button with VetoableClicks</literal> instance pass the same test
    suite? The suite won’t pass if it assumes that you can click a button as
    many times as you want. There are different “specifications” for these two
    kinds of buttons. This difference is expressed by the <emphasis>Liskov
    Substitution Principle</emphasis> (see <link linkend="Martin2003"
    xrefstyle="select:nopage">[Martin2003]</link>). An instance of a
    <literal>Button with VetoableClicks</literal> won’t be
    <emphasis>substitutable</emphasis> in every situation where a regular
    <literal>Button</literal> instance is used. This is a consequence of the
    invasive nature of <literal
    role="keep-together">VetoableClicks</literal>.</para>

    <para id="para_similarly_orthogonal_state_an">When a trait adds only
    orthogonal state and behavior, without affecting the rest of the state and
    behavior of the instance, it makes reuse and composition much easier, as
    well as reducing the potential for bugs. The Observer Pattern
    implementations we have seen are quite reusable. The only requirement for
    reuse is to provide some “glue” to adapt the generic subject and observer
    traits to particular circumstances.</para>

    <para id="para_this_does_not_mean_that__invas">This does not mean that
    invasive mixins are bad, just that they should be used wisely. The
    “vetoable events” pattern can be very useful.<indexterm class="endofrange"
    startref="ch13_appdesigntraits"></indexterm><indexterm class="endofrange"
    startref="ch13_traitseffective"></indexterm></para>
  </sect1>

  <sect1 id="DesignPatterns">
    <title>Design Patterns</title>

    <para id="para_design_patterns_have_taken_a_b">Design patterns have taken
    a beating lately. Critics dismiss them as workarounds for missing language
    features. Indeed, some of the <emphasis>Gang of Four</emphasis> patterns
    (see <link linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>)
    are not really needed in Scala, as native features provide better
    substitutes. Other patterns are part of the language itself, so no special
    coding is needed. Of course, patterns are frequently misused, but that’s
    not the fault of the patterns themselves.<indexterm>
        <primary>Gang of Four (GOF) patterns</primary>
      </indexterm><indexterm class="startofrange" id="ch13_designpatterns">
        <primary>design patterns</primary>
      </indexterm><indexterm class="startofrange" id="ch13_appsdesignpatterns">
        <primary>application design</primary>

        <secondary>design patterns</secondary>
      </indexterm></para>

    <para id="para_we_think_the_criticisms_often_">We think the criticisms
    often overlook an important point: the distinction between an idea and how
    it is implemented and used in a particular situation. Design patterns
    document recurring, widely useful ideas. These ideas are part of the
    <emphasis>vocabulary</emphasis> that software developers use to describe
    their designs.<indexterm>
        <primary>singleton objects</primary>

        <secondary>eliminating need for Singleton Pattern</secondary>
      </indexterm></para>

    <para id="para_pattern_ideas_language_features">Some common patterns are
    native language features in Scala, like <emphasis>singleton</emphasis>
    objects that eliminate the need for a <emphasis>Singleton
    Pattern</emphasis> (<link linkend="GOF1995"
    xrefstyle="select:nopage">[GOF1995]</link>) implementation like you often
    use in Java code.</para>

    <para id="para_pattern_ideas_language_features2">The <emphasis>Iterator
    Pattern</emphasis> (<link linkend="GOF1995"
    xrefstyle="select:nopage">[GOF1995]</link>) is so pervasive in programming
    that most languages include iteration mechanisms for any type that can be
    treated like a collection. For example, in Scala you can iterate through
    the characters in a <literal>String</literal> with
    <literal>foreach</literal>:<indexterm>
        <primary>Iterator Pattern</primary>
      </indexterm></para>

    <screen>"Programming Scala" foreach {c =&gt; println(c)}</screen>

    <para id="para_pattern_ideas_language_features_string_foreach">Actually,
    in this case, an implicit conversion is invoked to convert the
    <literal>java.lang.String</literal> to a <literal>RichString</literal>,
    which has the <literal>foreach</literal> method. That’s an example of the
    pattern called <emphasis>pimp my library</emphasis>, which we saw in <xref
    linkend="ImplicitConversions" />.</para>

    <para id="para_pattern_ideas_language_better_alternatives">Other common
    patterns have better alternatives in Scala. We’ll discuss a better
    alternative to the <emphasis>Visitor Pattern</emphasis> (<link
    linkend="GOF1995" xrefstyle="select:nopage">[GOF1995]</link>) in a
    moment.</para>

    <para id="para_other_patterns_useful">Finally, still other patterns can be
    implemented in Scala and remain very useful. For example, the
    <emphasis>Observer Pattern</emphasis> that we discussed earlier in this
    chapter and in <xref linkend="Traits" /> is a very useful pattern for many
    design problems. It can be implemented very elegantly using mixin
    composition.<indexterm>
        <primary>Observer Pattern</primary>
      </indexterm></para>

    <para id="para_wont_discuss_all_patterns">We won’t discuss all the well
    known patterns, such as those in <link linkend="GOF1995"
    xrefstyle="select:nopage">[GOF1995]</link>. A number of the GOF patterns
    are discussed at <link linkend="ScalaWikiPatterns"
    xrefstyle="select:nopage">[ScalaWiki:Patterns]</link>, along with other
    patterns that are somewhat specific to Scala. Instead, we’ll discuss a few
    illustrative examples. We’ll start by discussing a replacement for the
    <emphasis>Visitor Pattern</emphasis> that uses functional <phrase
    role="keep-together">idioms</phrase> and implicit conversions. Then we’ll
    discuss a powerful way of implementing <emphasis>dependency
    injection</emphasis> in Scala using the <emphasis>Cake
    Pattern</emphasis>.</para>

    <sect2 id="VisitorAlternativeInScala">
      <title>The Visitor Pattern: A Better Alternative</title>

      <para id="para_visitor_pattern_description">The Visitor Pattern solves
      the problem of adding a new operation to a class hierarchy without
      editing the source code for the classes in the hierarchy. For a number
      of practical reasons, it may not be feasible or desirable to edit the
      hierarchy to support the new operation.<indexterm class="startofrange"
          id="ch13_VisitorPattern">
          <primary>Visitor Pattern, alternative to</primary>
        </indexterm><indexterm class="startofrange"
          id="ch13_designpatternVisitor">
          <primary>design patterns</primary>

          <secondary>alternative to Visitor Pattern</secondary>
        </indexterm></para>

      <para id="para_let_s_look_at_an_example_of_th">Let’s look at an example
      of the pattern using the <literal>Shape</literal> class hierarchy we
      have used previously. We’ll start with the case class version from <xref
      linkend="CaseClasses" />:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AdvOOP/shapes/shapes-case.scala

package shapes {
  case class Point(x: Double, y: Double)

  abstract class Shape() {
    def draw(): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape() {
    def draw() = println("Circle.draw: " + this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
      extends Shape() {
    def draw() = println("Rectangle.draw: " + this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
      extends Shape() {
    def draw() = println("Triangle.draw: " + this)
  }
}</programlisting>

      <para id="para_suppose_we_don_t_want_the_dra">Suppose we don’t want the
      <literal>draw</literal> method in the classes. This is a reasonable
      design choice, since the drawing method will be highly dependent on the
      particular context of use, such as details of the graphics libraries on
      the platforms the application will run on. For greater reusability, we
      would like drawing to be an operation we decouple from the shapes
      themselves.</para>

      <para id="para_first_we_refactor_the_shape_">First, we refactor the
      <literal>Shape</literal> hierarchy to support the Visitor Pattern,
      following the example in <link linkend="GOF1995"
      xrefstyle="select:nopage">[GOF1995]</link>:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-visitor.scala

package shapes {
  trait ShapeVisitor {
    def visit(circle: Circle): Unit
    def visit(rect: Rectangle): Unit
    def visit(tri: Triangle): Unit
  }

  case class Point(x: Double, y: Double)

  sealed abstract class Shape() {
    def accept(visitor: ShapeVisitor): Unit
  }

  case class Circle(center: Point, radius: Double) extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
        extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }

  case class Triangle(point1: Point, point2: Point, point3: Point)
        extends Shape() {
    def accept(visitor: ShapeVisitor) = visitor.visit(this)
  }
}</programlisting>

      <para id="para_first_we_define_a_shapevisit">We define a
      <literal>ShapeVisitor</literal> trait, which has one method for each
      concrete class in the hierarchy, e.g., <literal>visit(circle:
      Circle)</literal>. Each such method takes one parameter of the
      corresponding type to visit. Concrete derived classes will implement
      each method to do the appropriate operation for the particular type
      passed in.</para>

      <para id="para_the_visitor_pattern_requires_a">The Visitor Pattern
      requires a one-time modification to the class hierarchy. An overridden
      method named <literal>accept</literal> must be added, which takes a
      <literal>Visitor</literal> parameter. This method must be overridden for
      each class. It calls the corresponding method defined on the
      <literal>visitor</literal> instance, passing <literal>this</literal> as
      the argument.</para>

      <para id="para_finally_note_that_we_declared">Finally, note that we
      declared <literal>Shape</literal> to be <literal>sealed</literal>. It
      won’t help us prevent some bugs in the Visitor Pattern implementation,
      but it will prove useful shortly.</para>

      <para id="para_here_is_a_concrete_visitor_tha">Here is a concrete
      visitor that supports our original <literal>draw</literal>
      operation:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-visitor.scala

package shapes {
  class ShapeDrawingVisitor extends ShapeVisitor {
    def visit(circle: Circle): Unit =
      println("Circle.draw: " + circle)

    def visit(rect: Rectangle): Unit =
      println("Rectangle.draw: " + rect)

    def visit(tri: Triangle): Unit =
      println("Triangle.draw: " + tri)
  }
}</programlisting>

      <para id="para_for_each_visitx_method_it_">For each
      <literal>visit</literal> method, it “draws” the <literal>Shape</literal>
      instance appropriately. Finally, here is a script that exercises the
      code:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-visitor-script.scala

import shapes._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

val shapesDrawer = new ShapeDrawingVisitor
list foreach { _.accept(shapesDrawer) }</programlisting>

      <para id="shape-hier-draw-visitor-script-output">It produces the
      following output:</para>

      <screen>Circle.draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</screen>

      <para id="para_visitor_has_been_criticized_fo">Visitor has been
      criticized for being somewhat inelegant and for breaking the
      <emphasis>Open-Closed Principle</emphasis> (OCP; see <link
      linkend="Martin2003" xrefstyle="select:nopage">[Martin2003]</link>),
      because if the hierarchy changes, you are forced to edit (and test and
      redeploy) <emphasis>all</emphasis> the visitors for that hierarchy. Note
      that every <literal>ShapeVisitor</literal> trait has methods that
      hardcode information about every <literal>Shape</literal> derived type.
      These kinds of changes are also error-prone.<indexterm>
          <primary>Open-Closed Principle (OCP)</primary>

          <secondary>violation by Visitor Pattern</secondary>
        </indexterm></para>

      <para id="para_visitor_pattern_alt_ruby_open_types">In languages with
      “open types,” like Ruby, an alternative to the Visitor Pattern is to
      create a new source file that reopens all the types in the hierarchy and
      inserts an appropriate method implementation in each one. No
      modifications to the original source code are required.</para>

      <para id="para_scala_does_not_support_open_ty">Scala does not support
      open types, of course, but it offers a few alternatives. The first
      approach we’ll discuss combines pattern matching with implicit
      conversions. Let’s begin by refactoring the
      <literal>ShapeVisitor</literal> code to remove the Visitor Pattern
      logic:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes.scala

package shapes2 {
  case class Point(x: Double, y: Double)

  sealed abstract class Shape()

  case class Circle(center: Point, radius: Double) extends Shape()

  case class Rectangle(lowerLeft: Point, height: Double, width: Double)
      extends Shape()

  case class Triangle(point1: Point, point2: Point, point3: Point)
      extends Shape()
}</programlisting>

      <para id="para_if_we_would_like_to_invoke_dr">If we would like to invoke
      <literal>draw</literal> as a method on any <literal>Shape</literal>,
      then we will have to use an implicit conversion to a wrapper class with
      the <literal>draw</literal> method:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-implicit.scala

package shapes2 {
  class ShapeDrawer(val shape: Shape) {
    def draw = shape match {
      case c: Circle    =&gt; println("Circle.draw: " + c)
      case r: Rectangle =&gt; println("Rectangle.draw: " + r)
      case t: Triangle  =&gt; println("Triangle.draw: " + t)
    }
  }

  object ShapeDrawer {
    implicit def shape2ShapeDrawer(shape: Shape) = new ShapeDrawer(shape)
  }
}</programlisting>

      <para id="para_instances_of_shapedrawer_hol">Instances of
      <literal>ShapeDrawer</literal> hold a <literal>Shape</literal> object.
      When <literal>draw</literal> is called, the shape is pattern matched
      based on its type to determine the appropriate way to draw it.</para>

      <para id="para_a_companion_object_declares_an">A companion object
      declares an implicit conversion that wraps a <literal>Shape</literal> in
      a <literal>ShapeDrawer</literal>.</para>

      <para id="para_implicit_script_exercises_code">This script exercises the
      code:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-implicit-script.scala

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

import shapes2.ShapeDrawer._

list foreach { _.draw }</programlisting>

      <para id="para_same_output_as_visitor">It produces the same output as
      the example using the Visitor Pattern.</para>

      <para id="para_this_implementation_shares_a_l">This implementation of
      <literal>ShapeDrawer</literal> has some similarities with the Visitor
      Pattern, but it is more concise, elegant, and requires no code
      modifications to the original <literal>Shape</literal> hierarchy.</para>

      <para id="para_the_implementation_of_shapedr">Technically, the
      implementation has the same OCP issue as the Visitor Pattern. Changing
      the <literal>Shape</literal> hierarchy requires a change to the pattern
      matching expression. However, the required changes are isolated to one
      place and they are more succinct. In fact, all the logic for drawing is
      now contained in one place, rather than separated into
      <literal>draw</literal> methods in each <literal>Shape</literal> class
      and potentially scattered across different files. Note that because we
      <literal>sealed</literal> the hierarchy, a compilation error in
      <literal>draw</literal> will occur if we forget to change it when the
      hierarchy changes.</para>

      <para id="para_if_we_don_t_like_the_pattern_m">If we don’t like the
      pattern matching in the draw method, we could implement a separate
      “drawer” class and a separate implicit conversion for each
      <literal>Shape</literal> class. That would allow us to keep each shape
      drawing operation in a separate file, for modularity, with the drawback
      of more code and files to manage.</para>

      <para id="para_if_on_the_other_hand_we_don_">If, on the other hand, we
      don’t care about using the object-oriented <literal>shape.draw</literal>
      syntax, we could eliminate the implicit conversion and do the same
      pattern matching that is done in <literal>ShapeDrawer.draw</literal>.
      This approach could be simpler, especially when the extra behavior can
      be isolated to one place. Indeed, this approach would be a conventional
      functional approach, as illustrated in the following script:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-pattern-script.scala

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(Circle(p00, 5.0),
                Rectangle(p00, 2.0, 3.0),
                Triangle(p00, p10, p01))

val drawText = (shape:Shape) =&gt; shape match {
  case circle: Circle =&gt;  println("Circle.draw: " + circle)
  case rect: Rectangle =&gt; println("Rectangle.draw: " + rect)
  case tri: Triangle =&gt;   println("Triangle.draw: " + tri)
}

def pointToXML(point: Point) =
  "&lt;point&gt;&lt;x&gt;%.1f&lt;/x&gt;&lt;y&gt;%.1f&lt;/y&gt;&lt;/point&gt;".format(point.x, point.y)

val drawXML = (shape:Shape) =&gt; shape match {
  case circle: Circle =&gt;  {
    println("&lt;circle&gt;")
    println("  &lt;center&gt;" + pointToXML(circle.center) + "&lt;/center&gt;")
    println("  &lt;radius&gt;" + circle.radius + "&lt;/radius&gt;")
    println("&lt;/circle&gt;")
  }
  case rect: Rectangle =&gt; {
    println("&lt;rectangle&gt;")
    println("  &lt;lower-left&gt;" + pointToXML(rect.lowerLeft) + "&lt;/lower-left&gt;")
    println("  &lt;height&gt;" + rect.height + "&lt;/height&gt;")
    println("  &lt;width&gt;" + rect.width + "&lt;/width&gt;")
    println("&lt;/rectangle&gt;")
  }
  case tri: Triangle =&gt; {
    println("&lt;triangle&gt;")
    println("  &lt;point1&gt;" + pointToXML(tri.point1) + "&lt;/point1&gt;")
    println("  &lt;point2&gt;" + pointToXML(tri.point2) + "&lt;/point2&gt;")
    println("  &lt;point3&gt;" + pointToXML(tri.point3) + "&lt;/point3&gt;")
    println("&lt;/triangle&gt;")
  }
}

list foreach (drawText)
println("")
list foreach (drawXML)</programlisting>

      <para id="para_we_define_to__function_values_">We define two
      <emphasis>function values</emphasis> and assign them to variables,
      <literal>drawText</literal> and <literal>drawXML</literal>,
      respectively. Each <literal>drawX</literal> function takes an input
      <literal>Shape</literal>, pattern matches it to the correct type, and
      “draws” it appropriately. We also define a helper method to convert a
      <literal>Point</literal> to XML in the format we want.</para>

      <para id="para_finally_we_loop_through_the_l">Finally, we loop through
      the list of shapes twice. The first time, we pass
      <literal>drawText</literal> as the argument to
      <literal>foreach</literal>. The second time, we pass
      <literal>drawXML</literal>. Running this script reproduces the previous
      results for “text” output, followed by new XML output:</para>

      <screen>Circle.draw: Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

&lt;circle&gt;
  &lt;center&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/center&gt;
  &lt;radius&gt;5.0&lt;/radius&gt;
&lt;/circle&gt;
&lt;rectangle&gt;
  &lt;lower-left&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/lower-left&gt;
  &lt;height&gt;2.0&lt;/height&gt;
  &lt;width&gt;3.0&lt;/width&gt;
&lt;/rectangle&gt;
&lt;triangle&gt;
  &lt;point1&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point1&gt;
  &lt;point2&gt;&lt;point&gt;&lt;x&gt;1.0&lt;/x&gt;&lt;y&gt;0.0&lt;/y&gt;&lt;/point&gt;&lt;/point2&gt;
  &lt;point3&gt;&lt;point&gt;&lt;x&gt;0.0&lt;/x&gt;&lt;y&gt;1.0&lt;/y&gt;&lt;/point&gt;&lt;/point3&gt;
&lt;/triangle&gt;</screen>

      <para id="para_this_is_a_powerful_way_to_add_">Any of these idioms
      provides a powerful way to add additional, special-purpose functionality
      that may not be needed “everywhere” in the application. It’s a great way
      to remove methods from objects that don’t <emphasis>absolutely have to
      be there</emphasis>.</para>

      <para id="para_a_drawing_application_should_o">A drawing application
      should only need to know how to do input and output of shapes in one
      place, whether it is serializing shapes to a textual format for storage
      or rendering shapes to the screen. We can separate the drawing “concern”
      from the rest of the <phrase role="keep-together">functionality</phrase>
      for shapes, and we can isolate the logic for drawing, all without
      modifying the <literal>Shape</literal> hierarchy or any of the places
      where it is used in the application. The Visitor Pattern gives us some
      of this separation and isolation, but we are required to add visitor
      implementation logic to each <literal>Shape</literal>.</para>

      <para id="para_let_s_conclude_with_a_discussi">Let’s conclude with a
      discussion of one other option that may be applicable in some contexts.
      If you have complete control over how shapes are constructed, e.g.,
      through a single factory, you can modify the factory to mix in traits
      that add new behaviors as needed:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-factory.scala

package shapes2 {
  trait Drawing {
    def draw: Unit
  }

  trait CircleDrawing extends Drawing {
    def draw = println("Circle.draw " + this)
  }
  trait RectangleDrawing extends Drawing {
    def draw = println("Rectangle.draw: " + this)
  }
  trait TriangleDrawing extends Drawing {
    def draw = println("Triangle.draw: " + this)
  }

  object ShapeFactory {
    def makeShape(args: Any*) = args(0) match {
      case "circle" =&gt; {
        val center = args(1).asInstanceOf[Point]
        val radius = args(2).asInstanceOf[Double]
        new Circle(center, radius) with CircleDrawing
      }
      case "rectangle" =&gt; {
        val lowerLeft = args(1).asInstanceOf[Point]
        val height    = args(2).asInstanceOf[Double]
        val width     = args(3).asInstanceOf[Double]
        new Rectangle(lowerLeft, height, width) with RectangleDrawing
      }
      case "triangle" =&gt; {
        val p1 = args(1).asInstanceOf[Point]
        val p2 = args(2).asInstanceOf[Point]
        val p3 = args(3).asInstanceOf[Point]
        new Triangle(p1, p2, p3) with TriangleDrawing
      }
      case x =&gt; throw new IllegalArgumentException("unknown: " + x)
    }
  }
}</programlisting>

      <para id="para_we_define_a_drawing_trait_an">We define a
      <literal>Drawing</literal> trait and concrete derived traits for each
      <literal>Shape</literal> class. Then we define a
      <literal>ShapeFactory</literal> object with a
      <literal>makeShape</literal> factory method that takes a variable-length
      list of arguments. A match is done on the first argument to determine
      which shape to make. The trailing arguments are cast to appropriate
      types to construct each shape, with the corresponding drawing trait
      mixed in. A similar factory could be written for adding draw methods
      that output XML. (The variable-length list of <literal>Any</literal>
      values, heavy use of casting, and minimal error checking were done for
      expediency. A real implementation could minimize these “hacks.”)</para>

      <para id="para_factory_script">The following script exercises the
      factory:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/patterns/shapes-drawing-factory-script.scala

import shapes2._

val p00 = Point(0.0, 0.0)
val p10 = Point(1.0, 0.0)
val p01 = Point(0.0, 1.0)

val list = List(
    ShapeFactory.makeShape("circle", p00, 5.0),
    ShapeFactory.makeShape("rectangle", p00, 2.0, 3.0),
    ShapeFactory.makeShape("triangle", p00, p10, p01))

list foreach { _.draw }</programlisting>

      <para id="para_factory_script_output">Compared to our previous scripts,
      the list of shapes is now constructed using the factory. When we want to
      draw the shapes in the <literal>foreach</literal> statement, we simply
      call <literal>draw</literal> on each shape. As before, the output is the
      following:</para>

      <screen>Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))</screen>

      <para id="para_there_is_one_subtlety_with_thi">There is one subtlety
      with this approach that we should discuss. Notice that the script never
      assigns the result of a <literal>ShapeFactory.makeShape</literal> call
      to a <literal>Shape</literal> variable. If it did that, it would not be
      able to call <literal>draw</literal> on the instance!</para>

      <para id="para_in_this_script_scala_inferred">In this script, Scala
      inferred a slightly different common supertype for the parameterized
      list. You can see that type if you use the <literal>:load</literal>
      command to load the script while inside the interactive
      <literal>scala</literal> interpreter, as in the following
      session:</para>

      <screen>$ scala -cp ...
Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; :load design-patterns/shapes-drawing-factory-script.scala
Loading design-patterns/shapes-drawing-factory-script.scala...
import shapes2._
p00: shapes2.Point = Point(0.0,0.0)
p10: shapes2.Point = Point(1.0,0.0)
p01: shapes2.Point = Point(0.0,1.0)
list: List[Product with shapes2.Shape with shapes2.Drawing] = List(...)
Circle.draw Circle(Point(0.0,0.0),5.0)
Rectangle.draw: Rectangle(Point(0.0,0.0),2.0,3.0)
Triangle.draw: Triangle(Point(0.0,0.0),Point(1.0,0.0),Point(0.0,1.0))

scala&gt;</screen>

      <para id="para_notice_the_line_that_begins_l">Notice the line that
      begins <literal>list: List[Product with shapes2.Shape with
      shapes2.Draw⁠ing]</literal>. This line was printed after the list of
      shapes was parsed. The inferred common supertype is <literal>Product
      with shapes2.Shape with shapes2.Drawing</literal>.
      <literal>Product</literal> is a trait mixed into all case classes, such
      as our concrete subclasses of <literal>Shape</literal>. Recall that to
      avoid case-class inheritance, <literal>Shape</literal> itself is not a
      case class. (See <xref linkend="CaseClasses" /> for details on why case
      class inheritance should be avoided.) So, our common supertype is an
      anonymous class that incorporates <literal>Shape</literal>,
      <literal>Product</literal>, and the <literal>Drawing</literal>
      trait.<indexterm>
          <primary>case classes</primary>

          <secondary>inheritance</secondary>
        </indexterm></para>

      <para id="para_if_you_want_to_assign_one_of_t">If you want to assign one
      of these drawable shapes to a variable and still be able to invoke
      <literal>draw</literal>, use a declaration like the following (shown as
      a continuation of the same interactive <literal>scala</literal>
      session):</para>

      <screen>scala&gt; val s: Shape with Drawing = ShapeFactory.makeShape("circle", p00, 5.0)
s: shapes2.Shape with shapes2.Drawing = Circle(Point(0.0,0.0),5.0)

scala&gt; s.draw
Circle.draw Circle(Point(0.0,0.0),5.0)

scala&gt;</screen>
    </sect2>

    <sect2 id="DependencyInjectionInScala">
      <title>Dependency Injection in Scala: The Cake Pattern</title>

      <para id="para_description_of_di"><emphasis>Dependency
      injection</emphasis> (DI), a form of <emphasis>inversion of
      control</emphasis> (IoC), is a powerful technique for resolving
      dependencies between “components” in larger applications. It supports
      minimizing the coupling between these components, so it is relatively
      easy to substitute different components for different
      circumstances.<indexterm>
          <primary>inversion of control (IoC)</primary>
        </indexterm><indexterm class="startofrange" id="ch13_DICakePattern">
          <primary>dependency injection (DI)</primary>

          <secondary>using Cake Pattern</secondary>
        </indexterm><indexterm class="startofrange"
          id="ch13_designpatternCAKE">
          <primary>design patterns</primary>

          <secondary>dependency injection (DI) implementation, Cake
          Pattern</secondary>
        </indexterm><indexterm class="endofrange"
      startref="ch13_designpatternVisitor"></indexterm><indexterm
      class="endofrange" startref="ch13_VisitorPattern"></indexterm></para>

      <para id="para_it_used_to_be_that_when_a_clie">It used to be that when a
      client object needed a database “accessor” object, for example, it would
      just instantiate the accessor itself. While convenient, this approach
      makes unit testing very difficult because you have to test with a real
      database. It also compromises reuse, for those alternative situations
      where another persistence mechanism (or none) is required. Inversion of
      control solves this problem by reversing responsibility for satisfying
      the dependency between the object and the database connection.</para>

      <para id="para_an_example_of_ioc_is_jndi_ins">An example of IoC is JNDI.
      Instead of instantiating an accessor object, the client object asks JDNI
      to provide one. The client doesn’t care what actual type of accessor is
      returned. Hence, the client object is no longer coupled to a concrete
      implementation of the dependency. It only depends on an appropriate
      <emphasis>abstraction</emphasis> of a persistence accessor, i.e., a Java
      interface or Scala trait.</para>

      <para id="para_dependency_injection_takes_ioc">Dependency injection
      takes IoC to its logical conclusion. Now the object does nothing to
      resolve the dependency. Instead, an external mechanism with system-wide
      knowledge “injects” the appropriate accessor object using a constructor
      argument or a setter method. This happens when the client is
      constructed. DI eliminates dependencies on IoC mechanisms in code (e.g.,
      no more JNDI calls) and keeps objects relatively simple, with minimal
      coupling to other objects.</para>

      <para id="para_back_to_unit_testing_it_is_pr">Back to unit testing, it
      is preferable to use a <emphasis>test double</emphasis> for heavyweight
      dependencies to minimize the overhead and other complications of
      testing. Our client object with a dependency on a database accessor
      object is a classic example. While unit testing the client, the overhead
      and complications of using a real database are prohibitive. Using a
      lightweight test double with hardcoded sample data provides simpler
      setup and tear down, faster execution, and predictable behavior from the
      data accessor dependency.</para>

      <para id="para_java_di">In Java, DI is usually done using an inversion
      of control container, like the Spring Framework (<link
      linkend="SpringFramework"
      xrefstyle="select:nopage">[SpringFramework]</link>), or a Java-API
      equivalent like Google’s Guice API (see <link linkend="Guice"
      xrefstyle="select:nopage">[Guice]</link>). These options can be used
      with Scala code, especially when you are introducing Scala into a mature
      Java environment.<indexterm>
          <primary>Java</primary>

          <secondary>DI (dependency injection)</secondary>
        </indexterm></para>

      <para id="para_the_cake_pattern_">However, Scala offers some unique
      options for implementing DI in Scala code, which are discussed by <link
      linkend="Boner2008b" xrefstyle="select:nopage">[Bonér2008b]</link>.
      We’ll discuss one of them, the <emphasis>Cake Pattern</emphasis>, which
      can replace or complement these other dependency injection mechanisms.
      We’ll see that it is similar to the implementation of the Observer
      Pattern we discussed earlier in this chapter, in <xref
      linkend="SelfTypeAnnotationsAndAbstractTypeMembers" />. The Cake Pattern
      was described by <link linkend="Odersky2005"
      xrefstyle="select:nopage">[Odersky2005]</link>, although it was given
      that name after that paper was published. <link linkend="Boner2008b"
      xrefstyle="select:nopage">[Bonér2008b]</link> also discusses
      alternatives.<indexterm class="startofrange" id="ch12_CakePattern">
          <primary>Cake Pattern</primary>
        </indexterm></para>

      <para id="para_let_s_build_a_simple_component">Let’s build a simple
      component model for an overly simplified Twitter client. We want a
      configurable UI, a configurable local cache of past tweets, and a
      configurable connection to the Twitter service itself. Each of these
      “components” will be specified separately, along with a client component
      that will function as the “middleware” that ties the application
      together. The client component will depend on the other components. When
      we create a concrete client, we’ll configure in the concrete pieces of
      the other components that we need:<indexterm class="startofrange"
          id="ch13_Twitterclient">
          <primary>Twitter client, component model for (example)</primary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/dep-injection/twitter-client.scala

package twitterclient
import java.util.Date
import java.text.DateFormat

class TwitterUserProfile(val userName: String) {
  override def toString = "@" + userName
}

case class Tweet(
  val tweeter: TwitterUserProfile,
  val message: String,
  val time: Date) {

  override def toString = "(" +
    DateFormat.getDateInstance(DateFormat.FULL).format(time) + ") " +
    tweeter + ": " + message
}

trait Tweeter {
  def tweet(message: String)
}

trait TwitterClientUIComponent {
  val ui: TwitterClientUI

  abstract class TwitterClientUI(val client: Tweeter) {
    def sendTweet(message: String) = client.tweet(message)
    def showTweet(tweet: Tweet): Unit
  }
}

trait TwitterLocalCacheComponent {
  val localCache: TwitterLocalCache

  trait TwitterLocalCache {
    def saveTweet(tweet: Tweet): Unit
    def history: List[Tweet]
  }
}

trait TwitterServiceComponent {
  val service: TwitterService

  trait TwitterService {
    def sendTweet(tweet: Tweet): Boolean
    def history: List[Tweet]
  }
}

trait TwitterClientComponent {
  self: TwitterClientUIComponent with
        TwitterLocalCacheComponent with
        TwitterServiceComponent =&gt;

  val client: TwitterClient

  class TwitterClient(val user: TwitterUserProfile) extends Tweeter {
    def tweet(msg: String) = {
      val twt = new Tweet(user, msg, new Date)
      if (service.sendTweet(twt)) {
        localCache.saveTweet(twt)
        ui.showTweet(twt)
      }
    }
  }
}</programlisting>

      <para id="para_the_first_class_twitteruserp">The first class,
      <literal>TwitterUserProfile</literal>, encapsulates a user’s profile,
      which we limit to the username. The second class is a case class,
      <literal>Tweet</literal>, that encapsulates a single “tweet” (a Twitter
      message, limited to 140 characters by the Twitter service). Besides the
      message string, it encapsulates the user who sent the tweet and the date
      and time when it was sent. We made this class a case class for the
      convenient support case classes provide for creating objects and pattern
      matching on them. We didn’t make the profile class a case class, because
      it is more likely to be used as the parent of more detailed profile
      classes.</para>

      <para id="para_next_is_the_tweeter_trait_th">Next is the
      <literal>Tweeter</literal> trait that declares one method,
      <literal>tweet</literal>. This trait is defined solely to eliminate a
      potential circular dependency between two components,
      <literal>TwitterClientComponent</literal> and
      <literal>TwitterClientUIComponent</literal>. All the components are
      defined next in the file.</para>

      <para id="para_there_are_four_components_">There are four components.
      Note that they are implemented as traits:<indexterm>
          <primary>traits</primary>

          <secondary>implementing components with</secondary>
        </indexterm><indexterm>
          <primary>components</primary>

          <secondary>implementing as traits</secondary>
        </indexterm></para>

      <itemizedlist>
        <listitem>
          <para><literal>TwitterClientUIComponent</literal>, for the UI</para>
        </listitem>

        <listitem>
          <para><literal>TwitterLocalCacheComponent</literal>, for the local
          cache of prior tweets</para>
        </listitem>

        <listitem>
          <para><literal>TwitterServiceComponent</literal>, for accessing the
          Twitter service</para>
        </listitem>

        <listitem>
          <para><literal>TwitterClientComponent</literal>, the client that
          pulls the pieces together</para>
        </listitem>
      </itemizedlist>

      <para id="para_they_all_have_a_similar_struct">They all have a similar
      structure. Each one declares a nested trait or class that encapsulates
      the component’s behavior. Each one also declares a
      <literal>val</literal> with one instance of the nested type.</para>

      <para id="para_java_packages_as_components">Often in Java, packages are
      informally associated with components. This is common in other
      languages, too, using their equivalent of a package, e.g., a module or a
      namespace. Here we define a more precise notion of a component, and a
      trait is the best vehicle for it, because traits are designed for mixin
      composition.</para>

      <para
      id="para__twitterclientuicomponent_dec"><literal>TwitterClientUIComponent</literal>
      declares a <literal>val</literal> named <literal>ui</literal> of the
      nested type <literal>TwitterClien⁠tUI</literal>. This class has a
      <literal>client</literal> field that must be initialized with a
      <literal>Tweeter</literal> instance. In fact, this instance will be a
      <literal>TwitterClient</literal> (defined in
      <literal>TwitterClientComponent</literal>), which extends
      <literal>Tweeter</literal>.</para>

      <para
      id="para__twitterclientui_has_two_meth"><literal>TwitterClientUI</literal>
      has two methods. The first is <literal>sendTweet</literal>, which is
      defined to call the <literal>client</literal> object. This method would
      be used by the UI to call the client when the user sends a new tweet.
      The second method, <literal>showTweet</literal>, goes the other
      direction. It is called whenever a new tweet is to be displayed, e.g.,
      from another user. It is abstract, pending the “decision” of the kind of
      UI to use.</para>

      <para id="para_similarly_twitterlocalcachec">Similarly,
      <literal>TwitterLocalCacheComponent</literal> declares
      <literal>TwitterLocalCache</literal> and an instance of it. Instances
      with this trait save tweets to the local persistent cache when
      <literal>saveTweet</literal> is called. You can retrieve the cached
      tweets with <literal>history</literal>.</para>

      <para
      id="para__twitterservicecomponent_is_v"><literal>TwitterServiceComponent</literal>
      is very similar. Its nested type has a method,
      <literal>sendTweet</literal>, that sends a new tweet to Twitter. It also
      has a <literal>history</literal> method that retrieves all the tweets
      for the current user.</para>

      <para id="para_finally_twitterclientcompone">Finally,
      <literal>TwitterClientComponent</literal> contains a concrete class,
      <literal>TwitterClient</literal>, that integrates the components. Its
      one <literal>tweet</literal> method sends new tweets to the Twitter
      service. If successful, it sends the tweet back to the UI and to the
      local persistent cache.</para>

      <para
      id="para__twitterclientcomponent_also_"><literal>TwitterClientComponent</literal>
      also has the following <emphasis>self-type
      annotation</emphasis>:<indexterm>
          <primary>self-type annotations</primary>

          <secondary>TwitterClientComponent (example)</secondary>
        </indexterm></para>

      <programlisting linenumbering="unnumbered">self: TwitterClientUIComponent with
      TwitterLocalCacheComponent with
      TwitterServiceComponent =&gt;</programlisting>

      <para id="para_the_effect_of_this_declaration">The effect of this
      declaration is to say that any concrete
      <literal>TwitterClientComponent</literal> must also behave like these
      other three components, thereby composing all the components into one
      client application instance. This composition will be realized by mixing
      in these components, which are traits, when we create concrete clients,
      as we will see shortly.</para>

      <para id="para_the_self_type_annotation_also_">The self-type annotation
      also means we can reference the <literal>vals</literal> declared in
      these components. Notice how <literal>TwitterClient.tweet</literal>
      references the <literal>service</literal>,
      <literal>localCache</literal>, and the <literal>ui</literal> as if they
      are variables in the scope of this method. In fact, they
      <emphasis>are</emphasis> in scope, because of the self-type
      annotation.</para>

      <para id="para_notice_also_that_all_the_metho">Notice also that all the
      methods that call other components are concrete. Those inter-component
      relationships are fully specified. The abstractions are directed
      “outward,” toward the graphical user interface, a caching mechanism,
      etc.</para>

      <para id="para_let_s_now_define_a_concrete_tw">Let’s now define a
      concrete Twitter client that uses a textual (command-line) UI, an
      in-memory local cache, and fakes the interaction with the Twitter
      service:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/dep-injection/twitter-text-client.scala

package twitterclient

class TextClient(userProfile: TwitterUserProfile)
    extends TwitterClientComponent
    with TwitterClientUIComponent
    with TwitterLocalCacheComponent
    with TwitterServiceComponent {

  // From TwitterClientComponent:

  val client = new TwitterClient(userProfile)

  // From TwitterClientUIComponent:

  val ui = new TwitterClientUI(client) {
    def showTweet(tweet: Tweet) = println(tweet)
  }

  // From TwitterLocalCacheComponent:

  val localCache = new TwitterLocalCache {
    private var tweets: List[Tweet] = Nil

    def saveTweet(tweet: Tweet) = tweets ::= tweet

    def history = tweets
  }

  // From TwitterServiceComponent

  val service = new TwitterService() {
    def sendTweet(tweet: Tweet) = {
      println("Sending tweet to Twitter HQ")
      true
    }
    def history = List[Tweet]()
  }
}</programlisting>

      <para id="para_our_textclient_concrete_clas">Our
      <literal>TextClient</literal> concrete class extends
      <literal>TwitterClientComponent</literal> and mixes in the three other
      components. By mixing in the other components, we satisfy the self-type
      annotations in <literal>TwitterClientComponent</literal>. In other
      words, <literal>TextClient</literal> <emphasis>is</emphasis> also a
      <literal>TwitterClien⁠tUIComponent</literal>, a
      <literal>TwitterLocalCacheComponent</literal>, and a
      <literal>TwitterServiceComponent</literal>, in addition to being a
      <literal>TwitterClientComponent</literal>.</para>

      <para id="para_the_textclient_constructor_t">The
      <literal>TextClient</literal> constructor takes one argument, a user
      profile, which will be passed onto the nested client class.</para>

      <para
      id="para__textclient_has_to_define_fou"><literal>TextClient</literal>
      has to define four <literal>vals</literal>, one from
      <literal>TwitterClientComponent</literal> and three from the other
      mixins. For the <literal>client</literal>, it simply creates a new
      <literal>TwitterClient</literal>, passing it the
      <literal>userProfile</literal>.</para>

      <para id="para_for_the_ui_it_instantiates_">For the
      <literal>ui</literal>, it instantiates an anonymous class derived from
      <literal>TwitterClientUI</literal>. It defines
      <literal>showTweet</literal> to print out the tweet.</para>

      <para id="para_for_the_localcache_it_insta">For the
      <literal>localCache</literal>, it instantiates an anonymous class
      derived from <literal>TwitterLocalC⁠ache</literal>. It keeps the history
      of tweets in a <literal>List</literal>.</para>

      <para id="para_finally_for_the_service_it">Finally, for the
      <literal>service</literal>, it instantiates an anonymous class derived
      from <literal>TwitterSer⁠vice</literal>. This “fake” defines
      <literal>sendTweet</literal> to print out a message and to return an
      empty list for the history.</para>

      <para id="para_let_s_try_our_client_with_the_">Let’s try our client with
      the following script:</para>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/dep-injection/twitter-text-client-script.scala

import twitterclient._

val client = new TextClient(new TwitterUserProfile("BuckTrends"))
client.ui.sendTweet("My First Tweet. How's this thing work?")
client.ui.sendTweet("Is this thing on?")
client.ui.sendTweet("Heading to the bathroom...")
println("Chat history:")
client.localCache.history.foreach {t =&gt; println(t)}</programlisting>

      <para id="para_may_3">We instantiate a <literal>TextClient</literal> for
      the user “BuckTrends.” Old Buck sends three insightful tweets through
      the UI. We finish by reprinting the history of tweets, in reverse order,
      that are cached locally. Running this script yields output like the
      following:</para>

      <screen>Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: My First Tweet. How's this thing work?
Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: Is this thing on?
Sending tweet to Twitter HQ
(Sunday, May 3, 2009) @BuckTrends: Heading to the bathroom...
Chat history:
(Sunday, May 3, 2009) @BuckTrends: Heading to the bathroom...
(Sunday, May 3, 2009) @BuckTrends: Is this thing on?
(Sunday, May 3, 2009) @BuckTrends: My First Tweet. How's this thing work?</screen>

      <para id="para_your_date_will_vary_of_course">Your date will vary, of
      course. Recall that the <literal>Sending tweet to Twitter HQ</literal>
      line is printed by the fake service.</para>

      <para id="para_to_recap_each_major_component">To recap, each major
      component in the Twitter client was declared in its own trait, with a
      nested type for the component’s fields and methods. The client component
      declared its dependencies on the other components through a self-type
      annotation. The concrete client class mixed in those components and
      defined each component <literal>val</literal> to be an appropriate
      subtype of the corresponding abstract classes and traits that were
      declared in the components.</para>

      <para id="para_other_di_approaches">We get type-safe “wiring” together
      of components, a flexible component model, and we did it all in Scala
      code! There are alternatives to the Cake Pattern for implementing
      dependency injection in Scala. See <link linkend="Boner2008b"
      xrefstyle="select:nopage">[Bonér2008b]</link> for other
      examples.<indexterm class="endofrange"
      startref="ch13_designpatternCAKE"></indexterm><indexterm
      class="endofrange" startref="ch13_Twitterclient"></indexterm><indexterm
      class="endofrange" startref="ch13_DICakePattern"></indexterm><indexterm
      class="endofrange" startref="ch12_CakePattern"></indexterm><indexterm
      class="endofrange"
      startref="ch13_appsdesignpatterns"></indexterm><indexterm
      class="endofrange" startref="ch13_designpatterns"></indexterm></para>
    </sect2>
  </sect1>

  <sect1 id="DesignByContractExample">
    <title>Better Design with Design By Contract</title>

    <para id="para_we_ll_conclude_this_chapter_wi">We’ll conclude this chapter
    with a look at an approach to programming called <emphasis>Design by
    Contract</emphasis> (<link linkend="DesignByContract"
    xrefstyle="select:nopage">[DesignByContract]</link>), which was developed
    by Bertrand Meyer for the Eiffel language (see <link linkend="Eiffel"
    xrefstyle="select:nopage">[Eiffel]</link>, <link linkend="Hunt2000"
    xrefstyle="select:nopage">[Hunt2000]</link>, and <xref
    linkend="Traits" />). Design by Contract has been around for about 20
    years. It has fallen somewhat out of favor, but it is still very useful
    for thinking about design.<indexterm>
        <primary>Meyer, Bertrand</primary>
      </indexterm><indexterm>
        <primary>Eiffel language</primary>
      </indexterm><indexterm>
        <primary>Design by Contract</primary>
      </indexterm><indexterm>
        <primary>application design</primary>

        <secondary>Design by Contract</secondary>
      </indexterm></para>

    <para id="para_when_considering_the_contract">When considering the
    “contract” of a module, you can specify three types of conditions. First,
    you can specify the required inputs for a module to successfully perform a
    service (e.g., when a method is called). These constraints are called
    <emphasis>preconditions</emphasis>. They can also include system
    requirements, e.g., global data (which you should normally avoid, of
    course).<indexterm>
        <primary>contractual constraints in Design by Contract</primary>
      </indexterm><indexterm>
        <primary>modules</primary>

        <secondary>contract of</secondary>
      </indexterm><indexterm>
        <primary>preconditions</primary>
      </indexterm></para>

    <para id="para_you_can_also_specify_the_resul">You can also specify the
    results the module guarantees to deliver, the
    <emphasis>postconditions</emphasis>, if the preconditions were
    satisfied.<indexterm>
        <primary>postconditions</primary>
      </indexterm></para>

    <para id="para_finally_you_can_specify__inva">Finally, you can specify
    <emphasis>invariants</emphasis> that must be true before and after an
    invocation of a service.<indexterm>
        <primary>invariants</primary>
      </indexterm></para>

    <para id="para_the_specific_addition_that_des">The specific addition that
    Design by Contract brings is the idea that these contractual constraints
    should be specified as executable code, so they can be enforced
    automatically at runtime, but usually only during testing.</para>

    <para id="para_a_constraint_failure_should_te">A constraint failure should
    terminate execution immediately, forcing you to fix the bug. Otherwise, it
    is very easy to ignore these bugs.</para>

    <para id="para_scala_doesn_t_provide_explicit">Scala doesn’t provide
    explicit support for Design by Contract, but there are several methods in
    <literal>Predef</literal> that can be used for this purpose. The following
    example shows how to use <literal>require</literal> and
    <literal>assume</literal> for contract enforcement:<indexterm>
        <primary>Predef object</primary>

        <secondary>require and assume methods, using for contract
        enforcement</secondary>
      </indexterm></para>

    <?dbfo-need height=”1in”
?>

    <programlisting linenumbering="unnumbered">// code-examples/AppDesign/design-by-contract/bank-account.scala

class BankAccount(val balance: Double) {
  require(balance &gt;= 0.0)
  def debit(amount: Double) = {
    require(amount &gt; 0.0, "The debit amount must be &gt; 0.0")
    assume(balance - amount &gt; 0.0, "Overdrafts are not permitted")
    new BankAccount(balance - amount)
  }
  def credit(amount: Double) = {
    require(amount &gt; 0.0, "The credit amount must be &gt; 0.0")
    new BankAccount(balance + amount)
  }
}</programlisting>

    <para id="para_class_bankaccount_uses_requ">The class
    <literal>BankAccount</literal> uses <literal>require</literal> to ensure
    that a non-negative balance is specified for the constructor. Similarly,
    the <literal>debit</literal> and <literal>credit</literal> methods use
    <literal>require</literal> to ensure that a positive
    <literal>amount</literal> is specified.</para>

    <para id="para_the_following_specification_co">The specification in <xref
    linkend="design-by-contract-example-spec" /> confirms that the “contract”
    is obeyed.<indexterm>
        <primary>Design by Contract</primary>

        <secondary>BankAccountSpec object (example)</secondary>
      </indexterm></para>

    <example id="design-by-contract-example-spec">
      <title>design-by-contract/bank-account-spec.scala: Testing the
      contract</title>

      <programlisting linenumbering="unnumbered">// code-examples/AppDesign/design-by-contract/bank-account-spec.scala

import org.specs._

object BankAccountSpec extends Specification {
  "Creating an account with a negative balance" should {
    "fail because the initial balance must be positive." in {
      new BankAccount(-100.0) must throwAn[IllegalArgumentException]
    }
  }

  "Debiting an account" should {
    "fail if the debit amount is &lt; 0" in {
      val account = new BankAccount(100.0)
      (account.debit(-10.0)) must throwAn[IllegalArgumentException]
    }
  }

  "Debiting an account" should {
    "fail if the debit amount is &gt; the balance" in {
      val account = new BankAccount(100.0)
      (account.debit(110.0)) must throwAn[AssertionError]
    }
  }
}</programlisting>
    </example>

    <para id="para_if_we_attempt_to_create_a_ban">If we attempt to create a
    <literal>BankAccount</literal> with a negative balance, an
    <literal>IllegalArgumentEx⁠ception</literal> is thrown. Similarly, the
    same kind of exception is thrown if the debit amount is less than zero.
    Both conditions are enforced using <literal>require</literal>, which
    throws an <literal role="keep-together">IllegalArgumentException</literal>
    when the condition specified is false.</para>

    <para id="para_the_assume_method_which_is_">The <literal>assume</literal>
    method, which is used to ensure that overdrafts don’t occur, is
    functionally almost identical to <literal>require</literal>. It throws an
    <literal>AssertionError</literal> instead of an <literal
    role="keep-together">IllegalArgumentException</literal>.</para>

    <para id="para_both_require_and_assume_co">Both <literal>require</literal>
    and <literal>assume</literal> come in two forms: one that takes just a
    boolean condition, and the other that also takes an error message
    string.</para>

    <para id="para_there_is_also_an_assert_pair">There is also an
    <literal>assert</literal> pair of methods that behave identically to
    <literal>assume</literal>, except for a slight change in the generated
    failure message. Pick <literal>assert</literal> or
    <literal>assume</literal> depending on which of these “names” provides a
    better conceptual fit in a given context.</para>

    <para id="para__predef_also_defines_an_ensu"><literal>Predef</literal>
    also defines an <literal>Ensuring</literal> class that can be used to
    generalize the capabilities of these methods. <literal>Ensuring</literal>
    has one overloaded method, <literal>ensure</literal>, some versions of
    which take a function literal as a “predicate.”<indexterm>
        <primary>Ensuring class</primary>
      </indexterm></para>

    <para id="para_a_drawback_of_using_these_meth">A drawback of using these
    methods and <literal>Ensuring</literal> is that you can’t disable these
    checks in production. It may <emphasis>not</emphasis> be acceptable to
    terminate abruptly if a condition fails, although if the system is allowed
    to “limp along,” it might crash later and the problem would be harder to
    debug. The performance overhead may be another reason to disable contract
    checks at runtime.</para>

    <para id="para_these_days_the_goals_of_desig">These days, the goals of
    Design by Contract are largely met by Test-Driven Development (TDD).
    However, thinking in terms of Design by Contract will complement the
    design benefits of TDD. If you decide to use Design by Contract in your
    code, consider creating a custom module that lets you disable the tests
    for production code.<indexterm>
        <primary>TDD (Test-Driven Development)</primary>

        <secondary>Design by Contract and</secondary>
      </indexterm></para>
  </sect1>

  <sect1 id="_recap_and_what_s_next_4">
    <title>Recap and What’s Next</title>

    <para id="para_we_learned_a_number_of_pragmat">We learned a number of
    pragmatic techniques, patterns, and idioms for effective application
    development using Scala.</para>

    <para id="para_good_tools_and_libraries_are_i">Good tools and libraries
    are important for building applications in any language. The next chapter
    provides more details about Scala’s command-line tools, describes the
    state of Scala IDE support, and introduces you to some important Scala
    libraries.<indexterm class="endofrange"
    startref="ch13_appdesign"></indexterm></para>
  </sect1>
</chapter>