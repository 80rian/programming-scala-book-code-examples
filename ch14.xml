<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="ScalaToolsLibs">
<title>Scala Tools, Libraries and IDE Support</title>
<para id="para_in_the_last_chapter_applica">In the last chapter, <xref linkend="ApplicationDesign"/>, we looked at how to design scalable applications in Scala. In this chapter, we discuss tools and libraries that are essential for Scala application developers.</para>
<para id="para_we_briefly_introduced_you_to_t">We briefly introduced you to the Scala command-line tools in <xref linkend="IntroducingScala"/>. Now we explore these tools in greater detail and learn about other tools that are essential for the Scala developer. We’ll discuss language-aware plugins for editors and IDEs, testing tools, and various libraries and frameworks. We won’t cover these topics in exhaustive detail, but we will tell you where to look for more information.</para>
<sect1 id="CommandLineTools">
<title>Command Line Tools</title>
<para id="para_even_if_you_do_most_of_your_wo">Even if you do most of your work with IDEs, understanding how the command-line tools work gives you additional flexibility, as well as a fallback should the graphical tools fail you. In this chapter, we’ll give you some practical advice for interacting with these tools. However, we won’t describe each and every command line option. For those gory details, we recommend downloading and consulting the tool documentation package <literal>scala-devel-docs</literal>, as described in <xref linkend="ForMoreInformation"/> in <xref linkend="IntroducingScala"/>, and also in the <xref linkend="CommandLineToolSbaz"/> section below.</para>
<para id="para_all_the_command_line_tools_are">All the command-line tools are installed in the <replaceable>scala-home</replaceable><literal>/bin</literal> directory (see <xref linkend="InstallingScala"/> in <xref linkend="IntroducingScala"/>).</para>
<sect2 id="CommandLineToolScalac">
<title>scalac Command Line Tool</title>
<para id="para_the_scalac_command_compiles_">The <userinput>scalac</userinput> command compiles Scala source files, generating JVM class files. In contrast with Java requirements, the source file name doesn’t have to match the public class name in the file. In fact, you can define as many public classes in the file as you want. You can also use arbitrary package declarations without putting the files in corresponding directories.</para>
<para id="para_however_in_order_to_conform_t">However, in order to conform to JVM requirements, a separate class file will be generated for each type with a name that corresponds to the type’s name (sometimes encoded, <emphasis>e.g.,</emphasis> for nested type definitions). Also, the class files will be written to directories corresponding to the package declarations. We’ll see an example of the types of class files generated in the next section, when we discuss the <userinput>scala</userinput> command.</para>
<para id="para_the_scalac_command_is_just_a">The <userinput>scalac</userinput> command is just a shell-script wrapper around the <userinput>java</userinput> command, passing it the name of the Scala compiler’s “Main” object. It adds Scala jar files to the <literal>CLASSPATH</literal> and it defines several Scala-related system properties. You invoke the command as follows.</para>
<para id="para__scalac_options_sourc"><userinput>scalac</userinput> <replaceable>[options …] [source-files]</replaceable></para>
<para id="para_scalac_examples">For example, we used the following <userinput>scalac</userinput> invocation command in <xref linkend="ATasteOfScala"/> in <xref linkend="IntroducingScala"/>, where we created a simple command-line tool to convert input strings to upper case.</para>
<screen>scalac upper3.scala</screen>
<para id="para_options_for_scalac"><xref linkend="scalac-command-options"/> shows the list of the <userinput>scalac</userinput> <replaceable>options</replaceable>, as reported by <userinput>scalac -help</userinput>.</para>
<table id="scalac-command-options">
<title>The scalac command options.</title>
<tgroup cols="2">


<thead valign="top">
<row>
<entry> Option </entry>
<entry> Description</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry><para><literal>-X</literal></para></entry>
<entry><para>Print a synopsis of advanced options.</para></entry>
</row>
<row>
<entry><para><literal>-bootclasspath</literal> <replaceable>path</replaceable></para></entry>
<entry><para>Override location of bootstrap class files.</para></entry>
</row>
<row>
<entry><para><literal>-classpath</literal> <replaceable>path</replaceable></para></entry>
<entry><para>Specify where to find user class files</para></entry>
</row>
<row>
<entry><para><literal>-d</literal> <replaceable>directory</replaceable></para></entry>
<entry><para>Specify where to place generated class files.</para></entry>
</row>
<row>
<entry><para><literal>-dependencyfile</literal> <replaceable>file</replaceable></para></entry>
<entry><para>Specify the file in which dependencies are tracked. (version 2.8)</para></entry>
</row>
<row>
<entry><para><literal>-deprecation</literal></para></entry>
<entry><para>Output source locations where deprecated APIs are used.</para></entry>
</row>
<row>
<entry><para><literal>-encoding</literal> <replaceable>encoding</replaceable></para></entry>
<entry><para>Specify character encoding used by source files.</para></entry>
</row>
<row>
<entry><para><literal>-explaintypes</literal></para></entry>
<entry><para>Explain type errors in more detail.</para></entry>
</row>
<row>
<entry><para><literal>-extdirs</literal> <replaceable>dirs</replaceable></para></entry>
<entry><para>Override location of installed compiler extensions.</para></entry>
</row>
<row>
<entry><para><literal>-g:</literal><replaceable>level</replaceable></para></entry>
<entry><para>Specify <replaceable>level</replaceable> of generated debugging info: <literal>none</literal>, <literal>source</literal>, <literal>line</literal>, <literal>vars</literal>, <literal>notailcalls</literal>.</para></entry>
</row>
<row>
<entry><para><literal>-help</literal></para></entry>
<entry><para>Print a synopsis of standard options.</para></entry>
</row>
<row>
<entry><para><literal>-make:</literal><replaceable>strategy</replaceable></para></entry>
<entry><para>Specify recompilation detection strategy: <literal>all</literal>, <literal>changed</literal>, <literal>immediate</literal>, <literal>transitive</literal>. (version 2.8)</para></entry>
</row>
<row>
<entry><para><literal>-nowarn</literal></para></entry>
<entry><para>Generate no warnings.</para></entry>
</row>
<row>
<entry><para><literal>-optimise</literal></para></entry>
<entry><para>Generate faster byte code by applying optimizations to the program.</para></entry>
</row>
<row>
<entry><para><literal>-print</literal></para></entry>
<entry><para>Print program with all Scala-specific features removed.</para></entry>
</row>
<row>
<entry><para><literal>-sourcepath</literal> <replaceable>path</replaceable></para></entry>
<entry><para>Specify where to find input source files.</para></entry>
</row>
<row>
<entry><para><literal>-target:</literal><replaceable>target</replaceable></para></entry>
<entry><para>Specify for which target JVM object files should be built: <literal>jvm-1.5</literal>, <literal>jvm-1.4</literal>, <literal>msil</literal>.</para></entry>
</row>
<row>
<entry><para><literal>-unchecked</literal></para></entry>
<entry><para>Enable detailed unchecked warnings.</para></entry>
</row>
<row>
<entry><para><literal>-uniqid</literal></para></entry>
<entry><para>Print identifiers with unique names for debugging.</para></entry>
</row>
<row>
<entry><para><literal>-verbose</literal></para></entry>
<entry><para>Output messages about what the compiler is doing.</para></entry>
</row>
<row>
<entry><para><literal>-version</literal></para></entry>
<entry><para>Print product version and exit.</para></entry>
</row>
<row>
<entry><para><literal>@</literal> <replaceable>file</replaceable></para></entry>
<entry><para>A text file containing compiler arguments (options and source files).</para></entry>
</row>
</tbody>
</tgroup>
</table>
<tip id="para_tip_we_recommend_routine_use_"><para>We recommend routine use of the <literal>-deprecation</literal> and <literal>-unchecked</literal> options. They help prevent some bugs and encourage you to eliminate use of obsolete libraries.</para></tip>
<para id="para_the_advanced_x_options_cont">The advanced <literal>-X</literal> options control verbose output, fine-tune the compiler behavior, including use of experimental extensions and plugins, <emphasis>etc</emphasis>. We’ll discuss the <literal>-Xscript</literal> option when we discuss the <userinput>scala</userinput> command in the next section.</para>
<para id="para_two_other_advanced_options">A few other advanced options, <literal>-Xfuture</literal> and <literal>-Xcheckinit</literal>, are useful for the <literal>val</literal> override issue described in <xref linkend="OverridingFieldsInTraits"/> that affects Scala version 2.7.X. Similarly, the <literal>-Xexperimental</literal> option enables experimental changes and issues warnings for potentially risky behavior changes. See <xref linkend="OverridingFieldsInTraits"/> for details.</para>
<para id="para_an_important_feature_of_scala">An important feature of <userinput>scalac</userinput> is its plugin architecture, which has been significantly enhanced in version 2.8. Compiler plugins can be inserted in all phases of the compilation, enabling code transformations, analysis, <emphasis>etc.</emphasis> For example, version 2.8 will include a continuations plugin that developers can use to generate byte code that uses a continuation-passing style (CPS), rather than a stack-based style. Other plugins that are under development include an “effects” analyzer, useful for determining whether functions are truly side-effect free, whether or not variables are modified, <emphasis>etc.</emphasis> Finally, the preliminary <literal>sxr</literal> documentation tool <link linkend="SXR" xrefstyle="select:nopage">[SXR]</link> uses a compiler plugin to generate hyperlinked documentation of Scala code.</para>
<para id="para_scalac_docs">You can read more information about <userinput>scalac</userinput> in the developer tools documentation that you can install with the <userinput>sbaz</userinput> command, discussed below in <xref linkend="CommandLineToolSbaz"/>. In particular, <xref linkend="sbaz-commands"/> shows an example <userinput>sbaz</userinput> command that installs the <literal>scala-devel-docs</literal> documentation.</para>
<warning id="para_warning_scala_version_2_8_com"><para>Scala version 2.8 compiled byte code will not be fully compatible with version 2.7.5 byte code. Source compatibility will be preserved in most cases. If you have your own collections implementations, they may require changes.</para></warning>
</sect2>
<sect2 id="CommandLineToolScala">
<title>The scala Command Line Tool</title>
<para id="para_the_scala_command_is_also_a_">The <userinput>scala</userinput> command is also a shell-script wrapper around the <userinput>java</userinput> command. It adds Scala jar files to the <literal>CLASSPATH</literal> and it defines several Scala-related system properties. You invoke the command as follows.</para>
<para id="para__scala_options_script"><userinput>scala</userinput> <replaceable>[options …] [script-or-object] [arguments]</replaceable></para>
<para id="para_scala_examples">For example, after compiling our <literal>upper3.scala</literal> file in <xref linkend="ATasteOfScala"/> in <xref linkend="IntroducingScala"/>, which we revisited in the previous discussion of <userinput>scalac</userinput>, we can execute the “application” as follows.</para>
<screen>scala -cp . Upper Hello World!</screen>
<para id="para_scala_upper_output">The <literal>-cp .</literal> option adds the current working directory to the class path. <literal>Upper</literal> is the class name with a <literal>main</literal> method to run. <literal>Hello World</literal> are arguments passed to <literal>Upper</literal>. This command produces the following output.</para>
<screen> HELLO WORLD!</screen>
<para id="para_the_command_decides_what_to_do">The command decides what to do based on the <replaceable>script-or-object</replaceable> specified. If you don’t specify a script or object, <userinput>scala</userinput> runs as an interactive interpreter. You type in code that is evaluated on the fly, a setup sometimes referred to as a REPL (Read, Evaluate, Print, Loop). There are a few special commands available in the interactive mode. Type <userinput>:help</userinput> to see a list of them.</para>
<note id="para_note_the_version_2_8_repl_add"><para>The version 2.8 REPL adds many enhancements, including code completion.</para></note>
<para id="para_if_you_specify_a_fully_qualifi">Our <literal>Upper</literal> example demonstrates the case where you specify a fully-qualified <literal>object</literal> name (or Java <literal>class</literal> name). In this case, <userinput>scala</userinput> behaves just like the <userinput>java</userinput> command; it searches the <literal>CLASSPATH</literal> for the corresponding code. It will expect to find a <literal>main</literal> method in the type. Recall that for Scala types, you have to define <literal>main</literal> methods in <literal>objects</literal>. Any <replaceable>arguments</replaceable> are passed as arguments to the <literal>main</literal> method.</para>
<para id="para_if_you_specify_a_scala_source_">If you specify a Scala source file for <replaceable>script-or-object</replaceable>, <userinput>scala</userinput> interprets the file as a script (<emphasis>i.e.,</emphasis> compiles and runs it). Many of the examples in the book are invoked this way. Any <replaceable>arguments</replaceable> are made available to the script in the <literal>args</literal> array. Here is an example script that implements the same “upper” feature.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/upper-script.scala

args.map(_.toUpperCase()).foreach(printf("%s ",_))
println("")</programlisting>
<para id="para_hello_script_invocation">If we run this script with the following command, <userinput>scala upper.scala Hello World</userinput>, we get the same output we got before, <literal>HELLO WORLD</literal>.</para>
<para id="para_interactive_mode_invocation">Finally, if you invoke <userinput>scala</userinput> without a script file or object name argument, <userinput>scala</userinput> runs in interpreted mode. Here is an example interactive session.</para>
<screen>$ scala
Welcome to Scala version 2.8.0.final (Java ...).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; "Programming Scala".foreach { c =&gt; println(c) }
P
r
o
g
...</screen>
<para id="para_the_scala_command_accepts_al">The <userinput>scala</userinput> command accepts all the <replaceable>options</replaceable> that <userinput>scalac</userinput> accepts (see <xref linkend="scalac-command-options"/>), plus the options listed in <xref linkend="scala-command-options"/>.</para>
<table id="scala-command-options">
<title>The scala command options (in additions to the scalac options).</title>
<tgroup cols="2">


<thead valign="top">
<row>
<entry> Option </entry>
<entry> Description</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry><para><literal>-howtorun script</literal></para></entry>
<entry><para>Explicitly interpret <replaceable>script-or-object</replaceable> as a script file.</para></entry>
</row>
<row>
<entry><para><literal>-howtorun object</literal></para></entry>
<entry><para>Explicitly interpret <replaceable>script-or-object</replaceable> as compiled object.</para></entry>
</row>
<row>
<entry><para><literal>-howtorun guess</literal></para></entry>
<entry><para>Guess what <replaceable>script-or-object</replaceable> is (default).</para></entry>
</row>
<row>
<entry><para><literal>-i</literal> <replaceable>file</replaceable></para></entry>
<entry><para>Preload <replaceable>file</replaceable>. It is only meaningful for interactive shells.</para></entry>
</row>
<row>
<entry><para><literal>-e</literal> <replaceable>argument</replaceable></para></entry>
<entry><para>Parse <replaceable>argument</replaceable> as Scala code.</para></entry>
</row>
<row>
<entry><para><literal>-savecompiled</literal></para></entry>
<entry><para>Save the compiled script for future use.</para></entry>
</row>
<row>
<entry><para><literal>-nocompdaemon</literal></para></entry>
<entry><para>Don’t use <literal>fsc</literal>, the offline compiler. (See the <xref linkend="CommandLineToolFsc"/> section.)</para></entry>
</row>
<row>
<entry><para><literal>-D</literal><replaceable>property</replaceable><literal>=</literal><replaceable>value</replaceable></para></entry>
<entry><para>Set a Java system <replaceable>property</replaceable> to <replaceable>value</replaceable>.</para></entry>
</row>
</tbody>
</tgroup>
</table>
<para id="para_use_the_i_file_option_in_">Use the <literal>-i</literal> <replaceable>file</replaceable> option in the interactive mode when you want to preload a file before typing commands. Once in the shell, you can also load a file using the command <userinput>:load</userinput> <replaceable>filename</replaceable>. <xref linkend="scala-interactive-special-commands"/> lists the special <literal>:X</literal> commands available within the interactive mode.</para>
<table id="scala-interactive-special-commands">
<title>Commands available within the scala interactive mode.</title>
<tgroup cols="2">


<thead valign="top">
<row>
<entry> Option </entry>
<entry> Description</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry><para><literal>:help</literal></para></entry>
<entry><para>Prints a help message about these commands.</para></entry>
</row>
<row>
<entry><para><literal>:load</literal></para></entry>
<entry><para>Followed by a filename loads a Scala file.</para></entry>
</row>
<row>
<entry><para><literal>:replay</literal></para></entry>
<entry><para>Resets execution and replays all previous commands.</para></entry>
</row>
<row>
<entry><para><literal>:quit</literal></para></entry>
<entry><para>Exits the interpreter.</para></entry>
</row>
<row>
<entry><para><literal>:power</literal></para></entry>
<entry><para>Enable power user mode. (version 2.8)</para></entry>
</row>
</tbody>
</tgroup>
</table>
<para id="para_power_user_mode">The new “power user mode” adds additional commands for viewing in-memory data, such as the abstract syntax tree and interpreter properties, and for doing other operations.</para>
<para id="para_for__batch_mode__invocation_u">For <emphasis>batch-mode</emphasis> invocation, use the <literal>-e</literal> <replaceable>argument</replaceable> option to specify Scala code to interpret. If you are using command shells that support I/O redirection (<emphasis>e.g.,</emphasis> the Bourne shell, the C shell, or their descendants) and you need to build up lines of code dynamically, you can also pipe the code into <userinput>scala</userinput>, as shown in the following somewhat contrived <emphasis>bash</emphasis> script example.</para>
<programlisting linenumbering="unnumbered">#!/usr/bin/env bash
# code-examples/ToolsLibs/pipe-example.sh

h=Hello
w=World
function commands {
cat &lt;&lt;-EOF
println("$h")
println("$w")
EOF
}

commands | scala</programlisting>
<para id="para_invoking_scripts_with_scala_">Invoking scripts with <userinput>scala</userinput> is tedious when you use these scripts frequently. On Windows and UNIX-like systems, you can create stand-alone Scala scripts that don’t require you to use the <userinput>scala</userinput> <replaceable>script-file-name</replaceable> invocation.</para>
<para id="para_for_unix_like_systems_the_fol">For UNIX-like systems, the following example demonstrates how to make an executable script. Remember that you have to make the permissions executable, <emphasis>e.g.,</emphasis> <userinput>chmod +x secho</userinput>.</para>
<programlisting linenumbering="unnumbered">#!/bin/sh
exec scala "$0" "$@"
!#
print("You entered: ")
argv.toList foreach { s =&gt; format("%s ", s) }
println</programlisting>
<para id="para_here_is_how_you_might_use_it_">Here is how you might use it.</para>
<screen>$ secho Hello World
You entered: Hello World</screen>
<para id="para_similarly_here_is_an_example_">Similarly, here is an example Windows <literal>.bat</literal> command.</para>
<programlisting linenumbering="unnumbered">::#!
@echo off
call scala %0 %*
goto :eof
::!#
print("You entered: ")
argv.toList foreach { s =&gt; format("%s ", s) }
println</programlisting>
<para id="para_see_the_scala_man_page_in_th">See the <userinput>scala</userinput> man page in the developer documentation package <literal>scala-devel-docs</literal> to find out more about all the command-line options for <userinput>scala</userinput>,</para>
<sect3 id="LimitationsOfScalaVsScalac">
<title>Limitations of scala vs. scalac</title>
<para id="para_there_are_some_limitations_when_running">There are some limitations when running a source file with <userinput>scala</userinput>
<emphasis>vs.</emphasis> compiling it with <userinput>scalac</userinput>.</para>
<para id="para_any_scripts_executed_with_scala">Any scripts executed with <userinput>scala</userinput> are wrapped in an anonymous <literal>object</literal>
that looks more or less like the following example.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/script-wrapper.scala

object Script {
  def main(args: Array[String]): Unit = {
    new AnyRef {
      // Your script code is inserted here.
    }
  }
}</programlisting>
<para id="para_as_of_this_writing_scala_obj">As of this writing, Scala <literal>objects</literal> cannot embed package declarations, and as such you can’t declare packages in scripts. This is why the examples in this book that declare packages must be compiled and executed separately, such as this example from <xref linkend="TypeLessDoMore"/>.</para>
<programlisting linenumbering="unnumbered">// code-examples/TypeLessDoMore/package-example1.scala

package com.example.mypkg

class MyClass {
  // ...
}</programlisting>
<para id="para_conversely_there_are_valid_sc">Conversely, there are valid scripts that can’t be compiled with <userinput>scalac</userinput>, unless a special <literal>-X</literal> option is used. For example, function definitions and function invocations outside of types are not allowed. The following example runs fine with <userinput>scala</userinput>.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/example-script.scala

case class Message(name: String)

def printMessage(msg: Message) = {
  println(msg)
}

printMessage(new Message(
    "Must compile this script with scalac -Xscript &lt;name&gt;!"))</programlisting>
<para id="para_running_this_script">Running this script with <userinput>scala</userinput> produces the following expected output.</para>
<screen>Message(Must compile this script with scalac -Xscript &lt;name&gt;!)</screen>
<para id="para_however_if_you_try_to_compile">However, if you try to compile the script with <userinput>scalac</userinput> (without the <literal>-Xscript</literal> option), you get the following errors.</para>
<screen>example-script.scala:3: error: expected class or object definition
def printMessage(msg: Message) = {
^
example-script.scala:7: error: expected class or object definition
printMessage(new Message("Must compile this script with scalac -Xscript &lt;name&gt;!"))
^
two errors found</screen>
<para id="para_the_script_itself_describes_th">The script itself describes the solution; to compile this script with <userinput>scalac</userinput> you must add the option <literal>-Xscript</literal> <replaceable>name</replaceable>, where <replaceable>name</replaceable> is the name you want to give the compiled class file. For example, using <literal>MessagePrinter</literal> for <replaceable>name</replaceable> will result in the creation of several class files with the name prefix <literal>MessagePrinter</literal>.</para>
<screen>scalac -Xscript MessagePrinter example-script.scala</screen>
<para id="para_run_msgprinter">You can now run the compiled code with the command</para>
<screen>scala -classpath . MessagePrinter</screen>
<para id="para_the_directory_will_contain_the">The current directory will contain the following class files.</para>
<screen>MessagePrinter$$anon$1$Message$.class
MessagePrinter$$anon$1$Message.class
MessagePrinter$$anon$1.class
MessagePrinter$.class
MessagePrinter.class</screen>
<para id="para_what_are_all_those_files_mes">What are all those files? <literal>MessagePrinter</literal> and <literal>MessagePrinter$</literal> are wrappers generated by <userinput>scalac</userinput> to provide the entry point for the script as an “application”. Recall that we specified <literal>MessagePrinter</literal> as the <replaceable>name</replaceable> argument for <literal>-Xscript</literal>. <literal>MessagePrinter</literal> has the <literal>static main</literal> method we need.</para>
<para id="para__messageprinter_036_036_ano"><literal>MessagePrinter$$anon$1</literal> is a generated class that wraps the whole script. The <literal>printMessage</literal> method in the script is a method in this class. <literal>MessagePrinter$$anon$1$Message</literal> and <literal>MessagePrinter$$anon$1$Message$</literal> are the <literal>Message</literal> class and companion object, respectively, that are declared in the script. They are nested inside the generated class <literal>MessagePrinter$$anon$1</literal> for the whole script. If you want to see what’s inside these class files, use one of the decompilers, which we describe next.</para>
</sect3>
</sect2>
<sect2 id="CommandLineToolDecompilers">
<title>The scalap, javap, and jad Command Line Tools</title>
<para id="para_when_you_re_learning_scala_and">When you are learning Scala and you want to understand how Scala constructs are mapped to the runtime, there are several decompilers that are very useful. They are especially useful when you need to invoke Scala code from Java and you want to know how Scala names are <emphasis>mangled</emphasis> into JVM-compatible names or you want to understand how the scala compiler translates Scala features into valid byte code.</para>
<para id="para_let_s_discuss_three_decompiler">Let’s discuss three decompilers and the benefits they offer. Since the class files generated by <userinput>scalac</userinput> contain valid JVM byte codes, you can use Java decompilers tools.</para>
<itemizedlist>
<listitem>
<para>
<userinput>scalap</userinput> is included with the Scala distribution. It outputs declarations as they would appear in Scala source code.
</para>
</listitem>
<listitem>
<para>
<userinput>javap</userinput> is included with the JDK. It outputs declarations as they would appear in Java source code. Therefore, running <userinput>javap</userinput> on Scala-generated class files is a good way to see how Scala definitions are mapped to valid byte code.
</para>
</listitem>
<listitem>
<para>
<userinput>jad</userinput> is an open-source command-line tool <link linkend="JAD" xrefstyle="select:nopage">[JAD]</link>. It attempts to reconstruct an entire Java source file from the class file, including method definitions, as well as the declarations.
</para>
</listitem>
</itemizedlist>
<para id="para_scalap_output"><literal>MessagePrinter.class</literal> is one of the class files generated from the example script in the previous section.
Let’s run <userinput>scalap -classpath . MessagePrinter</userinput>. We get the following output.</para>
<screen>package MessagePrinter;
final class MessagePrinter extends scala.AnyRef {
}
object MessagePrinter {
  def main(scala.Array[java.lang.String]): scala.Unit;
  def $tag(): scala.Int;
    throws java.rmi.RemoteException
}</screen>
<para id="para_you_can_see_the_main_method_">Note that the first method inside <literal>object MessagePrinter</literal> is the <literal>main</literal> method. The <literal>$tag</literal> method is part of Scala’s internal implementation. It is an abstract method defined by <literal>ScalaObject</literal>. The compiler automatically generates implementations for concrete types. The <literal>$tag</literal> method was originally introduced to optimize pattern matching, but it is now deprecated and it may be removed in a forthcoming release of Scala.</para>
<para id="para_javap_output">Let’s compare the <userinput>scalap</userinput> output to what we get when we run <userinput>javap -classpath . MessagePrinter</userinput>.</para>
<screen>Compiled from "(virtual file)"
public final class MessagePrinter extends java.lang.Object{
  public static final void main(java.lang.String[]);
  public static final int $tag()       throws java.rmi.RemoteException;
}</screen>
<para id="para_javap_output_main_method">Now we see the declaration of <literal>main</literal> as we would typically see it in a Java source file.</para>
<para id="para_jad_output">Finally, to use <userinput>jad</userinput>, you simply give it the file name of the class file. It generates a corresponding output file with the <literal>.jad</literal> extension. If you run <userinput>jad MessagePrinter.class</userinput>, you get a long file named <literal>MessagePrinter.jad</literal>. You will also get several warnings that <userinput>jad</userinput> could not fully decompile some methods. We won’t reproduce the output here, but the jad file will normal Java statements interspersed with several sections of JVM byte-code instructions, where it could not decompile the byte code.</para>
<para id="para_scalap_javap_jad_help">All these tools have command-line help.</para>
<itemizedlist>
<listitem>
<para>
<userinput>scalap -help</userinput>
</para>
</listitem>
<listitem>
<para>
<userinput>javap -help</userinput>
</para>
</listitem>
<listitem>
<para>
<userinput>jad --help</userinput>
</para>
</listitem>
</itemizedlist>
<para id="para_scalap_javap_jad_docs">The Scala developer documentation contains documentation for <userinput>scalap</userinput>. Similar documentation comes with the JDK for <userinput>javap</userinput>. The <userinput>jad</userinput> distribution includes a README file with documentation. The Mac and Linux distributions also include a <literal>man</literal> page.</para>
<para id="para_finally_as_an_exercise_compi">Finally, as an exercise, compile the following very simple <literal>Complex</literal> class, representing complex numbers. Then run <userinput>scalap</userinput>, <userinput>javap</userinput>, and <userinput>jad</userinput> on the resulting class files.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex.scala

case class Complex(real: Double, imaginary: Double) {
  def +(that: Complex) =
    new Complex(real + that.real, imaginary + that.imaginary)
  def -(that: Complex) =
    new Complex(real - that.real, imaginary - that.imaginary)
}</programlisting>
<para id="para_how_are_the_043_and_m">How are the <literal>+</literal> and <literal>-</literal> methods encoded? What are the names of the reader methods for the <literal>real</literal> and <literal>imaginary</literal> fields? What Java types are used for the fields?</para>
</sect2>
<sect2 id="CommandLineToolScaladoc">
<title>The scaladoc Command Line Tool</title>
<para id="para_the_scaladoc_command_is_anal">The <userinput>scaladoc</userinput> command is analogous to <userinput>javadoc</userinput>. It is used to generate documentation from Scala source files, called <emphasis>Scaladocs</emphasis>. The <userinput>scaladoc</userinput> parser supports the same <literal>@</literal> annotations that <userinput>javadoc</userinput> supports, such as <literal>@author</literal>, <literal>@param</literal>, <emphasis>etc.</emphasis></para>
<para id="para_if_you_use_scaladoc_for_your">If you use <userinput>scaladoc</userinput> for your documentation, you might want to investigate <userinput>vscaladoc</userinput>, an improved <userinput>scaladoc</userinput> tool that is available at <ulink url="http://code.google.com/p/vscaladoc/"/>. You can also find documentation on <userinput>vscaladoc</userinput> at <link linkend="ScalaTools" xrefstyle="select:nopage">[ScalaTools]</link>.</para>
</sect2>
<sect2 id="CommandLineToolSbaz">
<title>The sbaz Command Line Tool</title>
<para id="para_scala_bazaar_system_sbaz_i">Scala Bazaar System (<userinput>sbaz</userinput>) is a packaging system that helps automate maintenance of a Scala installation. It is analogous to the <emphasis>gem</emphasis> packaging system for Ruby, <emphasis>CPAN</emphasis> for Perl, <emphasis>etc.</emphasis></para>
<para id="para_there_is_a_nice_summary_of_how">There is a nice summary of how to use <userinput>sbaz</userinput> on the scala-lang.org website, <ulink url="http://www.scala-lang.org/node/93"/>. All command-line options are described in the developer documentation. The following table summarizes the most useful invokations.</para>
<table id="sbaz-commands">
<title>The most useful sbaz command options.</title>
<tgroup cols="2">


<thead valign="top">
<row>
<entry> Command </entry>
<entry> Description</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry><para><userinput>sbaz showuniverse</userinput></para></entry>
<entry><para>Show the current “universe” (remote repository). Defaults to <ulink url="http://scala-webapps.epfl.ch/sbaz/scala-dev"/>.</para></entry>
</row>
<row>
<entry><para><userinput>sbaz setuniverse</userinput> <replaceable>univ</replaceable></para></entry>
<entry><para>Points to a new “universe” <replaceable>univ</replaceable>.</para></entry>
</row>
<row>
<entry><para><userinput>sbaz installed</userinput></para></entry>
<entry><para>What’s already installed locally?</para></entry>
</row>
<row>
<entry><para><userinput>sbaz available</userinput></para></entry>
<entry><para>What goodness awaits on the Interwebs?</para></entry>
</row>
<row>
<entry><para><userinput>sbaz install scala-devel-docs</userinput></para></entry>
<entry><para>Install the invaluable <literal>scala-devel-docs</literal> package (for example).</para></entry>
</row>
<row>
<entry><para><userinput>sbaz upgrade</userinput></para></entry>
<entry><para>Upgrade all installed packages to the latest and greatest.</para></entry>
</row>
</tbody>
</tgroup>
</table>
<para id="para_note_that_a_remote_repository_">Note that a remote repository used by <userinput>sbaz</userinput> is called a “universe”.</para>
</sect2>
<sect2 id="CommandLineToolFsc">
<title>The fsc Command Line Tool</title>
<para id="para_the__fast_offline_scala_comp">The <emphasis>fast (offline) scala compiler</emphasis> runs as a daemon process to enable faster invocations of the compiler, mostly by eliminating the startup overhead. It is particularly useful when running scripts repeatedly (for example, when re-running a test suite until a bug can be reproduced). In fact, <userinput>fsc</userinput> is invoked automatically by the <userinput>scala</userinput> command. You can also invoke it directly.</para>
</sect2>
</sect1>
<sect1 id="BuildTools">
<title>Build Tools</title>
<para id="para_scala_plugins_have_been_implem">Scala plugins have been implemented for several, commonly used build tools, including <emphasis>ant</emphasis> (<ulink url="http://ant.apache.org/"/>), <emphasis>maven</emphasis> (<ulink url="http://maven.apache.org/"/>), and <emphasis>buildr</emphasis> (<ulink url="http://buildr.apache.org/"/>). There are also several build tools written in Scala and aimed specifically at Scala development. Perhaps the best known example of these tools is <emphasis>sbt</emphasis> (“Simple Build Tool” - <link linkend="SBT" xrefstyle="select:nopage">[SBT]</link>).</para>
<para id="para_build_tools_documented_on_sites">These plugins and tools are documented very well on their respective websites, so we refer you to those sites for details.</para>
<para id="para_ant_support">The Scala distribution includes <emphasis>ant</emphasis> tasks for <userinput>scalac</userinput>, <userinput>fsc</userinput>, and <userinput>scaladoc</userinput>. They are used very much like the corresponding Java ant tasks. They are described at <ulink url="http://scala-lang.org/node/98"/>.</para>
<para id="para_maven_support">A Scala <emphasis>maven</emphasis> plugin is available at <ulink url="http://scala-tools.org/mvnsites/maven-scala-plugin/"/>. It does not require Scala to be installed, as it will download Scala for you. Several third-party Scala projects, such as Lift (see <xref linkend="Lift"/> below), use <emphasis>maven</emphasis>.</para>
<para id="para_buildr_support"><emphasis>Buildr</emphasis> is an apache project available at <ulink url="http://buildr.apache.org/"/>. It is aimed at JVM applications written in any language, with built-in support for Scala and Groovy, as well as Java. It is compatible with maven repositories and project layouts. Since build scripts are written in Ruby, they tend to be much more succinct that corresponding <emphasis>maven</emphasis> files. Buildr is also useful for testing JVM applications with Ruby testing tools, like <emphasis>RSpec</emphasis> (<ulink url="http://rspec.info"/>) and Cucumber (<ulink url="http://cukes.info"/>), if you use JRuby (<ulink url="http://jruby.codehaus.org/"/>) to run your builds.</para>
<para id="para_sbt_support">The Scala-oriented <emphasis>sbt</emphasis> (simple-build-tool), available at <ulink url="http://code.google.com/p/simple-build-tool/"/>, has some similarities to <emphasis>Buildr</emphasis>. It is also compatible with <emphasis>maven</emphasis>, but it uses Scala as the language for writing build scripts. It also has built-in support for generating <emphasis>Scaladocs</emphasis> and for testing with ScalaTest, Specs, and ScalaCheck.</para>
</sect1>
<sect1 id="IntegrationWithIDEs">
<title>Integration with IDEs</title>
<para id="para_java_background">If you come from a Java background, you are probably a little bit spoiled by the rich features of today’s Java IDEs. Scala IDE support is not yet as good, but it is evolving rapidly in Eclipse, IntelliJ IDEA, and NetBeans. At the time of this writing, all the Scala plugins for these IDEs support syntax highlighting, project management, and limited support for automated refactorings, <emphasis>etc.</emphasis> While each of the plugins has particular advantages over the others, they are all close enough in functionality that you will probably find it acceptable to adopt the plugin for the IDE that you already prefer.</para>
<para id="para_this_section_describes_how_to_">This section describes how to use the Scala support available in Eclipse, IntelliJ IDEA, and NetBeans. We assume you already know how to use each IDE for development in other languages, like Java.</para>
<sect2 id="_eclipse">
<title>Eclipse</title>
<sect3 id="_installing_the_scala_plugin">
<title>Installing the Scala Plugin</title>
<para id="para_for_details_on_the_eclipse_sca">For details on the Eclipse Scala plugin, start at this web page, <ulink url="http://www.scala-lang.org/node/94"/>. If you are interested in contributing to the development of the plugin, see this web page, <ulink url="http://lampsvn.epfl.ch/trac/scala/wiki/EclipsePlugin"/>.</para>
<para id="para_the_plugin_requires_jdk_5_or_h">The plugin requires JDK 5 or higher (JDK 6 is recommended) and Eclipse 3.3 or higher (Eclipse 3.4 is recommended). The plugin installs the Scala SDK itself. To install the plugin, invoke the <emphasis>Software Updates</emphasis> command in the <emphasis>Help</emphasis> menu.</para>
<para id="para_click_the__available_software_">Click the <emphasis>Available Software</emphasis> tab and click the “Add Site…” button on the right hand side. You will see the dialog shown in <xref linkend="eclipse-add-site"/>.</para>
<figure id="eclipse-add-site">
  <title>The add site Eclipse dialog.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1401.pdf" format="PDF"/>
  </imageobject>
  <imageobject role="web">
    <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1401.png" format="PNG"/>
  </imageobject>
  </mediaobject>  
</figure>
<para id="para_enter_the_url_that_shown_in_th">Enter the URL that shown in the figure, <ulink url="http://www.scala-lang.org/scala-eclipse-plugin"/>. Some people prefer to work with the <emphasis>nightly</emphasis> releases, <ulink url="http://www.scala-lang.org/scala-eclipse-plugin-nightly"/>, but you should be aware that there is no guarantee they will work!</para>
<para id="para_select_the_check_box_next_to_t">Select the check box next to the newly-added update site and click the <emphasis>Install</emphasis> button, as indicated in <xref linkend="eclipse-install-scala2"/>. <emphasis role="strong">Don’t</emphasis> click the “default” <emphasis>Close</emphasis> button!</para>
<figure id="eclipse-install-scala2">
  <title>The Software Updates and Add-ons dialog.</title>
  <mediaobject>
  <imageobject role="print">
    <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1402.pdf" format="PDF"/>
  </imageobject>
  <imageobject role="web">
    <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1402.png" format="PNG"/>
  </imageobject>
  </mediaobject>
</figure>
<warning id="para_warning_it_is_easy_to_be_conf"><para>It is easy to be confused by the poor usability of the <emphasis>Software Updates</emphasis> dialog.</para></warning>
<para id="para_after_finding_the_plugin_on_th">After finding the plugin on the update site, an <emphasis>Install</emphasis> dialog is presented. Click through the sequence of screens to complete the installation. You will be asked to restart Eclipse when the installation completes.</para>
</sect3>
<sect3 id="_developing_scala_applications">
<title>Developing Scala Applications</title>
<para id="para_once_the_plugin_is_installed_">Once the plugin is installed, you can create Scala Projects using the <emphasis>File → New → Other …</emphasis> menu item. You will find a <emphasis>Scala Wizards</emphasis> folder that contains a wizard called <emphasis>Scala Project</emphasis>. This wizard works just like the familiar <emphasis>Java Project</emphasis> wizard.</para>
<para id="para_you_can_work_with_your_scala_p">You can work with your Scala project using most of the same commands you would use with a typical Java project. For example, you can create a new Scala <literal>trait</literal>, <literal>class</literal> or <literal>object</literal> using the context menu.</para>
<para id="para_the_eclipse_scala_plugin_still">The Eclipse Scala plugin still has some “rough edges”, but Scala developers using Eclipse should find it acceptable for their daily needs.</para>
</sect3>
</sect2>
<sect2 id="_intellij">
<title>IntelliJ</title>
<sect3 id="_installing_the_scala_plugins">
<title>Installing the Scala Plugins</title>
<para id="para_the_intellij__idea__team_provi">The IntelliJ <emphasis>IDEA</emphasis> team provides a <emphasis>beta</emphasis>-quality Scala plugin. Start here for details: <ulink url="http://www.jetbrains.net/confluence/display/SCA/Scala+Plugin+for+IntelliJ+IDEA"/>.</para>
<para id="para_to_use_the_plugin_you_must_us">To use the plugin, you must use IntelliJ 8.0.X or later. Consider using the most recent “EAP” build for the latest feature updates. You must also have the Scala command-line SDK installed, as discussed in <xref linkend="InstallingScala"/> in <xref linkend="IntroducingScala"/>.</para>
<para id="para_to_install_the_scala_plugin_s">To install the Scala plugin, start IDEA. Open the <emphasis>Settings</emphasis> panel, <emphasis>e.g.,</emphasis> using the <emphasis>File → Settings</emphasis> menu item. On the left-hand side, scroll down to and click the <emphasis>Plugins</emphasis> item, as shown in <xref linkend="idea-settings-plugins"/>.</para>
<figure id="idea-settings-plugins">
  <title>IntelliJ IDEA Settings → Plugins.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1403.pdf" format="PDF"/>
    </imageobject>
    <imageobject role="web">
      <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1403.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</figure>
<para id="para_select_the__available__tab_on_">Select the <emphasis>Available</emphasis> tab on the right-hand side. Scroll down to the <emphasis>Scala</emphasis> plugin, as shown in
<xref linkend="idea-settings-plugins-scala"/>.</para>
<figure id="idea-settings-plugins-scala">
  <title>Available IntelliJ IDEA Scala plugins.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1404.pdf" format="PDF"/>
    </imageobject>
    <imageobject role="web">
      <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1404.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</figure>
<para id="para_right_click_the__scala__plugin">Right-click the <emphasis>Scala</emphasis> plugin name and select <emphasis>Download and Install</emphasis> from the menu. Repeat for the <emphasis>Scala Application</emphasis> plugin. You will have to restart IDEA for the plugins to be enabled.</para>
<para id="para_after_idea_restarts_confirm_t">After IDEA restarts, confirm that the two plugins were installed correctly by reopening the <emphasis>Plugin Manager</emphasis>. Click the <emphasis>Installed</emphasis> tab and scroll down to find the two Scala plugins. They should be listed with a black font and the check boxes next to them should be checked, as seen in <xref linkend="idea-settings-plugins-confirm"/>.</para>
<figure id="idea-settings-plugins-confirm">
  <title>Installed IntelliJ IDEA Scala plugins.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1405.pdf" format="PDF"/>
    </imageobject>
    <imageobject role="web">
      <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1405.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</figure>
<para id="para_if_the_font_is_red_or_the_chec">If the font is red or the check boxes are not checked, refer to the Scala Plugin web page above for debugging help.</para>
</sect3>
<sect3 id="_developing_scala_applications_2">
<title>Developing Scala Applications</title>
<para id="para_to_create_an_idea_scala_project_sta">To create an IDEA Scala Project, start by selecting the <emphasis>File → New Project</emphasis> menu item. In the dialog, select the appropriate radio button for your situation, <emphasis>e.g.,</emphasis> “Create New Project from Scratch”.</para>
<para id="para_on_the_next_screen_select__ja">On the next screen, select <emphasis>Java Module</emphasis> and fill in the usual project information. An example is shown in <xref linkend="idea-new-project1a"/>.</para>
<figure id="idea-new-project1a">
  <title>Specifying IntelliJ IDEA Scala project details.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1406.pdf" format="PDF"/>
      </imageobject><imageobject role="web">
      <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1406.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</figure>
<para id="para_click_through_to_the_screen_ti">Click through to the screen titled <emphasis>Please Select Desired Technology</emphasis>. Check the <emphasis>Scala</emphasis> check box and check the <emphasis>New Scala SDK</emphasis> checkbox. Click the button labeled “…” to navigate to the location of your Scala SDK installation, as shown in <xref linkend="idea-new-project1b"/>. You will only need to specify the SDK the first time you create a project or when you install a new SDK in a different location.</para>
<figure id="idea-new-project1b">
  <title>Adding Scala to the IntelliJ IDEA project.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1407.pdf" format="PDF"/>
    </imageobject>
    <imageobject role="web">
      <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1407.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</figure>
<para id="para_click__finish__you_will_be_pr">Click <emphasis>Finish</emphasis>. You will be prompted to create either a <emphasis>Project</emphasis> or an <emphasis>Application</emphasis>. Select <emphasis>Application</emphasis> if you want to share this project with other Scala projects on the same machine.</para>
<para id="para_now_you_can_work_with_your_sca">Now you can work with your Scala project using most of the same commands you would use with a typical Java project. For example, you can create a new Scala <literal>trait</literal>, <literal>object</literal> or <literal>class</literal> using the context menu, as for Java projects.</para>
<para id="para_the_intellij_idea_scala_plugin">The IntelliJ IDEA Scala plugin is still <emphasis>beta</emphasis>-quality, but Scala developers using IDEA should find it acceptable for their daily needs.</para>
</sect3>
</sect2>
<sect2 id="_netbeans">
<title>NetBeans</title>
<sect3 id="_installing_the_scala_plugins_2">
<title>Installing the Scala Plugins</title>
<para id="para_netbeans_has__beta__quality_sc">NetBeans has <emphasis>beta</emphasis>-quality Scala plugins. Start at this web page for details, <ulink url="http://wiki.netbeans.org/Scala"/>. NetBeans 6.5 or a more recent nightly build is required. The Scala plugin contains a version of the Scala SDK. The wiki page provides instructions for using a different SDK, when desired.</para>
<para id="para_to_install_the_plugin_downloa">To install the plugin, download the plugins zip file from <ulink url="http://sourceforge.net/project/showfiles.php?group_id=192439&amp;package_id=256544"/>. Unzip the file in a convenient directory.</para>
<para id="para_start_netbeans_and_invoke_the_">Start NetBeans and invoke the <emphasis>Tools → Plugins</emphasis> menu item. Select the <emphasis>Downloaded</emphasis> tab and click the <emphasis>Add Plugins…</emphasis> button. Choose the directory where the Scala plugins are unzipped, select all the listed <literal>*.nbm</literal> files, as shown in <xref linkend="netbeans-add-plugins"/>. Click <emphasis>Open</emphasis>.</para>
<figure id="netbeans-add-plugins">
  <title>Adding the Scala plugins to be installed.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1408.pdf" format="PDF"/>
    </imageobject>
    <imageobject role="web">
      <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1408.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</figure>
<para id="para_back_in_the__plugins__dialog_">Back in the <emphasis>Plugins</emphasis> dialog, make sure the check boxes for all the new plugins are checked. Click <emphasis>Install</emphasis>.</para>
<para id="para_click_through_the_installation">Click through the installation dialog and restart NetBeans when finished.</para>
</sect3>
<sect3 id="_developing_scala_applications_3">
<title>Developing Scala Applications</title>
<para id="para_to_create_a_netbeans_scala_project_sta">To create a NetBeans Scala Project, start by selecting the <emphasis>File → New Project</emphasis> menu item or clicking the <emphasis>New Project</emphasis> button. In the pop-up dialog, select <emphasis>Scala</emphasis> under <emphasis>Categories</emphasis> and <emphasis>Scala Application</emphasis> under <emphasis>Projects</emphasis>, as shown in <xref linkend="netbeans-new-project1"/>. Click <emphasis>Next</emphasis>.</para>
<figure id="netbeans-new-project1">
  <title>Creating a new NetBeans Scala project.</title>
  <mediaobject>
    <imageobject role="print">
      <imagedata fileref="/work/eans/9780596155957/figs/print/prsc_1409.pdf" format="PDF"/>
    </imageobject>
    <imageobject role="web">
      <imagedata fileref="/work/eans/9780596155957/figs/web/prsc_1409.png" format="PNG"/>
    </imageobject>
  </mediaobject>
</figure>
<para id="para_fill_in_the_project_name_loca">Fill in the project name, location, <emphasis>etc.</emphasis> and click <emphasis>Finish</emphasis>.</para>
<para id="para_once_the_project_is_creates_y">Once the project is creates, you can work with it using most of the same commands you would use with a typical Java project. There are some difference. For example, when you invoke the <emphasis>New</emphasis> item in the context menu, the submenu does not show items for creating new Scala types. Instead, you have invoke the <emphasis>Other …</emphasis> menu item and work through a dialog. This will be probably changed in a future release.</para>
<para id="para_despite_some_minor_issues_like">Despite some minor issues like this, the NetBeans Scala plugin is mature enough for regular use.</para>
</sect3>
</sect2>
<sect2 id="_text_editors">
<title>Text Editors</title>
<para id="para_the_sbaz_tool_manages_the_s">The <userinput>sbaz</userinput> tool manages the <literal>scala-tool-support</literal> package that includes Scala plugins for several editors, including <emphasis>Emacs</emphasis>, <emphasis>Vim</emphasis>, <emphasis>TextMate</emphasis> and others. Like <userinput>sbaz</userinput>, the <literal>scala-tool-support</literal> package is also included with the language installation. See the directories in <replaceable>scala-home</replaceable><literal>/misc/scala-tool-support</literal> for the supported editors. Most of the editor-specific directories contain instructions for installing the plugin. In other cases, consult your editor’s instructions for installing third-party plugins.</para>
<para id="para_some_of_the_packages_are_fairl">Some of the packages are fairly immature. If you want to contribute to the Scala community, please consider improving the quality of the existing plugins or contributing new plugins.</para>
<note id="para_note_at_the_time_of_this_writ"><para>At the time of this writing, there are several variations of a Scala “bundle” for the <emphasis>TextMate</emphasis> editor, which is a popular text editor for Mac OS X. These bundles are currently being managed by Paul Phillips on the GitHub site at <ulink url="http://github.com/paulp/scala-textmate/tree/master"/>. Hopefully, the best features of each bundle will be unified into an “authoritative” bundle and integrated back into the <literal>scala-tool-support</literal> package.</para></note>
</sect2>
</sect1>
<sect1 id="_test_driven_development_in_scala">
<title>Test-Driven Development in Scala</title>
<para id="para_one_of_the_most_important_deve">One of the most important developer practices introduced in the last decade is <emphasis>Test-Driven Development</emphasis> (TDD). The Scala community has created several tools to support TDD.</para>
<para id="para_if_you_work_in_a_pure_java">If you work in a “pure” Java shop, consider introducing one or more of these Scala testing tools to test-drive your Java code. This approach is a low-risk way to introduce Scala to your environment, so you can gain experience with it before making the commitment to Scala as your production code language. In particular, you might experiment with <emphasis>ScalaTest</emphasis> (see <xref linkend="ScalaTest"/> next), which can be used with <emphasis>JUnit</emphasis> <link linkend="JUnit" xrefstyle="select:nopage">[JUnit]</link> and <emphasis>TestNG</emphasis> <link linkend="TestNG" xrefstyle="select:nopage">[TestNG]</link>. You might also consider <emphasis>ScalaCheck</emphasis> or <emphasis>Reductio</emphasis> (see <xref linkend="ScalaCheck"/> below), which offer innovations that may not be available in Java testing frameworks. All of the tools we describe here integrate with Java testing and build tools, like <emphasis>JUnit</emphasis>, <emphasis>TestNG</emphasis>, various <emphasis>mocking</emphasis> libraries, <emphasis>Ant</emphasis> <link linkend="Ant" xrefstyle="select:nopage">[Ant]</link>, and <emphasis>Maven</emphasis> <link linkend="Maven" xrefstyle="select:nopage">[Maven]</link>. All of them also offer convenient Scala DSLs for testing.</para>
<sect2 id="ScalaTest">
<title>ScalaTest</title>
<para id="para_scala_s_version_of_the_venerab">Scala’s version of the venerable <emphasis>XUnit</emphasis> tool is <emphasis>ScalaTest</emphasis>, available at <ulink url="http://www.artima.com/scalatest/"/>.</para>
<para id="para_you_can_drive_your_tests_using">You can drive your tests using the built-in <literal>Runner</literal> or use the provided integration with <emphasis>JUnit</emphasis> or <emphasis>TestNG</emphasis>. <emphasis>ScalaTest</emphasis> also comes with an <emphasis>Ant</emphasis> task and it works with the <emphasis>ScalaCheck</emphasis> testing tool (described below).</para>
<para id="para_besides_supporting_the_traditi">Besides supporting the traditional <emphasis>XUnit</emphasis>-style syntax with test methods and assertions, <emphasis>ScalaTest</emphasis> provides a <emphasis>Behavior-Driven Development</emphasis> <link linkend="BDD" xrefstyle="select:nopage">[BDD]</link> syntax that is becoming increasingly popular. The <emphasis>ScalaTest</emphasis> web site (<ulink url="http://www.artima.com/scalatest/"/>) provides examples for these and other options.</para>
<para id="para_here_is_an_example_test_for_th">Here is an example <emphasis>ScalaTest</emphasis> test for the simple <literal>Complex</literal> class we used previously in the <xref linkend="CommandLineToolDecompilers"/> section.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-test.scala

import org.scalatest.FunSuite

class ComplexSuite extends FunSuite {

  val c1 = Complex(1.2, 3.4)
  val c2 = Complex(5.6, 7.8)

  test("addition with (0, 0)") {
    assert(c1 + Complex(0.0, 0.0) === c1)
  }

  test("subtraction with (0, 0)") {
    assert(c1 - Complex(0.0, 0.0) === c1)
  }

  test("addition") {
    assert((c1 + c2).real === (c1.real + c2.real))
    assert((c1 + c2).imaginary === (c1.imaginary + c2.imaginary))
  }

  test("subtraction") {
    assert((c1 - c2).real === (c1.real - c2.real))
    assert((c1 - c2).imaginary === (c1.imaginary - c2.imaginary))
  }
}</programlisting>
<para id="para_this_particular_example_uses_t">This particular example uses the “function value” syntax for each test that is provided by the <literal>FunSuite</literal> parent class. Each call to <literal>test</literal> receives as arguments a descriptive string and a <emphasis>function literal</emphasis> with the actual test code.</para>
<para id="para_the_following_commands_compile">The following commands compile <literal>complex.scala</literal> and <literal>complex-test.scala</literal>, putting the class files in a <literal>build</literal> directory, and then run the tests. Note that we assume that <literal>scalatest-0.9.5.jar</literal> (the latest release at the time of this writing) is in the <literal>../lib</literal> directory. The downloadable distribution of the code examples is organized this way.</para>
<screen>scalac -classpath ../lib/scalatest-0.9.5.jar -d build complex.scala complex-test.scala
scala -classpath build:../lib/scalatest-0.9.5.jar org.scalatest.tools.Runner \
  -p build -o -s ComplexSuite</screen>
<para>(We used a <literal>\</literal> to continue the second, long command on a second line.) The output is the following.</para>
<screen>Run starting. Expected test count is: 4
Suite Starting - ComplexSuite: The execute method of a nested suite is \
   about to be invoked.
Test Starting - ComplexSuite: addition with (0, 0)
Test Succeeded - ComplexSuite: addition with (0, 0)
Test Starting - ComplexSuite: subtraction with (0, 0)
Test Succeeded - ComplexSuite: subtraction with (0, 0)
Test Starting - ComplexSuite: addition
Test Succeeded - ComplexSuite: addition
Test Starting - ComplexSuite: subtraction
Test Succeeded - ComplexSuite: subtraction
Suite Completed - ComplexSuite: The execute method of a nested suite \
  returned normally.
Run completed. Total number of tests run was: 4
All tests passed.</screen>
<para id="para_again_we_wrapped_the_long_out">Again, we wrapped the long output lines with a <literal>\</literal>.</para>
</sect2>
<sect2 id="ScalaSpecs">
<title>Specs</title>
<para id="para_the__specs__library_http_co">The <emphasis>Specs</emphasis> library <link linkend="ScalaSpecsTool" xrefstyle="select:nopage">[ScalaSpecsTool]</link> is a <emphasis>Behavior-Driven Development</emphasis> <link linkend="BDD" xrefstyle="select:nopage">[BDD]</link> testing tool for Scala. It is inspired by Ruby’s <emphasis>RSpec</emphasis> <link linkend="RSpec" xrefstyle="select:nopage">[RSpec]</link>. In a nutshell, the goal of BDD is to recast traditional test syntax into a form that better emphasizes the role of TDD as a process that drives <emphasis>design</emphasis>, which in turn should implement the <emphasis>requirements</emphasis> “specification”. The syntax of traditional TDD tools, like the <emphasis>XUnit</emphasis> frameworks, tend to emphasize the <emphasis>testing</emphasis> role of TDD. With the syntax realigned, it is believed that the developer will be more likely to stay focused on the <emphasis>primary</emphasis> role of TDD: driving application design.</para>
<para id="para_you_can_also_find_documentation">You can also find documentation on <emphasis>Specs</emphasis> at <link linkend="ScalaTools" xrefstyle="select:nopage">[ScalaTools]</link>.</para>
<para id="para_we_have_already_used__specs__i">We have already used <emphasis>Specs</emphasis> in several examples in the book, <emphasis>e.g.,</emphasis> <literal>ButtonObserverSpec</literal> in <xref linkend="TraitsAsMixins"/> in <xref linkend="Traits"/>. Here is another example for the simple <literal>Complex</literal> class we showed previously.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-spec.scala

import org.specs._

object ComplexSpec extends Specification {
  "Complex addition with (0.0, 0.0)" should {
    "return a number N' that is identical to original number N" in {
      val c1 = Complex(1.2, 3.4)
      (c1 + Complex(0.0, 0.0)) mustEqual c1
    }
  }
  "Complex subtraction with (0.0, 0.0)" should {
    "return a number N' that is identical to original number N" in {
      val c1 = Complex(1.2, 3.4)
      (c1 - Complex(0.0, 0.0)) mustEqual c1
    }
  }
  "Complex addition" should {
    """return a new number where
    the real and imaginary parts are the sums of the
    input values' real and imaginary parts, respectively.""" in {
      val c1 = Complex(1.2, 3.4)
      val c2 = Complex(5.6, 7.8)
      (c1 + c2).real mustEqual (c1.real + c2.real)
      (c1 + c2).imaginary mustEqual (c1.imaginary + c2.imaginary)
    }
  }
  "Complex subtraction" should {
    """return a new number where
    the real and imaginary parts are the differences of the
    input values' real and imaginary parts, respectively.""" in {
      val c1 = Complex(1.2, 3.4)
      val c2 = Complex(5.6, 7.8)
      (c1 - c2).real mustEqual (c1.real - c2.real)
      (c1 - c2).imaginary mustEqual (c1.imaginary - c2.imaginary)
    }
  }
}</programlisting>
<para id="para_an_object_that_extends_spec">An <literal>object</literal> that extends <literal>Specification</literal> is the analog of a test suite. The next level of grouping, <emphasis>e.g.,</emphasis> the clause <literal>"Complex addition with (0.0, 0.0)" should {…}</literal>, encapsulates the information at the level of the type being tested or perhaps a “cluster” of behaviors that go together for the type.</para>
<para id="para_the_next_level_clause__e_g__">The next level clause, <emphasis>e.g.,</emphasis> the clause <literal>"return a number N' that is identical to original number N" in {…}</literal> is called an “example” in BDD terminology. It is analogous to a single test. Like typical <emphasis>XUnit</emphasis> frameworks, the testing is done using “representative examples”, rather than by doing an exhaustive exploration of the entire “space” of possible states. Hence, the term “example”. (However, see the discussion of <emphasis>ScalaCheck</emphasis> next.)</para>
<para id="para_statements_like_c1_complex">Statements like <literal>(c1 + Complex(0.0, 0.0)) mustEqual c1</literal> are called “expectations”. They do the actual verifications that conditions are satisfied. Hence, “expectations” are analogous to assertions in <emphasis>XUnit</emphasis> tools.</para>
<para id="para_there_are_several_ways_to_run_">There are several ways to run your “specs”. After compiling <literal>complex-spec.scala</literal> above, we can run the “specs” as follows.</para>
<screen>scala -classpath ../lib/specs-1.4.3.jar:build ComplexSpec</screen>
<para id="para_here_as_before_we_assume_the">Here, as before, we assume the <emphasis>Specs</emphasis> jar is in the <literal>../lib</literal> directory and we assume the compiled class files are in the <literal>build</literal> directory. We get the following output.</para>
<screen>Specification "ComplexSpec"
  Complex addition with (0.0, 0.0) should
  + return a number N' that is identical to original number N

  Total for SUT "Complex addition with (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  Complex subtraction with (0.0, 0.0) should
  + return a number N' that is identical to original number N

  Total for SUT "Complex subtraction with (0.0, 0.0)":
  Finished in 0 second, 0 ms
  1 example, 1 expectation, 0 failure, 0 error

  Complex addition should
  + return a new number where
        the real and imaginary parts are the sums of the
        input values real and imaginary parts, respectively.

  Total for SUT "Complex addition":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

  Complex subtraction should
  + return a new number where
        the real and imaginary parts are the differences of the
        input values real and imaginary parts, respectively.

  Total for SUT "Complex subtraction":
  Finished in 0 second, 0 ms
  1 example, 2 expectations, 0 failure, 0 error

Total for specification "ComplexSpec":
Finished in 0 second, 37 ms
4 examples, 6 expectations, 0 failure, 0 error</screen>
<para id="para_note_that_the_strings_in_the_s">Note that the strings in the specification are written in a form that reads somewhat like a requirements specification.</para>
<screen>...
Complex addition with (0.0, 0.0) should
+ return a number N' that is identical to original number N
...</screen>
<para id="para_there_are_many_ways_to_run_spe">There are many ways to run specifications, including using an <emphasis>Ant</emphasis> task or using the built-in integration with <emphasis>ScalaTest</emphasis> or <emphasis>JUnit</emphasis>. <emphasis>JUnit</emphasis> is the best approach for running specifications in some IDEs. These and other options are described in the <emphasis>User’s Guide</emphasis> at <ulink url="http://code.google.com/p/specs/wiki/RunningSpecs"/>.</para>
</sect2>
<sect2 id="ScalaCheck">
<title>ScalaCheck</title>
<para id="para__scalacheck__http_code_goog"><emphasis>ScalaCheck</emphasis> <link linkend="ScalaCheckTool" xrefstyle="select:nopage">[ScalaCheckTool]</link> is a Scala port of the innovative Haskell <emphasis>QuickCheck</emphasis> <link linkend="QuickCheck" xrefstyle="select:nopage">[QuickCheck]</link> tool that supports <emphasis>Automated Specification-Based Testing</emphasis>, sometimes called <emphasis>type-based “property” testing</emphasis> in the Haskell literature (<emphasis>e.g.,</emphasis> <link linkend="OSullivan2009" xrefstyle="select:nopage">[O'Sullivan2009]</link>).</para>
<para id="para__scalacheck__can_be_installed_"><emphasis>ScalaCheck</emphasis> can be installed using <userinput>sbaz</userinput>, <emphasis>i.e.,</emphasis> <userinput>sbaz install scalacheck</userinput>.</para>
<para id="para_using__scalacheck__or__quickc">Using <emphasis>ScalaCheck</emphasis> (or <emphasis>QuickCheck</emphasis> for Haskell), conditions for a type are specified that should be true for any instances of the type. The tool tries the conditions using automatically-generated instances of the type and verifies that the conditions are satisfied.</para>
<para id="para_here_is_a__scalacheck__test_fo">Here is a <emphasis>ScalaCheck</emphasis> test for <literal>Complex</literal>.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-check-script.scala

import org.scalacheck._
import org.scalacheck.Prop._

def toD(i: Int) = i * .1

implicit def arbitraryComplex: Arbitrary[Complex] = Arbitrary {
  Gen.sized {s =&gt;
    for {
      r &lt;- Gen.choose(-toD(s), toD(s))
      i &lt;- Gen.choose(-toD(s), toD(s))
    } yield Complex(r, i)
  }
}

object ComplexSpecification extends Properties("Complex") {
  def additionTest(a: Complex, b: Complex) =
    (a + b).real.equals(a.real + b.real) &amp;&amp;
    (a + b).imaginary.equals(a.imaginary + b.imaginary)

  def subtractionTest(a: Complex, b: Complex) =
    (a - b).real.equals(a.real - b.real) &amp;&amp;
    (a - b).imaginary.equals(a.imaginary - b.imaginary)

  val zero = Complex(0.0, 0.0)

  specify("addition with (0,0)", (a: Complex)  =&gt; additionTest(a, zero))
  specify("subtraction with (0,0)", (a: Complex)  =&gt; subtractionTest(a, zero))

  specify("addition", (a: Complex, b: Complex) =&gt; additionTest(a,b))
  specify("subtraction", (a: Complex, b: Complex) =&gt; subtractionTest(a,b))
}
ComplexSpecification.check</programlisting>
<para id="para_the_tod_function_just_conver">The <literal>toD</literal> function just converts an <literal>Int</literal> to a <literal>Double</literal> by dividing by <literal>0.1</literal>. It’s useful to convert an <literal>Int</literal> index provided by <emphasis>ScalaCheck</emphasis> into <literal>Double</literal> values that we will use to construct <literal>Complex</literal> instances.</para>
<para id="para_we_also_need_an_implicit_conve">We also need an implicit conversion visible in the scope of the test that generates new <literal>Complex</literal> values. The <literal>arbitraryComplex</literal> function provides this generator. An <literal>Arbitrary[Complex]</literal> object (part of the <emphasis>ScalaCheck</emphasis> API) is returned by this method. <emphasis>ScalaCheck</emphasis> invokes another API method <literal>Gen[Complex].sized</literal>. We provide a <emphasis>function literal</emphasis> that assigns a passed-in <literal>Int</literal> value to a variable <literal>s</literal>. We then use a <literal>for</literal> comprehension to return <literal>Complex</literal> numbers with real and imaginary parts that range from <literal>-toD(s)</literal> to <literal>toD(s)</literal> (<emphasis>i.e.,</emphasis> <literal>-(s * .1)</literal> to <literal>(s * .1)</literal>). Fortunately, you don’t have to define implicit conversions or generators for most of the commonly-used Scala and Java types.</para>
<para id="para_the_most_interesting_part_is_t">The most interesting part is the definition and use of <literal>ComplexSpecification</literal>. This object defines a few helper methods, <literal>additionTest</literal> and <literal>subtractionTest</literal> that each return <literal>true</literal> if the conditions they define are true. For <literal>additionTest</literal>, if a new <literal>Complex</literal> number is the sum of two other <literal>Complex</literal> numbers, then its <literal>real</literal> part must equal the sum of the <literal>real</literal> parts of the two original numbers. Likewise, a similar condition must hold for the <literal>imaginary</literal> part of the numbers. For <literal>subtractionTest</literal>, the same conditions must hold with subtraction substituted for addition.</para>
<para id="para_next_two_specify_clauses_as">Next, two <literal>specify</literal> clauses assert that the addition and subtraction conditions should hold for any <literal>Complex</literal> number when <literal>Complex(0.0, 0.0)</literal> is added to it or subtracted from it, respective. Two more <literal>specify</literal> classes assert that the conditions should also hold for any pair of <literal>Complex</literal> numbers.</para>
<para id="para_finally_when_complexspecific">Finally, when <literal>ComplexSpecification.check</literal> is called, test runs are made with different values of <literal>Complex</literal> numbers, verifying that the properties specified are valid for each combination of numbers passed to the helper methods.</para>
<para id="para_we_can_run_the_check_using_the">We can run the check using the following command (once again assuming that <literal>Complex</literal> is already compiled into the <literal>build</literal> directory).</para>
<screen>scala -classpath ../lib/scalacheck.jar:build complex-check-script.scala</screen>
<para id="para_it_produces_the_following_outp">It produces the following output.</para>
<screen>+ Complex.addition with (0,0): OK, passed 100 tests.
+ Complex.addition: OK, passed 100 tests.
+ Complex.subtraction with (0,0): OK, passed 100 tests.
+ Complex.subtraction: OK, passed 100 tests.</screen>
<para id="para_note_that_by_default__scalach">Note that <emphasis>ScalaCheck</emphasis> tried each <literal>specify</literal> case with 100 different inputs.</para>
<para id="para_it_s_important_to_understand_t">It’s important to understand the value that <emphasis>ScalaCheck</emphasis> delivers. Rather than going through the process of writing enough “example” test cases with representative data, which is tedious and error prone, we define reusable “generators”, like the <literal>arbitraryComplex</literal> function, to produce an appropriate range of instances of the type under test. Then we write property specifications that should hold for any instances. <emphasis>ScalaCheck</emphasis> does the work of testing the properties against a random sample of the instances produced by the generators.</para>
<para id="para_you_can_find_more_examples_of_">You can find more examples of <emphasis>ScalaCheck</emphasis> usage in the online code examples. Some of the types used in the <emphasis>payroll</emphasis> example in <xref linkend="InternalDSLs"/> in <xref linkend="DomainSpecificLanguages"/> were tested with <emphasis>ScalaCheck</emphasis>. These tests were not shown in <xref linkend="InternalDSLs"/>.</para>
<para id="para_finally_note_that_there_is_an">Finally, note that there is another port of <emphasis>QuickCheck</emphasis> called <emphasis>Reductio</emphasis>. It is part of the <emphasis>Functional Java</emphasis> project <link linkend="FunctionalJava" xrefstyle="select:nopage">[FunctionalJava]</link>. <emphasis>Reductio</emphasis> is less widely used than <emphasis>ScalaCheck</emphasis>, but it offers a “native” Java API as well as a Scala API, so it would be more convenient for “pure” Java teams.</para>
</sect2>
</sect1>
<sect1 id="OtherLibraries">
<title>Other Notable Scala Libraries and Tools</title>
<para id="para_while_scala_benefits_from_the_">While Scala benefits from the rich legacy of Java and .NET libraries, there is a growing collection of libraries written specifically for Scala. Here we discuss some of the more notable ones.</para>
<sect2 id="Lift">
<title>Lift</title>
<para id="para__lift__http_liftweb_net_i"><emphasis>Lift</emphasis> (<ulink url="http://liftweb.net/"/>) is the leading web application framework written in Scala. It recently reached “1.0” status. <emphasis>Lift</emphasis> has been used for a number of commercial websites. You can also find documentation on Lift at <link linkend="ScalaTools" xrefstyle="select:nopage">[ScalaTools]</link>.</para>
<para id="para_other_web_frameworks_include_s">Other web frameworks include Sweet (<ulink url="http://code.google.com/p/sweetscala/"/>), Pinky (<ulink url="http://bitbucket.org/pk11/pinky/wiki/Home"/>), and Slinky (<ulink url="http://code.google.com/p/slinky2/"/>).</para>
</sect2>
<sect2 id="Scalaz">
<title>Scalaz</title>
<para id="para__scalaz__http_wiki_workingm"><emphasis>Scalaz</emphasis> (<ulink url="http://code.google.com/p/scalaz/"/>) is a library that fills-in gaps in the standard library. Among its features are enhancements to several core Scala types, such as <literal>Boolean</literal>, <literal>Unit</literal>, <literal>String</literal>, and <literal>Option</literal>, plus support for functional <emphasis>control</emphasis> abstractions, such as <literal>FoldLeft</literal>, <literal>FoldRight</literal>, <literal>Monad</literal>, <emphasis>etc.</emphasis> that expand upon what is available in the standard library.</para>
</sect2>
<sect2 id="Scalax">
<title>Scalax</title>
<para id="para__scalax__http_scalax_scalaf"><emphasis>Scalax</emphasis> (<ulink url="http://scalax.scalaforge.org/"/>) is another third-party library effort to supplement the Scala core library.</para>
</sect2>
<sect2 id="MetaScala">
<title>MetaScala</title>
<para id="para__metascala__http_www_assemb"><emphasis>MetaScala</emphasis> (<ulink url="http://www.assembla.com/wiki/show/metascala"/>) is an experimental metaprogramming library for Scala. Metaprogramming features tend to be weaker in statically-typed languages than in dynamically-typed languages. Also, the JVM and .NET CLR impose their own constraints on metaprogramming.</para>
<para id="para_many_of_the_features_of_scala_">Many of the features of Scala obviate the need for metaprogramming, compared to languages like Ruby, but sometimes metaprogramming is still useful. <emphasis>MetaScala</emphasis> attempts to address those needs more fully than Scala’s built-in reflection support.</para>
</sect2>
<sect2 id="JavaRebel">
<title>JavaRebel</title>
<para id="para__javarebel__is_a_commercial_to"><emphasis>JavaRebel</emphasis> is a commercial tool that permits dynamic reloading of classes in a running JVM (written in any language), beyond the limited support provided natively by the “HotSwap” feature of the JVM. <emphasis>JavaRebel</emphasis> is designed to provide the developer faster turnaround for changes, providing an experience more like the rapid turnaround users of dynamic languages enjoy. <emphasis>JavaRebel</emphasis> can be used with Scala code, as well.</para>
</sect2>
<sect2 id="MiscSmallerLibraries">
<title>Miscellaneous Smaller Libraries</title>
<para id="para_finally_here_is_a_list_of_sev">Finally, here is a list of several Scala-specific libraries you might find useful for your applications.</para>
<table id="misc-scala-libs">
<title>Miscellaneous Scala Libraries.</title>
<tgroup cols="2">


<thead valign="top">
<row>
<entry> Name </entry>
<entry> Description and URL</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry><para>Kestrel</para></entry>
<entry><para>A tiny, very fast queue system (<ulink url="http://github.com/robey/kestrel/tree/master"/>).</para></entry>
</row>
<row>
<entry><para>ScalaModules</para></entry>
<entry><para>Scala DSL to ease OSGi development (<ulink url="http://code.google.com/p/scalamodules/"/>).</para></entry>
</row>
<row>
<entry><para>Configgy</para></entry>
<entry><para>Managing configuration files and logging for “daemons” written in Scala (<ulink url="http://www.lag.net/configgy/"/>).</para></entry>
</row>
<row>
<entry><para>scouchdb</para></entry>
<entry><para>Scala interface to CouchDB (<ulink url="http://code.google.com/p/scouchdb/"/>).</para></entry>
</row>
<row>
<entry><para>scala-otp</para></entry>
<entry><para>A project to implement a platform for building fault-tolerant, distributed applications based on Actors, patterned after Erlang’s OTP (<ulink url="http://github.com/jboner/scala-otp/tree/master"/>).</para></entry>
</row>
<row>
<entry><para>scala-query</para></entry>
<entry><para>A type-safe database query API for Scala (<ulink url="http://github.com/szeiger/scala-query/tree/master"/>).</para></entry>
</row>
</tbody>
</tgroup>
</table>
<para id="para_we_ll_discuss_using_scala_with">We’ll discuss using Scala with several well-known Java libraries after we discuss Java interoperability next.</para>
</sect2>
</sect1>
<sect1 id="JavaInterop">
<title>Java Interoperability</title>
<para id="para_of_all_the_alternative_jvm_lan">Of all the alternative JVM languages, Scala’s interoperability with Java source code is among the most seamless. This section begins with a discussion of interoperability with code written in Java. Once you understand the details, they can be generalized to address interoperability with other JVM languages, such as JRuby or Groovy. For example, if you already know how to use JRuby and Java together and you know how to use Java and Scala together, then you can generalize to using JRuby and Scala together.</para>
<para id="para_because_scala_syntax_is_primar">Because Scala syntax is primarily a superset of Java syntax, invoking Java code from Scala is usually straightforward. Going the other direction requires that you understand how some Scala features are encoded in ways that satisfy the JVM specification. We discuss several of the interoperability issues here. <link linkend="Spiewak2009a" xrefstyle="select:nopage">[Spiewak2009a]</link> and <link linkend="Odersky2008" xrefstyle="select:nopage">[Odersky2008]</link> provide additional information.</para>
<sect2 id="_java_and_scala_generics">
<title>Java and Scala Generics</title>
<para id="para_we_have_seen_many_examples_of_">We have seen many examples of Scala code that uses Java types, such as <literal>java.lang.String</literal> and various java collection classes. Instantiating Java generic types is straightforward in Scala (since Scala version 2.7.0). Consider the following very simple Java generic class, <literal>JStack</literal>.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/JStack.java

import java.util.*;

public class JStack&lt;T&gt; {
  private List&lt;T&gt; stack = new ArrayList&lt;T&gt;();
  public void push(T t) {
    stack.add(t);
  }
  public T pop() {
    return stack.remove(stack.size() - 1);
  }
}</programlisting>
<para id="para_we_can_instantiate_it_from_sca">We can instantiate it from Scala, specifying the type parameter, as shown next.</para>
<example>
<title>A Scala “spec” to test the simple Java stack.</title>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/JStack-spec.scala

import org.specs._

object JStackSpec extends Specification {
  "Calling a Java generic type from Scala" should {
    "Support parameterization" in {
      val js = new JStack[String]
      js must notBe(null)  // Dummy check...
    }
    "Support invoking the the type's methods" in {
      val js = new JStack[String]
      js.push("one")
      js.push("two")
      js.pop() mustEqual "two"
      js.pop() mustEqual "one"
    }
  }
}</programlisting>
</example>
<para id="para_since_scala_version_2_7_2_you">Since Scala version 2.7.2, you can also use Scala generics from Java. Consider the following JUnit 4 test, which shows some of the idiosyncrasies you might encounter.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/SMapTest.java

import org.junit.*;
import static org.junit.Assert.*;
import scala.*;
import scala.collection.mutable.LinkedHashMap;

public class SMapTest {
  static class Name {
    public String firstName;
    public String lastName;

    public Name(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName  = lastName;
    }
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  @Before
  public void setup() {
    map = new LinkedHashMap&lt;Integer, Name&gt;();
    map.update(1, new Name("Dean", "Wampler"));
    map.update(2, new Name("Alex", "Payne"));
  }

  @Test
  public void usingMapGetWithWarnings() {
    assertEquals(2, map.size());
    Option&lt;Name&gt; n1 = map.get(1);  // warning
    Option&lt;Name&gt; n2 = map.get(2);  // warning
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals("Dean", n1.get().firstName);
    assertEquals("Alex", n2.get().firstName);
  }

  @Test
  public void usingMapGetWithoutWarnings() {
    assertEquals(2, map.size());
    Option&lt;?&gt; n1 = map.get(1);
    Option&lt;?&gt; n2 = map.get(2);
    assertTrue(n1.isDefined());
    assertTrue(n2.isDefined());
    assertEquals("Dean", ((Name) n1.get()).firstName);
    assertEquals("Alex", ((Name) n2.get()).firstName);
 }
}</programlisting>
<para id="para_on_unix_like_systems_it_is_co">On UNIX-like systems, it is compiled with the following command line.</para>
<screen>javac -Xlint:unchecked \
  -cp $SCALA_HOME/lib/scala-library.jar:$JUNIT_HOME/junit-4.4.jar SMapTest.java</screen>
<para>(Again, we wrapped the long line with <literal>\</literal>.) <literal>SCALA_HOME</literal> and <literal>JUNIT_HOME</literal> are the installation directories of Scala and JUnit, respectively.</para>
<para id="para_the_smaptest_class_defines_a">The <literal>SMapTest</literal> class defines a nested <literal>Name</literal> class that is used as the “value” type in a <literal>scala.collection.mutable.LinkedHashMap</literal>. For simplicity, <literal>Name</literal> has public <literal>firstName</literal> and <literal>lastName</literal> fields and a constructor.</para>
<para id="para_the_setup_method_creates_a_n">The <literal>setup</literal> method creates a new <literal>LinkedHashMap&lt;Integer,Name&gt;</literal> and inserts two key-value pairs. The two tests, <literal>usingMapGetWithWarnings</literal> and <literal>usingMapGetWithoutWarnings</literal> exercise the Java-Scala interoperability the same way. However, the first test has two compile-time warnings, indicated by the <literal>// warning</literal> comments, while the second test compiles without warnings.</para>
<screen>SMapTest.java:29: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n1 = map.get(1);  // warning
                             ^
SMapTest.java:30: warning: [unchecked] unchecked conversion
found   : scala.Option
required: scala.Option&lt;SMapTest.Name&gt;
    Option&lt;Name&gt; n2 = map.get(2);  // warning
                             ^
2 warnings</screen>
<para id="para_the_warnings_occur_because_of_">The warnings occur because of type erasure. In the compiled scala library, the return type of <literal>Map.get</literal> is <literal>Option</literal> with no type parameter or effectively <literal>Option&lt;Object&gt;</literal>. So we get warnings for the conversion to <literal>Option&lt;Name&gt;</literal>.</para>
<para id="para_the_second_test_usingmapgetw">The second test, <literal>usingMapGetWithoutWarnings</literal>, has no warnings, because we assign the values returned by <literal>Map.get</literal> to <literal>Option&lt;?&gt;</literal> and then do an explicit cast to <literal>Name</literal> when we call <literal>Option.get</literal> in the final two assertions.</para>
</sect2>
<sect2 id="FunctionsInJava">
<title>Using Scala Functions in Java</title>
<para id="para_continuing_with_our_previous_">Continuing with our previous <literal>SMapTest</literal> example, we can explore invoking Scala code from Java where Scala functions are required.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/SMapTestWithFunctions.java

import org.junit.*;
import static org.junit.Assert.*;
import scala.*;
import scala.collection.mutable.LinkedHashMap;
import static scala.collection.Map.Projection;

public class SMapTestWithFunctions {
  static class Name {
    public String firstName;
    public String lastName;

    public Name(String firstName, String lastName) {
      this.firstName = firstName;
      this.lastName  = lastName;
    }

    public static Name emptyName = new Name("","");

    public static Function0&lt;Name&gt; empty = new Function0&lt;Name&gt;() {
      public Name apply() { return emptyName; }

      public int $tag() { return 0; }
    };
  }

  LinkedHashMap&lt;Integer, Name&gt; map;

  @Before
  public void setup() {
    map = new LinkedHashMap&lt;Integer, Name&gt;();
    map.update(1, new Name("Dean", "Wampler"));
    map.update(2, new Name("Alex", "Payne"));
  }

  @Test
  public void usingMapGetOrElse() {
    assertEquals(2, map.size());
    assertEquals("Dean", ((Name) map.getOrElse(1, Name.empty)).firstName);
    assertEquals("Alex", ((Name) map.getOrElse(2, Name.empty)).firstName);
  }

  Function1&lt;Integer, Boolean&gt; filter = new Function1&lt;Integer, Boolean&gt;() {
    public Boolean apply(Integer i) { return i.intValue() &lt;= 1; }

    public &lt;A&gt; Function1&lt;A,Boolean&gt; compose(Function1&lt;A,Integer&gt; g) {
      return Function1$class.compose(this, g);
    }

    public &lt;A&gt; Function1&lt;Integer,A&gt; andThen(Function1&lt;Boolean,A&gt; g) {
      return Function1$class.andThen(this, g);
    }

    public int $tag() { return 0; }
  };

  @Test
  public void usingFilterKeys() {
    assertEquals(2, map.size());
    Projection&lt;Integer, Name&gt; filteredMap =
        (Projection&lt;Integer, Name&gt;) map.filterKeys(filter);
    assertEquals(1, filteredMap.size());
    assertEquals("Dean", filteredMap.getOrElse(1, Name.empty).firstName);
    assertEquals("",     filteredMap.getOrElse(2, Name.empty).firstName);
  }
}</programlisting>
<para id="para_the_smaptestwithfunctions_cl">The <literal>SMapTestWithFunctions</literal> class has its own <literal>Name</literal> class that adds a static <literal>emptyName</literal> object and a static <literal>scala.Function0</literal> object <literal>empty</literal>, which defines <literal>apply</literal> to return <literal>emptyName</literal>. Note that it is also necessary to define the <literal>$tag</literal> method that was discussed previously in the <xref linkend="CommandLineToolDecompilers"/> section.</para>
<para id="para_the_empty_function_object_is">The <literal>empty</literal> function object is needed when we use <literal>Map.getOrElse</literal> in the test method, <literal>usingMapGetOrElse</literal>. The signature of <literal>getOrElse</literal> is the following.</para>
<programlisting linenumbering="unnumbered">def getOrElse[B2 &gt;: B](key : A, default : =&gt; B2) : B2</programlisting>
<para id="para_where_a_is_the_key_type_para">Where <literal>A</literal> is the key type parameter, <literal>B</literal> is the value type parameter, and <literal>B2</literal> is a supertype of <literal>B</literal> or the same as <literal>B</literal>. The second <literal>default</literal> argument is a <emphasis>by-name</emphasis> parameter. As discussed in <xref linkend="FunctionalProgramming"/>, <emphasis>by-name</emphasis> parameters are implemented as <literal>scala.Function0</literal> objects. So, we can’t simply pass in the static object <literal>emptyName</literal>.</para>
<para id="para_the_second_test_usingfilterk">The second test, <literal>usingFilterKeys</literal>, requires a <literal>Function1</literal> object, which has an <literal>apply</literal> method that takes one argument. We use this <literal>Function1</literal> object as a filter passed to <literal>Map.filterKeys</literal>.</para>
<para id="para_we_define_the_filter_before_">We define the <literal>filter</literal> before the test. The Java code here is considerably more involved than the equivalent Scala code would be! Not only do we have to define the <literal>apply</literal> and <literal>$tag</literal> methods, we must also define methods used for function composition, <literal>compose</literal> and <literal>andThen</literal>. Fortunately, we can delegate to objects that are already in the Scala library, as shown. Note that other <literal>FunctionN</literal> types, for <literal>N</literal> equals 2 to 22, have other methods that would have to be implemented using similar “boilerplate”. For example, these types each have a <literal>curry</literal> method.</para>
<para id="para_finally_recall_that_in_comp">Finally, recall that in <xref linkend="CompanionObjectsAndJavaStaticMethods"/> in <xref linkend="AdvancedObjectOrientedProgramming"/>, we discussed that methods defined in companion objects are not visible as <literal>static</literal> methods to Java code. For example, <literal>main</literal> methods defined in companion objects can’t be used to run the application. Instead, you should define such methods in <emphasis>singleton</emphasis> objects.</para>
<para id="para_so_using_scala_function_objec">So, using Scala function objects from Java can be challenging. If you find it necessary to use them frequently, you could define Java utility classes that handle the “boilerplate” for all the methods except <literal>apply</literal>.</para>
</sect2>
<sect2 id="JavaBeanProperties">
<title>JavaBean Properties</title>
<para id="para_we_saw_in_objectorientedprog">We saw in <xref linkend="BasicObjectOrientedProgramming"/> that Scala does not follow the <emphasis>JavaBeans</emphasis> <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link> conventions for field reader and writer methods, for reasons described in <xref linkend="UniformAccessPrinciple"/>. However, there are times when you need <emphasis>JavaBeans</emphasis> accessor methods. For example, you need them when you want your Scala instances to be configurable by a <emphasis>dependency-injection</emphasis> mechanism, like the one provided by the Spring Framework <link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link>. You may also need <emphasis>JavaBeans</emphasis> accessor methods for some IDEs that do bean “introspection”.</para>
<para id="para_scala_solves_this_problem_with">Scala solves this problem with an annotation that you can apply to a field, <literal>@scala.reflect.BeanProperty</literal>, which tells the compiler to generate JavaBeans-style getter and setter methods. We introduced this annotation in <xref linkend="Annotations"/> in <xref linkend="ApplicationDesign"/>.</para>
<para id="para_recall_the_complex_class_we_">Recall the <literal>Complex</literal> class we saw previously. Now we add the annotation to each constructor argument, which is a field in the <literal>case</literal> class.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/complex-javabean.scala

case class ComplexBean(
  @scala.reflect.BeanProperty real: Double,
  @scala.reflect.BeanProperty imaginary: Double) {

  def +(that: ComplexBean) =
    new ComplexBean(real + that.real, imaginary + that.imaginary)
  def -(that: ComplexBean) =
    new ComplexBean(real - that.real, imaginary - that.imaginary)
}</programlisting>
<para id="para_if_you_compile_this_class_the">If you compile this class, then decompile it with <userinput>javap -classpath ... ComplexBean</userinput>, you get the following output.</para>
<programlisting linenumbering="unnumbered">public class ComplexBean extends java.lang.Object
  implements scala.ScalaObject,scala.Product,java.io.Serializable{
  public ComplexBean(double, double);
  public java.lang.Object productElement(int);
  public int productArity();
  public java.lang.String productPrefix();
  public boolean equals(java.lang.Object);
  public java.lang.String toString();
  public int hashCode();
  public int $tag();
  public ComplexBean $minus(ComplexBean);
  public ComplexBean $plus(ComplexBean);
  public double imaginary();
  public double real();
  public double getImaginary();
  public double getReal();
}</programlisting>
<para id="para_now_compare_this_output_with_t">Now compare this output with the result of decompiling the original <literal>Complex.class</literal> file.</para>
<programlisting linenumbering="unnumbered">public class Complex extends java.lang.Object
  implements scala.ScalaObject,scala.Product,java.io.Serializable{
  public Complex(double, double);
  public java.lang.Object productElement(int);
  public int productArity();
  public java.lang.String productPrefix();
  public boolean equals(java.lang.Object);
  public java.lang.String toString();
  public int hashCode();
  public int $tag();
  public Complex $minus(Complex);
  public Complex $plus(Complex);
  public double imaginary();
  public double real();
}</programlisting>
<para id="para_the_order_of_the_methods_shown">The order of the methods shown may be different when you run <userinput>javap</userinput> on these files. We reordered them so the two listings would match as closely as possible. Note that the only differences are the names of the classes and the presence of <literal>getImaginary</literal> and <literal>getReal</literal> methods in the <literal>ComplexBean</literal> case. We would also have corresponding setter methods if the <literal>real</literal> and <literal>imaginary</literal> fields were declared as <literal>vars</literal> instead of <literal>vals</literal>.</para>
<warning id="para_warning_the__scaladoc__page_f"><para>The <emphasis>Scaladoc</emphasis> page for <literal>@BeanProperty</literal> (version 2.7) say that you can’t call the bean setter methods from Scala. You can call them, but as the <emphasis>Scaladoc</emphasis> page goes on to say, you should use the Scala-style writer (and reader) methods instead.</para></warning>
</sect2>
<sect2 id="AnyValTypesAndJavaPrimitives">
<title>AnyVal Types and Java Primitives</title>
<para id="para_notice_also_in_the_previous_c">Notice also in the previous <literal>Complex</literal> example that the <literal>Doubles</literal> were converted to Java primitive <literal>doubles</literal>. All the <literal>AnyVal</literal> types are converted to their corresponding Java primitives. We showed the mapping in <xref linkend="AnyVal-value-types"/>. In particular, note that <literal>Unit</literal> is mapped to <literal>void</literal>.</para>
</sect2>
<sect2 id="ScalaNamesInJavaCode">
<title>Scala Names in Java Code</title>
<para id="para_as_we_discussed_in_roundingo">As we discussed in <xref linkend="RoundingOutTheEssentials"/>, Scala allows more flexible identifiers, <emphasis>e.g.</emphasis>, <emphasis>operator characters</emphasis> like <literal>*</literal>, <literal>&lt;</literal>, <emphasis>etc.</emphasis> These characters are encoded (or “mangled”, if you prefer) to satisfy the tighter constraints of the JVM specification. They are translated as follows (adapted from <link linkend="Spiewak2009a" xrefstyle="select:nopage">[Spiewak2009a]</link>).</para>
<table id="char-encoding">
<title>Encoding of operator characters.</title>
<tgroup cols="2">


<thead valign="top">
<row>
<entry> Operator </entry>
<entry> Encoding</entry>
</row>
</thead>
<tbody valign="top">
<row>
<entry><para>=</para></entry>
<entry><para><literal>$eq</literal></para></entry>
</row>
<row>
<entry><para>&gt;</para></entry>
<entry><para><literal>$greater</literal></para></entry>
</row>
<row>
<entry><para>&lt;</para></entry>
<entry><para><literal>$less</literal></para></entry>
</row>
<row>
<entry><para>+</para></entry>
<entry><para><literal>$plus</literal></para></entry>
</row>
<row>
<entry><para>-</para></entry>
<entry><para><literal>$minus</literal></para></entry>
</row>
<row>
<entry><para>*</para></entry>
<entry><para><literal>$times</literal></para></entry>
</row>
<row>
<entry><para>/</para></entry>
<entry><para><literal>$div</literal></para></entry>
</row>
<row>
<entry><para>\</para></entry>
<entry><para><literal>$bslash</literal></para></entry>
</row>
<row>
<entry><para>|</para></entry>
<entry><para><literal>$bar</literal></para></entry>
</row>
<row>
<entry><para>!</para></entry>
<entry><para><literal>$bang</literal></para></entry>
</row>
<row>
<entry><para>?</para></entry>
<entry><para><literal>$qmark</literal></para></entry>
</row>
<row>
<entry><para>:</para></entry>
<entry><para><literal>$colon</literal></para></entry>
</row>
<row>
<entry><para>%</para></entry>
<entry><para><literal>$percent</literal></para></entry>
</row>
<row>
<entry><para>^</para></entry>
<entry><para><literal>$up</literal></para></entry>
</row>
<row>
<entry><para>&amp;</para></entry>
<entry><para><literal>$amp</literal></para></entry>
</row>
<row>
<entry><para>@</para></entry>
<entry><para><literal>$at</literal></para></entry>
</row>
<row>
<entry><para>#</para></entry>
<entry><para><literal>$hash</literal></para></entry>
</row>
<row>
<entry><para>~</para></entry>
<entry><para><literal>$tilde</literal></para></entry>
</row>
</tbody>
</tgroup>
</table>
<para id="para_you_can_see_this_at_work_in_th">You can see this at work in the following contrived trait, where each character is used to declare an abstract method that takes no arguments and returns <literal>Unit</literal>.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/all-op-chars.scala

trait AllOpChars {
  def == : Unit   // $eq$eq
  def &gt;  : Unit   // $greater
  def &lt;  : Unit   // $less
  def +  : Unit   // $plus
  def -  : Unit   // $minus
  def *  : Unit   // $times
  def /  : Unit   // $div
  def \  : Unit   // $bslash
  def |  : Unit   // $bar
  def !  : Unit   // $bang
  def ?  : Unit   // $qmark
  def :: : Unit   // $colon$colon
  def %  : Unit   // $percent
  def ^  : Unit   // $up
  def &amp;  : Unit   // $amp
  def @@ : Unit   // $at$at
  def ## : Unit   // $hash$hash
  def ~  : Unit   // $tilde
}</programlisting>
<para id="para_note_that_we_doubled_up_some_o">Note that we doubled up some of the characters to get them to compile as method names, where using single characters would have been ambiguous. Compiling this file and decompiling the resulting class file with <userinput>javap AllOpChars</userinput> yields the following Java interface. (We have rearranged the output order of the methods to match the order in the original Scala file.)</para>
<programlisting linenumbering="unnumbered">Compiled from "all-op-chars.scala"
public interface AllOpChars{
  public abstract void $eq$eq();
  public abstract void $greater();
  public abstract void $less();
  public abstract void $plus();
  public abstract void $minus();
  public abstract void $times();
  public abstract void $div();
  public abstract void $bslash();
  public abstract void $bar();
  public abstract void $bang();
  public abstract void $qmark();
  public abstract void $colon$colon();
  public abstract void $percent();
  public abstract void $up();
  public abstract void $amp();
  public abstract void $at$at();
  public abstract void $hash$hash();
  public abstract void $tilde();
}</programlisting>
<para id="para_to_conclude_interoperability_">To conclude, interoperability between Java and Scala works very well, but there are a few things you must remmeber when invoking Scala code from Java. If you’re uncertain about how a Scala identifier is encoded or a Scala method is translated to valid byte code, use <userinput>javap</userinput> to find out.</para>
</sect2>
</sect1>
<sect1 id="JavaLibraryInterop">
<title>Java Library Interoperability</title>
<para id="para_this_section_specifically_cons">This section specifically considers interoperability with several important Java frameworks: AspectJ, the Spring Framework, Terracotta, and Hadoop. Because they are widely used in “enterprise” and Internet Java applications, successful interoperability with Scala is important.</para>
<sect2 id="AspectJInterop">
<title>AspectJ</title>
<para id="para_aspectj_aspectj_is_an_exte">AspectJ <link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link> is an extension of Java that supports <emphasis>Aspect-Oriented Programming</emphasis> (AOP), also known as <emphasis>Aspect-Oriented Software Development</emphasis> <link linkend="AOSD" xrefstyle="select:nopage">[AOSD]</link>. The goal of AOP is to enable systemic changes of the same kind across many modules, while avoiding copying and pasting the same code over and over into each location. Avoiding this duplication not only improves productivity, it greatly reduces bugs.</para>
<para id="para_for_example_if_you_want_all_f">For example, if you want all field changes to all “domain model” objects to be persisted automatically after the changes occur, you can write an aspect that observes those changes and triggers a persistence write after each change.</para>
<para id="para_aspectj_supports_aop_by_provid">AspectJ supports AOP by providing a <emphasis>pointcut language</emphasis> for specifying in a declarative way all the “execution points” in a program for which a particular behavior modification (called <emphasis>advice</emphasis>) is required. In AspectJ parlance, each execution point is called a <emphasis>join point</emphasis> and a particular query over join points is a <emphasis>pointcut</emphasis>. Hence the <emphasis>pointcut language</emphasis> is a query language, of sorts. For a given pointcut, AspectJ incorporates the desired behavior modifications into each join point. Manual insertion of these changes is not required. An <emphasis>aspect</emphasis> encapsulates pointcuts and advices, much the way a class encapsulates member fields and methods.</para>
<para id="para_for_a_detailed_introduction_to">For a detailed introduction to AspectJ with many practical examples, see <xref linkend="Laddad2009"/>.</para>
<para id="para_there_are_two_issues_that_must">There are two issues that must be considered when using AspectJ with Scala. The first issue is how to reference Scala execution points using AspectJ’s pointcut language, <emphasis>e.g.,</emphasis> Scala types and methods. The second issue is how to invoke Scala code as <emphasis>advice</emphasis>.</para>
<para id="para_let_s_look_at_an_aspect_that_l">Let’s look at an aspect that logs method calls to the <literal>Complex</literal> class we used previously in this chapter. We’ll add a package declaration this time to provide some scope.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/aspectj/complex.scala

package example.aspectj

case class Complex(real: Double, imaginary: Double) {
  def +(that: Complex) =
    new Complex(real + that.real, imaginary + that.imaginary)
  def -(that: Complex) =
    new Complex(real - that.real, imaginary - that.imaginary)
}</programlisting>
<para id="para_here_is_an_object_that_uses_">Here is an <literal>object</literal> that uses <literal>Complex</literal>.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/aspectj/complex-main.scala

package example.aspectj

object ComplexMain {
  def main(args: Array[String]) {
    val c1 = Complex(1.0, 2.0)
    val c2 = Complex(3.0, 4.0)
    val c12 = c1 + c2
    println(c12)
  }
}</programlisting>
<para id="para_next_here_is_an_aspectj_aspec">Next, here is an AspectJ aspect that defines one <emphasis>pointcut</emphasis> for the creation of <literal>Complex</literal> instances and another pointcut for invocations of the <literal>+</literal> method.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/aspectj/LogComplex.aj

package example.aspectj;

public aspect LogComplex {
  public pointcut newInstances(double real, double imag):
    execution(Complex.new(..)) &amp;&amp; args(real, imag);

  public pointcut plusInvocations(Complex self, Complex other):
    execution(Complex Complex.$plus(Complex)) &amp;&amp; this(self) &amp;&amp; args(other);

  before(double real, double imag): newInstances(real, imag) {
    System.out.println("new Complex(" + real + "," + imag + ") called.");
  }

  before(Complex self, Complex other): plusInvocations(self, other) {
    System.out.println("Calling " + self + ".+(" + other + ")");
  }

  after(Complex self, Complex other) returning(Complex c):
    plusInvocations(self, other) {
    System.out.println("Complex.+ returned " + c);
  }
}</programlisting>
<para id="para_we_won_t_explain_all_the_detai">We won’t explain all the details of AspectJ syntax here. See the AspectJ document at <link linkend="AspectJ" xrefstyle="select:nopage">[AspectJ]</link> and <xref linkend="Laddad2009"/> for those details. We’ll limit ourselves to a “conceptual” overview of this aspect.</para>
<para id="para_the_first_pointcut_newinst">The first <literal>pointcut</literal>, <literal>newInstances</literal>, matches on “executions” of the constructor calls, using the syntax <literal>Complex.new</literal> to refer to the constructor. We expect <literal>double</literal> arguments to the constructor call. As we saw previously, <literal>scala.Double</literal> occurrences are converted to Java primitive <literal>doubles</literal> when generating byte code. The <literal>args</literal> clause “binds” the values of the arguments passed in, so we can refer to them in <emphasis>advice</emphasis>.</para>
<para id="para_the_second_pointcut_plusca">The second <literal>pointcut</literal>, <literal>plusInvocations</literal>, matches on “executions” of the <literal>+</literal> method, which is actually <literal>$plus</literal> in the byte code. The <literal>self</literal> and <literal>other</literal> parameters are bound to the object on which the <literal>+</literal> method is invoked (using the <literal>this</literal> clause) and the argument to it (using the <literal>args</literal> clause), respectively.</para>
<para id="para_the_first_before__advice__is">The first <literal>before</literal> <emphasis>advice</emphasis> is executed for the <literal>newInstances</literal> pointcut, that is before we actually enter the constructor. We “log” the call, displaying the actual real and imaginary values passed in.</para>
<para id="para_the_next_before__advice__is_">The next <literal>before</literal> <emphasis>advice</emphasis> is executed for the <literal>plusInvocations</literal> pointcut, that is before the <literal>+</literal> method is executed. We log the value of <literal>self</literal> (<emphasis>i.e.</emphasis>, <literal>this</literal> instance) and the other number.</para>
<para id="para_finally_an_after_returning_">Finally, an <literal>after returning</literal> <emphasis>advice</emphasis> is also executed for the <literal>plusInvocations</literal> pointcut, that is after the <literal>+</literal> method returns. We capture the return value in the variable <literal>c</literal> and we log it.</para>
<para id="para_if_you_have_aspectj_installed_">If you have AspectJ installed in an <replaceable>aspectj-home</replaceable> directory, you can compile this file as follows.</para>
<screen>ajc -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar \
  aspectj/LogComplex.aj</screen>
<para id="para_this_is_one_line_we_used_the_">This is one line; we used the \ to indicate a line wrap. To run this code with the <literal>LogComplex</literal> aspect, we use <emphasis>load-time weaving</emphasis> (<ulink url="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html"/>). We’ll invoke Java with an <emphasis>agent</emphasis> that “weaves” the <emphasis>advice</emphasis> from <literal>LogComplex</literal> into <literal>Complex</literal>. To use load-time weaving, we also need the following configuration file, <literal>META-INF/aop.xml</literal>.</para>
<programlisting linenumbering="unnumbered">&lt;!-- code-examples/ToolsLibs/META-INF/aop.xml --&gt;

&lt;aspectj&gt;
  &lt;aspects&gt;
    &lt;aspect name="example.aspectj.LogComplex" /&gt;
    &lt;include within="example.aspectj.*" /&gt;
  &lt;/aspects&gt;

  &lt;weaver options="-verbose"&gt;
    &lt;dump within="example.aspectj.*" beforeandafter="true"&gt;
      &lt;include within="example.aspectj.*" /&gt;
    &lt;/dump&gt;
  &lt;/weaver&gt;
&lt;/aspectj&gt;</programlisting>
<para>(The <literal>META-INF</literal> directory should be on the class path; we’ll assume it’s in the current working directory.) This file tells the weaver which aspects to use (the <literal>aspect</literal> tag), which classes to target for weaving (the <literal>include</literal> tag) and it also enables verbose output, which is useful for debugging purposes. Finally, we can run the application with the following command.</para>
<screen>java -classpath .:aspectj-home/lib/aspectjrt.jar:../lib/scala-library.jar \
  -javaagent:aspectj-home/lib/aspectjweaver.jar example.aspectj.ComplexMain</screen>
<para id="para_you_get_several_lines_of_messa">You get several lines of messages logging the weaving process. The output ends with these lines.</para>
<screen>new Complex(1.0,2.0) called.
new Complex(3.0,4.0) called.
Calling Complex(1.0,2.0).+(Complex(3.0,4.0))
new Complex(4.0,6.0) called.
Complex.+ returned Complex(4.0,6.0)
Complex(4.0,6.0)</screen>
<para id="para_all_but_the_last_line_were_out">All but the last line were output by <literal>LogComplex</literal>. We added this additional behavior without manually inserting these statements in <literal>Complex</literal> itself!</para>
<para id="para_recall_we_said_that_the_second">Recall we said that the second issue you might encounter when using AspectJ is how to invoke Scala code from <emphasis>advice</emphasis>.  In our <literal>LogComplex</literal> aspect, the statements inside our different <literal>before</literal> and <literal>after</literal> advices are really just Java code. Therefore, we can just as easily invoke Scala code, applying the same lessons we have already learned for invoking Scala from Java.</para>
<para id="para_scala_traits__almost__replace_">Scala traits <emphasis>almost</emphasis> replace aspects. We saw in <xref linkend="Traits"/> and <xref linkend="ApplicationDesign"/> how you can construct traits that modify the behavior of other traits, then mix the behaviors together when you create new classes or instances. This powerful technique lets you implement a form of aspect <emphasis>advice</emphasis>. However, Scala doesn’t have a pointcut language, like AspectJ. When you need to affect a set of join points that don’t share a common supertype, you’ll need the capabilities of AspectJ. However, if you find yourself in that situation, you should consider if you can refactor your code to extract a common trait that provides the “hooks” you need for <emphasis>advice</emphasis> implemented using traits.</para>
</sect2>
<sect2 id="TheSpringFrameworkInterop">
<title>The Spring Framework</title>
<para id="para_the_spring_framework_springf">The Spring Framework <link linkend="SpringFramework" xrefstyle="select:nopage">[SpringFramework]</link> is an open-source, modular Java enterprise framework that provides a “pure” Java AOP API, integrated support for AspectJ, a <emphasis>Dependency Injection</emphasis> (DI) container, uniform and well designed APIs for invoking a variety of other Java third-party APIs, and additional components for security, web development, <emphasis>etc.</emphasis></para>
<para id="para_here_we_focus_on_dependency_in">Here we focus on dependency injection, as interoperability issues with the other parts of the Spring Framework boil down to either Java or AspectJ issues, which we covered above.</para>
<para id="para_we_discussed_the_concept_of_de">We discussed the concept of DI in <xref linkend="DependencyInjectionInScala"/> in <xref linkend="ApplicationDesign"/>, where we showed elegant patterns for injecting dependencies using Scala itself. However, if you are in a mixed Java/Scala environment, it might be necessary to use a DI framework like the one provided by Spring to manage dependencies.</para>
<para id="para_in_spring_di_dependencies_are">In Spring DI, dependencies are specified using a combination of XML configuration files and source-code annotations. The Spring API resolves these dependencies as classes are instantiated. Spring expects these classes to follow <emphasis>JavaBean</emphasis> conventions (see <link linkend="JavaBeansSpec" xrefstyle="select:nopage">[JavaBeansSpec]</link>). Well designed classes will only depend on abstractions, <emphasis>i.e.,</emphasis> Java interfaces or Scala traits, and the concrete instances satisfying those dependencies will be given to the bean through constructor arguments or through <emphasis>JavaBean</emphasis> setter methods. Hence, if you use Spring DI with Scala classes, you will need to use the <literal>@scala.reflect.BeanProperty</literal> annotation when you use setter injection. The annotation is not needed when you use constructor injection.</para>
<tip id="para_tip_prefer_constructor_inject"><para>Prefer constructor injection, when possible. Not only does this choice eliminate the need to use the <literal>@BeanProperty</literal> annotation, it leaves each instances in a known, good state when the construction process is finished.</para></tip>
<para id="para_however_if_you_inject_depende">However, if you inject dependencies into Scala <literal>objects</literal>, you must use setter injection, as you have no way to define constructor parameters and you have no control over the construction process.</para>
<para id="para_one_other_point_remember_that">One other point; remember that Spring will expect Java-compatible names, so you must use <emphasis>encoded</emphasis> names for methods and <literal>objects</literal>, as needed.</para>
<para id="para_here_is_an_example_that_illust">Here is an example that illustrates “wire together” objects with Spring.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/spring/object-bean.scala

package example.spring

case class NamedObject(name: String)

trait Factory {
  @scala.reflect.BeanProperty
  var nameOfFactory = "unknown"

  def make(name: String): AnyRef
}

object NamedObjectFactory extends Factory {
  def make(name: String) = NamedObject(name)
}

case class FactoryUsingBean(factory: Factory)</programlisting>
<para id="para_the_case_class_factoryusingbe">The case class <literal>FactoryUsingBean</literal> is a simple type with a dependency on a <literal>Factory</literal> abstraction that we want to inject using constructor injection.</para>
<para id="para_the_trait_factory_defines_th">The trait <literal>Factory</literal> defines the factory abstraction. It has a <literal>make</literal> method to create instances of some kind. To demonstrate setter injection on <literal>objects</literal>, we also give it a <literal>nameOfFactory</literal> field. This will demonstrate <literal>object</literal> dependency injection because the concrete subtype we will actually use, <literal>NamedObjectFactory</literal>, is an <literal>object</literal>.</para>
<para id="para_scala_requires_us_to_initializ">Scala requires us to initialize <literal>nameOfFactory</literal> with a value, but we will use Spring to set the real value. We have to use the <literal>@BeanProperty</literal> annotation to generate the <literal>setNameOfFactory</literal> method Spring will expect to find.</para>
<para id="para_the_concrete_make_method_in_">The concrete <literal>make</literal> method in <literal>NamedObjectFactory</literal> creates a new <literal>NamedObject</literal>. It is a simple case class with a <literal>name</literal> field.</para>
<para id="para_note_that_none_of_these_types_">Note that none of these types depend on the Spring API. You can compile this file without any Spring jar files.</para>
<para id="para_next_we_define_the_dependency">Next, we define the dependency “wiring” using a standard Spring XML configuration file.</para>
<programlisting linenumbering="unnumbered">&lt;!-- code-examples/ToolsLibs/spring/scala-spring.xml --&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

  &lt;bean id="factory" class="example.spring.NamedObjectFactory$"&gt;
    &lt;property name="nameOfFactory" value="Factory for Named Objects" /&gt;
  &lt;/bean&gt;

  &lt;bean id="factoryUsingBean" class="example.spring.FactoryUsingBean"&gt;
    &lt;constructor-arg ref="factory" /&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</programlisting>
<para id="para_we_define_two_beans_our_fac">We define two <literal>beans</literal>. Our factory is given the id <literal>factory</literal>. The “class” is actually the <literal>object</literal> <literal>NamedObjectFactory</literal>. Note that we have to append a <literal>$</literal> to the end of the name, the actual name of the <literal>object</literal> in the byte code.</para>
<para id="para_the_property_tag_sets_the_va">The <literal>property</literal> tag sets the value of <literal>nameOfFactory</literal>. We can’t control instantiation of <literal>objects</literal>, so we have to inject the correct dependency after construction completes.</para>
<para id="para_the_second_bean_is_our_simple_">The second bean is our simple <literal>FactoryUsingBean</literal>. Since this is a <literal>class</literal>, we can use constructor injection. The <literal>constructor</literal> tag specifies that the <literal>factory</literal> bean is used to satisfy the dependency at construction time.</para>
<para id="para_spring_di_script">Finally, here is a script that uses these types to demonstrate Spring DI with Scala.</para>
<programlisting linenumbering="unnumbered">// code-examples/ToolsLibs/spring/object-bean-script.scala

import example.spring._
import org.springframework.context.support._

val context = new ClassPathXmlApplicationContext("spring/scala-spring.xml");

val bean = context.getBean("factoryUsingBean").asInstanceOf[FactoryUsingBean]
println("Factory Name: " + bean.factory.nameOfFactory)

val obj  = bean.factory.make("Dean Wampler")
println("Object: " + obj)</programlisting>
<para id="para_we_create_an_instance_of_clas">We create an instance of <literal>ClassPathXmlApplicationContext</literal>, specifying our XML file. This context object is our gateway to the DI container. We ask it for our <literal>factoryUsingBean</literal>. We have to cast the returned <literal>AnyRef</literal> (<emphasis>i.e.,</emphasis> Java <literal>Object</literal>) to the correct type. We print out the factory’s name, to see if it is correct.</para>
<para id="para_next_we_ask_the_bean_s_factor">Next, we ask the bean’s factory to make “something” with the string “Dean Wampler”. When we print the returned object, it should be a <literal>NamedObject</literal>.</para>
<para id="para_if_you_have_spring_installed_i">If you have Spring installed in a <replaceable>spring-home</replaceable> directory, you can run this script with the following command.</para>
<screen>scala -cp \
  spring-home/dist/spring.jar:spring-home/.../commons-logging.jar:. \
  spring/object-bean-script.scala</screen>
<para>(The current working directory “.” is needed in the classpath to find the XML file.) There are many lines of logging output. The last two lines are what we care about.</para>
<screen>...
Factory Name: Factory for Named Objects
Object: NamedObject(Dean Wampler)</screen>
<para id="para_this_example_required_a_number">This example required a number of files and configuration details to get working. For a moderately large Java application, the effort is justified. However, Scala gives you new and simpler ways to implement dependency injection in Scala code without configuration files and a DI container.</para>
</sect2>
<sect2 id="TerracottaInterop">
<title>Terracotta</title>
<para id="para_terracotta_terracotta_is_a">Terracotta <link linkend="Terracotta" xrefstyle="select:nopage">[Terracotta]</link> is an open-source clustering product that distributes an application over several servers by clustering JVMs upon which the application executes. For efficiency, not all of the application’s heap objects are distributed. Instead, the programmer specifies which data structures to distribute through configuration files. A benefit of Terracotta is that the application does not require code changes to support this clustering (at least in principle; some limited customization can be useful for performance reasons). Instead, the byte code is instrumented to provide the clustering. Terracotta is an alternative to distributed caches that require code changes.</para>
<para id="para_terracotta_example"><link linkend="Boner2008a" xrefstyle="select:nopage">[Bonér2008a]</link> provides a detailed write up of how to use Terracotta with Scala Actors. A Scala-specific, Terracotta Integration Module (TIM) must be installed. When configuring which objects to distribute, you have to use the encoded names for companion objects, method names, <emphasis>etc.</emphasis> as they exist at the byte-code level. We discussed these encodings in <xref linkend="ScalaNamesInJavaCode"/> above. Finally, you have to add some more parameters to the <userinput>java</userinput> invocation command inside the <userinput>scala</userinput> script. Otherwise, clustering Scala applications with Terracotta works just like it does for Java applications.</para>
</sect2>
<sect2 id="HadoopInterop">
<title>Hadoop</title>
<para id="para_what_is_mapreduce"><emphasis>MapReduce</emphasis> is a divide and conquer programming model for processing large data sets in parallel. In the “map” phase, a data set is divided into N subsets of approximately equal size, where N is chosen to optimize the amount of work that can be done in parallel. For example, N might be close to the total number of processor cores available. (A few cores might be left idle as “backups” or for doing other processing.) The desired computation is performed on each subset. The “reduce” phase combines the results of the subset calculations into a final result.</para>
<para id="para_note_that_mapping_and_reducing">Note that mapping and reducing are essentially functional operations. Therefore a functional language like Scala is ideally suited for writing MapReduce applications.</para>
<para id="para_mapreduce_frameworks">MapReduce frameworks provide tools for mapping and reducing data sets, managing all phases of the computation, including the processing nodes, restarting operations that fail for some reason, <emphasis>etc</emphasis>. The user of a MapReduce framework only has to write the algorithms for mapping (subdividing) the input data, the computations with the data subsets, and reducing the results. See <link linkend="MapReduceTutorial" xrefstyle="select:nopage">[MapReduceTutorial]</link> for a succinct overview and <link linkend="MapReduce" xrefstyle="select:nopage">[MapReduce]</link> that describes Google’s <emphasis>MapReduce</emphasis> framework. The name of the Google framework has become a <emphasis>de facto</emphasis> standard for these frameworks.</para>
<para id="para_hadoop_hadoop_is_an_open_s">Hadoop <link linkend="Hadoop" xrefstyle="select:nopage">[Hadoop]</link> is a open-source MapReduce framework created and maintained by Yahoo!. There are two Scala wrappers around the Hadoop API: <emphasis>SHadoop</emphasis> <link linkend="SHadoop" xrefstyle="select:nopage">[SHadoop]</link> and <emphasis>SMR</emphasis> <link linkend="SMRa" xrefstyle="select:nopage">[SMRa]</link> and <link linkend="SMRb" xrefstyle="select:nopage">[SMRb]</link>. Both examples demonstrate the great reduction in code size when using Scala. <xref linkend="SMRa" xrefstyle="select: title nopage"/> attributes this code reduction to Scala’s support for higher-order and anonymous functions, its sophisticated type system and type inference, and the ability of <literal>for</literal> comprehensions to generate maps in an elegant and succinct way.</para>
</sect2>
</sect1>
<sect1 id="_recap_and_what_s_next_5">
<title>Recap and What’s Next</title>
<para id="para_this_chapter_filled_in_the_det">This chapter filled in the details of the Scala command-line tools that you will use every day. We also surveyed the available support for Scala in various text editors and IDEs. We discussed a number of important libraries, such as testing APIs. Finally, we discussed interoperability between Scala and other JVM languages and libraries.</para>
<para id="para_this_completes_our_survey_of_t">This completes our survey of the world of Scala programming. The next chapter is a glossary of terms that we have used throughout the book. Following the glossary is a list of references for further exploration.</para>
</sect1>
</chapter>
