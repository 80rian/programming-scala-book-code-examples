<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE glossary PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<glossary id="Glossary">
  <title>Glossary</title>

  <glossentry id="glossentry-tag">
    <glossterm>$tag</glossterm>

    <glossdef>
      <para>A method declared by the <literal>ScalaObject</literal> trait and
      used internally by Scala. It takes no arguments and returns an integer.
      It is currently used to optimize pattern matching, but it may be removed
      in a future release of Scala. While normally invisible to Scala code (it
      is generated automatically by the compiler), Java code that extends some
      Scala traits and classes may need to implement this method.<indexterm>
          <primary sortas="tag method">$tag method (ScalaObject)</primary>
        </indexterm><indexterm>
          <primary>ScalaObject class</primary>

          <secondary>$tag method</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-abstraction">
    <glossterm>Abstraction</glossterm>

    <glossdef>
      <para>The outwardly visible state, state transformations, and other
      operations supported by a type. This is separate from the
      <emphasis>encapsulated</emphasis> implementation (fields and methods) of
      the abstraction. Scala <emphasis>traits</emphasis> and
      <emphasis>abstract classes</emphasis> are often used to define
      abstractions and optionally implement them. <emphasis>Concrete
      types</emphasis> provide complete implementations.<indexterm>
          <primary>abstraction</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-abstract-type">
    <glossterm>Abstract Type</glossterm>

    <glossdef>
      <orderedlist id="glossary_abstract_type" numeration="lowerroman">
        <listitem>
          <para>A <emphasis>class</emphasis> or <emphasis>trait</emphasis>
          with one or more methods, fields, or types declared, but <phrase
          role="keep-together">undefined</phrase>. Abstract types can’t be
          instantiated. Contrast with <emphasis>concrete
          types</emphasis>.<indexterm>
              <primary>abstract types</primary>

              <secondary>defined</secondary>
            </indexterm></para>
        </listitem>

        <listitem>
          <para>A <literal>type</literal> declaration within an
          <emphasis>class</emphasis> or <emphasis>trait</emphasis> that is
          abstract.</para>
        </listitem>
      </orderedlist>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-actor">
    <glossterm>Actor</glossterm>

    <glossdef>
      <para>An autonomous sender and receiver of messages in the
      <emphasis>Actor model of concurrency</emphasis>.<indexterm>
          <primary>Actors</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-actor-model-of-concurrency">
    <glossterm>Actor Model of Concurrency</glossterm>

    <glossdef>
      <para>A concurrency model where autonomous <emphasis>Actors</emphasis>
      coordinate work by exchanging <phrase
      role="keep-together">messages</phrase>. An Actor’s messages are stored
      in a <emphasis>mailbox</emphasis> until the Actor processes
      them.<indexterm>
          <primary>concurrency</primary>

          <secondary>Actor model of</secondary>
        </indexterm><indexterm>
          <primary>Actors</primary>

          <secondary>Actor model of concurrency</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-annotated-type">
    <glossterm>Annotated Type</glossterm>

    <glossdef>
      <para>Any type that has one or more <literal>@</literal> annotations
      applied to it.<indexterm>
          <primary>annotated types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-annotation">
    <glossterm>Annotation</glossterm>

    <glossdef>
      <para>A way of attaching “metadata” to a declaration that can be
      exploited by the compiler and other tools for code generation,
      verification and validation, etc. In Scala (and Java), an annotation is
      a class. When used, it is prefixed with the <literal>@</literal>
      character.<indexterm>
          <primary>annotations</primary>

          <secondary>defined</secondary>
        </indexterm></para>

      <para id="para_any_explicit_type_declarations">Any explicit type
      declarations are also called <emphasis>type
      annotations</emphasis>.</para>

      <para id="para_one_or_more_additions_to_a_typ">One or more additions to
      a type declaration that specify behaviors like variance under
      inheritance, bounds, and views.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-application">
    <glossterm>Application</glossterm>

    <glossdef>
      <para>In Scala, any <literal>object</literal> with a
      <literal>main</literal> routine that is invoked by the JVM or .NET CLR
      at the start of a new process.<indexterm>
          <primary>applications</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-arity">
    <glossterm>Arity</glossterm>

    <glossdef>
      <para>The number of arguments to a function.<indexterm>
          <primary>arity</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-aspect-oriented-programming">
    <glossterm>Aspect-Oriented Programming</glossterm>

    <glossdef>
      <para>(Sometimes called <emphasis>aspect-oriented software
      development</emphasis>.) An approach to <emphasis>cross-cutting
      concerns</emphasis>, where the concerns are designed and implemented in
      a “modular” way (that is, with appropriate encapsulation, lack of
      duplication, etc.), then integrated into all the relevant execution
      points in a succinct and robust way, e.g., through declarative or
      programmatic means. In AOP terms, the execution points are called
      <emphasis>join points</emphasis>; a particular set of them is called a
      <emphasis>pointcut</emphasis>; and the new behavior that is executed
      before, after, or “around” a join point is called
      <emphasis>advice</emphasis>. <emphasis>AspectJ</emphasis> is the best
      known AOP toolkit. Scala <emphasis>traits</emphasis> can be used to
      implement some aspect-like functionality.<indexterm>
          <primary>aspect-oriented programming (AOP)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-aspectj">
    <glossterm>AspectJ</glossterm>

    <glossdef>
      <para>An extension of Java that supports <emphasis>Aspect-Ori⁠ented
      Programming</emphasis>. AspectJ (<link linkend="AspectJ"
      xrefstyle="select:nopage">[AspectJ]</link>) supports two forms of
      syntax: an extended Java-based syntax, and a “pure” Java syntax that
      uses Java annotations to indicate the <emphasis>pointcuts</emphasis> and
      <emphasis>advices</emphasis> of an aspect. The aspect behaviors
      (advices) can be incorporated into the target code at compile time, as a
      <phrase role="keep-together">post-</phrase><phrase
      role="keep-together">compile</phrase> “weaving” step, or at load
      time.<indexterm>
          <primary>AspectJ library</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-attribute">
    <glossterm>Attribute</glossterm>

    <glossdef>
      <para>Another name for a <emphasis>field</emphasis>, used by <phrase
      role="keep-together">convention</phrase> in many object-oriented
      programming languages. Scala follows Java’s convention of preferring the
      term <emphasis>field</emphasis> over <emphasis
      role="keep-together">attribute</emphasis>.<indexterm>
          <primary>attributes</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-auxiliary-constructor">
    <glossterm>Auxiliary Constructor</glossterm>

    <glossdef>
      <para>A secondary constructor of a class, declared as a method named
      <literal>this</literal> with no return type. An auxiliary constructor
      must invoke the <emphasis>primary constructor</emphasis> or a previously
      defined <emphasis>auxiliary constructor</emphasis> as the first or only
      statement in its method body.<indexterm>
          <primary>auxiliary constructors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-base-type">
    <glossterm>Base Type</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>parent type</emphasis>.<indexterm>
          <primary>base type</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-behavior-driven-development">
    <glossterm>Behavior-Driven Development</glossterm>

    <glossdef>
      <para>A style of <emphasis>Test-Driven Development</emphasis> (TDD) that
      emphasizes TDD’s role in driving the understanding of requirements for
      the code. You follow the same process as in TDD, where the “tests” are
      written before the code. The difference is that the automated tests are
      written in a format that looks more like a requirements (or behavioral)
      specification and less like a test of the code’s conformance to the
      requirements. However, the specification format is still executable and
      it still provides the verification, validation, and regression testing
      service that TDD tests provide.<indexterm>
          <primary>BDD (Behavior-Driven Development)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-bound-variable">
    <glossterm>Bound Variable</glossterm>

    <glossdef>
      <para>A <emphasis>variable</emphasis> that is declared as an argument to
      a <emphasis>function literal</emphasis>. It is “bound” to a value when
      the <emphasis>closure</emphasis> created from the function literal is
      invoked.<indexterm>
          <primary>bound variables</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-by-name-parameter">
    <glossterm>By-Name Parameter</glossterm>

    <glossdef>
      <para>A <emphasis>by-name parameter</emphasis> looks like a function
      value that takes no parameters, but rather than being declared with the
      signature <literal>p: () ⇒ R</literal>, where <literal>R</literal> is
      the return type, it is declared with the signature <literal>p: ⇒
      R</literal>. By-name parameters are evaluated every time they are
      referenced in the function, rather than being evaluated
      <emphasis>once</emphasis> just before the function call, like a
      <emphasis>by-value parameter</emphasis>. For example, they are useful
      for a function that is designed to look like a control construct that
      takes a “block,” not a function with explicit parameter arguments (think
      of how <literal>while</literal> loops look, for example). The function
      argument that has block-like behavior would be a by-name
      parameter.<indexterm>
          <primary>by-name parameters</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-by-value-parameter">
    <glossterm>By-Value Parameter</glossterm>

    <glossdef>
      <para>A <emphasis>by-value parameter</emphasis> is the usual kind of
      method parameter that is evaluated before it is passed to the method.
      Contrast with <emphasis>by-name parameter</emphasis>.<indexterm>
          <primary>by-value parameters</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-call-by-name">
    <glossterm>Call By Name</glossterm>

    <glossdef>
      <para>See <emphasis>by-name parameter</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-call-by-value">
    <glossterm>Call By Value</glossterm>

    <glossdef>
      <para>See <emphasis>by-value parameter</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-call-site">
    <glossterm>Call Site</glossterm>

    <glossdef>
      <para>See <emphasis>declaration site</emphasis>.<indexterm>
          <primary>call site</primary>

          <see>declaration site</see>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-case">
    <glossterm>Case</glossterm>

    <glossdef>
      <para>The keyword used in <emphasis>pattern matching</emphasis>
      expressions for testing an object against an
      <emphasis>extractor</emphasis>, type check, etc.<indexterm>
          <primary>case keyword</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-case-class">
    <glossterm>Case Class</glossterm>

    <glossdef>
      <para>A class declared with the keyword <literal>case</literal>. The
      Scala compiler automatically defines <literal>equals</literal>,
      <literal>hashCode</literal> and <literal>toString</literal> methods for
      the class and creates a <emphasis>companion object</emphasis> with an
      <literal role="keep-together">apply</literal> factory method and an
      <literal>unapply</literal> extractor method. Case classes are
      particularly convenient for use with <emphasis>pattern
      matching</emphasis> (<emphasis>case</emphasis>) expressions.<indexterm>
          <primary>case classes</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-child-type">
    <glossterm>Child Type</glossterm>

    <glossdef>
      <para>A class or trait that inherits from a <literal>parent</literal>
      class or trait. Sometimes called a <emphasis>subtype</emphasis> or
      <emphasis>derived type</emphasis>. See
      <emphasis>inheritance</emphasis>.<indexterm>
          <primary>derived types</primary>
        </indexterm><indexterm>
          <primary>subtypes</primary>
        </indexterm><indexterm>
          <primary>child types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-client">
    <glossterm>Client</glossterm>

    <glossdef>
      <para>An informal term used throughout the book to indicate a section of
      software that uses another as an API, etc.<indexterm>
          <primary>clients</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-class">
    <glossterm>Class</glossterm>

    <glossdef>
      <para>A template for <emphasis>instances</emphasis> that will have the
      same fields, representing state values, and the same methods. Scala
      classes support single <emphasis>inheritance</emphasis> and zero or more
      <emphasis>mixin</emphasis> traits. Contrast with
      <emphasis>type</emphasis>.<indexterm>
          <primary>classes</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-closure">
    <glossterm>Closure</glossterm>

    <glossdef>
      <para>In Scala, an instance that has been created from a
      <emphasis>function literal</emphasis> with all the <emphasis>free
      variables</emphasis> referenced in the function literal bound to
      variables of the same name in the enclosing scope where the function
      literal was defined. In other words, the instance is “closed” in the
      sense that the free variables are bound. Because they are instances,
      closures are <emphasis>first-class</emphasis> values. They can be passed
      to other functions to customize their behavior. For example,
      <literal>List.foreach</literal> takes a closure that is applied to each
      element in the list. See also <emphasis>bound variables</emphasis> and
      <emphasis>function literals</emphasis>.<indexterm>
          <primary>closures</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-comments">
    <glossterm>Comments</glossterm>

    <glossdef>
      <para>Scala follows the same comment conventions as Java, C#, C++, etc.
      A <literal>// <replaceable>comment</replaceable></literal> goes to the
      end of a line, while a <literal>/* <replaceable
      role="keep-together">comment</replaceable> */</literal> can cross line
      boundaries.<indexterm>
          <primary>comments</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-companion-class">
    <glossterm>Companion Class</glossterm>

    <glossdef>
      <para>A <literal>class</literal> declared with the same name as an
      object and defined in the same source file. See also <emphasis>companion
      object</emphasis>.<indexterm>
          <primary>companion classes</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-companion-object">
    <glossterm>Companion Object</glossterm>

    <glossdef>
      <para>An <literal>object</literal> declared with the same name as a
      class (called its <emphasis>companion class</emphasis>) and <phrase
      role="keep-together">defined</phrase> in the same source file. Companion
      objects are where methods and fields are defined that would be statics
      in Java classes, such as factory methods, <literal>apply</literal> and
      <literal role="keep-together">unapply</literal> for pattern matching,
      etc.<indexterm>
          <primary>companion objects</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-component">
    <glossterm>Component</glossterm>

    <glossdef>
      <para>For our purposes, an aggregation of cohesive types that expose
      services through well-defined abstractions, while encapsulating
      implementation details and minimizing coupling to other components.
      (There is a wide-range of definitions for <emphasis>component</emphasis>
      in computer science and industry.)<indexterm>
          <primary>components</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-compound-type">
    <glossterm>Compound Type</glossterm>

    <glossdef>
      <para>The actual type of a declaration of the form <literal>T1 extends
      T2 with T3 with ... TN { R }</literal>, where <literal>R</literal> is
      the <emphasis>refinement</emphasis> (body). Definitions in
      <literal>R</literal> affect the type.<indexterm>
          <primary>compound types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-concrete-type">
    <glossterm>Concrete Type</glossterm>

    <glossdef>
      <para>A <emphasis>class</emphasis>, <emphasis>trait</emphasis>, or
      <emphasis>object</emphasis> with all methods, fields, and types defined.
      <emphasis>Instances</emphasis> can be created from concrete types.
      Contrast with <emphasis>abstract types</emphasis>.<indexterm>
          <primary>concrete types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-contract">
    <glossterm>Contract</glossterm>

    <glossdef>
      <para>The protocol and requirements that exist between a module (e.g.,
      class, trait, object, or even function or method) and clients of the
      module. More specifically, see <emphasis>Design by
      Contract</emphasis>.<indexterm>
          <primary>contract</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-context-free-grammar">
    <glossterm>Context-Free Grammar</glossterm>

    <glossdef>
      <para>A kind of language grammar for which each
      <emphasis>nonterminal</emphasis> can be specified as a
      <emphasis>production</emphasis> without reference to additional context
      information. That is, each nonterminal can appear by itself on the
      lefthand side of the production the specifies it.<indexterm>
          <primary>grammars</primary>

          <secondary>context-free</secondary>
        </indexterm><indexterm>
          <primary>context-free grammars</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-contravariance-or-contravariant">
    <glossterm>Contravariance or Contravariant</glossterm>

    <glossdef>
      <para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal>A</literal>
      is <emphasis>contravariant</emphasis> in a parameterized type
      <literal>T[-A]</literal>, then the <literal>-</literal> is the
      <emphasis>variance annotation</emphasis>, and a type
      <literal>T[B]</literal> is a <emphasis>supertype</emphasis> of
      <literal>T[A]</literal> if <literal>B</literal> is a
      <emphasis>subtype</emphasis> of <literal>A</literal>. See also
      <emphasis>covariance</emphasis> and
      <emphasis>invariance</emphasis>.<indexterm>
          <primary>contravariance or contravariant</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-covariance-or-covariant">
    <glossterm>Covariance or Covariant</glossterm>

    <glossdef>
      <para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal>A</literal>
      is <emphasis>covariant</emphasis> in a parameterized type
      <literal>T[+A]</literal>, then the <literal>+</literal> is the
      <emphasis>variance annotation</emphasis>, and a type
      <literal>T[B]</literal> is a <emphasis>subtype</emphasis> of
      <literal>T[A]</literal> if <literal>B</literal> is a
      <emphasis>subtype</emphasis> of <literal>A</literal>. See also
      <emphasis>contravariance</emphasis> and
      <emphasis>invariance</emphasis>.<indexterm>
          <primary>covariance or covariant</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-cross-cutting-concerns">
    <glossterm>Cross-Cutting Concerns</glossterm>

    <glossdef>
      <para>“Concerns” (kinds of requirements, design or coding issues) that
      don’t fit in the same boundaries as the primary modularity
      decomposition. The same behaviors must be invoked consistently at
      specific execution points over a range of objects and functions. For
      example, the same ORM (<phrase
      role="keep-together">Object-</phrase><phrase
      role="keep-together">Relational</phrase> Mapping) persistence strategy
      needs to be used consistently for a set of classes, not just a single
      class. Hence, such concerns are said to be cross-cutting. Supporting
      these concerns should not involve duplication of code, etc. See also
      <emphasis>aspect-</emphasis><emphasis role="keep-together">oriented
      programming</emphasis>.<indexterm>
          <primary>cross-cutting concerns</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-currying">
    <glossterm>Currying</glossterm>

    <glossdef>
      <para>Converting an N argument function into a sequence of N functions
      of one argument, where each function except for the last <phrase
      role="keep-together">returns</phrase> a new function that takes a single
      argument that returns a new function, etc., until the last function that
      takes a single <phrase role="keep-together">argument</phrase> and
      returns a value.<indexterm>
          <primary>currying</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-declaration-site">
    <glossterm>Declaration Site</glossterm>

    <glossdef>
      <para>In reference to how the <emphasis>variance</emphasis> behavior of
      parameterized types is specified, in Scala, this is done when types are
      <emphasis>declared</emphasis>, i.e., at the <emphasis>declaration
      site</emphasis>. In Java, it is done when types are
      <emphasis>called</emphasis> (that is, used), i.e., at the <emphasis>call
      site</emphasis>.<indexterm>
          <primary>declaration site</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-declarative-programming">
    <glossterm>Declarative Programming</glossterm>

    <glossdef>
      <para>The quality of many <emphasis>functional</emphasis> programs and
      <emphasis>Domain-Specific Languages</emphasis> where the code consists
      of statements that declare relationships between values and types,
      rather than directing the system to take a particular sequence of
      action. Contrast with <emphasis>imperative
      programming</emphasis>.<indexterm>
          <primary>declarative programming</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-default-argument-value">
    <glossterm>Default Argument Value</glossterm>

    <glossdef>
      <para>(Scala version 2.8.) The ability to define a default value for a
      method argument that will be used if the caller does not specify a
      value. See also <emphasis>implicit argument</emphasis> and
      <emphasis>named argument</emphasis>.<indexterm>
          <primary>default argument value</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-dependency-injection">
    <glossterm>Dependency Injection</glossterm>

    <glossdef>
      <para>A form of <emphasis>inversion of control</emphasis> where an
      object’s external dependencies are given to it, either programmatically
      or through a DI framework that is driven by configuration information.
      Hence, the object remains “passive,” rather than taking an active role
      in resolving dependencies. The injection mechanism uses constructor
      arguments or field setters provided by the object. DI minimizes the
      coupling of objects; they only need to know about the abstractions of
      their dependencies.<indexterm>
          <primary>dependency injection (DI)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-derived-type">
    <glossterm>Derived Type</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>child type</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-design-by-contract">
    <glossterm>Design By Contract</glossterm>

    <glossdef>
      <para>An approach to class and module design invented by Bertrand Meyer
      for the Eiffel language. For each entry point, valid inputs are
      specified in a programmatic way, so they can be validated during
      testing. These specifications are called
      <emphasis>preconditions</emphasis>. Similarly, <phrase
      role="keep-together">assuming</phrase> the preconditions are specified,
      specifications on the guaranteed results are called
      <emphasis>postconditions</emphasis> and are also specified in an
      executable way. <emphasis>Invariants</emphasis> can also be specified
      that should be true on entry and on exit.<indexterm>
          <primary>Design by Contract</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-design-pattern">
    <glossterm>Design Pattern</glossterm>

    <glossdef>
      <para>A solution to a problem in a context. A code idiom or design
      structure that satisfies the needs of a frequently occurring problem,
      constraint, requirement, etc.<indexterm>
          <primary>design patterns</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-domain-specific-language">
    <glossterm>Domain-Specific Language</glossterm>

    <glossdef>
      <para>A custom programming language that resembles the terms, idioms,
      and expressions of a particular domain. An <emphasis>internal</emphasis>
      DSL is an idiomatic form of a general-purpose programming language. That
      is, no <phrase role="keep-together">special-</phrase><phrase
      role="keep-together">purpose</phrase> parser is created for the
      language. <phrase role="keep-together">Instead</phrase>, DSL code is
      written in the general-purpose language and parsed just like any other
      code. An <emphasis>external</emphasis> DSL is a language with its own
      grammar and parser.<indexterm>
          <primary>DSLs (Domain-Specific Languages)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-duck-typing">
    <glossterm>Duck Typing</glossterm>

    <glossdef>
      <para>A term used in languages with <emphasis>dynamic typing</emphasis>
      for the way method resolution works. As long as an object accepts a
      method call (message send), the runtime is satisfied. “If it walks like
      a duck and talks like a duck, it’s a duck.” Contrast with the use of
      <emphasis>structural types</emphasis> in some <emphasis>statically
      typed</emphasis> languages like Scala.<indexterm>
          <primary>duck typing</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-dynamic-typing">
    <glossterm>Dynamic Typing</glossterm>

    <glossdef>
      <para>Loosely speaking, late binding of type information, sometimes
      referred to as binding to the value a reference is assigned to, rather
      than to the reference itself. Contrast with <emphasis>static
      typing</emphasis>.<indexterm>
          <primary>dynamic typing</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-encapsulation">
    <glossterm>Encapsulation</glossterm>

    <glossdef>
      <para>Restricting the visibility of members of a type so they are not
      visible to clients of the type when they shouldn’t be. This is a way of
      exposing only the <emphasis>abstraction</emphasis> supported by the
      type, while hiding implementation details, which prevents unwanted
      access to them from clients and keeps the
      <emphasis>abstraction</emphasis> exposed by the type consistent and
      <phrase role="keep-together">minimal</phrase>.<indexterm>
          <primary>encapsulation</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-event">
    <glossterm>Event</glossterm>

    <glossdef>
      <para>The notification of a state change in <emphasis>event-based
      concurrency</emphasis>.<indexterm>
          <primary>events</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-event-based-concurrency">
    <glossterm>Event-Based Concurrency</glossterm>

    <glossdef>
      <para>A high-performance form of concurrency where events are used to
      signal important state changes and handlers are used to respond to the
      events.<indexterm>
          <primary>events</primary>

          <secondary>using for concurrency</secondary>
        </indexterm><indexterm>
          <primary>concurrency</primary>

          <secondary>event-based</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-existential-types">
    <glossterm>Existential Types</glossterm>

    <glossdef>
      <para>A way of expressing the presence of a type without knowing its
      concrete value, sometimes, because it can’t be known. It is used
      primarily to support aspects of Java’s type system within Scala’s type
      system, including <emphasis>type erasure</emphasis>, “raw” types (e.g.,
      pre-Java 5 collections), and <emphasis>call site</emphasis>
      <emphasis>type variance</emphasis>.<indexterm>
          <primary>existential types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-extractor">
    <glossterm>Extractor</glossterm>

    <glossdef>
      <para>An <literal>unapply</literal> method defined in a
      <emphasis>companion object</emphasis> that is used to extract the
      constituent values for fields in an object. They are most commonly used
      in <emphasis>pattern matching</emphasis> <phrase
      role="keep-together">expressions</phrase>.<indexterm>
          <primary>extractors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-field">
    <glossterm>Field</glossterm>

    <glossdef>
      <para>A <literal>val</literal> or <literal>var</literal> in a type that
      represents part, if not all, of the state of a corresponding instance of
      the type.<indexterm>
          <primary>fields</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-final">
    <glossterm>Final</glossterm>

    <glossdef>
      <para>Keyword for declarations. For types, <literal>final</literal>
      prevents users from subclassing the type. For type members,
      <literal>final</literal> prevents users from overriding the
      members.<indexterm>
          <primary>final keyword</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-first-class">
    <glossterm>First Class</glossterm>

    <glossdef>
      <para>An adjective indicating that the applicable “thing” is a
      first-class value in the language, meaning you can assign instances to
      variables, pass them as function parameters, and return them from
      functions. Often used to refer to <emphasis>functions</emphasis>, which
      are first-class values in Scala and other <emphasis>functional
      programming</emphasis> languages.<indexterm>
          <primary>first class</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-for-comprehension">
    <glossterm>For Comprehension</glossterm>

    <glossdef>
      <para>Another name for Scala’s <literal>for</literal> expression.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-formal-parameter">
    <glossterm>Formal Parameter</glossterm>

    <glossdef>
      <para>Another name for a function argument, used in the context of
      binding the <emphasis>free variables</emphasis> in the
      function.<indexterm>
          <primary>formal parameters</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-free-variable">
    <glossterm>Free Variable</glossterm>

    <glossdef>
      <para>A <emphasis>variable</emphasis> that is referenced in a
      <emphasis>function literal</emphasis> but is not passed in as an
      argument. Therefore, it must be “bound” to a defined variable of the
      same name in the context where the function literal is defined, to form
      a <emphasis>closure</emphasis>.<indexterm>
          <primary>free variables</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-function">
    <glossterm>Function</glossterm>

    <glossdef>
      <para>In Scala, the term <emphasis>function</emphasis> is used for a
      function that is not tied to a particular object or class. Contrast with
      <emphasis>method</emphasis>. Functions are instances of
      <literal>FunctionN</literal> types, where <literal>N</literal> is the
      <emphasis>arity</emphasis> of the function.<indexterm>
          <primary>functions</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-function-literal">
    <glossterm>Function Literal</glossterm>

    <glossdef>
      <para>Scala’s term for an anonymous <emphasis>function</emphasis>
      expression, from which <emphasis>closures</emphasis> are
      created.<indexterm>
          <primary>function literals</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-function-type">
    <glossterm>Function Type</glossterm>

    <glossdef>
      <para>In Scala, all functions are instances of <literal
      role="keep-together">FunctionN[-T1, T2, ..., TN, +R]</literal> types,
      where <literal>N</literal> is the number of arguments (0 through 22 are
      supported). The type signature syntax <literal>(T1, T2, ..., TN) ⇒
      R</literal> is used for declaring concrete instances, i.e., function
      literals.<indexterm>
          <primary>function types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-functional-programming">
    <glossterm>Functional Programming</glossterm>

    <glossdef>
      <para>A form of programming that mimics the way mathematical functions
      and variables work. Mathematical functions are
      <emphasis>side-effect-free</emphasis>, and they are composable from
      other functions. Variables are assigned once. Functions can be assigned
      to variables and <phrase role="keep-together">returned</phrase> from
      other functions.<indexterm>
          <primary>functional programming</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-generator">
    <glossterm>Generator</glossterm>

    <glossdef>
      <para>Expressions like <literal>i &lt;- listOfInts</literal> in
      <literal>for</literal> expressions. Each pass through the loop
      <emphasis>generates</emphasis> a new <literal>val</literal>
      <literal>i</literal> taken from the list <literal>listOfInts</literal>,
      in this example.<indexterm>
          <primary>generators</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-generics">
    <glossterm>Generics</glossterm>

    <glossdef>
      <para>Another term for <emphasis>parameterized types</emphasis>, used
      more often in Java than Scala.<indexterm>
          <primary>generics</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-higher-order-functions">
    <glossterm>Higher-Order Functions</glossterm>

    <glossdef>
      <para>Functions that take other functions as arguments or return a
      function value.<indexterm>
          <primary>functions</primary>

          <secondary>higher order</secondary>
        </indexterm><indexterm>
          <primary>higher-order functions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-immutable-value">
    <glossterm>Immutable Value</glossterm>

    <glossdef>
      <para>A value that can’t be changed after it has been initialized.
      Contrast with <emphasis>mutable value</emphasis>.<indexterm>
          <primary>immutable values</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-imperative-programming">
    <glossterm>Imperative Programming</glossterm>

    <glossdef>
      <para>The quality of many <emphasis>object-oriented</emphasis> and
      “procedural” programs where the code consists of statements directing
      the system to take a particular sequence of actions. Contrast with
      <emphasis>declarative programming</emphasis>.<indexterm>
          <primary>imperative programming</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-implicit">
    <glossterm>Implicit</glossterm>

    <glossdef>
      <para>A Scala keyword used to mark a method or function value as
      eligible for use as an <emphasis>implicit type conversion</emphasis>.
      The keyword is also used to mark an <emphasis>implicit
      argument</emphasis>.<indexterm>
          <primary>implicit keyword</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-implicit-type-conversion">
    <glossterm>Implicit Type Conversion</glossterm>

    <glossdef>
      <para>A method or function value that is marked with the
      <emphasis>implicit</emphasis> keyword, marking it as eligible for use as
      an <emphasis>implicit type conversion</emphasis>, whenever it is in
      scope and conversion is needed (e.g., for the <emphasis>Pimp My
      Library</emphasis> <phrase
      role="keep-together">pattern</phrase>).<indexterm>
          <primary>implicit conversions</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-implicit-argument">
    <glossterm>Implicit Argument</glossterm>

    <glossdef>
      <para>Method arguments that are optional for the user to specify and
      indicated with the <literal>implicit</literal> keyword. If the user does
      not specify a value for the argument, a default value is used instead,
      which is either an in-scope value of the same type or the result of
      calling an in-scope, no-argument method that returns an instance of the
      same type. See also <emphasis>default argument
      value</emphasis>.<indexterm>
          <primary>implicit arguments</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-infinite-data-structure">
    <glossterm>Infinite Data Structure</glossterm>

    <glossdef>
      <para>A data structure that represents a non-<phrase
      role="keep-together">terminating</phrase> collection of values, but
      which is capable of doing so without exhausting system resources. The
      values are not computed until the data structure is asked to produce
      them. As long as only a finite subset of the values are requested,
      resource exhaustion is avoided.<indexterm>
          <primary>infinite data structures</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-infix-notation">
    <glossterm>Infix Notation</glossterm>

    <glossdef>
      <para>A syntax supported by the compiler for methods with one argument.
      The method can be invoked without the period between the object and the
      method name and without the parentheses around the argument. When used
      for methods named with <emphasis>operator characters</emphasis>, the
      syntax provides a form of <emphasis>operator overloading</emphasis>.
      Sometimes also called <emphasis>operator notation</emphasis>. See also
      <emphasis>postfix no⁠tation</emphasis>.<indexterm>
          <primary>operator notation</primary>
        </indexterm><indexterm>
          <primary>infix notation</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-infix-type">
    <glossterm>Infix Type</glossterm>

    <glossdef>
      <para>When a parameterized type of the form <literal>Op[A,B]</literal>
      is used to instantiate a type, it can also be written as <literal>A Op
      B</literal>. For example, <literal>Or[Throwable,Boolean]</literal> can
      be written <literal role="keep-together">Throwable Or
      Boolean</literal>.<indexterm>
          <primary>infix types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-inheritance">
    <glossterm>Inheritance</glossterm>

    <glossdef>
      <para>A strong relationship between one class or trait and another class
      or trait. The <phrase role="keep-together">inheriting</phrase>
      (<emphasis>derived</emphasis>) class or trait incorporates the members
      of the <emphasis>parent</emphasis> class or trait, as if they were
      defined within the derivative. The derivative may override inherited
      members (in most cases). Instances of a derivative are
      <emphasis>substitutable</emphasis> for instances of the
      parent.<indexterm>
          <primary>inheritance</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-instance-or-instantiate">
    <glossterm>Instance or Instantiate</glossterm>

    <glossdef>
      <para>An <emphasis>object</emphasis> created by invoking a
      <emphasis>class</emphasis> constructor. The word
      <emphasis>object</emphasis> is synonymous in most object-oriented
      languages, but we use the term <emphasis>object</emphasis> to refer to
      an explicitly <phrase role="keep-together">declared</phrase> Scala
      <emphasis>object</emphasis>, and we use the term <emphasis
      role="keep-together">instance</emphasis> (and the verb
      <emphasis>instantiate</emphasis>) for the more general case.<indexterm>
          <primary>instantiate</primary>
        </indexterm><indexterm>
          <primary>instance</primary>
        </indexterm></para>

      <para id="para_instantiation_can_also_refer_t">Instantiation can also
      refer to creating a <emphasis>concrete type</emphasis> from a
      <emphasis>parameterized type</emphasis> <phrase role="keep-together">by
      specifying concrete</phrase> types for the <phrase
      role="keep-together">parameters</phrase>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-invariance-and-invariant">
    <glossterm>Invariance and Invariant</glossterm>

    <glossdef>
      <para>In the context of the variance behavior of <emphasis>parameterized
      types</emphasis> under inheritance, if a parameter <literal>A</literal>
      is <emphasis>invariant</emphasis> in a parameterized type
      <literal>T[A]</literal>, then there is no <emphasis>variance
      annotation</emphasis>, and a type <literal>T[B]</literal> is a
      <emphasis>subtype</emphasis> of <literal>T[A]</literal> if and only if
      <literal>B</literal> equals <literal>A</literal>. That is, the type
      can’t be changed. See also <emphasis>covariance</emphasis> and <emphasis
      role="keep-together">contravariance</emphasis>.<indexterm>
          <primary>invariance and invariant</primary>
        </indexterm></para>

      <para id="para_in_the_context_of__design_by_c">In the context of
      <emphasis>Design by Contract</emphasis>, an assertion that should be
      true before and after a method is executed.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-inversion-of-control">
    <glossterm>Inversion of Control</glossterm>

    <glossdef>
      <para>The idea that an object should not instantiate its own copies of
      external dependencies, but rather rely on other mechanisms to supply
      those dependencies. IoC promotes better decoupling and testability, as
      the object only knows about the abstractions of its dependencies, not
      specific concrete implementers of them. A weak form of IoC is when an
      object calls a factory, service locator, etc., to obtain the dependents.
      Hence, the object still has an active role and it has a dependency on
      the “provider.” The strongest form of IoC is <emphasis>dependency
      injection</emphasis>, where the object remains “passive.”<indexterm>
          <primary>inversion of control (IoC)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-lazy">
    <glossterm>Lazy</glossterm>

    <glossdef>
      <para>Immutable variables (<literal>val</literal>s) can be declared
      <literal>lazy</literal>, meaning they will only be evaluated when they
      are read. This feature is useful for expensive evaluations that may not
      be <phrase role="keep-together">needed</phrase>.<indexterm>
          <primary>lazy, defined</primary>
        </indexterm></para>

      <para id="para_lazy_data_structures_can_also_">Lazy data structures can
      also be used to <phrase role="keep-together">define</phrase> infinite
      data structures that won’t exhaust system resources as long as only a
      finite subset of the structure is evaluated. The
      <literal>Stream</literal> and <literal>Range</literal> classes are both
      lazy. <phrase role="keep-together">Contrast</phrase> with
      <emphasis>strict</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-linearization">
    <glossterm>Linearization</glossterm>

    <glossdef>
      <para>The algorithm used for a type to resolve member lookup, such as
      overridden methods, including calls to
      <literal>super</literal>.<indexterm>
          <primary>linearization of object hierarchy</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-literal">
    <glossterm>Literal</glossterm>

    <glossdef>
      <para>Used to refer to “literal” value expressions, such as numbers
      (e.g., <literal>1</literal>, <literal>3.14</literal>), strings (e.g.,
      “Hello Scala!”), tuples (e.g., <literal>(1, 2, 3)</literal>), and
      <emphasis>function literals</emphasis> (e.g., <literal>(x) ⇒ x +
      x</literal>).<indexterm>
          <primary>literals</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-lower-type-bounds">
    <glossterm>Lower Type Bounds</glossterm>

    <glossdef>
      <para>See <emphasis>type bounds</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mailbox">
    <glossterm>Mailbox</glossterm>

    <glossdef>
      <para>The queue where an <emphasis>Actor’s</emphasis> messages are
      stored until the Actor processes them in the A<emphasis>ctor model of
      concurrency</emphasis>.<indexterm>
          <primary>mailbox for Actors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-main">
    <glossterm>Main</glossterm>

    <glossdef>
      <para>The entry function for an application that is invoked by the
      runtime is called <literal>main</literal>. The name dates back to the
      <emphasis>C</emphasis> language. In Scala, a <literal>main</literal>
      <emphasis>method</emphasis> must be defined in an
      <literal>object</literal>. Java, by way of contrast, requires a
      <literal>main</literal> method to be defined as a static method of a
      <literal>class</literal>.<indexterm>
          <primary>main method</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mapreduce">
    <glossterm>MapReduce</glossterm>

    <glossdef>
      <para>A divide-and-conquer strategy for processing large data sets in
      parallel. In the “map” phase, the data sets are subdivided. The desired
      computation is performed on each subset. The “reduce” phase combines the
      results of the subset calculations into a final result. MapReduce
      frameworks handle the details of managing the operations and the nodes
      they run on, including restarting <phrase
      role="keep-together">operations</phrase> that fail for some reason. The
      user of the framework only has to write the algorithms for mapping and
      reducing <phrase role="keep-together">the data sets and</phrase>
      computing with the subsets.<indexterm>
          <primary>MapReduce</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-member">
    <glossterm>Member</glossterm>

    <glossdef>
      <para>A generic term for a <emphasis>type</emphasis>,
      <emphasis>field</emphasis>, or <emphasis>method</emphasis> declared in a
      <emphasis>class</emphasis> or <emphasis>trait</emphasis>.<indexterm>
          <primary>members</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-memoization">
    <glossterm>Memoization</glossterm>

    <glossdef>
      <para>A form of caching that optimizes function invocations. The results
      from a function’s invocations are saved so that when repeated
      invocations with the same inputs are made, the cached results can be
      returned instead of reinvoking the function.<indexterm>
          <primary>memoization</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-message">
    <glossterm>Message</glossterm>

    <glossdef>
      <para>In the <emphasis>Actor model of concurrency</emphasis>, messages
      are exchanged between Actors to coordinate their work.<indexterm>
          <primary>messages</primary>
        </indexterm></para>

      <para id="para_in_object_oriented_programming">In object-oriented
      programming, method invocation is sometimes referred to as “sending a
      message to an object,” especially in certain languages, like Smalltalk
      and, to some extent, Ruby.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-method">
    <glossterm>Method</glossterm>

    <glossdef>
      <para>A <emphasis>function</emphasis> that is associated exclusively
      with an instance, either defined in a <emphasis>class</emphasis>,
      <emphasis>trait</emphasis>, or <emphasis>object</emphasis> definition.
      Methods can only be invoked using the <literal>object.method</literal>
      syntax.<indexterm>
          <primary>methods</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mixin">
    <glossterm>Mixin</glossterm>

    <glossdef>
      <para>A narrowly focused encapsulation of state and behavior that is
      more useful as an adjunct to another object’s state and behavior, rather
      than standing on its own. Mixins in Scala are implemented using
      <emphasis>traits</emphasis>.<indexterm>
          <primary>mixins</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-multiple-inheritance">
    <glossterm>Multiple Inheritance</glossterm>

    <glossdef>
      <para>In some languages, but not Scala, a type can extend more than one
      parent class. Compare to <emphasis>single
      inheritance</emphasis>.<indexterm>
          <primary>multiple inheritance</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-mutable-value">
    <glossterm>Mutable Value</glossterm>

    <glossdef>
      <para>A value that can be changed after it has been initialized.
      Contrast with <emphasis>immutable value</emphasis>.<indexterm>
          <primary>mutable values</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-named-argument">
    <glossterm>Named Argument</glossterm>

    <glossdef>
      <para>(Scala version 2.8.) The ability to refer to a method argument by
      name when calling the method. It is useful in combination with
      <emphasis>default argument values</emphasis> for minimizing the number
      of arguments that have to be specified by the caller.<indexterm>
          <primary>named arguments</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-nonterminal">
    <glossterm>Nonterminal</glossterm>

    <glossdef>
      <para>An item in a grammar that requires further decomposition into one
      or more <emphasis>nonterminals</emphasis> (including possibly a
      recursive reference to itself) and
      <emphasis>terminals</emphasis>.<indexterm>
          <primary>nonterminals</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-object">
    <glossterm>Object</glossterm>

    <glossdef>
      <para>A cohesive unit with a particular state, possible state
      transitions, and behaviors. In Scala, the keyword
      <literal>object</literal> is used to declare a
      <emphasis>singleton</emphasis> explicitly, using the same syntax as
      <emphasis>class</emphasis> declarations, except for the lack of
      constructor parameters and auxiliary parameters (because
      <literal>objects</literal> are instantiated by the Scala runtime, not by
      user code). To avoid confusion with <literal>objects</literal>, we use
      the term <emphasis>instance</emphasis> to refer to
      <emphasis>instances</emphasis> of <emphasis>classes</emphasis> and
      <literal>objects</literal> generically.<indexterm>
          <primary>objects</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-object-oriented-programming">
    <glossterm>Object-Oriented Programming</glossterm>

    <glossdef>
      <para>A form of programming that encapsulates state values and
      operations on that state, exposing a cohesive abstraction to clients of
      the object while hiding internal implementation details. OOP also
      supports subtyping to define specializations and “family” relationships
      between types.<indexterm>
          <primary>object-oriented programming (OOP)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-operator-characters">
    <glossterm>Operator Characters</glossterm>

    <glossdef>
      <para>Characters like <literal>&lt;</literal>, <literal>*</literal>,
      etc. that are not letters, nor digits, nor reserved characters, like
      left and right parentheses, curly braces, square brackets, the
      semicolon, colon, or comma. These characters can be used in method names
      to implement a form of <emphasis>operator</emphasis> <emphasis
      role="keep-together">overloading</emphasis>.<indexterm>
          <primary>operator characters</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-operator-notation">
    <glossterm>Operator Notation</glossterm>

    <glossdef>
      <para>See <emphasis>infix notation</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-operator-overloading">
    <glossterm>Operator Overloading</glossterm>

    <glossdef>
      <para>The feature in some languages where standard mathematical
      operators, like <literal>*</literal>, <literal>/</literal>,
      <literal>&lt;</literal>, etc., can be defined by users for custom types.
      In Scala, a form of operator overloading is supported by allowing
      operator characters to be used as normal method names and by allowing
      methods with one argument to be invoked with <emphasis>infix
      notation</emphasis>. The “operator precedence” for these methods is
      determined by the first character, e.g., method <literal>*&lt;</literal>
      will have higher precedence than method
      <literal>+&lt;</literal>.<indexterm>
          <primary>operator overloading</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-overloaded-functions">
    <glossterm>Overloaded Functions</glossterm>

    <glossdef>
      <para>Two or more functions defined in the same scope (e.g., as methods
      in a type or as “bare” functions) that have the same name but different
      <emphasis>signatures</emphasis>.<indexterm>
          <primary>functions</primary>

          <secondary>overloaded</secondary>
        </indexterm><indexterm>
          <primary>overloaded functions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-package-objects">
    <glossterm>Package Objects</glossterm>

    <glossdef>
      <para>A special kind of object declaration that declares members that
      should be visible at the scope of the named package. For example, for
      the declaration <literal>package object math { type Complex = ...
      }</literal>, the <literal>Complex</literal> type can be referenced as
      <literal>math.Complex</literal>. (Scala version 2.8.)<indexterm>
          <primary>package objects</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-packrat-parsers">
    <glossterm>Packrat Parsers</glossterm>

    <glossdef>
      <para>Parsers for <emphasis>parsing expression grammars</emphasis>
      (PEGs; see <link linkend="Ford"
      xrefstyle="select:nopage">[Ford]</link>). They have several benefits,
      such as lack of ambiguity and good performance characteristics. The
      forthcoming Scala version 2.8 parser combinator library will add support
      for creating packrat <phrase
      role="keep-together">parsers</phrase>.<indexterm>
          <primary>packrat parsers</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-parameterized-types">
    <glossterm>Parameterized Types</glossterm>

    <glossdef>
      <para>Scala’s analog of <emphasis>generics</emphasis> in Java.
      Parameterized types are defined with placeholder parameters for types
      they use. When an instance of a parameterized type is created, specific
      types must be specified to replace all the type parameters. See also
      <emphasis>type</emphasis> <emphasis
      role="keep-together">constructor</emphasis>.<indexterm>
          <primary>parameterized types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-parent-type">
    <glossterm>Parent Type</glossterm>

    <glossdef>
      <para>A class or trait from which another class or trait is
      <emphasis>derived</emphasis>. Also called a
      <emphasis>supertype</emphasis> or <emphasis>base type</emphasis>. See
      <emphasis>inheritance</emphasis>.<indexterm>
          <primary>parent classes</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-parsing-expression-grammars-pegs">
    <glossterm>Parsing expression grammars (PEGs)</glossterm>

    <glossdef>
      <para>An alternative to <emphasis>context-free grammars</emphasis> that
      provide guaranteed linear-time parsing <phrase
      role="keep-together">using</phrase> <emphasis>memoization</emphasis> and
      unambiguous <phrase role="keep-together">grammars</phrase> (<link
      linkend="PEG" xrefstyle="select:nopage">[PEG]</link>).<indexterm>
          <primary>PEGs (parsing expression grammars)</primary>
        </indexterm><indexterm>
          <primary>grammars</primary>

          <secondary>parsing expression grammars (PEGs)</secondary>
        </indexterm><indexterm>
          <primary>parsing expression grammars (PEGs)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-partial-application">
    <glossterm>Partial Application</glossterm>

    <glossdef>
      <para>Associated with <emphasis>currying</emphasis>, where a subset of a
      curried function’s arguments are applied, yielding a new function that
      takes the remaining arguments.<indexterm>
          <primary>partial application</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-partial-function">
    <glossterm>Partial Function</glossterm>

    <glossdef>
      <para>A function that is not valid over the whole range of its
      arguments. Pattern matching expressions can be converted to partial
      functions by the compiler in some contexts.<indexterm>
          <primary>partial functions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-path-dependent-type">
    <glossterm>Path-Dependent Type</glossterm>

    <glossdef>
      <para>A nested type T is unique based on its “path,” the hierarchical,
      period-delimited list of the the enclosing packages, the enclosing
      types, and finally the type T itself. Instances of T can have different,
      incompatible types. For example, if T is nested in a trait and the trait
      appears in the <emphasis>linearizations</emphasis> of different types,
      then the instances in those Ts will have different types.<indexterm>
          <primary>path-dependent types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-pattern-matching">
    <glossterm>Pattern Matching</glossterm>

    <glossdef>
      <para>Case expressions, usually in a match expression, that compare an
      object against <phrase role="keep-together">possible</phrase> types,
      type extractors, regular expressions, etc., to determine the appropriate
      handling.<indexterm>
          <primary>pattern matching</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-pimp-my-library">
    <glossterm>Pimp My Library</glossterm>

    <glossdef>
      <para>The name of a design pattern that appears to add new methods to a
      type. It uses an <emphasis>implicit type conversion</emphasis> to
      automatically wrap the type in a wrapper type, where the wrapper type
      has the desired methods.<indexterm>
          <primary>Pimp My Library design pattern</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-precondition">
    <glossterm>Precondition</glossterm>

    <glossdef>
      <para>An assertion that should be true on entry to a method or other
      entry point. See <emphasis>Design by Contract</emphasis>.<indexterm>
          <primary>preconditions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-postcondition">
    <glossterm>Postcondition</glossterm>

    <glossdef>
      <para>An assertion that should be true on exit from a method or other
      boundary point. See <emphasis>Design by Contract</emphasis>.<indexterm>
          <primary>postconditions</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-postfix-notation">
    <glossterm>Postfix Notation</glossterm>

    <glossdef>
      <para>A syntax supported by the compiler for methods with no argument,
      sometimes called <emphasis>nullary</emphasis> methods. The method can be
      invoked without the period between the <phrase
      role="keep-together">object</phrase> and the method name. See also
      <emphasis>infix no⁠tation</emphasis>.<indexterm>
          <primary>postfix notation</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-primary-constructor">
    <glossterm>Primary Constructor</glossterm>

    <glossdef>
      <para>The main constructor of a class, consisting of the class body with
      the parameter list specified after the name of the class. See also
      <emphasis>auxiliary constructor</emphasis>.<indexterm>
          <primary>primary constructor</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-primitive-type">
    <glossterm>Primitive Type</glossterm>

    <glossdef>
      <para>A non-object type on the underlying runtime platform (e.g., JVM
      and .NET). Scala does not have primitive types at the source code level.
      Rather, it uses <emphasis>value types</emphasis>, which are subclasses
      of <literal>AnyVal</literal>, to wrap runtime primitives, providing
      object semantics at the code level, while using boxing and unboxing of
      primitives at the byte code level to optimize performance.<indexterm>
          <primary>primitive data types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-production">
    <glossterm>Production</glossterm>

    <glossdef>
      <para>A term used for each part of a grammar that decomposes a specific
      <emphasis>nonterminal</emphasis> into other nonterminals (perhaps
      including a <phrase role="keep-together">recursive</phrase> reference to
      the original nonterminal) and <emphasis>terminals</emphasis>.<indexterm>
          <primary>production</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-pure">
    <glossterm>Pure</glossterm>

    <glossdef>
      <para>Used in the context of functions to mean that they are
      <emphasis>side-effect-free</emphasis>. See also <emphasis>referential
      transparency</emphasis>.<indexterm>
          <primary>pure (side-effect-free functions)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-recursion">
    <glossterm>Recursion</glossterm>

    <glossdef>
      <para>When a function calls itself as part of its computation. A
      termination condition is required to prevent an infinite recursion. See
      also <emphasis>tail-call recursion</emphasis>.<indexterm>
          <primary>recursion</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-reference-type">
    <glossterm>Reference Type</glossterm>

    <glossdef>
      <para>A type whose instances are implemented as objects on the runtime
      platform. All reference types subtype
      <literal>AnyRef</literal>.<indexterm>
          <primary>reference types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-referential-transparency">
    <glossterm>Referential Transparency</glossterm>

    <glossdef>
      <para>The property of an expression, such as a function, where it can be
      replaced with its value without changing the behavior of the code. This
      can be done with <emphasis>side-effect-free</emphasis> functions when
      the inputs are the same. The primary benefit of referential transparency
      is that it is easy to reason about the behavior of a function, without
      having to understand the context in which it is invoked. That makes the
      function easier to test, refactor, and reuse.<indexterm>
          <primary>referential transparency</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-refinement">
    <glossterm>Refinement</glossterm>

    <glossdef>
      <para>The term used for adding or overriding members in a type body for
      a <emphasis>compound type</emphasis>.<indexterm>
          <primary>refinement in compound type declarations</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-reified-types">
    <glossterm>Reified Types</glossterm>

    <glossdef>
      <para>Where the specific types used when instantiating a generic type
      are retained in the byte code, so the information is available at
      runtime. This is a property of .NET byte code, but not JVM byte code,
      which uses <emphasis>type erasure</emphasis>. To minimize
      incompatibilities, both the Java and .NET Scala versions use
      <emphasis>type erasure.<indexterm>
          <primary>reified types</primary>
        </indexterm></emphasis></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-repl">
    <glossterm>REPL</glossterm>

    <glossdef>
      <para>A name given to interactive language interpreters, like the
      <literal>scala</literal> command in interpreter mode. REPL is an acronym
      for <emphasis>Read, Evaluate, Print, Loop</emphasis>.<indexterm>
          <primary>REPL (Read, Evaluate, Print, Loop)</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-scaladocs">
    <glossterm>Scaladocs</glossterm>

    <glossdef>
      <para>The API documentation generated from Scala source code using the
      <literal>scaladoc</literal> tool, analogous to Java’s
      Javadocs.<indexterm>
          <primary>Scaladocs</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-scope">
    <glossterm>Scope</glossterm>

    <glossdef>
      <para>A defined boundary of <emphasis>visibility</emphasis>,
      constraining what types and their members are visible within
      it.<indexterm>
          <primary>scope</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-sealed">
    <glossterm>Sealed</glossterm>

    <glossdef>
      <para>Keyword for parent classes when <emphasis>all</emphasis> the
      direct subclasses allowed are defined in the same source
      <emphasis>file</emphasis>.<indexterm>
          <primary>sealed keyword</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-self-type-annotation">
    <glossterm>Self-Type Annotation</glossterm>

    <glossdef>
      <para>A declaration in a trait or class that changes its type, sometimes
      with an alias for <literal>this</literal> defined
      (<literal>self</literal> is conventional). A self type can be used to
      indicate dependencies on other traits that will have to be mixed into a
      concrete instance to resolve the dependency. In some cases, these
      dependencies are used to ensure that an instance of the current type can
      be used as an instance of a dependent type in certain contexts (e.g., as
      used in the Observer Pattern in <xref
      linkend="SelfTypeAnnotationsAndAbstractTypeMembers" />).<indexterm>
          <primary>self-type annotations</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-side-effect-free">
    <glossterm>Side-Effect-Free</glossterm>

    <glossdef>
      <para>Functions or expressions that have no side effects, meaning they
      modify no global or “object” state.<indexterm>
          <primary>side-effect-free</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-signature">
    <glossterm>Signature</glossterm>

    <glossdef>
      <para>For a function: the name, parameter list types, and return value.
      For a <emphasis>method</emphasis>: also includes the type that defines
      the method.<indexterm>
          <primary>signature</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-single-inheritance">
    <glossterm>Single Inheritance</glossterm>

    <glossdef>
      <para>A class, object, or trait can extend one parent class. Compare to
      <emphasis>multiple inheritance</emphasis>.<indexterm>
          <primary>single inheritance</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-singleton">
    <glossterm>Singleton</glossterm>

    <glossdef>
      <para>A class that has only one instance. In Scala, singletons are
      declared using the keyword <literal>object</literal> instead of
      <literal>class</literal>.<indexterm>
          <primary>singletons</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-singleton-types">
    <glossterm>Singleton Types</glossterm>

    <glossdef>
      <para>The unique type designator that excludes path dependencies. If
      <literal>p1</literal> and <literal>p2</literal> are two different
      path-dependent types, their singleton types are
      <literal>p1.type</literal> and <literal>p2.type</literal>, which may be
      the same. Contrast with <emphasis>singleton</emphasis> objects.
      Singleton types are not specifically the types of singleton objects, but
      singleton objects do have singleton types.<indexterm>
          <primary>singleton types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-stable-types">
    <glossterm>Stable Types</glossterm>

    <glossdef>
      <para>Used in the context of <emphasis>path-dependent types</emphasis>,
      all but the last elements in the path must be
      <emphasis>stable</emphasis>, which roughly means that they are either
      packages, singleton objects, or type declarations that alias the
      same.<indexterm>
          <primary>stable types</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-state">
    <glossterm>State</glossterm>

    <glossdef>
      <para>As in, “the state of an object,” where it informally means the set
      of all the current values of an object’s
      <emphasis>fields</emphasis>.<indexterm>
          <primary>state</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-static-typing">
    <glossterm>Static Typing</glossterm>

    <glossdef>
      <para>Loosely speaking, early binding of type information, sometimes
      referred to as binding to a reference, rather than the value to which
      the reference is assigned.<indexterm>
          <primary>static typing</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-strict">
    <glossterm>Strict</glossterm>

    <glossdef>
      <para>Used to refer to data structures that are not
      <emphasis>lazy</emphasis>, i.e., they are defined “eagerly” by the
      expressions used to construct them.<indexterm>
          <primary>strict</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-structural-type">
    <glossterm>Structural Type</glossterm>

    <glossdef>
      <para>A <emphasis>structural type</emphasis> is like an anonymous type,
      where only the “structure” a candidate type must support is specified,
      such as <emphasis>members</emphasis> that must be present. Structural
      types do not name the candidate types that can match, nor do any
      matching types need to share a common <emphasis>parent trait</emphasis>
      or <emphasis>class</emphasis> with the structural type. Hence,
      structural types are a type-safe analog to <emphasis>duck
      typing</emphasis> in dynamically typed languages, like Ruby.<indexterm>
          <primary>structural types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-subtype">
    <glossterm>Subtype</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>derived type</emphasis>.<indexterm>
          <primary>subtypes</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-supertype">
    <glossterm>Supertype</glossterm>

    <glossdef>
      <para>A synonym for <emphasis>parent type</emphasis>.<indexterm>
          <primary>supertype</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-symbol">
    <glossterm>Symbol</glossterm>

    <glossdef>
      <para>An interned string. Literal symbols are written starting with a
      single “right quote,” e.g., <literal>'name</literal>.<indexterm>
          <primary>symbols</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-tail-call-recursion">
    <glossterm>Tail-Call Recursion</glossterm>

    <glossdef>
      <para>A form of recursion where a function calls itself as the
      <emphasis>last</emphasis> thing it does, i.e., it does no additional
      computations with the result of the recursive call. The Scala compiler
      will optimize <emphasis>tail-call</emphasis> recursions into a
      loop.<indexterm>
          <primary>tail-call recursion</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-test-driven-development">
    <glossterm>Test-Driven Development</glossterm>

    <glossdef>
      <para>A development discipline where no new functionality is implemented
      until a test has been written that will pass once the functionality is
      implemented. See also <emphasis>Behavior-Driven
      Development</emphasis>.<indexterm>
          <primary>TDD (Test-Driven Development)</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-terminal">
    <glossterm>Terminal</glossterm>

    <glossdef>
      <para>A token in a grammar, such as a keyword, that requires no further
      decomposition. See also <emphasis>nonterminal</emphasis>.<indexterm>
          <primary>terminals</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-test-double">
    <glossterm>Test Double</glossterm>

    <glossdef>
      <para>When testing the behavior of one object, a test double is another
      object that satisfies a dependency in the object under test. The test
      double may assist in the testing process, provide controlled test data
      and behaviors, and modify the interaction between the object under test
      and the test double. Specific types of test doubles include “fakes,”
      “mocks,” and “stubs.”<indexterm>
          <primary>test double</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-trait">
    <glossterm>Trait</glossterm>

    <glossdef>
      <para>A class-like encapsulation of state (fields) and behavior
      (methods) that is used for <emphasis>mixin</emphasis> composition. Zero
      or more traits can be mixed into class declarations or when creating
      instances directly, effectively creating an anonymous class.<indexterm>
          <primary>traits</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-trampoline">
    <glossterm>Trampoline</glossterm>

    <glossdef>
      <para>A loop that iterates through a list of functions, invoking each in
      turn. The metaphor of bouncing the functions off a trampoline is the
      source of the name. It can be used to rewrite a form of recursion where
      a function doesn’t call itself, but rather calls a different function
      that invokes the original function, and so forth, back and forth. There
      is a proposal for the Scala version 2.8 compiler to include a trampoline
      implementation.<indexterm>
          <primary>trampolines</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-tuple">
    <glossterm>Tuple</glossterm>

    <glossdef>
      <para>A grouping of two or more items of arbitrary types into a
      “Cartesian product,” without first defining a class to hold them.
      Literal tuple values are written in parentheses and separated by commas,
      e.g., <literal>(x1, x2, ...)</literal>. They are
      <emphasis>first-class</emphasis> values, so you can assign them to
      variables, pass them as values, and return them from functions. Tuples
      are represented by <literal>TupleN</literal> classes, for N between 2
      and 22, inclusive.<indexterm>
          <primary>tuples</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type">
    <glossterm>Type</glossterm>

    <glossdef>
      <para>A categorization of allowed states and operations on those states,
      including transformations from one state to another. The type of an
      instance is the combination of its declared <emphasis>class</emphasis>
      (explicitly named or anonymous), mixed-in <emphasis>traits</emphasis>,
      and the specific types used to resolve any parameters if the class or
      traits are <emphasis>parameterized types</emphasis>. In Scala,
      <literal>type</literal> is also a keyword. When indicated in the text,
      we sometimes use the term type to refer to a <emphasis>class</emphasis>,
      <emphasis>object</emphasis>, or <emphasis>trait</emphasis>
      generically.<indexterm>
          <primary>types</primary>

          <secondary>defined</secondary>
        </indexterm><indexterm>
          <primary>data types</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-annotation">
    <glossterm>Type Annotation</glossterm>

    <glossdef>
      <para>An explicit declaration of the type of a value, e.g.,
      <literal>count: Int</literal>, where <literal>Int</literal> is the
      <emphasis>type annotation</emphasis>. A type annotation is required when
      <emphasis>type inference</emphasis> can’t be used. In Scala, function
      parameters require type annotations, and annotations are required in
      some other contexts where the type can’t be inferred, e.g., for return
      values of some functions.<indexterm>
          <primary>type annotations</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-bounds">
    <glossterm>Type Bounds</glossterm>

    <glossdef>
      <para>Constraints on the allowed types that can be used for a parameter
      in a <emphasis>parameterized type</emphasis> or assigned to an
      <emphasis>abstract type</emphasis>. In Scala, the expression <literal>A
      &lt;: B</literal> defines an <emphasis>upper bound</emphasis> on
      <literal>A</literal>; it must be a <emphasis>subtype</emphasis> or the
      same as <literal>B</literal>. The expression <literal>A &gt;:
      B</literal> defines a <emphasis>lower bound</emphasis> on
      <literal>A</literal>; it must be a <emphasis>supertype</emphasis> or the
      same as <literal>B</literal>.<indexterm>
          <primary>type bounds</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-constructor">
    <glossterm>Type Constructor</glossterm>

    <glossdef>
      <para>Informally, a <emphasis>parameterized type</emphasis> is sometimes
      called a type constructor, although a “non-parameterized” type is really
      a type constructor too, just with zero parameters! The analogy with an
      instance constructor is that you specify specific concrete types for the
      parameters to create a new concrete type, just as you specify values to
      an instance constructor to create an instance.<indexterm>
          <primary>type constructors</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-designators">
    <glossterm>Type Designators</glossterm>

    <glossdef>
      <para>The conventional type IDs commonly used, e.g., <literal>class
      Person</literal>, <literal>object O { type t }</literal>. They are
      actually a shorthand syntax for <emphasis>type
      projections</emphasis>.<indexterm>
          <primary>type designators</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-erasure">
    <glossterm>Type Erasure</glossterm>

    <glossdef>
      <para>A property of the generics type model on the JVM. When a type is
      created from a generic, the information about the specific types
      substituted for the type parameters is not stored in the byte code and
      is therefore not available at runtime. Scala must follow the same model.
      So, for example, instances of <literal>List[String]</literal> and
      <literal>List[Int]</literal> are indistinguishable. Contrast with
      <emphasis>reified types</emphasis>.<indexterm>
          <primary>type erasure</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-inference">
    <glossterm>Type Inference</glossterm>

    <glossdef>
      <para>Inferring the type of a value based on the context in which it is
      used, rather than <phrase role="keep-together">relying</phrase> on
      explicit type <emphasis>annotations</emphasis>. Sometimes called
      <emphasis>implicit typing</emphasis>.<indexterm>
          <primary>implicit typing</primary>
        </indexterm><indexterm>
          <primary>type inference</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-projections">
    <glossterm>Type Projections</glossterm>

    <glossdef>
      <para>A way to refer to a type nested within another type. For example,
      if a type <literal>t</literal> is declared in a class
      <literal>C</literal>, then the type projection for <literal>t</literal>
      is <literal>C#t</literal>.<indexterm>
          <primary>type projections</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-variance">
    <glossterm>Type Variance</glossterm>

    <glossdef>
      <para>When a <emphasis>parameterized type</emphasis> is declared, the
      variance behavior under inheritance of each type parameter can be
      specified using a <emphasis>type variance annotation</emphasis> on the
      type symbol.<indexterm>
          <primary>type variance</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-type-variance-annotation">
    <glossterm>Type Variance Annotation</glossterm>

    <glossdef>
      <para>On a type parameter in a parameterized types, a
      <literal>+</literal> prefixed to the type symbol is used to indicate
      <emphasis>covariance</emphasis>. A <literal>-</literal> prefix on the
      type symbol is used to indicate <emphasis>contravariance</emphasis>. No
      variance annotation is used to indicate <emphasis>invariance</emphasis>
      (the default).<indexterm>
          <primary>type variance annotations</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-upper-type-bounds">
    <glossterm>Upper Type Bounds</glossterm>

    <glossdef>
      <para>See <emphasis>type bounds</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-value">
    <glossterm>Value</glossterm>

    <glossdef>
      <para>The actual state of an instance, usually in the context of a
      variable that refers to the instance. See also <emphasis>value
      type</emphasis>.<indexterm>
          <primary>values</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-value-object">
    <glossterm>Value Object</glossterm>

    <glossdef>
      <para>An immutable instance or object.<indexterm>
          <primary>Value object</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-value-type">
    <glossterm>Value Type</glossterm>

    <glossdef>
      <para>A subclass of <literal>AnyVal</literal> that wraps a corresponding
      non-object “primitive” type on the runtime platform (e.g., JVM and
      .NET). The value types are <literal>Boolean</literal>,
      <literal>Char</literal>, <literal>Byte</literal>, <literal
      role="keep-together">Double</literal>, <literal>Float</literal>,
      <literal>Long</literal>, <literal>Int</literal>, and
      <literal>Short</literal>. (<literal>Unit</literal> is also a value
      type.) All are declared <literal>abstract final</literal> so they can’t
      be used in <literal>new V</literal> expressions. Instead, programs
      specify literal values, e.g., <literal>3.14</literal> for a
      <literal>Double</literal> or use methods that return new values. The
      Scala runtime handles instantiation. All the instances of value types
      are immutable <emphasis>value objects</emphasis>.<indexterm>
          <primary>value types</primary>

          <secondary>defined</secondary>
        </indexterm></para>

      <para id="para_the_term__value_type__is_also_">The term <emphasis>value
      type</emphasis> is also used to mean the categories of types for
      instances. That is, the type of every instance must fall into one
      <phrase role="keep-together">of several</phrase> categories:
      <emphasis>annotated types</emphasis>, <emphasis
      role="keep-together">compound types</emphasis>, <emphasis>function
      types</emphasis>, <emphasis>infix types</emphasis>,
      <emphasis>parameterized types</emphasis>, <emphasis>tuples</emphasis>,
      <emphasis>type designators</emphasis>, <emphasis>type
      projections</emphasis>, and <emphasis>singleton types</emphasis>.</para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-variable">
    <glossterm>Variable</glossterm>

    <glossdef>
      <para>A named reference to a value. If the variable is declared with the
      <literal>val</literal> keyword, a new value can’t be assigned to the
      variable. If the variable is declared with the <literal>var</literal>
      keyword, a new value can be assigned to the variable. The value a
      variable references must be type-compatible with the declared or
      inferred type of the variable.<indexterm>
          <primary>variables</primary>

          <secondary>defined</secondary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-view">
    <glossterm>View</glossterm>

    <glossdef>
      <para>An implicit value of function type that converts a type
      <literal>A</literal> to <literal>B</literal>. The function has the type
      <literal>A =&gt; B</literal> or <literal>(=&gt; A) =&gt; B</literal>.
      (In the later case, the <literal>(=&gt; A)</literal> is a
      <emphasis>by-name parameter</emphasis>.) An in-scope <emphasis>implicit
      type conversion</emphasis> method with the same signature can also be
      used as a view.<indexterm>
          <primary>views</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-view-bounds">
    <glossterm>View Bounds</glossterm>

    <glossdef>
      <para>A type specification of the form <literal>A &lt;% B</literal>,
      which says that any type can be used for <literal>A</literal> as long as
      an in-scope <emphasis>view</emphasis> exists that can convert an
      <literal>A</literal> to a <literal>B</literal>.<indexterm>
          <primary>view bounds</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>

  <glossentry id="glossentry-visibility">
    <glossterm>Visibility</glossterm>

    <glossdef>
      <para>The <emphasis>scope</emphasis> in which a declared
      <emphasis>type</emphasis> or type <emphasis>member</emphasis> is visible
      to other types and <phrase
      role="keep-together">members</phrase>.<indexterm>
          <primary>visibility</primary>
        </indexterm></para>
    </glossdef>
  </glossentry>
</glossary>